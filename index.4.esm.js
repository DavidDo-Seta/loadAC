function Q5e(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var wA = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function KC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function X5e(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var QV = { exports: {} }, _A = {}, XV = { exports: {} }, Hr = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qse;
function K5e() {
  if (qse)
    return Hr;
  qse = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), l = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.iterator;
  function p(H) {
    return H === null || typeof H != "object" ? null : (H = h && H[h] || H["@@iterator"], typeof H == "function" ? H : null);
  }
  var g = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, y = Object.assign, b = {};
  function _(H, ie, he) {
    this.props = H, this.context = ie, this.refs = b, this.updater = he || g;
  }
  _.prototype.isReactComponent = {}, _.prototype.setState = function(H, ie) {
    if (typeof H != "object" && typeof H != "function" && H != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, H, ie, "setState");
  }, _.prototype.forceUpdate = function(H) {
    this.updater.enqueueForceUpdate(this, H, "forceUpdate");
  };
  function S() {
  }
  S.prototype = _.prototype;
  function C(H, ie, he) {
    this.props = H, this.context = ie, this.refs = b, this.updater = he || g;
  }
  var A = C.prototype = new S();
  A.constructor = C, y(A, _.prototype), A.isPureReactComponent = !0;
  var O = Array.isArray, R = Object.prototype.hasOwnProperty, j = { current: null }, $ = { key: !0, ref: !0, __self: !0, __source: !0 };
  function z(H, ie, he) {
    var ye, _e = {}, Ne = null, Oe = null;
    if (ie != null)
      for (ye in ie.ref !== void 0 && (Oe = ie.ref), ie.key !== void 0 && (Ne = "" + ie.key), ie)
        R.call(ie, ye) && !$.hasOwnProperty(ye) && (_e[ye] = ie[ye]);
    var ke = arguments.length - 2;
    if (ke === 1)
      _e.children = he;
    else if (1 < ke) {
      for (var Me = Array(ke), we = 0; we < ke; we++)
        Me[we] = arguments[we + 2];
      _e.children = Me;
    }
    if (H && H.defaultProps)
      for (ye in ke = H.defaultProps, ke)
        _e[ye] === void 0 && (_e[ye] = ke[ye]);
    return { $$typeof: e, type: H, key: Ne, ref: Oe, props: _e, _owner: j.current };
  }
  function W(H, ie) {
    return { $$typeof: e, type: H.type, key: ie, ref: H.ref, props: H.props, _owner: H._owner };
  }
  function Y(H) {
    return typeof H == "object" && H !== null && H.$$typeof === e;
  }
  function V(H) {
    var ie = { "=": "=0", ":": "=2" };
    return "$" + H.replace(/[=:]/g, function(he) {
      return ie[he];
    });
  }
  var ee = /\/+/g;
  function K(H, ie) {
    return typeof H == "object" && H !== null && H.key != null ? V("" + H.key) : ie.toString(36);
  }
  function Q(H, ie, he, ye, _e) {
    var Ne = typeof H;
    (Ne === "undefined" || Ne === "boolean") && (H = null);
    var Oe = !1;
    if (H === null)
      Oe = !0;
    else
      switch (Ne) {
        case "string":
        case "number":
          Oe = !0;
          break;
        case "object":
          switch (H.$$typeof) {
            case e:
            case t:
              Oe = !0;
          }
      }
    if (Oe)
      return Oe = H, _e = _e(Oe), H = ye === "" ? "." + K(Oe, 0) : ye, O(_e) ? (he = "", H != null && (he = H.replace(ee, "$&/") + "/"), Q(_e, ie, he, "", function(we) {
        return we;
      })) : _e != null && (Y(_e) && (_e = W(_e, he + (!_e.key || Oe && Oe.key === _e.key ? "" : ("" + _e.key).replace(ee, "$&/") + "/") + H)), ie.push(_e)), 1;
    if (Oe = 0, ye = ye === "" ? "." : ye + ":", O(H))
      for (var ke = 0; ke < H.length; ke++) {
        Ne = H[ke];
        var Me = ye + K(Ne, ke);
        Oe += Q(Ne, ie, he, Me, _e);
      }
    else if (Me = p(H), typeof Me == "function")
      for (H = Me.call(H), ke = 0; !(Ne = H.next()).done; )
        Ne = Ne.value, Me = ye + K(Ne, ke++), Oe += Q(Ne, ie, he, Me, _e);
    else if (Ne === "object")
      throw ie = String(H), Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(H).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.");
    return Oe;
  }
  function q(H, ie, he) {
    if (H == null)
      return H;
    var ye = [], _e = 0;
    return Q(H, ye, "", "", function(Ne) {
      return ie.call(he, Ne, _e++);
    }), ye;
  }
  function te(H) {
    if (H._status === -1) {
      var ie = H._result;
      ie = ie(), ie.then(function(he) {
        (H._status === 0 || H._status === -1) && (H._status = 1, H._result = he);
      }, function(he) {
        (H._status === 0 || H._status === -1) && (H._status = 2, H._result = he);
      }), H._status === -1 && (H._status = 0, H._result = ie);
    }
    if (H._status === 1)
      return H._result.default;
    throw H._result;
  }
  var X = { current: null }, Z = { transition: null }, se = { ReactCurrentDispatcher: X, ReactCurrentBatchConfig: Z, ReactCurrentOwner: j };
  return Hr.Children = { map: q, forEach: function(H, ie, he) {
    q(H, function() {
      ie.apply(this, arguments);
    }, he);
  }, count: function(H) {
    var ie = 0;
    return q(H, function() {
      ie++;
    }), ie;
  }, toArray: function(H) {
    return q(H, function(ie) {
      return ie;
    }) || [];
  }, only: function(H) {
    if (!Y(H))
      throw Error("React.Children.only expected to receive a single React element child.");
    return H;
  } }, Hr.Component = _, Hr.Fragment = n, Hr.Profiler = i, Hr.PureComponent = C, Hr.StrictMode = r, Hr.Suspense = u, Hr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se, Hr.cloneElement = function(H, ie, he) {
    if (H == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + H + ".");
    var ye = y({}, H.props), _e = H.key, Ne = H.ref, Oe = H._owner;
    if (ie != null) {
      if (ie.ref !== void 0 && (Ne = ie.ref, Oe = j.current), ie.key !== void 0 && (_e = "" + ie.key), H.type && H.type.defaultProps)
        var ke = H.type.defaultProps;
      for (Me in ie)
        R.call(ie, Me) && !$.hasOwnProperty(Me) && (ye[Me] = ie[Me] === void 0 && ke !== void 0 ? ke[Me] : ie[Me]);
    }
    var Me = arguments.length - 2;
    if (Me === 1)
      ye.children = he;
    else if (1 < Me) {
      ke = Array(Me);
      for (var we = 0; we < Me; we++)
        ke[we] = arguments[we + 2];
      ye.children = ke;
    }
    return { $$typeof: e, type: H.type, key: _e, ref: Ne, props: ye, _owner: Oe };
  }, Hr.createContext = function(H) {
    return H = { $$typeof: a, _currentValue: H, _currentValue2: H, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, H.Provider = { $$typeof: o, _context: H }, H.Consumer = H;
  }, Hr.createElement = z, Hr.createFactory = function(H) {
    var ie = z.bind(null, H);
    return ie.type = H, ie;
  }, Hr.createRef = function() {
    return { current: null };
  }, Hr.forwardRef = function(H) {
    return { $$typeof: s, render: H };
  }, Hr.isValidElement = Y, Hr.lazy = function(H) {
    return { $$typeof: f, _payload: { _status: -1, _result: H }, _init: te };
  }, Hr.memo = function(H, ie) {
    return { $$typeof: l, type: H, compare: ie === void 0 ? null : ie };
  }, Hr.startTransition = function(H) {
    var ie = Z.transition;
    Z.transition = {};
    try {
      H();
    } finally {
      Z.transition = ie;
    }
  }, Hr.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Hr.useCallback = function(H, ie) {
    return X.current.useCallback(H, ie);
  }, Hr.useContext = function(H) {
    return X.current.useContext(H);
  }, Hr.useDebugValue = function() {
  }, Hr.useDeferredValue = function(H) {
    return X.current.useDeferredValue(H);
  }, Hr.useEffect = function(H, ie) {
    return X.current.useEffect(H, ie);
  }, Hr.useId = function() {
    return X.current.useId();
  }, Hr.useImperativeHandle = function(H, ie, he) {
    return X.current.useImperativeHandle(H, ie, he);
  }, Hr.useInsertionEffect = function(H, ie) {
    return X.current.useInsertionEffect(H, ie);
  }, Hr.useLayoutEffect = function(H, ie) {
    return X.current.useLayoutEffect(H, ie);
  }, Hr.useMemo = function(H, ie) {
    return X.current.useMemo(H, ie);
  }, Hr.useReducer = function(H, ie, he) {
    return X.current.useReducer(H, ie, he);
  }, Hr.useRef = function(H) {
    return X.current.useRef(H);
  }, Hr.useState = function(H) {
    return X.current.useState(H);
  }, Hr.useSyncExternalStore = function(H, ie, he) {
    return X.current.useSyncExternalStore(H, ie, he);
  }, Hr.useTransition = function() {
    return X.current.useTransition();
  }, Hr.version = "18.2.0", Hr;
}
var wO = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
wO.exports;
var Gse;
function Z5e() {
  return Gse || (Gse = 1, function(e, t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.2.0", r = Symbol.for("react.element"), i = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), l = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), b = Symbol.for("react.offscreen"), _ = Symbol.iterator, S = "@@iterator";
      function C(ne) {
        if (ne === null || typeof ne != "object")
          return null;
        var be = _ && ne[_] || ne[S];
        return typeof be == "function" ? be : null;
      }
      var A = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, O = {
        transition: null
      }, R = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, j = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, $ = {}, z = null;
      function W(ne) {
        z = ne;
      }
      $.setExtraStackFrame = function(ne) {
        z = ne;
      }, $.getCurrentStack = null, $.getStackAddendum = function() {
        var ne = "";
        z && (ne += z);
        var be = $.getCurrentStack;
        return be && (ne += be() || ""), ne;
      };
      var Y = !1, V = !1, ee = !1, K = !1, Q = !1, q = {
        ReactCurrentDispatcher: A,
        ReactCurrentBatchConfig: O,
        ReactCurrentOwner: j
      };
      q.ReactDebugCurrentFrame = $, q.ReactCurrentActQueue = R;
      function te(ne) {
        {
          for (var be = arguments.length, Be = new Array(be > 1 ? be - 1 : 0), qe = 1; qe < be; qe++)
            Be[qe - 1] = arguments[qe];
          Z("warn", ne, Be);
        }
      }
      function X(ne) {
        {
          for (var be = arguments.length, Be = new Array(be > 1 ? be - 1 : 0), qe = 1; qe < be; qe++)
            Be[qe - 1] = arguments[qe];
          Z("error", ne, Be);
        }
      }
      function Z(ne, be, Be) {
        {
          var qe = q.ReactDebugCurrentFrame, gt = qe.getStackAddendum();
          gt !== "" && (be += "%s", Be = Be.concat([gt]));
          var gn = Be.map(function(Dt) {
            return String(Dt);
          });
          gn.unshift("Warning: " + be), Function.prototype.apply.call(console[ne], console, gn);
        }
      }
      var se = {};
      function H(ne, be) {
        {
          var Be = ne.constructor, qe = Be && (Be.displayName || Be.name) || "ReactClass", gt = qe + "." + be;
          if (se[gt])
            return;
          X("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", be, qe), se[gt] = !0;
        }
      }
      var ie = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(ne) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(ne, be, Be) {
          H(ne, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(ne, be, Be, qe) {
          H(ne, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(ne, be, Be, qe) {
          H(ne, "setState");
        }
      }, he = Object.assign, ye = {};
      Object.freeze(ye);
      function _e(ne, be, Be) {
        this.props = ne, this.context = be, this.refs = ye, this.updater = Be || ie;
      }
      _e.prototype.isReactComponent = {}, _e.prototype.setState = function(ne, be) {
        if (typeof ne != "object" && typeof ne != "function" && ne != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, ne, be, "setState");
      }, _e.prototype.forceUpdate = function(ne) {
        this.updater.enqueueForceUpdate(this, ne, "forceUpdate");
      };
      {
        var Ne = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Oe = function(ne, be) {
          Object.defineProperty(_e.prototype, ne, {
            get: function() {
              te("%s(...) is deprecated in plain JavaScript React classes. %s", be[0], be[1]);
            }
          });
        };
        for (var ke in Ne)
          Ne.hasOwnProperty(ke) && Oe(ke, Ne[ke]);
      }
      function Me() {
      }
      Me.prototype = _e.prototype;
      function we(ne, be, Be) {
        this.props = ne, this.context = be, this.refs = ye, this.updater = Be || ie;
      }
      var Ye = we.prototype = new Me();
      Ye.constructor = we, he(Ye, _e.prototype), Ye.isPureReactComponent = !0;
      function ze() {
        var ne = {
          current: null
        };
        return Object.seal(ne), ne;
      }
      var fe = Array.isArray;
      function Qe(ne) {
        return fe(ne);
      }
      function $e(ne) {
        {
          var be = typeof Symbol == "function" && Symbol.toStringTag, Be = be && ne[Symbol.toStringTag] || ne.constructor.name || "Object";
          return Be;
        }
      }
      function pt(ne) {
        try {
          return _t(ne), !1;
        } catch {
          return !0;
        }
      }
      function _t(ne) {
        return "" + ne;
      }
      function Ot(ne) {
        if (pt(ne))
          return X("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", $e(ne)), _t(ne);
      }
      function mn(ne, be, Be) {
        var qe = ne.displayName;
        if (qe)
          return qe;
        var gt = be.displayName || be.name || "";
        return gt !== "" ? Be + "(" + gt + ")" : Be;
      }
      function jr(ne) {
        return ne.displayName || "Context";
      }
      function tn(ne) {
        if (ne == null)
          return null;
        if (typeof ne.tag == "number" && X("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ne == "function")
          return ne.displayName || ne.name || null;
        if (typeof ne == "string")
          return ne;
        switch (ne) {
          case o:
            return "Fragment";
          case i:
            return "Portal";
          case s:
            return "Profiler";
          case a:
            return "StrictMode";
          case h:
            return "Suspense";
          case p:
            return "SuspenseList";
        }
        if (typeof ne == "object")
          switch (ne.$$typeof) {
            case l:
              var be = ne;
              return jr(be) + ".Consumer";
            case u:
              var Be = ne;
              return jr(Be._context) + ".Provider";
            case f:
              return mn(ne, ne.render, "ForwardRef");
            case g:
              var qe = ne.displayName || null;
              return qe !== null ? qe : tn(ne.type) || "Memo";
            case y: {
              var gt = ne, gn = gt._payload, Dt = gt._init;
              try {
                return tn(Dt(gn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Zt = Object.prototype.hasOwnProperty, qn = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, fn, gr, Zn;
      Zn = {};
      function xr(ne) {
        if (Zt.call(ne, "ref")) {
          var be = Object.getOwnPropertyDescriptor(ne, "ref").get;
          if (be && be.isReactWarning)
            return !1;
        }
        return ne.ref !== void 0;
      }
      function Un(ne) {
        if (Zt.call(ne, "key")) {
          var be = Object.getOwnPropertyDescriptor(ne, "key").get;
          if (be && be.isReactWarning)
            return !1;
        }
        return ne.key !== void 0;
      }
      function Qt(ne, be) {
        var Be = function() {
          fn || (fn = !0, X("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", be));
        };
        Be.isReactWarning = !0, Object.defineProperty(ne, "key", {
          get: Be,
          configurable: !0
        });
      }
      function Ut(ne, be) {
        var Be = function() {
          gr || (gr = !0, X("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", be));
        };
        Be.isReactWarning = !0, Object.defineProperty(ne, "ref", {
          get: Be,
          configurable: !0
        });
      }
      function er(ne) {
        if (typeof ne.ref == "string" && j.current && ne.__self && j.current.stateNode !== ne.__self) {
          var be = tn(j.current.type);
          Zn[be] || (X('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', be, ne.ref), Zn[be] = !0);
        }
      }
      var We = function(ne, be, Be, qe, gt, gn, Dt) {
        var dn = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: ne,
          key: be,
          ref: Be,
          props: Dt,
          // Record the component responsible for creating this element.
          _owner: gn
        };
        return dn._store = {}, Object.defineProperty(dn._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(dn, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: qe
        }), Object.defineProperty(dn, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: gt
        }), Object.freeze && (Object.freeze(dn.props), Object.freeze(dn)), dn;
      };
      function ht(ne, be, Be) {
        var qe, gt = {}, gn = null, Dt = null, dn = null, sr = null;
        if (be != null) {
          xr(be) && (Dt = be.ref, er(be)), Un(be) && (Ot(be.key), gn = "" + be.key), dn = be.__self === void 0 ? null : be.__self, sr = be.__source === void 0 ? null : be.__source;
          for (qe in be)
            Zt.call(be, qe) && !qn.hasOwnProperty(qe) && (gt[qe] = be[qe]);
        }
        var Tr = arguments.length - 2;
        if (Tr === 1)
          gt.children = Be;
        else if (Tr > 1) {
          for (var _i = Array(Tr), tr = 0; tr < Tr; tr++)
            _i[tr] = arguments[tr + 2];
          Object.freeze && Object.freeze(_i), gt.children = _i;
        }
        if (ne && ne.defaultProps) {
          var ki = ne.defaultProps;
          for (qe in ki)
            gt[qe] === void 0 && (gt[qe] = ki[qe]);
        }
        if (gn || Dt) {
          var yr = typeof ne == "function" ? ne.displayName || ne.name || "Unknown" : ne;
          gn && Qt(gt, yr), Dt && Ut(gt, yr);
        }
        return We(ne, gn, Dt, dn, sr, j.current, gt);
      }
      function Ft(ne, be) {
        var Be = We(ne.type, be, ne.ref, ne._self, ne._source, ne._owner, ne.props);
        return Be;
      }
      function _n(ne, be, Be) {
        if (ne == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + ne + ".");
        var qe, gt = he({}, ne.props), gn = ne.key, Dt = ne.ref, dn = ne._self, sr = ne._source, Tr = ne._owner;
        if (be != null) {
          xr(be) && (Dt = be.ref, Tr = j.current), Un(be) && (Ot(be.key), gn = "" + be.key);
          var _i;
          ne.type && ne.type.defaultProps && (_i = ne.type.defaultProps);
          for (qe in be)
            Zt.call(be, qe) && !qn.hasOwnProperty(qe) && (be[qe] === void 0 && _i !== void 0 ? gt[qe] = _i[qe] : gt[qe] = be[qe]);
        }
        var tr = arguments.length - 2;
        if (tr === 1)
          gt.children = Be;
        else if (tr > 1) {
          for (var ki = Array(tr), yr = 0; yr < tr; yr++)
            ki[yr] = arguments[yr + 2];
          gt.children = ki;
        }
        return We(ne.type, gn, Dt, dn, sr, Tr, gt);
      }
      function Dn(ne) {
        return typeof ne == "object" && ne !== null && ne.$$typeof === r;
      }
      var di = ".", bi = ":";
      function ua(ne) {
        var be = /[=:]/g, Be = {
          "=": "=0",
          ":": "=2"
        }, qe = ne.replace(be, function(gt) {
          return Be[gt];
        });
        return "$" + qe;
      }
      var Zr = !1, Wa = /\/+/g;
      function Lr(ne) {
        return ne.replace(Wa, "$&/");
      }
      function Ar(ne, be) {
        return typeof ne == "object" && ne !== null && ne.key != null ? (Ot(ne.key), ua("" + ne.key)) : be.toString(36);
      }
      function Ks(ne, be, Be, qe, gt) {
        var gn = typeof ne;
        (gn === "undefined" || gn === "boolean") && (ne = null);
        var Dt = !1;
        if (ne === null)
          Dt = !0;
        else
          switch (gn) {
            case "string":
            case "number":
              Dt = !0;
              break;
            case "object":
              switch (ne.$$typeof) {
                case r:
                case i:
                  Dt = !0;
              }
          }
        if (Dt) {
          var dn = ne, sr = gt(dn), Tr = qe === "" ? di + Ar(dn, 0) : qe;
          if (Qe(sr)) {
            var _i = "";
            Tr != null && (_i = Lr(Tr) + "/"), Ks(sr, be, _i, "", function(Ww) {
              return Ww;
            });
          } else
            sr != null && (Dn(sr) && (sr.key && (!dn || dn.key !== sr.key) && Ot(sr.key), sr = Ft(
              sr,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              Be + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (sr.key && (!dn || dn.key !== sr.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                Lr("" + sr.key) + "/"
              ) : "") + Tr
            )), be.push(sr));
          return 1;
        }
        var tr, ki, yr = 0, _r = qe === "" ? di : qe + bi;
        if (Qe(ne))
          for (var Uc = 0; Uc < ne.length; Uc++)
            tr = ne[Uc], ki = _r + Ar(tr, Uc), yr += Ks(tr, be, Be, ki, gt);
        else {
          var Eu = C(ne);
          if (typeof Eu == "function") {
            var ih = ne;
            Eu === ih.entries && (Zr || te("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Zr = !0);
            for (var wv = Eu.call(ih), kr, cl = 0; !(kr = wv.next()).done; )
              tr = kr.value, ki = _r + Ar(tr, cl++), yr += Ks(tr, be, Be, ki, gt);
          } else if (gn === "object") {
            var Pp = String(ne);
            throw new Error("Objects are not valid as a React child (found: " + (Pp === "[object Object]" ? "object with keys {" + Object.keys(ne).join(", ") + "}" : Pp) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return yr;
      }
      function ws(ne, be, Be) {
        if (ne == null)
          return ne;
        var qe = [], gt = 0;
        return Ks(ne, qe, "", "", function(gn) {
          return be.call(Be, gn, gt++);
        }), qe;
      }
      function Ql(ne) {
        var be = 0;
        return ws(ne, function() {
          be++;
        }), be;
      }
      function Lc(ne, be, Be) {
        ws(ne, function() {
          be.apply(this, arguments);
        }, Be);
      }
      function zc(ne) {
        return ws(ne, function(be) {
          return be;
        }) || [];
      }
      function Xl(ne) {
        if (!Dn(ne))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return ne;
      }
      function Fc(ne) {
        var be = {
          $$typeof: l,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: ne,
          _currentValue2: ne,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        be.Provider = {
          $$typeof: u,
          _context: be
        };
        var Be = !1, qe = !1, gt = !1;
        {
          var gn = {
            $$typeof: l,
            _context: be
          };
          Object.defineProperties(gn, {
            Provider: {
              get: function() {
                return qe || (qe = !0, X("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), be.Provider;
              },
              set: function(Dt) {
                be.Provider = Dt;
              }
            },
            _currentValue: {
              get: function() {
                return be._currentValue;
              },
              set: function(Dt) {
                be._currentValue = Dt;
              }
            },
            _currentValue2: {
              get: function() {
                return be._currentValue2;
              },
              set: function(Dt) {
                be._currentValue2 = Dt;
              }
            },
            _threadCount: {
              get: function() {
                return be._threadCount;
              },
              set: function(Dt) {
                be._threadCount = Dt;
              }
            },
            Consumer: {
              get: function() {
                return Be || (Be = !0, X("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), be.Consumer;
              }
            },
            displayName: {
              get: function() {
                return be.displayName;
              },
              set: function(Dt) {
                gt || (te("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Dt), gt = !0);
              }
            }
          }), be.Consumer = gn;
        }
        return be._currentRenderer = null, be._currentRenderer2 = null, be;
      }
      var _s = -1, as = 0, Es = 1, xa = 2;
      function la(ne) {
        if (ne._status === _s) {
          var be = ne._result, Be = be();
          if (Be.then(function(gn) {
            if (ne._status === as || ne._status === _s) {
              var Dt = ne;
              Dt._status = Es, Dt._result = gn;
            }
          }, function(gn) {
            if (ne._status === as || ne._status === _s) {
              var Dt = ne;
              Dt._status = xa, Dt._result = gn;
            }
          }), ne._status === _s) {
            var qe = ne;
            qe._status = as, qe._result = Be;
          }
        }
        if (ne._status === Es) {
          var gt = ne._result;
          return gt === void 0 && X(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, gt), "default" in gt || X(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, gt), gt.default;
        } else
          throw ne._result;
      }
      function Hi(ne) {
        var be = {
          // We use these fields to store the result.
          _status: _s,
          _result: ne
        }, Be = {
          $$typeof: y,
          _payload: be,
          _init: la
        };
        {
          var qe, gt;
          Object.defineProperties(Be, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return qe;
              },
              set: function(gn) {
                X("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), qe = gn, Object.defineProperty(Be, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return gt;
              },
              set: function(gn) {
                X("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), gt = gn, Object.defineProperty(Be, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return Be;
      }
      function ss(ne) {
        ne != null && ne.$$typeof === g ? X("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof ne != "function" ? X("forwardRef requires a render function but was given %s.", ne === null ? "null" : typeof ne) : ne.length !== 0 && ne.length !== 2 && X("forwardRef render functions accept exactly two parameters: props and ref. %s", ne.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), ne != null && (ne.defaultProps != null || ne.propTypes != null) && X("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var be = {
          $$typeof: f,
          render: ne
        };
        {
          var Be;
          Object.defineProperty(be, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Be;
            },
            set: function(qe) {
              Be = qe, !ne.name && !ne.displayName && (ne.displayName = qe);
            }
          });
        }
        return be;
      }
      var xe;
      xe = Symbol.for("react.module.reference");
      function lt(ne) {
        return !!(typeof ne == "string" || typeof ne == "function" || ne === o || ne === s || Q || ne === a || ne === h || ne === p || K || ne === b || Y || V || ee || typeof ne == "object" && ne !== null && (ne.$$typeof === y || ne.$$typeof === g || ne.$$typeof === u || ne.$$typeof === l || ne.$$typeof === f || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        ne.$$typeof === xe || ne.getModuleId !== void 0));
      }
      function St(ne, be) {
        lt(ne) || X("memo: The first argument must be a component. Instead received: %s", ne === null ? "null" : typeof ne);
        var Be = {
          $$typeof: g,
          type: ne,
          compare: be === void 0 ? null : be
        };
        {
          var qe;
          Object.defineProperty(Be, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return qe;
            },
            set: function(gt) {
              qe = gt, !ne.name && !ne.displayName && (ne.displayName = gt);
            }
          });
        }
        return Be;
      }
      function $t() {
        var ne = A.current;
        return ne === null && X(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), ne;
      }
      function In(ne) {
        var be = $t();
        if (ne._context !== void 0) {
          var Be = ne._context;
          Be.Consumer === ne ? X("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Be.Provider === ne && X("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return be.useContext(ne);
      }
      function lr(ne) {
        var be = $t();
        return be.useState(ne);
      }
      function zn(ne, be, Be) {
        var qe = $t();
        return qe.useReducer(ne, be, Be);
      }
      function sn(ne) {
        var be = $t();
        return be.useRef(ne);
      }
      function No(ne, be) {
        var Be = $t();
        return Be.useEffect(ne, be);
      }
      function xi(ne, be) {
        var Be = $t();
        return Be.useInsertionEffect(ne, be);
      }
      function wi(ne, be) {
        var Be = $t();
        return Be.useLayoutEffect(ne, be);
      }
      function nn(ne, be) {
        var Be = $t();
        return Be.useCallback(ne, be);
      }
      function Oi(ne, be) {
        var Be = $t();
        return Be.useMemo(ne, be);
      }
      function lm(ne, be, Be) {
        var qe = $t();
        return qe.useImperativeHandle(ne, be, Be);
      }
      function mr(ne, be) {
        {
          var Be = $t();
          return Be.useDebugValue(ne, be);
        }
      }
      function Vw() {
        var ne = $t();
        return ne.useTransition();
      }
      function Kl(ne) {
        var be = $t();
        return be.useDeferredValue(ne);
      }
      function cr() {
        var ne = $t();
        return ne.useId();
      }
      function Zl(ne, be, Be) {
        var qe = $t();
        return qe.useSyncExternalStore(ne, be, Be);
      }
      var Uf = 0, Np, qd, Zs, vv, Ss, cm, fm;
      function bv() {
      }
      bv.__reactDisabledLog = !0;
      function Gd() {
        {
          if (Uf === 0) {
            Np = console.log, qd = console.info, Zs = console.warn, vv = console.error, Ss = console.group, cm = console.groupCollapsed, fm = console.groupEnd;
            var ne = {
              configurable: !0,
              enumerable: !0,
              value: bv,
              writable: !0
            };
            Object.defineProperties(console, {
              info: ne,
              log: ne,
              warn: ne,
              error: ne,
              group: ne,
              groupCollapsed: ne,
              groupEnd: ne
            });
          }
          Uf++;
        }
      }
      function Qd() {
        {
          if (Uf--, Uf === 0) {
            var ne = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: he({}, ne, {
                value: Np
              }),
              info: he({}, ne, {
                value: qd
              }),
              warn: he({}, ne, {
                value: Zs
              }),
              error: he({}, ne, {
                value: vv
              }),
              group: he({}, ne, {
                value: Ss
              }),
              groupCollapsed: he({}, ne, {
                value: cm
              }),
              groupEnd: he({}, ne, {
                value: fm
              })
            });
          }
          Uf < 0 && X("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var sl = q.ReactCurrentDispatcher, wa;
      function Yf(ne, be, Be) {
        {
          if (wa === void 0)
            try {
              throw Error();
            } catch (gt) {
              var qe = gt.stack.trim().match(/\n( *(at )?)/);
              wa = qe && qe[1] || "";
            }
          return `
` + wa + ne;
        }
      }
      var Xd = !1, Hf;
      {
        var Dp = typeof WeakMap == "function" ? WeakMap : Map;
        Hf = new Dp();
      }
      function Kd(ne, be) {
        if (!ne || Xd)
          return "";
        {
          var Be = Hf.get(ne);
          if (Be !== void 0)
            return Be;
        }
        var qe;
        Xd = !0;
        var gt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var gn;
        gn = sl.current, sl.current = null, Gd();
        try {
          if (be) {
            var Dt = function() {
              throw Error();
            };
            if (Object.defineProperty(Dt.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Dt, []);
              } catch (_r) {
                qe = _r;
              }
              Reflect.construct(ne, [], Dt);
            } else {
              try {
                Dt.call();
              } catch (_r) {
                qe = _r;
              }
              ne.call(Dt.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (_r) {
              qe = _r;
            }
            ne();
          }
        } catch (_r) {
          if (_r && qe && typeof _r.stack == "string") {
            for (var dn = _r.stack.split(`
`), sr = qe.stack.split(`
`), Tr = dn.length - 1, _i = sr.length - 1; Tr >= 1 && _i >= 0 && dn[Tr] !== sr[_i]; )
              _i--;
            for (; Tr >= 1 && _i >= 0; Tr--, _i--)
              if (dn[Tr] !== sr[_i]) {
                if (Tr !== 1 || _i !== 1)
                  do
                    if (Tr--, _i--, _i < 0 || dn[Tr] !== sr[_i]) {
                      var tr = `
` + dn[Tr].replace(" at new ", " at ");
                      return ne.displayName && tr.includes("<anonymous>") && (tr = tr.replace("<anonymous>", ne.displayName)), typeof ne == "function" && Hf.set(ne, tr), tr;
                    }
                  while (Tr >= 1 && _i >= 0);
                break;
              }
          }
        } finally {
          Xd = !1, sl.current = gn, Qd(), Error.prepareStackTrace = gt;
        }
        var ki = ne ? ne.displayName || ne.name : "", yr = ki ? Yf(ki) : "";
        return typeof ne == "function" && Hf.set(ne, yr), yr;
      }
      function Vf(ne, be, Be) {
        return Kd(ne, !1);
      }
      function $b(ne) {
        var be = ne.prototype;
        return !!(be && be.isReactComponent);
      }
      function ul(ne, be, Be) {
        if (ne == null)
          return "";
        if (typeof ne == "function")
          return Kd(ne, $b(ne));
        if (typeof ne == "string")
          return Yf(ne);
        switch (ne) {
          case h:
            return Yf("Suspense");
          case p:
            return Yf("SuspenseList");
        }
        if (typeof ne == "object")
          switch (ne.$$typeof) {
            case f:
              return Vf(ne.render);
            case g:
              return ul(ne.type, be, Be);
            case y: {
              var qe = ne, gt = qe._payload, gn = qe._init;
              try {
                return ul(gn(gt), be, Be);
              } catch {
              }
            }
          }
        return "";
      }
      var Or = {}, Jl = q.ReactDebugCurrentFrame;
      function Zd(ne) {
        if (ne) {
          var be = ne._owner, Be = ul(ne.type, ne._source, be ? be.type : null);
          Jl.setExtraStackFrame(Be);
        } else
          Jl.setExtraStackFrame(null);
      }
      function Ap(ne, be, Be, qe, gt) {
        {
          var gn = Function.call.bind(Zt);
          for (var Dt in ne)
            if (gn(ne, Dt)) {
              var dn = void 0;
              try {
                if (typeof ne[Dt] != "function") {
                  var sr = Error((qe || "React class") + ": " + Be + " type `" + Dt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ne[Dt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw sr.name = "Invariant Violation", sr;
                }
                dn = ne[Dt](be, Dt, qe, Be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Tr) {
                dn = Tr;
              }
              dn && !(dn instanceof Error) && (Zd(gt), X("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", qe || "React class", Be, Dt, typeof dn), Zd(null)), dn instanceof Error && !(dn.message in Or) && (Or[dn.message] = !0, Zd(gt), X("Failed %s type: %s", Be, dn.message), Zd(null));
            }
        }
      }
      function Rr(ne) {
        if (ne) {
          var be = ne._owner, Be = ul(ne.type, ne._source, be ? be.type : null);
          W(Be);
        } else
          W(null);
      }
      var Op;
      Op = !1;
      function Rp() {
        if (j.current) {
          var ne = tn(j.current.type);
          if (ne)
            return `

Check the render method of \`` + ne + "`.";
        }
        return "";
      }
      function jn(ne) {
        if (ne !== void 0) {
          var be = ne.fileName.replace(/^.*[\\\/]/, ""), Be = ne.lineNumber;
          return `

Check your code at ` + be + ":" + Be + ".";
        }
        return "";
      }
      function Jd(ne) {
        return ne != null ? jn(ne.__source) : "";
      }
      var vo = {};
      function Js(ne) {
        var be = Rp();
        if (!be) {
          var Be = typeof ne == "string" ? ne : ne.displayName || ne.name;
          Be && (be = `

Check the top-level render call using <` + Be + ">.");
        }
        return be;
      }
      function Ms(ne, be) {
        if (!(!ne._store || ne._store.validated || ne.key != null)) {
          ne._store.validated = !0;
          var Be = Js(be);
          if (!vo[Be]) {
            vo[Be] = !0;
            var qe = "";
            ne && ne._owner && ne._owner !== j.current && (qe = " It was passed a child from " + tn(ne._owner.type) + "."), Rr(ne), X('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Be, qe), Rr(null);
          }
        }
      }
      function Wf(ne, be) {
        if (typeof ne == "object") {
          if (Qe(ne))
            for (var Be = 0; Be < ne.length; Be++) {
              var qe = ne[Be];
              Dn(qe) && Ms(qe, be);
            }
          else if (Dn(ne))
            ne._store && (ne._store.validated = !0);
          else if (ne) {
            var gt = C(ne);
            if (typeof gt == "function" && gt !== ne.entries)
              for (var gn = gt.call(ne), Dt; !(Dt = gn.next()).done; )
                Dn(Dt.value) && Ms(Dt.value, be);
          }
        }
      }
      function Do(ne) {
        {
          var be = ne.type;
          if (be == null || typeof be == "string")
            return;
          var Be;
          if (typeof be == "function")
            Be = be.propTypes;
          else if (typeof be == "object" && (be.$$typeof === f || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          be.$$typeof === g))
            Be = be.propTypes;
          else
            return;
          if (Be) {
            var qe = tn(be);
            Ap(Be, ne.props, "prop", qe, ne);
          } else if (be.PropTypes !== void 0 && !Op) {
            Op = !0;
            var gt = tn(be);
            X("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", gt || "Unknown");
          }
          typeof be.getDefaultProps == "function" && !be.getDefaultProps.isReactClassApproved && X("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function ii(ne) {
        {
          for (var be = Object.keys(ne.props), Be = 0; Be < be.length; Be++) {
            var qe = be[Be];
            if (qe !== "children" && qe !== "key") {
              Rr(ne), X("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", qe), Rr(null);
              break;
            }
          }
          ne.ref !== null && (Rr(ne), X("Invalid attribute `ref` supplied to `React.Fragment`."), Rr(null));
        }
      }
      function Pb(ne, be, Be) {
        var qe = lt(ne);
        if (!qe) {
          var gt = "";
          (ne === void 0 || typeof ne == "object" && ne !== null && Object.keys(ne).length === 0) && (gt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var gn = Jd(be);
          gn ? gt += gn : gt += Rp();
          var Dt;
          ne === null ? Dt = "null" : Qe(ne) ? Dt = "array" : ne !== void 0 && ne.$$typeof === r ? (Dt = "<" + (tn(ne.type) || "Unknown") + " />", gt = " Did you accidentally export a JSX literal instead of a component?") : Dt = typeof ne, X("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Dt, gt);
        }
        var dn = ht.apply(this, arguments);
        if (dn == null)
          return dn;
        if (qe)
          for (var sr = 2; sr < arguments.length; sr++)
            Wf(arguments[sr], ne);
        return ne === o ? ii(dn) : Do(dn), dn;
      }
      var eu = !1;
      function Ko(ne) {
        var be = Pb.bind(null, ne);
        return be.type = ne, eu || (eu = !0, te("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(be, "type", {
          enumerable: !1,
          get: function() {
            return te("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: ne
            }), ne;
          }
        }), be;
      }
      function Bc(ne, be, Be) {
        for (var qe = _n.apply(this, arguments), gt = 2; gt < arguments.length; gt++)
          Wf(arguments[gt], qe.type);
        return Do(qe), qe;
      }
      function Ib(ne, be) {
        var Be = O.transition;
        O.transition = {};
        var qe = O.transition;
        O.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          ne();
        } finally {
          if (O.transition = Be, Be === null && qe._updatedFibers) {
            var gt = qe._updatedFibers.size;
            gt > 10 && te("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), qe._updatedFibers.clear();
          }
        }
      }
      var qf = !1, eh = null;
      function jb(ne) {
        if (eh === null)
          try {
            var be = ("require" + Math.random()).slice(0, 7), Be = e && e[be];
            eh = Be.call(e, "timers").setImmediate;
          } catch {
            eh = function(gt) {
              qf === !1 && (qf = !0, typeof MessageChannel > "u" && X("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var gn = new MessageChannel();
              gn.port1.onmessage = gt, gn.port2.postMessage(void 0);
            };
          }
        return eh(ne);
      }
      var wr = 0, zr = !1;
      function th(ne) {
        {
          var be = wr;
          wr++, R.current === null && (R.current = []);
          var Be = R.isBatchingLegacy, qe;
          try {
            if (R.isBatchingLegacy = !0, qe = ne(), !Be && R.didScheduleLegacyUpdate) {
              var gt = R.current;
              gt !== null && (R.didScheduleLegacyUpdate = !1, rh(gt));
            }
          } catch (ki) {
            throw ll(be), ki;
          } finally {
            R.isBatchingLegacy = Be;
          }
          if (qe !== null && typeof qe == "object" && typeof qe.then == "function") {
            var gn = qe, Dt = !1, dn = {
              then: function(ki, yr) {
                Dt = !0, gn.then(function(_r) {
                  ll(be), wr === 0 ? dm(_r, ki, yr) : ki(_r);
                }, function(_r) {
                  ll(be), yr(_r);
                });
              }
            };
            return !zr && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Dt || (zr = !0, X("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), dn;
          } else {
            var sr = qe;
            if (ll(be), wr === 0) {
              var Tr = R.current;
              Tr !== null && (rh(Tr), R.current = null);
              var _i = {
                then: function(ki, yr) {
                  R.current === null ? (R.current = [], dm(sr, ki, yr)) : ki(sr);
                }
              };
              return _i;
            } else {
              var tr = {
                then: function(ki, yr) {
                  ki(sr);
                }
              };
              return tr;
            }
          }
        }
      }
      function ll(ne) {
        ne !== wr - 1 && X("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), wr = ne;
      }
      function dm(ne, be, Be) {
        {
          var qe = R.current;
          if (qe !== null)
            try {
              rh(qe), jb(function() {
                qe.length === 0 ? (R.current = null, be(ne)) : dm(ne, be, Be);
              });
            } catch (gt) {
              Be(gt);
            }
          else
            be(ne);
        }
      }
      var nh = !1;
      function rh(ne) {
        if (!nh) {
          nh = !0;
          var be = 0;
          try {
            for (; be < ne.length; be++) {
              var Be = ne[be];
              do
                Be = Be(!0);
              while (Be !== null);
            }
            ne.length = 0;
          } catch (qe) {
            throw ne = ne.slice(be + 1), qe;
          } finally {
            nh = !1;
          }
        }
      }
      var kp = Pb, $p = Bc, xv = Ko, Ri = {
        map: ws,
        forEach: Lc,
        count: Ql,
        toArray: zc,
        only: Xl
      };
      t.Children = Ri, t.Component = _e, t.Fragment = o, t.Profiler = s, t.PureComponent = we, t.StrictMode = a, t.Suspense = h, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = q, t.cloneElement = $p, t.createContext = Fc, t.createElement = kp, t.createFactory = xv, t.createRef = ze, t.forwardRef = ss, t.isValidElement = Dn, t.lazy = Hi, t.memo = St, t.startTransition = Ib, t.unstable_act = th, t.useCallback = nn, t.useContext = In, t.useDebugValue = mr, t.useDeferredValue = Kl, t.useEffect = No, t.useId = cr, t.useImperativeHandle = lm, t.useInsertionEffect = xi, t.useLayoutEffect = wi, t.useMemo = Oi, t.useReducer = zn, t.useRef = sn, t.useState = lr, t.useSyncExternalStore = Zl, t.useTransition = Vw, t.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(wO, wO.exports)), wO.exports;
}
process.env.NODE_ENV === "production" ? XV.exports = K5e() : XV.exports = Z5e();
var ae = XV.exports;
const Oy = /* @__PURE__ */ KC(ae), KV = /* @__PURE__ */ Q5e({
  __proto__: null,
  default: Oy
}, [ae]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qse;
function J5e() {
  if (Qse)
    return _A;
  Qse = 1;
  var e = ae, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, u, l) {
    var f, h = {}, p = null, g = null;
    l !== void 0 && (p = "" + l), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (g = u.ref);
    for (f in u)
      r.call(u, f) && !o.hasOwnProperty(f) && (h[f] = u[f]);
    if (s && s.defaultProps)
      for (f in u = s.defaultProps, u)
        h[f] === void 0 && (h[f] = u[f]);
    return { $$typeof: t, type: s, key: p, ref: g, props: h, _owner: i.current };
  }
  return _A.Fragment = n, _A.jsx = a, _A.jsxs = a, _A;
}
var EA = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xse;
function eze() {
  return Xse || (Xse = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ae, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), y = Symbol.iterator, b = "@@iterator";
    function _(xe) {
      if (xe === null || typeof xe != "object")
        return null;
      var lt = y && xe[y] || xe[b];
      return typeof lt == "function" ? lt : null;
    }
    var S = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function C(xe) {
      {
        for (var lt = arguments.length, St = new Array(lt > 1 ? lt - 1 : 0), $t = 1; $t < lt; $t++)
          St[$t - 1] = arguments[$t];
        A("error", xe, St);
      }
    }
    function A(xe, lt, St) {
      {
        var $t = S.ReactDebugCurrentFrame, In = $t.getStackAddendum();
        In !== "" && (lt += "%s", St = St.concat([In]));
        var lr = St.map(function(zn) {
          return String(zn);
        });
        lr.unshift("Warning: " + lt), Function.prototype.apply.call(console[xe], console, lr);
      }
    }
    var O = !1, R = !1, j = !1, $ = !1, z = !1, W;
    W = Symbol.for("react.module.reference");
    function Y(xe) {
      return !!(typeof xe == "string" || typeof xe == "function" || xe === r || xe === o || z || xe === i || xe === l || xe === f || $ || xe === g || O || R || j || typeof xe == "object" && xe !== null && (xe.$$typeof === p || xe.$$typeof === h || xe.$$typeof === a || xe.$$typeof === s || xe.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      xe.$$typeof === W || xe.getModuleId !== void 0));
    }
    function V(xe, lt, St) {
      var $t = xe.displayName;
      if ($t)
        return $t;
      var In = lt.displayName || lt.name || "";
      return In !== "" ? St + "(" + In + ")" : St;
    }
    function ee(xe) {
      return xe.displayName || "Context";
    }
    function K(xe) {
      if (xe == null)
        return null;
      if (typeof xe.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof xe == "function")
        return xe.displayName || xe.name || null;
      if (typeof xe == "string")
        return xe;
      switch (xe) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof xe == "object")
        switch (xe.$$typeof) {
          case s:
            var lt = xe;
            return ee(lt) + ".Consumer";
          case a:
            var St = xe;
            return ee(St._context) + ".Provider";
          case u:
            return V(xe, xe.render, "ForwardRef");
          case h:
            var $t = xe.displayName || null;
            return $t !== null ? $t : K(xe.type) || "Memo";
          case p: {
            var In = xe, lr = In._payload, zn = In._init;
            try {
              return K(zn(lr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Q = Object.assign, q = 0, te, X, Z, se, H, ie, he;
    function ye() {
    }
    ye.__reactDisabledLog = !0;
    function _e() {
      {
        if (q === 0) {
          te = console.log, X = console.info, Z = console.warn, se = console.error, H = console.group, ie = console.groupCollapsed, he = console.groupEnd;
          var xe = {
            configurable: !0,
            enumerable: !0,
            value: ye,
            writable: !0
          };
          Object.defineProperties(console, {
            info: xe,
            log: xe,
            warn: xe,
            error: xe,
            group: xe,
            groupCollapsed: xe,
            groupEnd: xe
          });
        }
        q++;
      }
    }
    function Ne() {
      {
        if (q--, q === 0) {
          var xe = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Q({}, xe, {
              value: te
            }),
            info: Q({}, xe, {
              value: X
            }),
            warn: Q({}, xe, {
              value: Z
            }),
            error: Q({}, xe, {
              value: se
            }),
            group: Q({}, xe, {
              value: H
            }),
            groupCollapsed: Q({}, xe, {
              value: ie
            }),
            groupEnd: Q({}, xe, {
              value: he
            })
          });
        }
        q < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Oe = S.ReactCurrentDispatcher, ke;
    function Me(xe, lt, St) {
      {
        if (ke === void 0)
          try {
            throw Error();
          } catch (In) {
            var $t = In.stack.trim().match(/\n( *(at )?)/);
            ke = $t && $t[1] || "";
          }
        return `
` + ke + xe;
      }
    }
    var we = !1, Ye;
    {
      var ze = typeof WeakMap == "function" ? WeakMap : Map;
      Ye = new ze();
    }
    function fe(xe, lt) {
      if (!xe || we)
        return "";
      {
        var St = Ye.get(xe);
        if (St !== void 0)
          return St;
      }
      var $t;
      we = !0;
      var In = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var lr;
      lr = Oe.current, Oe.current = null, _e();
      try {
        if (lt) {
          var zn = function() {
            throw Error();
          };
          if (Object.defineProperty(zn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(zn, []);
            } catch (mr) {
              $t = mr;
            }
            Reflect.construct(xe, [], zn);
          } else {
            try {
              zn.call();
            } catch (mr) {
              $t = mr;
            }
            xe.call(zn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (mr) {
            $t = mr;
          }
          xe();
        }
      } catch (mr) {
        if (mr && $t && typeof mr.stack == "string") {
          for (var sn = mr.stack.split(`
`), No = $t.stack.split(`
`), xi = sn.length - 1, wi = No.length - 1; xi >= 1 && wi >= 0 && sn[xi] !== No[wi]; )
            wi--;
          for (; xi >= 1 && wi >= 0; xi--, wi--)
            if (sn[xi] !== No[wi]) {
              if (xi !== 1 || wi !== 1)
                do
                  if (xi--, wi--, wi < 0 || sn[xi] !== No[wi]) {
                    var nn = `
` + sn[xi].replace(" at new ", " at ");
                    return xe.displayName && nn.includes("<anonymous>") && (nn = nn.replace("<anonymous>", xe.displayName)), typeof xe == "function" && Ye.set(xe, nn), nn;
                  }
                while (xi >= 1 && wi >= 0);
              break;
            }
        }
      } finally {
        we = !1, Oe.current = lr, Ne(), Error.prepareStackTrace = In;
      }
      var Oi = xe ? xe.displayName || xe.name : "", lm = Oi ? Me(Oi) : "";
      return typeof xe == "function" && Ye.set(xe, lm), lm;
    }
    function Qe(xe, lt, St) {
      return fe(xe, !1);
    }
    function $e(xe) {
      var lt = xe.prototype;
      return !!(lt && lt.isReactComponent);
    }
    function pt(xe, lt, St) {
      if (xe == null)
        return "";
      if (typeof xe == "function")
        return fe(xe, $e(xe));
      if (typeof xe == "string")
        return Me(xe);
      switch (xe) {
        case l:
          return Me("Suspense");
        case f:
          return Me("SuspenseList");
      }
      if (typeof xe == "object")
        switch (xe.$$typeof) {
          case u:
            return Qe(xe.render);
          case h:
            return pt(xe.type, lt, St);
          case p: {
            var $t = xe, In = $t._payload, lr = $t._init;
            try {
              return pt(lr(In), lt, St);
            } catch {
            }
          }
        }
      return "";
    }
    var _t = Object.prototype.hasOwnProperty, Ot = {}, mn = S.ReactDebugCurrentFrame;
    function jr(xe) {
      if (xe) {
        var lt = xe._owner, St = pt(xe.type, xe._source, lt ? lt.type : null);
        mn.setExtraStackFrame(St);
      } else
        mn.setExtraStackFrame(null);
    }
    function tn(xe, lt, St, $t, In) {
      {
        var lr = Function.call.bind(_t);
        for (var zn in xe)
          if (lr(xe, zn)) {
            var sn = void 0;
            try {
              if (typeof xe[zn] != "function") {
                var No = Error(($t || "React class") + ": " + St + " type `" + zn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof xe[zn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw No.name = "Invariant Violation", No;
              }
              sn = xe[zn](lt, zn, $t, St, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (xi) {
              sn = xi;
            }
            sn && !(sn instanceof Error) && (jr(In), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $t || "React class", St, zn, typeof sn), jr(null)), sn instanceof Error && !(sn.message in Ot) && (Ot[sn.message] = !0, jr(In), C("Failed %s type: %s", St, sn.message), jr(null));
          }
      }
    }
    var Zt = Array.isArray;
    function qn(xe) {
      return Zt(xe);
    }
    function fn(xe) {
      {
        var lt = typeof Symbol == "function" && Symbol.toStringTag, St = lt && xe[Symbol.toStringTag] || xe.constructor.name || "Object";
        return St;
      }
    }
    function gr(xe) {
      try {
        return Zn(xe), !1;
      } catch {
        return !0;
      }
    }
    function Zn(xe) {
      return "" + xe;
    }
    function xr(xe) {
      if (gr(xe))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", fn(xe)), Zn(xe);
    }
    var Un = S.ReactCurrentOwner, Qt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ut, er, We;
    We = {};
    function ht(xe) {
      if (_t.call(xe, "ref")) {
        var lt = Object.getOwnPropertyDescriptor(xe, "ref").get;
        if (lt && lt.isReactWarning)
          return !1;
      }
      return xe.ref !== void 0;
    }
    function Ft(xe) {
      if (_t.call(xe, "key")) {
        var lt = Object.getOwnPropertyDescriptor(xe, "key").get;
        if (lt && lt.isReactWarning)
          return !1;
      }
      return xe.key !== void 0;
    }
    function _n(xe, lt) {
      if (typeof xe.ref == "string" && Un.current && lt && Un.current.stateNode !== lt) {
        var St = K(Un.current.type);
        We[St] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', K(Un.current.type), xe.ref), We[St] = !0);
      }
    }
    function Dn(xe, lt) {
      {
        var St = function() {
          Ut || (Ut = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", lt));
        };
        St.isReactWarning = !0, Object.defineProperty(xe, "key", {
          get: St,
          configurable: !0
        });
      }
    }
    function di(xe, lt) {
      {
        var St = function() {
          er || (er = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", lt));
        };
        St.isReactWarning = !0, Object.defineProperty(xe, "ref", {
          get: St,
          configurable: !0
        });
      }
    }
    var bi = function(xe, lt, St, $t, In, lr, zn) {
      var sn = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: xe,
        key: lt,
        ref: St,
        props: zn,
        // Record the component responsible for creating this element.
        _owner: lr
      };
      return sn._store = {}, Object.defineProperty(sn._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(sn, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $t
      }), Object.defineProperty(sn, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: In
      }), Object.freeze && (Object.freeze(sn.props), Object.freeze(sn)), sn;
    };
    function ua(xe, lt, St, $t, In) {
      {
        var lr, zn = {}, sn = null, No = null;
        St !== void 0 && (xr(St), sn = "" + St), Ft(lt) && (xr(lt.key), sn = "" + lt.key), ht(lt) && (No = lt.ref, _n(lt, In));
        for (lr in lt)
          _t.call(lt, lr) && !Qt.hasOwnProperty(lr) && (zn[lr] = lt[lr]);
        if (xe && xe.defaultProps) {
          var xi = xe.defaultProps;
          for (lr in xi)
            zn[lr] === void 0 && (zn[lr] = xi[lr]);
        }
        if (sn || No) {
          var wi = typeof xe == "function" ? xe.displayName || xe.name || "Unknown" : xe;
          sn && Dn(zn, wi), No && di(zn, wi);
        }
        return bi(xe, sn, No, In, $t, Un.current, zn);
      }
    }
    var Zr = S.ReactCurrentOwner, Wa = S.ReactDebugCurrentFrame;
    function Lr(xe) {
      if (xe) {
        var lt = xe._owner, St = pt(xe.type, xe._source, lt ? lt.type : null);
        Wa.setExtraStackFrame(St);
      } else
        Wa.setExtraStackFrame(null);
    }
    var Ar;
    Ar = !1;
    function Ks(xe) {
      return typeof xe == "object" && xe !== null && xe.$$typeof === t;
    }
    function ws() {
      {
        if (Zr.current) {
          var xe = K(Zr.current.type);
          if (xe)
            return `

Check the render method of \`` + xe + "`.";
        }
        return "";
      }
    }
    function Ql(xe) {
      {
        if (xe !== void 0) {
          var lt = xe.fileName.replace(/^.*[\\\/]/, ""), St = xe.lineNumber;
          return `

Check your code at ` + lt + ":" + St + ".";
        }
        return "";
      }
    }
    var Lc = {};
    function zc(xe) {
      {
        var lt = ws();
        if (!lt) {
          var St = typeof xe == "string" ? xe : xe.displayName || xe.name;
          St && (lt = `

Check the top-level render call using <` + St + ">.");
        }
        return lt;
      }
    }
    function Xl(xe, lt) {
      {
        if (!xe._store || xe._store.validated || xe.key != null)
          return;
        xe._store.validated = !0;
        var St = zc(lt);
        if (Lc[St])
          return;
        Lc[St] = !0;
        var $t = "";
        xe && xe._owner && xe._owner !== Zr.current && ($t = " It was passed a child from " + K(xe._owner.type) + "."), Lr(xe), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', St, $t), Lr(null);
      }
    }
    function Fc(xe, lt) {
      {
        if (typeof xe != "object")
          return;
        if (qn(xe))
          for (var St = 0; St < xe.length; St++) {
            var $t = xe[St];
            Ks($t) && Xl($t, lt);
          }
        else if (Ks(xe))
          xe._store && (xe._store.validated = !0);
        else if (xe) {
          var In = _(xe);
          if (typeof In == "function" && In !== xe.entries)
            for (var lr = In.call(xe), zn; !(zn = lr.next()).done; )
              Ks(zn.value) && Xl(zn.value, lt);
        }
      }
    }
    function _s(xe) {
      {
        var lt = xe.type;
        if (lt == null || typeof lt == "string")
          return;
        var St;
        if (typeof lt == "function")
          St = lt.propTypes;
        else if (typeof lt == "object" && (lt.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        lt.$$typeof === h))
          St = lt.propTypes;
        else
          return;
        if (St) {
          var $t = K(lt);
          tn(St, xe.props, "prop", $t, xe);
        } else if (lt.PropTypes !== void 0 && !Ar) {
          Ar = !0;
          var In = K(lt);
          C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", In || "Unknown");
        }
        typeof lt.getDefaultProps == "function" && !lt.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function as(xe) {
      {
        for (var lt = Object.keys(xe.props), St = 0; St < lt.length; St++) {
          var $t = lt[St];
          if ($t !== "children" && $t !== "key") {
            Lr(xe), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $t), Lr(null);
            break;
          }
        }
        xe.ref !== null && (Lr(xe), C("Invalid attribute `ref` supplied to `React.Fragment`."), Lr(null));
      }
    }
    function Es(xe, lt, St, $t, In, lr) {
      {
        var zn = Y(xe);
        if (!zn) {
          var sn = "";
          (xe === void 0 || typeof xe == "object" && xe !== null && Object.keys(xe).length === 0) && (sn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var No = Ql(In);
          No ? sn += No : sn += ws();
          var xi;
          xe === null ? xi = "null" : qn(xe) ? xi = "array" : xe !== void 0 && xe.$$typeof === t ? (xi = "<" + (K(xe.type) || "Unknown") + " />", sn = " Did you accidentally export a JSX literal instead of a component?") : xi = typeof xe, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", xi, sn);
        }
        var wi = ua(xe, lt, St, In, lr);
        if (wi == null)
          return wi;
        if (zn) {
          var nn = lt.children;
          if (nn !== void 0)
            if ($t)
              if (qn(nn)) {
                for (var Oi = 0; Oi < nn.length; Oi++)
                  Fc(nn[Oi], xe);
                Object.freeze && Object.freeze(nn);
              } else
                C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fc(nn, xe);
        }
        return xe === r ? as(wi) : _s(wi), wi;
      }
    }
    function xa(xe, lt, St) {
      return Es(xe, lt, St, !0);
    }
    function la(xe, lt, St) {
      return Es(xe, lt, St, !1);
    }
    var Hi = la, ss = xa;
    EA.Fragment = r, EA.jsx = Hi, EA.jsxs = ss;
  }()), EA;
}
process.env.NODE_ENV === "production" ? QV.exports = J5e() : QV.exports = eze();
var pe = QV.exports, _O = {}, ZV = { exports: {} }, cf = {}, yI = { exports: {} }, XU = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kse;
function tze() {
  return Kse || (Kse = 1, function(e) {
    function t(Z, se) {
      var H = Z.length;
      Z.push(se);
      e:
        for (; 0 < H; ) {
          var ie = H - 1 >>> 1, he = Z[ie];
          if (0 < i(he, se))
            Z[ie] = se, Z[H] = he, H = ie;
          else
            break e;
        }
    }
    function n(Z) {
      return Z.length === 0 ? null : Z[0];
    }
    function r(Z) {
      if (Z.length === 0)
        return null;
      var se = Z[0], H = Z.pop();
      if (H !== se) {
        Z[0] = H;
        e:
          for (var ie = 0, he = Z.length, ye = he >>> 1; ie < ye; ) {
            var _e = 2 * (ie + 1) - 1, Ne = Z[_e], Oe = _e + 1, ke = Z[Oe];
            if (0 > i(Ne, H))
              Oe < he && 0 > i(ke, Ne) ? (Z[ie] = ke, Z[Oe] = H, ie = Oe) : (Z[ie] = Ne, Z[_e] = H, ie = _e);
            else if (Oe < he && 0 > i(ke, H))
              Z[ie] = ke, Z[Oe] = H, ie = Oe;
            else
              break e;
          }
      }
      return se;
    }
    function i(Z, se) {
      var H = Z.sortIndex - se.sortIndex;
      return H !== 0 ? H : Z.id - se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var a = Date, s = a.now();
      e.unstable_now = function() {
        return a.now() - s;
      };
    }
    var u = [], l = [], f = 1, h = null, p = 3, g = !1, y = !1, b = !1, _ = typeof setTimeout == "function" ? setTimeout : null, S = typeof clearTimeout == "function" ? clearTimeout : null, C = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function A(Z) {
      for (var se = n(l); se !== null; ) {
        if (se.callback === null)
          r(l);
        else if (se.startTime <= Z)
          r(l), se.sortIndex = se.expirationTime, t(u, se);
        else
          break;
        se = n(l);
      }
    }
    function O(Z) {
      if (b = !1, A(Z), !y)
        if (n(u) !== null)
          y = !0, te(R);
        else {
          var se = n(l);
          se !== null && X(O, se.startTime - Z);
        }
    }
    function R(Z, se) {
      y = !1, b && (b = !1, S(z), z = -1), g = !0;
      var H = p;
      try {
        for (A(se), h = n(u); h !== null && (!(h.expirationTime > se) || Z && !V()); ) {
          var ie = h.callback;
          if (typeof ie == "function") {
            h.callback = null, p = h.priorityLevel;
            var he = ie(h.expirationTime <= se);
            se = e.unstable_now(), typeof he == "function" ? h.callback = he : h === n(u) && r(u), A(se);
          } else
            r(u);
          h = n(u);
        }
        if (h !== null)
          var ye = !0;
        else {
          var _e = n(l);
          _e !== null && X(O, _e.startTime - se), ye = !1;
        }
        return ye;
      } finally {
        h = null, p = H, g = !1;
      }
    }
    var j = !1, $ = null, z = -1, W = 5, Y = -1;
    function V() {
      return !(e.unstable_now() - Y < W);
    }
    function ee() {
      if ($ !== null) {
        var Z = e.unstable_now();
        Y = Z;
        var se = !0;
        try {
          se = $(!0, Z);
        } finally {
          se ? K() : (j = !1, $ = null);
        }
      } else
        j = !1;
    }
    var K;
    if (typeof C == "function")
      K = function() {
        C(ee);
      };
    else if (typeof MessageChannel < "u") {
      var Q = new MessageChannel(), q = Q.port2;
      Q.port1.onmessage = ee, K = function() {
        q.postMessage(null);
      };
    } else
      K = function() {
        _(ee, 0);
      };
    function te(Z) {
      $ = Z, j || (j = !0, K());
    }
    function X(Z, se) {
      z = _(function() {
        Z(e.unstable_now());
      }, se);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(Z) {
      Z.callback = null;
    }, e.unstable_continueExecution = function() {
      y || g || (y = !0, te(R));
    }, e.unstable_forceFrameRate = function(Z) {
      0 > Z || 125 < Z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : W = 0 < Z ? Math.floor(1e3 / Z) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return p;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(u);
    }, e.unstable_next = function(Z) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var se = 3;
          break;
        default:
          se = p;
      }
      var H = p;
      p = se;
      try {
        return Z();
      } finally {
        p = H;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(Z, se) {
      switch (Z) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Z = 3;
      }
      var H = p;
      p = Z;
      try {
        return se();
      } finally {
        p = H;
      }
    }, e.unstable_scheduleCallback = function(Z, se, H) {
      var ie = e.unstable_now();
      switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? ie + H : ie) : H = ie, Z) {
        case 1:
          var he = -1;
          break;
        case 2:
          he = 250;
          break;
        case 5:
          he = 1073741823;
          break;
        case 4:
          he = 1e4;
          break;
        default:
          he = 5e3;
      }
      return he = H + he, Z = { id: f++, callback: se, priorityLevel: Z, startTime: H, expirationTime: he, sortIndex: -1 }, H > ie ? (Z.sortIndex = H, t(l, Z), n(u) === null && Z === n(l) && (b ? (S(z), z = -1) : b = !0, X(O, H - ie))) : (Z.sortIndex = he, t(u, Z), y || g || (y = !0, te(R))), Z;
    }, e.unstable_shouldYield = V, e.unstable_wrapCallback = function(Z) {
      var se = p;
      return function() {
        var H = p;
        p = se;
        try {
          return Z.apply(this, arguments);
        } finally {
          p = H;
        }
      };
    };
  }(XU)), XU;
}
var KU = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zse;
function nze() {
  return Zse || (Zse = 1, function(e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, r = 5;
      function i(We, ht) {
        var Ft = We.length;
        We.push(ht), s(We, ht, Ft);
      }
      function o(We) {
        return We.length === 0 ? null : We[0];
      }
      function a(We) {
        if (We.length === 0)
          return null;
        var ht = We[0], Ft = We.pop();
        return Ft !== ht && (We[0] = Ft, u(We, Ft, 0)), ht;
      }
      function s(We, ht, Ft) {
        for (var _n = Ft; _n > 0; ) {
          var Dn = _n - 1 >>> 1, di = We[Dn];
          if (l(di, ht) > 0)
            We[Dn] = ht, We[_n] = di, _n = Dn;
          else
            return;
        }
      }
      function u(We, ht, Ft) {
        for (var _n = Ft, Dn = We.length, di = Dn >>> 1; _n < di; ) {
          var bi = (_n + 1) * 2 - 1, ua = We[bi], Zr = bi + 1, Wa = We[Zr];
          if (l(ua, ht) < 0)
            Zr < Dn && l(Wa, ua) < 0 ? (We[_n] = Wa, We[Zr] = ht, _n = Zr) : (We[_n] = ua, We[bi] = ht, _n = bi);
          else if (Zr < Dn && l(Wa, ht) < 0)
            We[_n] = Wa, We[Zr] = ht, _n = Zr;
          else
            return;
        }
      }
      function l(We, ht) {
        var Ft = We.sortIndex - ht.sortIndex;
        return Ft !== 0 ? Ft : We.id - ht.id;
      }
      var f = 1, h = 2, p = 3, g = 4, y = 5;
      function b(We, ht) {
      }
      var _ = typeof performance == "object" && typeof performance.now == "function";
      if (_) {
        var S = performance;
        e.unstable_now = function() {
          return S.now();
        };
      } else {
        var C = Date, A = C.now();
        e.unstable_now = function() {
          return C.now() - A;
        };
      }
      var O = 1073741823, R = -1, j = 250, $ = 5e3, z = 1e4, W = O, Y = [], V = [], ee = 1, K = null, Q = p, q = !1, te = !1, X = !1, Z = typeof setTimeout == "function" ? setTimeout : null, se = typeof clearTimeout == "function" ? clearTimeout : null, H = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ie(We) {
        for (var ht = o(V); ht !== null; ) {
          if (ht.callback === null)
            a(V);
          else if (ht.startTime <= We)
            a(V), ht.sortIndex = ht.expirationTime, i(Y, ht);
          else
            return;
          ht = o(V);
        }
      }
      function he(We) {
        if (X = !1, ie(We), !te)
          if (o(Y) !== null)
            te = !0, xr(ye);
          else {
            var ht = o(V);
            ht !== null && Un(he, ht.startTime - We);
          }
      }
      function ye(We, ht) {
        te = !1, X && (X = !1, Qt()), q = !0;
        var Ft = Q;
        try {
          var _n;
          if (!n)
            return _e(We, ht);
        } finally {
          K = null, Q = Ft, q = !1;
        }
      }
      function _e(We, ht) {
        var Ft = ht;
        for (ie(Ft), K = o(Y); K !== null && !t && !(K.expirationTime > Ft && (!We || jr())); ) {
          var _n = K.callback;
          if (typeof _n == "function") {
            K.callback = null, Q = K.priorityLevel;
            var Dn = K.expirationTime <= Ft, di = _n(Dn);
            Ft = e.unstable_now(), typeof di == "function" ? K.callback = di : K === o(Y) && a(Y), ie(Ft);
          } else
            a(Y);
          K = o(Y);
        }
        if (K !== null)
          return !0;
        var bi = o(V);
        return bi !== null && Un(he, bi.startTime - Ft), !1;
      }
      function Ne(We, ht) {
        switch (We) {
          case f:
          case h:
          case p:
          case g:
          case y:
            break;
          default:
            We = p;
        }
        var Ft = Q;
        Q = We;
        try {
          return ht();
        } finally {
          Q = Ft;
        }
      }
      function Oe(We) {
        var ht;
        switch (Q) {
          case f:
          case h:
          case p:
            ht = p;
            break;
          default:
            ht = Q;
            break;
        }
        var Ft = Q;
        Q = ht;
        try {
          return We();
        } finally {
          Q = Ft;
        }
      }
      function ke(We) {
        var ht = Q;
        return function() {
          var Ft = Q;
          Q = ht;
          try {
            return We.apply(this, arguments);
          } finally {
            Q = Ft;
          }
        };
      }
      function Me(We, ht, Ft) {
        var _n = e.unstable_now(), Dn;
        if (typeof Ft == "object" && Ft !== null) {
          var di = Ft.delay;
          typeof di == "number" && di > 0 ? Dn = _n + di : Dn = _n;
        } else
          Dn = _n;
        var bi;
        switch (We) {
          case f:
            bi = R;
            break;
          case h:
            bi = j;
            break;
          case y:
            bi = W;
            break;
          case g:
            bi = z;
            break;
          case p:
          default:
            bi = $;
            break;
        }
        var ua = Dn + bi, Zr = {
          id: ee++,
          callback: ht,
          priorityLevel: We,
          startTime: Dn,
          expirationTime: ua,
          sortIndex: -1
        };
        return Dn > _n ? (Zr.sortIndex = Dn, i(V, Zr), o(Y) === null && Zr === o(V) && (X ? Qt() : X = !0, Un(he, Dn - _n))) : (Zr.sortIndex = ua, i(Y, Zr), !te && !q && (te = !0, xr(ye))), Zr;
      }
      function we() {
      }
      function Ye() {
        !te && !q && (te = !0, xr(ye));
      }
      function ze() {
        return o(Y);
      }
      function fe(We) {
        We.callback = null;
      }
      function Qe() {
        return Q;
      }
      var $e = !1, pt = null, _t = -1, Ot = r, mn = -1;
      function jr() {
        var We = e.unstable_now() - mn;
        return !(We < Ot);
      }
      function tn() {
      }
      function Zt(We) {
        if (We < 0 || We > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        We > 0 ? Ot = Math.floor(1e3 / We) : Ot = r;
      }
      var qn = function() {
        if (pt !== null) {
          var We = e.unstable_now();
          mn = We;
          var ht = !0, Ft = !0;
          try {
            Ft = pt(ht, We);
          } finally {
            Ft ? fn() : ($e = !1, pt = null);
          }
        } else
          $e = !1;
      }, fn;
      if (typeof H == "function")
        fn = function() {
          H(qn);
        };
      else if (typeof MessageChannel < "u") {
        var gr = new MessageChannel(), Zn = gr.port2;
        gr.port1.onmessage = qn, fn = function() {
          Zn.postMessage(null);
        };
      } else
        fn = function() {
          Z(qn, 0);
        };
      function xr(We) {
        pt = We, $e || ($e = !0, fn());
      }
      function Un(We, ht) {
        _t = Z(function() {
          We(e.unstable_now());
        }, ht);
      }
      function Qt() {
        se(_t), _t = -1;
      }
      var Ut = tn, er = null;
      e.unstable_IdlePriority = y, e.unstable_ImmediatePriority = f, e.unstable_LowPriority = g, e.unstable_NormalPriority = p, e.unstable_Profiling = er, e.unstable_UserBlockingPriority = h, e.unstable_cancelCallback = fe, e.unstable_continueExecution = Ye, e.unstable_forceFrameRate = Zt, e.unstable_getCurrentPriorityLevel = Qe, e.unstable_getFirstCallbackNode = ze, e.unstable_next = Oe, e.unstable_pauseExecution = we, e.unstable_requestPaint = Ut, e.unstable_runWithPriority = Ne, e.unstable_scheduleCallback = Me, e.unstable_shouldYield = jr, e.unstable_wrapCallback = ke, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(KU)), KU;
}
var Jse;
function Xve() {
  return Jse || (Jse = 1, process.env.NODE_ENV === "production" ? yI.exports = tze() : yI.exports = nze()), yI.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eue;
function rze() {
  if (eue)
    return cf;
  eue = 1;
  var e = ae, t = Xve();
  function n(m) {
    for (var v = "https://reactjs.org/docs/error-decoder.html?invariant=" + m, T = 1; T < arguments.length; T++)
      v += "&args[]=" + encodeURIComponent(arguments[T]);
    return "Minified React error #" + m + "; visit " + v + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function o(m, v) {
    a(m, v), a(m + "Capture", v);
  }
  function a(m, v) {
    for (i[m] = v, m = 0; m < v.length; m++)
      r.add(v[m]);
  }
  var s = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), u = Object.prototype.hasOwnProperty, l = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, h = {};
  function p(m) {
    return u.call(h, m) ? !0 : u.call(f, m) ? !1 : l.test(m) ? h[m] = !0 : (f[m] = !0, !1);
  }
  function g(m, v, T, k) {
    if (T !== null && T.type === 0)
      return !1;
    switch (typeof v) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return k ? !1 : T !== null ? !T.acceptsBooleans : (m = m.toLowerCase().slice(0, 5), m !== "data-" && m !== "aria-");
      default:
        return !1;
    }
  }
  function y(m, v, T, k) {
    if (v === null || typeof v > "u" || g(m, v, T, k))
      return !0;
    if (k)
      return !1;
    if (T !== null)
      switch (T.type) {
        case 3:
          return !v;
        case 4:
          return v === !1;
        case 5:
          return isNaN(v);
        case 6:
          return isNaN(v) || 1 > v;
      }
    return !1;
  }
  function b(m, v, T, k, L, B, oe) {
    this.acceptsBooleans = v === 2 || v === 3 || v === 4, this.attributeName = k, this.attributeNamespace = L, this.mustUseProperty = T, this.propertyName = m, this.type = v, this.sanitizeURL = B, this.removeEmptyString = oe;
  }
  var _ = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(m) {
    _[m] = new b(m, 0, !1, m, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(m) {
    var v = m[0];
    _[v] = new b(v, 1, !1, m[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(m) {
    _[m] = new b(m, 2, !1, m.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(m) {
    _[m] = new b(m, 2, !1, m, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(m) {
    _[m] = new b(m, 3, !1, m.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(m) {
    _[m] = new b(m, 3, !0, m, null, !1, !1);
  }), ["capture", "download"].forEach(function(m) {
    _[m] = new b(m, 4, !1, m, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(m) {
    _[m] = new b(m, 6, !1, m, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(m) {
    _[m] = new b(m, 5, !1, m.toLowerCase(), null, !1, !1);
  });
  var S = /[\-:]([a-z])/g;
  function C(m) {
    return m[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(m) {
    var v = m.replace(
      S,
      C
    );
    _[v] = new b(v, 1, !1, m, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(m) {
    var v = m.replace(S, C);
    _[v] = new b(v, 1, !1, m, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(m) {
    var v = m.replace(S, C);
    _[v] = new b(v, 1, !1, m, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(m) {
    _[m] = new b(m, 1, !1, m.toLowerCase(), null, !1, !1);
  }), _.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(m) {
    _[m] = new b(m, 1, !1, m.toLowerCase(), null, !0, !0);
  });
  function A(m, v, T, k) {
    var L = _.hasOwnProperty(v) ? _[v] : null;
    (L !== null ? L.type !== 0 : k || !(2 < v.length) || v[0] !== "o" && v[0] !== "O" || v[1] !== "n" && v[1] !== "N") && (y(v, T, L, k) && (T = null), k || L === null ? p(v) && (T === null ? m.removeAttribute(v) : m.setAttribute(v, "" + T)) : L.mustUseProperty ? m[L.propertyName] = T === null ? L.type === 3 ? !1 : "" : T : (v = L.attributeName, k = L.attributeNamespace, T === null ? m.removeAttribute(v) : (L = L.type, T = L === 3 || L === 4 && T === !0 ? "" : "" + T, k ? m.setAttributeNS(k, v, T) : m.setAttribute(v, T))));
  }
  var O = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, R = Symbol.for("react.element"), j = Symbol.for("react.portal"), $ = Symbol.for("react.fragment"), z = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), Y = Symbol.for("react.provider"), V = Symbol.for("react.context"), ee = Symbol.for("react.forward_ref"), K = Symbol.for("react.suspense"), Q = Symbol.for("react.suspense_list"), q = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), X = Symbol.for("react.offscreen"), Z = Symbol.iterator;
  function se(m) {
    return m === null || typeof m != "object" ? null : (m = Z && m[Z] || m["@@iterator"], typeof m == "function" ? m : null);
  }
  var H = Object.assign, ie;
  function he(m) {
    if (ie === void 0)
      try {
        throw Error();
      } catch (T) {
        var v = T.stack.trim().match(/\n( *(at )?)/);
        ie = v && v[1] || "";
      }
    return `
` + ie + m;
  }
  var ye = !1;
  function _e(m, v) {
    if (!m || ye)
      return "";
    ye = !0;
    var T = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (v)
        if (v = function() {
          throw Error();
        }, Object.defineProperty(v.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(v, []);
          } catch (He) {
            var k = He;
          }
          Reflect.construct(m, [], v);
        } else {
          try {
            v.call();
          } catch (He) {
            k = He;
          }
          m.call(v.prototype);
        }
      else {
        try {
          throw Error();
        } catch (He) {
          k = He;
        }
        m();
      }
    } catch (He) {
      if (He && k && typeof He.stack == "string") {
        for (var L = He.stack.split(`
`), B = k.stack.split(`
`), oe = L.length - 1, me = B.length - 1; 1 <= oe && 0 <= me && L[oe] !== B[me]; )
          me--;
        for (; 1 <= oe && 0 <= me; oe--, me--)
          if (L[oe] !== B[me]) {
            if (oe !== 1 || me !== 1)
              do
                if (oe--, me--, 0 > me || L[oe] !== B[me]) {
                  var Ee = `
` + L[oe].replace(" at new ", " at ");
                  return m.displayName && Ee.includes("<anonymous>") && (Ee = Ee.replace("<anonymous>", m.displayName)), Ee;
                }
              while (1 <= oe && 0 <= me);
            break;
          }
      }
    } finally {
      ye = !1, Error.prepareStackTrace = T;
    }
    return (m = m ? m.displayName || m.name : "") ? he(m) : "";
  }
  function Ne(m) {
    switch (m.tag) {
      case 5:
        return he(m.type);
      case 16:
        return he("Lazy");
      case 13:
        return he("Suspense");
      case 19:
        return he("SuspenseList");
      case 0:
      case 2:
      case 15:
        return m = _e(m.type, !1), m;
      case 11:
        return m = _e(m.type.render, !1), m;
      case 1:
        return m = _e(m.type, !0), m;
      default:
        return "";
    }
  }
  function Oe(m) {
    if (m == null)
      return null;
    if (typeof m == "function")
      return m.displayName || m.name || null;
    if (typeof m == "string")
      return m;
    switch (m) {
      case $:
        return "Fragment";
      case j:
        return "Portal";
      case W:
        return "Profiler";
      case z:
        return "StrictMode";
      case K:
        return "Suspense";
      case Q:
        return "SuspenseList";
    }
    if (typeof m == "object")
      switch (m.$$typeof) {
        case V:
          return (m.displayName || "Context") + ".Consumer";
        case Y:
          return (m._context.displayName || "Context") + ".Provider";
        case ee:
          var v = m.render;
          return m = m.displayName, m || (m = v.displayName || v.name || "", m = m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef"), m;
        case q:
          return v = m.displayName || null, v !== null ? v : Oe(m.type) || "Memo";
        case te:
          v = m._payload, m = m._init;
          try {
            return Oe(m(v));
          } catch {
          }
      }
    return null;
  }
  function ke(m) {
    var v = m.type;
    switch (m.tag) {
      case 24:
        return "Cache";
      case 9:
        return (v.displayName || "Context") + ".Consumer";
      case 10:
        return (v._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return m = v.render, m = m.displayName || m.name || "", v.displayName || (m !== "" ? "ForwardRef(" + m + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return v;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Oe(v);
      case 8:
        return v === z ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof v == "function")
          return v.displayName || v.name || null;
        if (typeof v == "string")
          return v;
    }
    return null;
  }
  function Me(m) {
    switch (typeof m) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return m;
      case "object":
        return m;
      default:
        return "";
    }
  }
  function we(m) {
    var v = m.type;
    return (m = m.nodeName) && m.toLowerCase() === "input" && (v === "checkbox" || v === "radio");
  }
  function Ye(m) {
    var v = we(m) ? "checked" : "value", T = Object.getOwnPropertyDescriptor(m.constructor.prototype, v), k = "" + m[v];
    if (!m.hasOwnProperty(v) && typeof T < "u" && typeof T.get == "function" && typeof T.set == "function") {
      var L = T.get, B = T.set;
      return Object.defineProperty(m, v, { configurable: !0, get: function() {
        return L.call(this);
      }, set: function(oe) {
        k = "" + oe, B.call(this, oe);
      } }), Object.defineProperty(m, v, { enumerable: T.enumerable }), { getValue: function() {
        return k;
      }, setValue: function(oe) {
        k = "" + oe;
      }, stopTracking: function() {
        m._valueTracker = null, delete m[v];
      } };
    }
  }
  function ze(m) {
    m._valueTracker || (m._valueTracker = Ye(m));
  }
  function fe(m) {
    if (!m)
      return !1;
    var v = m._valueTracker;
    if (!v)
      return !0;
    var T = v.getValue(), k = "";
    return m && (k = we(m) ? m.checked ? "true" : "false" : m.value), m = k, m !== T ? (v.setValue(m), !0) : !1;
  }
  function Qe(m) {
    if (m = m || (typeof document < "u" ? document : void 0), typeof m > "u")
      return null;
    try {
      return m.activeElement || m.body;
    } catch {
      return m.body;
    }
  }
  function $e(m, v) {
    var T = v.checked;
    return H({}, v, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: T ?? m._wrapperState.initialChecked });
  }
  function pt(m, v) {
    var T = v.defaultValue == null ? "" : v.defaultValue, k = v.checked != null ? v.checked : v.defaultChecked;
    T = Me(v.value != null ? v.value : T), m._wrapperState = { initialChecked: k, initialValue: T, controlled: v.type === "checkbox" || v.type === "radio" ? v.checked != null : v.value != null };
  }
  function _t(m, v) {
    v = v.checked, v != null && A(m, "checked", v, !1);
  }
  function Ot(m, v) {
    _t(m, v);
    var T = Me(v.value), k = v.type;
    if (T != null)
      k === "number" ? (T === 0 && m.value === "" || m.value != T) && (m.value = "" + T) : m.value !== "" + T && (m.value = "" + T);
    else if (k === "submit" || k === "reset") {
      m.removeAttribute("value");
      return;
    }
    v.hasOwnProperty("value") ? jr(m, v.type, T) : v.hasOwnProperty("defaultValue") && jr(m, v.type, Me(v.defaultValue)), v.checked == null && v.defaultChecked != null && (m.defaultChecked = !!v.defaultChecked);
  }
  function mn(m, v, T) {
    if (v.hasOwnProperty("value") || v.hasOwnProperty("defaultValue")) {
      var k = v.type;
      if (!(k !== "submit" && k !== "reset" || v.value !== void 0 && v.value !== null))
        return;
      v = "" + m._wrapperState.initialValue, T || v === m.value || (m.value = v), m.defaultValue = v;
    }
    T = m.name, T !== "" && (m.name = ""), m.defaultChecked = !!m._wrapperState.initialChecked, T !== "" && (m.name = T);
  }
  function jr(m, v, T) {
    (v !== "number" || Qe(m.ownerDocument) !== m) && (T == null ? m.defaultValue = "" + m._wrapperState.initialValue : m.defaultValue !== "" + T && (m.defaultValue = "" + T));
  }
  var tn = Array.isArray;
  function Zt(m, v, T, k) {
    if (m = m.options, v) {
      v = {};
      for (var L = 0; L < T.length; L++)
        v["$" + T[L]] = !0;
      for (T = 0; T < m.length; T++)
        L = v.hasOwnProperty("$" + m[T].value), m[T].selected !== L && (m[T].selected = L), L && k && (m[T].defaultSelected = !0);
    } else {
      for (T = "" + Me(T), v = null, L = 0; L < m.length; L++) {
        if (m[L].value === T) {
          m[L].selected = !0, k && (m[L].defaultSelected = !0);
          return;
        }
        v !== null || m[L].disabled || (v = m[L]);
      }
      v !== null && (v.selected = !0);
    }
  }
  function qn(m, v) {
    if (v.dangerouslySetInnerHTML != null)
      throw Error(n(91));
    return H({}, v, { value: void 0, defaultValue: void 0, children: "" + m._wrapperState.initialValue });
  }
  function fn(m, v) {
    var T = v.value;
    if (T == null) {
      if (T = v.children, v = v.defaultValue, T != null) {
        if (v != null)
          throw Error(n(92));
        if (tn(T)) {
          if (1 < T.length)
            throw Error(n(93));
          T = T[0];
        }
        v = T;
      }
      v == null && (v = ""), T = v;
    }
    m._wrapperState = { initialValue: Me(T) };
  }
  function gr(m, v) {
    var T = Me(v.value), k = Me(v.defaultValue);
    T != null && (T = "" + T, T !== m.value && (m.value = T), v.defaultValue == null && m.defaultValue !== T && (m.defaultValue = T)), k != null && (m.defaultValue = "" + k);
  }
  function Zn(m) {
    var v = m.textContent;
    v === m._wrapperState.initialValue && v !== "" && v !== null && (m.value = v);
  }
  function xr(m) {
    switch (m) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Un(m, v) {
    return m == null || m === "http://www.w3.org/1999/xhtml" ? xr(v) : m === "http://www.w3.org/2000/svg" && v === "foreignObject" ? "http://www.w3.org/1999/xhtml" : m;
  }
  var Qt, Ut = function(m) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(v, T, k, L) {
      MSApp.execUnsafeLocalFunction(function() {
        return m(v, T, k, L);
      });
    } : m;
  }(function(m, v) {
    if (m.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in m)
      m.innerHTML = v;
    else {
      for (Qt = Qt || document.createElement("div"), Qt.innerHTML = "<svg>" + v.valueOf().toString() + "</svg>", v = Qt.firstChild; m.firstChild; )
        m.removeChild(m.firstChild);
      for (; v.firstChild; )
        m.appendChild(v.firstChild);
    }
  });
  function er(m, v) {
    if (v) {
      var T = m.firstChild;
      if (T && T === m.lastChild && T.nodeType === 3) {
        T.nodeValue = v;
        return;
      }
    }
    m.textContent = v;
  }
  var We = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, ht = ["Webkit", "ms", "Moz", "O"];
  Object.keys(We).forEach(function(m) {
    ht.forEach(function(v) {
      v = v + m.charAt(0).toUpperCase() + m.substring(1), We[v] = We[m];
    });
  });
  function Ft(m, v, T) {
    return v == null || typeof v == "boolean" || v === "" ? "" : T || typeof v != "number" || v === 0 || We.hasOwnProperty(m) && We[m] ? ("" + v).trim() : v + "px";
  }
  function _n(m, v) {
    m = m.style;
    for (var T in v)
      if (v.hasOwnProperty(T)) {
        var k = T.indexOf("--") === 0, L = Ft(T, v[T], k);
        T === "float" && (T = "cssFloat"), k ? m.setProperty(T, L) : m[T] = L;
      }
  }
  var Dn = H({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function di(m, v) {
    if (v) {
      if (Dn[m] && (v.children != null || v.dangerouslySetInnerHTML != null))
        throw Error(n(137, m));
      if (v.dangerouslySetInnerHTML != null) {
        if (v.children != null)
          throw Error(n(60));
        if (typeof v.dangerouslySetInnerHTML != "object" || !("__html" in v.dangerouslySetInnerHTML))
          throw Error(n(61));
      }
      if (v.style != null && typeof v.style != "object")
        throw Error(n(62));
    }
  }
  function bi(m, v) {
    if (m.indexOf("-") === -1)
      return typeof v.is == "string";
    switch (m) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ua = null;
  function Zr(m) {
    return m = m.target || m.srcElement || window, m.correspondingUseElement && (m = m.correspondingUseElement), m.nodeType === 3 ? m.parentNode : m;
  }
  var Wa = null, Lr = null, Ar = null;
  function Ks(m) {
    if (m = us(m)) {
      if (typeof Wa != "function")
        throw Error(n(280));
      var v = m.stateNode;
      v && (v = cn(v), Wa(m.stateNode, m.type, v));
    }
  }
  function ws(m) {
    Lr ? Ar ? Ar.push(m) : Ar = [m] : Lr = m;
  }
  function Ql() {
    if (Lr) {
      var m = Lr, v = Ar;
      if (Ar = Lr = null, Ks(m), v)
        for (m = 0; m < v.length; m++)
          Ks(v[m]);
    }
  }
  function Lc(m, v) {
    return m(v);
  }
  function zc() {
  }
  var Xl = !1;
  function Fc(m, v, T) {
    if (Xl)
      return m(v, T);
    Xl = !0;
    try {
      return Lc(m, v, T);
    } finally {
      Xl = !1, (Lr !== null || Ar !== null) && (zc(), Ql());
    }
  }
  function _s(m, v) {
    var T = m.stateNode;
    if (T === null)
      return null;
    var k = cn(T);
    if (k === null)
      return null;
    T = k[v];
    e:
      switch (v) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (k = !k.disabled) || (m = m.type, k = !(m === "button" || m === "input" || m === "select" || m === "textarea")), m = !k;
          break e;
        default:
          m = !1;
      }
    if (m)
      return null;
    if (T && typeof T != "function")
      throw Error(n(231, v, typeof T));
    return T;
  }
  var as = !1;
  if (s)
    try {
      var Es = {};
      Object.defineProperty(Es, "passive", { get: function() {
        as = !0;
      } }), window.addEventListener("test", Es, Es), window.removeEventListener("test", Es, Es);
    } catch {
      as = !1;
    }
  function xa(m, v, T, k, L, B, oe, me, Ee) {
    var He = Array.prototype.slice.call(arguments, 3);
    try {
      v.apply(T, He);
    } catch (ft) {
      this.onError(ft);
    }
  }
  var la = !1, Hi = null, ss = !1, xe = null, lt = { onError: function(m) {
    la = !0, Hi = m;
  } };
  function St(m, v, T, k, L, B, oe, me, Ee) {
    la = !1, Hi = null, xa.apply(lt, arguments);
  }
  function $t(m, v, T, k, L, B, oe, me, Ee) {
    if (St.apply(this, arguments), la) {
      if (la) {
        var He = Hi;
        la = !1, Hi = null;
      } else
        throw Error(n(198));
      ss || (ss = !0, xe = He);
    }
  }
  function In(m) {
    var v = m, T = m;
    if (m.alternate)
      for (; v.return; )
        v = v.return;
    else {
      m = v;
      do
        v = m, v.flags & 4098 && (T = v.return), m = v.return;
      while (m);
    }
    return v.tag === 3 ? T : null;
  }
  function lr(m) {
    if (m.tag === 13) {
      var v = m.memoizedState;
      if (v === null && (m = m.alternate, m !== null && (v = m.memoizedState)), v !== null)
        return v.dehydrated;
    }
    return null;
  }
  function zn(m) {
    if (In(m) !== m)
      throw Error(n(188));
  }
  function sn(m) {
    var v = m.alternate;
    if (!v) {
      if (v = In(m), v === null)
        throw Error(n(188));
      return v !== m ? null : m;
    }
    for (var T = m, k = v; ; ) {
      var L = T.return;
      if (L === null)
        break;
      var B = L.alternate;
      if (B === null) {
        if (k = L.return, k !== null) {
          T = k;
          continue;
        }
        break;
      }
      if (L.child === B.child) {
        for (B = L.child; B; ) {
          if (B === T)
            return zn(L), m;
          if (B === k)
            return zn(L), v;
          B = B.sibling;
        }
        throw Error(n(188));
      }
      if (T.return !== k.return)
        T = L, k = B;
      else {
        for (var oe = !1, me = L.child; me; ) {
          if (me === T) {
            oe = !0, T = L, k = B;
            break;
          }
          if (me === k) {
            oe = !0, k = L, T = B;
            break;
          }
          me = me.sibling;
        }
        if (!oe) {
          for (me = B.child; me; ) {
            if (me === T) {
              oe = !0, T = B, k = L;
              break;
            }
            if (me === k) {
              oe = !0, k = B, T = L;
              break;
            }
            me = me.sibling;
          }
          if (!oe)
            throw Error(n(189));
        }
      }
      if (T.alternate !== k)
        throw Error(n(190));
    }
    if (T.tag !== 3)
      throw Error(n(188));
    return T.stateNode.current === T ? m : v;
  }
  function No(m) {
    return m = sn(m), m !== null ? xi(m) : null;
  }
  function xi(m) {
    if (m.tag === 5 || m.tag === 6)
      return m;
    for (m = m.child; m !== null; ) {
      var v = xi(m);
      if (v !== null)
        return v;
      m = m.sibling;
    }
    return null;
  }
  var wi = t.unstable_scheduleCallback, nn = t.unstable_cancelCallback, Oi = t.unstable_shouldYield, lm = t.unstable_requestPaint, mr = t.unstable_now, Vw = t.unstable_getCurrentPriorityLevel, Kl = t.unstable_ImmediatePriority, cr = t.unstable_UserBlockingPriority, Zl = t.unstable_NormalPriority, Uf = t.unstable_LowPriority, Np = t.unstable_IdlePriority, qd = null, Zs = null;
  function vv(m) {
    if (Zs && typeof Zs.onCommitFiberRoot == "function")
      try {
        Zs.onCommitFiberRoot(qd, m, void 0, (m.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ss = Math.clz32 ? Math.clz32 : bv, cm = Math.log, fm = Math.LN2;
  function bv(m) {
    return m >>>= 0, m === 0 ? 32 : 31 - (cm(m) / fm | 0) | 0;
  }
  var Gd = 64, Qd = 4194304;
  function sl(m) {
    switch (m & -m) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return m & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return m & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return m;
    }
  }
  function wa(m, v) {
    var T = m.pendingLanes;
    if (T === 0)
      return 0;
    var k = 0, L = m.suspendedLanes, B = m.pingedLanes, oe = T & 268435455;
    if (oe !== 0) {
      var me = oe & ~L;
      me !== 0 ? k = sl(me) : (B &= oe, B !== 0 && (k = sl(B)));
    } else
      oe = T & ~L, oe !== 0 ? k = sl(oe) : B !== 0 && (k = sl(B));
    if (k === 0)
      return 0;
    if (v !== 0 && v !== k && !(v & L) && (L = k & -k, B = v & -v, L >= B || L === 16 && (B & 4194240) !== 0))
      return v;
    if (k & 4 && (k |= T & 16), v = m.entangledLanes, v !== 0)
      for (m = m.entanglements, v &= k; 0 < v; )
        T = 31 - Ss(v), L = 1 << T, k |= m[T], v &= ~L;
    return k;
  }
  function Yf(m, v) {
    switch (m) {
      case 1:
      case 2:
      case 4:
        return v + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return v + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Xd(m, v) {
    for (var T = m.suspendedLanes, k = m.pingedLanes, L = m.expirationTimes, B = m.pendingLanes; 0 < B; ) {
      var oe = 31 - Ss(B), me = 1 << oe, Ee = L[oe];
      Ee === -1 ? (!(me & T) || me & k) && (L[oe] = Yf(me, v)) : Ee <= v && (m.expiredLanes |= me), B &= ~me;
    }
  }
  function Hf(m) {
    return m = m.pendingLanes & -1073741825, m !== 0 ? m : m & 1073741824 ? 1073741824 : 0;
  }
  function Dp() {
    var m = Gd;
    return Gd <<= 1, !(Gd & 4194240) && (Gd = 64), m;
  }
  function Kd(m) {
    for (var v = [], T = 0; 31 > T; T++)
      v.push(m);
    return v;
  }
  function Vf(m, v, T) {
    m.pendingLanes |= v, v !== 536870912 && (m.suspendedLanes = 0, m.pingedLanes = 0), m = m.eventTimes, v = 31 - Ss(v), m[v] = T;
  }
  function $b(m, v) {
    var T = m.pendingLanes & ~v;
    m.pendingLanes = v, m.suspendedLanes = 0, m.pingedLanes = 0, m.expiredLanes &= v, m.mutableReadLanes &= v, m.entangledLanes &= v, v = m.entanglements;
    var k = m.eventTimes;
    for (m = m.expirationTimes; 0 < T; ) {
      var L = 31 - Ss(T), B = 1 << L;
      v[L] = 0, k[L] = -1, m[L] = -1, T &= ~B;
    }
  }
  function ul(m, v) {
    var T = m.entangledLanes |= v;
    for (m = m.entanglements; T; ) {
      var k = 31 - Ss(T), L = 1 << k;
      L & v | m[k] & v && (m[k] |= v), T &= ~L;
    }
  }
  var Or = 0;
  function Jl(m) {
    return m &= -m, 1 < m ? 4 < m ? m & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Zd, Ap, Rr, Op, Rp, jn = !1, Jd = [], vo = null, Js = null, Ms = null, Wf = /* @__PURE__ */ new Map(), Do = /* @__PURE__ */ new Map(), ii = [], Pb = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function eu(m, v) {
    switch (m) {
      case "focusin":
      case "focusout":
        vo = null;
        break;
      case "dragenter":
      case "dragleave":
        Js = null;
        break;
      case "mouseover":
      case "mouseout":
        Ms = null;
        break;
      case "pointerover":
      case "pointerout":
        Wf.delete(v.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Do.delete(v.pointerId);
    }
  }
  function Ko(m, v, T, k, L, B) {
    return m === null || m.nativeEvent !== B ? (m = { blockedOn: v, domEventName: T, eventSystemFlags: k, nativeEvent: B, targetContainers: [L] }, v !== null && (v = us(v), v !== null && Ap(v)), m) : (m.eventSystemFlags |= k, v = m.targetContainers, L !== null && v.indexOf(L) === -1 && v.push(L), m);
  }
  function Bc(m, v, T, k, L) {
    switch (v) {
      case "focusin":
        return vo = Ko(vo, m, v, T, k, L), !0;
      case "dragenter":
        return Js = Ko(Js, m, v, T, k, L), !0;
      case "mouseover":
        return Ms = Ko(Ms, m, v, T, k, L), !0;
      case "pointerover":
        var B = L.pointerId;
        return Wf.set(B, Ko(Wf.get(B) || null, m, v, T, k, L)), !0;
      case "gotpointercapture":
        return B = L.pointerId, Do.set(B, Ko(Do.get(B) || null, m, v, T, k, L)), !0;
    }
    return !1;
  }
  function Ib(m) {
    var v = Ts(m.target);
    if (v !== null) {
      var T = In(v);
      if (T !== null) {
        if (v = T.tag, v === 13) {
          if (v = lr(T), v !== null) {
            m.blockedOn = v, Rp(m.priority, function() {
              Rr(T);
            });
            return;
          }
        } else if (v === 3 && T.stateNode.current.memoizedState.isDehydrated) {
          m.blockedOn = T.tag === 3 ? T.stateNode.containerInfo : null;
          return;
        }
      }
    }
    m.blockedOn = null;
  }
  function qf(m) {
    if (m.blockedOn !== null)
      return !1;
    for (var v = m.targetContainers; 0 < v.length; ) {
      var T = $p(m.domEventName, m.eventSystemFlags, v[0], m.nativeEvent);
      if (T === null) {
        T = m.nativeEvent;
        var k = new T.constructor(T.type, T);
        ua = k, T.target.dispatchEvent(k), ua = null;
      } else
        return v = us(T), v !== null && Ap(v), m.blockedOn = T, !1;
      v.shift();
    }
    return !0;
  }
  function eh(m, v, T) {
    qf(m) && T.delete(v);
  }
  function jb() {
    jn = !1, vo !== null && qf(vo) && (vo = null), Js !== null && qf(Js) && (Js = null), Ms !== null && qf(Ms) && (Ms = null), Wf.forEach(eh), Do.forEach(eh);
  }
  function wr(m, v) {
    m.blockedOn === v && (m.blockedOn = null, jn || (jn = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, jb)));
  }
  function zr(m) {
    function v(L) {
      return wr(L, m);
    }
    if (0 < Jd.length) {
      wr(Jd[0], m);
      for (var T = 1; T < Jd.length; T++) {
        var k = Jd[T];
        k.blockedOn === m && (k.blockedOn = null);
      }
    }
    for (vo !== null && wr(vo, m), Js !== null && wr(Js, m), Ms !== null && wr(Ms, m), Wf.forEach(v), Do.forEach(v), T = 0; T < ii.length; T++)
      k = ii[T], k.blockedOn === m && (k.blockedOn = null);
    for (; 0 < ii.length && (T = ii[0], T.blockedOn === null); )
      Ib(T), T.blockedOn === null && ii.shift();
  }
  var th = O.ReactCurrentBatchConfig, ll = !0;
  function dm(m, v, T, k) {
    var L = Or, B = th.transition;
    th.transition = null;
    try {
      Or = 1, rh(m, v, T, k);
    } finally {
      Or = L, th.transition = B;
    }
  }
  function nh(m, v, T, k) {
    var L = Or, B = th.transition;
    th.transition = null;
    try {
      Or = 4, rh(m, v, T, k);
    } finally {
      Or = L, th.transition = B;
    }
  }
  function rh(m, v, T, k) {
    if (ll) {
      var L = $p(m, v, T, k);
      if (L === null)
        Gb(m, v, k, kp, T), eu(m, k);
      else if (Bc(L, m, v, T, k))
        k.stopPropagation();
      else if (eu(m, k), v & 4 && -1 < Pb.indexOf(m)) {
        for (; L !== null; ) {
          var B = us(L);
          if (B !== null && Zd(B), B = $p(m, v, T, k), B === null && Gb(m, v, k, kp, T), B === L)
            break;
          L = B;
        }
        L !== null && k.stopPropagation();
      } else
        Gb(m, v, k, null, T);
    }
  }
  var kp = null;
  function $p(m, v, T, k) {
    if (kp = null, m = Zr(k), m = Ts(m), m !== null)
      if (v = In(m), v === null)
        m = null;
      else if (T = v.tag, T === 13) {
        if (m = lr(v), m !== null)
          return m;
        m = null;
      } else if (T === 3) {
        if (v.stateNode.current.memoizedState.isDehydrated)
          return v.tag === 3 ? v.stateNode.containerInfo : null;
        m = null;
      } else
        v !== m && (m = null);
    return kp = m, null;
  }
  function xv(m) {
    switch (m) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Vw()) {
          case Kl:
            return 1;
          case cr:
            return 4;
          case Zl:
          case Uf:
            return 16;
          case Np:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ri = null, ne = null, be = null;
  function Be() {
    if (be)
      return be;
    var m, v = ne, T = v.length, k, L = "value" in Ri ? Ri.value : Ri.textContent, B = L.length;
    for (m = 0; m < T && v[m] === L[m]; m++)
      ;
    var oe = T - m;
    for (k = 1; k <= oe && v[T - k] === L[B - k]; k++)
      ;
    return be = L.slice(m, 1 < k ? 1 - k : void 0);
  }
  function qe(m) {
    var v = m.keyCode;
    return "charCode" in m ? (m = m.charCode, m === 0 && v === 13 && (m = 13)) : m = v, m === 10 && (m = 13), 32 <= m || m === 13 ? m : 0;
  }
  function gt() {
    return !0;
  }
  function gn() {
    return !1;
  }
  function Dt(m) {
    function v(T, k, L, B, oe) {
      this._reactName = T, this._targetInst = L, this.type = k, this.nativeEvent = B, this.target = oe, this.currentTarget = null;
      for (var me in m)
        m.hasOwnProperty(me) && (T = m[me], this[me] = T ? T(B) : B[me]);
      return this.isDefaultPrevented = (B.defaultPrevented != null ? B.defaultPrevented : B.returnValue === !1) ? gt : gn, this.isPropagationStopped = gn, this;
    }
    return H(v.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var T = this.nativeEvent;
      T && (T.preventDefault ? T.preventDefault() : typeof T.returnValue != "unknown" && (T.returnValue = !1), this.isDefaultPrevented = gt);
    }, stopPropagation: function() {
      var T = this.nativeEvent;
      T && (T.stopPropagation ? T.stopPropagation() : typeof T.cancelBubble != "unknown" && (T.cancelBubble = !0), this.isPropagationStopped = gt);
    }, persist: function() {
    }, isPersistent: gt }), v;
  }
  var dn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(m) {
    return m.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, sr = Dt(dn), Tr = H({}, dn, { view: 0, detail: 0 }), _i = Dt(Tr), tr, ki, yr, _r = H({}, Tr, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Kw, button: 0, buttons: 0, relatedTarget: function(m) {
    return m.relatedTarget === void 0 ? m.fromElement === m.srcElement ? m.toElement : m.fromElement : m.relatedTarget;
  }, movementX: function(m) {
    return "movementX" in m ? m.movementX : (m !== yr && (yr && m.type === "mousemove" ? (tr = m.screenX - yr.screenX, ki = m.screenY - yr.screenY) : ki = tr = 0, yr = m), tr);
  }, movementY: function(m) {
    return "movementY" in m ? m.movementY : ki;
  } }), Uc = Dt(_r), Eu = H({}, _r, { dataTransfer: 0 }), ih = Dt(Eu), wv = H({}, Tr, { relatedTarget: 0 }), kr = Dt(wv), cl = H({}, dn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Pp = Dt(cl), Ww = H({}, dn, { clipboardData: function(m) {
    return "clipboardData" in m ? m.clipboardData : window.clipboardData;
  } }), qw = Dt(Ww), WN = H({}, dn, { data: 0 }), Gw = Dt(WN), Qw = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Xw = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, _v = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ip(m) {
    var v = this.nativeEvent;
    return v.getModifierState ? v.getModifierState(m) : (m = _v[m]) ? !!v[m] : !1;
  }
  function Kw() {
    return Ip;
  }
  var Yc = H({}, Tr, { key: function(m) {
    if (m.key) {
      var v = Qw[m.key] || m.key;
      if (v !== "Unidentified")
        return v;
    }
    return m.type === "keypress" ? (m = qe(m), m === 13 ? "Enter" : String.fromCharCode(m)) : m.type === "keydown" || m.type === "keyup" ? Xw[m.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Kw, charCode: function(m) {
    return m.type === "keypress" ? qe(m) : 0;
  }, keyCode: function(m) {
    return m.type === "keydown" || m.type === "keyup" ? m.keyCode : 0;
  }, which: function(m) {
    return m.type === "keypress" ? qe(m) : m.type === "keydown" || m.type === "keyup" ? m.keyCode : 0;
  } }), b2 = Dt(Yc), Ev = H({}, _r, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), hm = Dt(Ev), Lb = H({}, Tr, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Kw }), qN = Dt(Lb), pm = H({}, dn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), zb = Dt(pm), tu = H({}, _r, {
    deltaX: function(m) {
      return "deltaX" in m ? m.deltaX : "wheelDeltaX" in m ? -m.wheelDeltaX : 0;
    },
    deltaY: function(m) {
      return "deltaY" in m ? m.deltaY : "wheelDeltaY" in m ? -m.wheelDeltaY : "wheelDelta" in m ? -m.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Hc = Dt(tu), Wr = [9, 13, 27, 32], Su = s && "CompositionEvent" in window, ec = null;
  s && "documentMode" in document && (ec = document.documentMode);
  var Sv = s && "TextEvent" in window && !ec, Zw = s && (!Su || ec && 8 < ec && 11 >= ec), gm = String.fromCharCode(32), x2 = !1;
  function w2(m, v) {
    switch (m) {
      case "keyup":
        return Wr.indexOf(v.keyCode) !== -1;
      case "keydown":
        return v.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Fb(m) {
    return m = m.detail, typeof m == "object" && "data" in m ? m.data : null;
  }
  var mm = !1;
  function ym(m, v) {
    switch (m) {
      case "compositionend":
        return Fb(v);
      case "keypress":
        return v.which !== 32 ? null : (x2 = !0, gm);
      case "textInput":
        return m = v.data, m === gm && x2 ? null : m;
      default:
        return null;
    }
  }
  function GN(m, v) {
    if (mm)
      return m === "compositionend" || !Su && w2(m, v) ? (m = Be(), be = ne = Ri = null, mm = !1, m) : null;
    switch (m) {
      case "paste":
        return null;
      case "keypress":
        if (!(v.ctrlKey || v.altKey || v.metaKey) || v.ctrlKey && v.altKey) {
          if (v.char && 1 < v.char.length)
            return v.char;
          if (v.which)
            return String.fromCharCode(v.which);
        }
        return null;
      case "compositionend":
        return Zw && v.locale !== "ko" ? null : v.data;
      default:
        return null;
    }
  }
  var _2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Bb(m) {
    var v = m && m.nodeName && m.nodeName.toLowerCase();
    return v === "input" ? !!_2[m.type] : v === "textarea";
  }
  function Jw(m, v, T, k) {
    ws(k), v = Dv(v, "onChange"), 0 < v.length && (T = new sr("onChange", "change", null, T, k), m.push({ event: T, listeners: v }));
  }
  var fl = null, Gf = null;
  function vm(m) {
    Wb(m, 0);
  }
  function bm(m) {
    var v = nr(m);
    if (fe(v))
      return m;
  }
  function E2(m, v) {
    if (m === "change")
      return v;
  }
  var oh = !1;
  if (s) {
    var Mu;
    if (s) {
      var Ub = "oninput" in document;
      if (!Ub) {
        var S2 = document.createElement("div");
        S2.setAttribute("oninput", "return;"), Ub = typeof S2.oninput == "function";
      }
      Mu = Ub;
    } else
      Mu = !1;
    oh = Mu && (!document.documentMode || 9 < document.documentMode);
  }
  function M2() {
    fl && (fl.detachEvent("onpropertychange", T2), Gf = fl = null);
  }
  function T2(m) {
    if (m.propertyName === "value" && bm(Gf)) {
      var v = [];
      Jw(v, Gf, m, Zr(m)), Fc(vm, v);
    }
  }
  function QN(m, v, T) {
    m === "focusin" ? (M2(), fl = v, Gf = T, fl.attachEvent("onpropertychange", T2)) : m === "focusout" && M2();
  }
  function XN(m) {
    if (m === "selectionchange" || m === "keyup" || m === "keydown")
      return bm(Gf);
  }
  function xm(m, v) {
    if (m === "click")
      return bm(v);
  }
  function Ae(m, v) {
    if (m === "input" || m === "change")
      return bm(v);
  }
  function Ke(m, v) {
    return m === v && (m !== 0 || 1 / m === 1 / v) || m !== m && v !== v;
  }
  var Fe = typeof Object.is == "function" ? Object.is : Ke;
  function It(m, v) {
    if (Fe(m, v))
      return !0;
    if (typeof m != "object" || m === null || typeof v != "object" || v === null)
      return !1;
    var T = Object.keys(m), k = Object.keys(v);
    if (T.length !== k.length)
      return !1;
    for (k = 0; k < T.length; k++) {
      var L = T[k];
      if (!u.call(v, L) || !Fe(m[L], v[L]))
        return !1;
    }
    return !0;
  }
  function Yn(m) {
    for (; m && m.firstChild; )
      m = m.firstChild;
    return m;
  }
  function qr(m, v) {
    var T = Yn(m);
    m = 0;
    for (var k; T; ) {
      if (T.nodeType === 3) {
        if (k = m + T.textContent.length, m <= v && k >= v)
          return { node: T, offset: v - m };
        m = k;
      }
      e: {
        for (; T; ) {
          if (T.nextSibling) {
            T = T.nextSibling;
            break e;
          }
          T = T.parentNode;
        }
        T = void 0;
      }
      T = Yn(T);
    }
  }
  function Zo(m, v) {
    return m && v ? m === v ? !0 : m && m.nodeType === 3 ? !1 : v && v.nodeType === 3 ? Zo(m, v.parentNode) : "contains" in m ? m.contains(v) : m.compareDocumentPosition ? !!(m.compareDocumentPosition(v) & 16) : !1 : !1;
  }
  function oi() {
    for (var m = window, v = Qe(); v instanceof m.HTMLIFrameElement; ) {
      try {
        var T = typeof v.contentWindow.location.href == "string";
      } catch {
        T = !1;
      }
      if (T)
        m = v.contentWindow;
      else
        break;
      v = Qe(m.document);
    }
    return v;
  }
  function tc(m) {
    var v = m && m.nodeName && m.nodeName.toLowerCase();
    return v && (v === "input" && (m.type === "text" || m.type === "search" || m.type === "tel" || m.type === "url" || m.type === "password") || v === "textarea" || m.contentEditable === "true");
  }
  function Yb(m) {
    var v = oi(), T = m.focusedElem, k = m.selectionRange;
    if (v !== T && T && T.ownerDocument && Zo(T.ownerDocument.documentElement, T)) {
      if (k !== null && tc(T)) {
        if (v = k.start, m = k.end, m === void 0 && (m = v), "selectionStart" in T)
          T.selectionStart = v, T.selectionEnd = Math.min(m, T.value.length);
        else if (m = (v = T.ownerDocument || document) && v.defaultView || window, m.getSelection) {
          m = m.getSelection();
          var L = T.textContent.length, B = Math.min(k.start, L);
          k = k.end === void 0 ? B : Math.min(k.end, L), !m.extend && B > k && (L = k, k = B, B = L), L = qr(T, B);
          var oe = qr(
            T,
            k
          );
          L && oe && (m.rangeCount !== 1 || m.anchorNode !== L.node || m.anchorOffset !== L.offset || m.focusNode !== oe.node || m.focusOffset !== oe.offset) && (v = v.createRange(), v.setStart(L.node, L.offset), m.removeAllRanges(), B > k ? (m.addRange(v), m.extend(oe.node, oe.offset)) : (v.setEnd(oe.node, oe.offset), m.addRange(v)));
        }
      }
      for (v = [], m = T; m = m.parentNode; )
        m.nodeType === 1 && v.push({ element: m, left: m.scrollLeft, top: m.scrollTop });
      for (typeof T.focus == "function" && T.focus(), T = 0; T < v.length; T++)
        m = v[T], m.element.scrollLeft = m.left, m.element.scrollTop = m.top;
    }
  }
  var Tu = s && "documentMode" in document && 11 >= document.documentMode, nu = null, e_ = null, Vc = null, wm = !1;
  function Mv(m, v, T) {
    var k = T.window === T ? T.document : T.nodeType === 9 ? T : T.ownerDocument;
    wm || nu == null || nu !== Qe(k) || (k = nu, "selectionStart" in k && tc(k) ? k = { start: k.selectionStart, end: k.selectionEnd } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = { anchorNode: k.anchorNode, anchorOffset: k.anchorOffset, focusNode: k.focusNode, focusOffset: k.focusOffset }), Vc && It(Vc, k) || (Vc = k, k = Dv(e_, "onSelect"), 0 < k.length && (v = new sr("onSelect", "select", null, v, T), m.push({ event: v, listeners: k }), v.target = nu)));
  }
  function Gr(m, v) {
    var T = {};
    return T[m.toLowerCase()] = v.toLowerCase(), T["Webkit" + m] = "webkit" + v, T["Moz" + m] = "moz" + v, T;
  }
  var jp = { animationend: Gr("Animation", "AnimationEnd"), animationiteration: Gr("Animation", "AnimationIteration"), animationstart: Gr("Animation", "AnimationStart"), transitionend: Gr("Transition", "TransitionEnd") }, Hb = {}, _m = {};
  s && (_m = document.createElement("div").style, "AnimationEvent" in window || (delete jp.animationend.animation, delete jp.animationiteration.animation, delete jp.animationstart.animation), "TransitionEvent" in window || delete jp.transitionend.transition);
  function _a(m) {
    if (Hb[m])
      return Hb[m];
    if (!jp[m])
      return m;
    var v = jp[m], T;
    for (T in v)
      if (v.hasOwnProperty(T) && T in _m)
        return Hb[m] = v[T];
    return m;
  }
  var t_ = _a("animationend"), C2 = _a("animationiteration"), Tv = _a("animationstart"), Qf = _a("transitionend"), Cv = /* @__PURE__ */ new Map(), n_ = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function dl(m, v) {
    Cv.set(m, v), o(v, [m]);
  }
  for (var Em = 0; Em < n_.length; Em++) {
    var ah = n_[Em], Vb = ah.toLowerCase(), Sm = ah[0].toUpperCase() + ah.slice(1);
    dl(Vb, "on" + Sm);
  }
  dl(t_, "onAnimationEnd"), dl(C2, "onAnimationIteration"), dl(Tv, "onAnimationStart"), dl("dblclick", "onDoubleClick"), dl("focusin", "onFocus"), dl("focusout", "onBlur"), dl(Qf, "onTransitionEnd"), a("onMouseEnter", ["mouseout", "mouseover"]), a("onMouseLeave", ["mouseout", "mouseover"]), a("onPointerEnter", ["pointerout", "pointerover"]), a("onPointerLeave", ["pointerout", "pointerover"]), o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Lp = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xf));
  function Nv(m, v, T) {
    var k = m.type || "unknown-event";
    m.currentTarget = T, $t(k, v, void 0, m), m.currentTarget = null;
  }
  function Wb(m, v) {
    v = (v & 4) !== 0;
    for (var T = 0; T < m.length; T++) {
      var k = m[T], L = k.event;
      k = k.listeners;
      e: {
        var B = void 0;
        if (v)
          for (var oe = k.length - 1; 0 <= oe; oe--) {
            var me = k[oe], Ee = me.instance, He = me.currentTarget;
            if (me = me.listener, Ee !== B && L.isPropagationStopped())
              break e;
            Nv(L, me, He), B = Ee;
          }
        else
          for (oe = 0; oe < k.length; oe++) {
            if (me = k[oe], Ee = me.instance, He = me.currentTarget, me = me.listener, Ee !== B && L.isPropagationStopped())
              break e;
            Nv(L, me, He), B = Ee;
          }
      }
    }
    if (ss)
      throw m = xe, ss = !1, xe = null, m;
  }
  function $i(m, v) {
    var T = v[Xb];
    T === void 0 && (T = v[Xb] = /* @__PURE__ */ new Set());
    var k = m + "__bubble";
    T.has(k) || (qb(v, m, 2, !1), T.add(k));
  }
  function sh(m, v, T) {
    var k = 0;
    v && (k |= 4), qb(T, m, k, v);
  }
  var hl = "_reactListening" + Math.random().toString(36).slice(2);
  function Kf(m) {
    if (!m[hl]) {
      m[hl] = !0, r.forEach(function(T) {
        T !== "selectionchange" && (Lp.has(T) || sh(T, !1, m), sh(T, !0, m));
      });
      var v = m.nodeType === 9 ? m : m.ownerDocument;
      v === null || v[hl] || (v[hl] = !0, sh("selectionchange", !1, v));
    }
  }
  function qb(m, v, T, k) {
    switch (xv(v)) {
      case 1:
        var L = dm;
        break;
      case 4:
        L = nh;
        break;
      default:
        L = rh;
    }
    T = L.bind(null, v, T, m), L = void 0, !as || v !== "touchstart" && v !== "touchmove" && v !== "wheel" || (L = !0), k ? L !== void 0 ? m.addEventListener(v, T, { capture: !0, passive: L }) : m.addEventListener(v, T, !0) : L !== void 0 ? m.addEventListener(v, T, { passive: L }) : m.addEventListener(v, T, !1);
  }
  function Gb(m, v, T, k, L) {
    var B = k;
    if (!(v & 1) && !(v & 2) && k !== null)
      e:
        for (; ; ) {
          if (k === null)
            return;
          var oe = k.tag;
          if (oe === 3 || oe === 4) {
            var me = k.stateNode.containerInfo;
            if (me === L || me.nodeType === 8 && me.parentNode === L)
              break;
            if (oe === 4)
              for (oe = k.return; oe !== null; ) {
                var Ee = oe.tag;
                if ((Ee === 3 || Ee === 4) && (Ee = oe.stateNode.containerInfo, Ee === L || Ee.nodeType === 8 && Ee.parentNode === L))
                  return;
                oe = oe.return;
              }
            for (; me !== null; ) {
              if (oe = Ts(me), oe === null)
                return;
              if (Ee = oe.tag, Ee === 5 || Ee === 6) {
                k = B = oe;
                continue e;
              }
              me = me.parentNode;
            }
          }
          k = k.return;
        }
    Fc(function() {
      var He = B, ft = Zr(T), mt = [];
      e: {
        var dt = Cv.get(m);
        if (dt !== void 0) {
          var jt = sr, qt = m;
          switch (m) {
            case "keypress":
              if (qe(T) === 0)
                break e;
            case "keydown":
            case "keyup":
              jt = b2;
              break;
            case "focusin":
              qt = "focus", jt = kr;
              break;
            case "focusout":
              qt = "blur", jt = kr;
              break;
            case "beforeblur":
            case "afterblur":
              jt = kr;
              break;
            case "click":
              if (T.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              jt = Uc;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              jt = ih;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              jt = qN;
              break;
            case t_:
            case C2:
            case Tv:
              jt = Pp;
              break;
            case Qf:
              jt = zb;
              break;
            case "scroll":
              jt = _i;
              break;
            case "wheel":
              jt = Hc;
              break;
            case "copy":
            case "cut":
            case "paste":
              jt = qw;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              jt = hm;
          }
          var Xt = (v & 4) !== 0, Bo = !Xt && m === "scroll", Pe = Xt ? dt !== null ? dt + "Capture" : null : dt;
          Xt = [];
          for (var Te = He, Ie; Te !== null; ) {
            Ie = Te;
            var wt = Ie.stateNode;
            if (Ie.tag === 5 && wt !== null && (Ie = wt, Pe !== null && (wt = _s(Te, Pe), wt != null && Xt.push(Mm(Te, wt, Ie)))), Bo)
              break;
            Te = Te.return;
          }
          0 < Xt.length && (dt = new jt(dt, qt, null, T, ft), mt.push({ event: dt, listeners: Xt }));
        }
      }
      if (!(v & 7)) {
        e: {
          if (dt = m === "mouseover" || m === "pointerover", jt = m === "mouseout" || m === "pointerout", dt && T !== ua && (qt = T.relatedTarget || T.fromElement) && (Ts(qt) || qt[Cu]))
            break e;
          if ((jt || dt) && (dt = ft.window === ft ? ft : (dt = ft.ownerDocument) ? dt.defaultView || dt.parentWindow : window, jt ? (qt = T.relatedTarget || T.toElement, jt = He, qt = qt ? Ts(qt) : null, qt !== null && (Bo = In(qt), qt !== Bo || qt.tag !== 5 && qt.tag !== 6) && (qt = null)) : (jt = null, qt = He), jt !== qt)) {
            if (Xt = Uc, wt = "onMouseLeave", Pe = "onMouseEnter", Te = "mouse", (m === "pointerout" || m === "pointerover") && (Xt = hm, wt = "onPointerLeave", Pe = "onPointerEnter", Te = "pointer"), Bo = jt == null ? dt : nr(jt), Ie = qt == null ? dt : nr(qt), dt = new Xt(wt, Te + "leave", jt, T, ft), dt.target = Bo, dt.relatedTarget = Ie, wt = null, Ts(ft) === He && (Xt = new Xt(Pe, Te + "enter", qt, T, ft), Xt.target = Ie, Xt.relatedTarget = Bo, wt = Xt), Bo = wt, jt && qt)
              t: {
                for (Xt = jt, Pe = qt, Te = 0, Ie = Xt; Ie; Ie = zp(Ie))
                  Te++;
                for (Ie = 0, wt = Pe; wt; wt = zp(wt))
                  Ie++;
                for (; 0 < Te - Ie; )
                  Xt = zp(Xt), Te--;
                for (; 0 < Ie - Te; )
                  Pe = zp(Pe), Ie--;
                for (; Te--; ) {
                  if (Xt === Pe || Pe !== null && Xt === Pe.alternate)
                    break t;
                  Xt = zp(Xt), Pe = zp(Pe);
                }
                Xt = null;
              }
            else
              Xt = null;
            jt !== null && zo(mt, dt, jt, Xt, !1), qt !== null && Bo !== null && zo(mt, Bo, qt, Xt, !0);
          }
        }
        e: {
          if (dt = He ? nr(He) : window, jt = dt.nodeName && dt.nodeName.toLowerCase(), jt === "select" || jt === "input" && dt.type === "file")
            var Jt = E2;
          else if (Bb(dt))
            if (oh)
              Jt = Ae;
            else {
              Jt = XN;
              var Wt = QN;
            }
          else
            (jt = dt.nodeName) && jt.toLowerCase() === "input" && (dt.type === "checkbox" || dt.type === "radio") && (Jt = xm);
          if (Jt && (Jt = Jt(m, He))) {
            Jw(mt, Jt, T, ft);
            break e;
          }
          Wt && Wt(m, dt, He), m === "focusout" && (Wt = dt._wrapperState) && Wt.controlled && dt.type === "number" && jr(dt, "number", dt.value);
        }
        switch (Wt = He ? nr(He) : window, m) {
          case "focusin":
            (Bb(Wt) || Wt.contentEditable === "true") && (nu = Wt, e_ = He, Vc = null);
            break;
          case "focusout":
            Vc = e_ = nu = null;
            break;
          case "mousedown":
            wm = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            wm = !1, Mv(mt, T, ft);
            break;
          case "selectionchange":
            if (Tu)
              break;
          case "keydown":
          case "keyup":
            Mv(mt, T, ft);
        }
        var rn;
        if (Su)
          e: {
            switch (m) {
              case "compositionstart":
                var On = "onCompositionStart";
                break e;
              case "compositionend":
                On = "onCompositionEnd";
                break e;
              case "compositionupdate":
                On = "onCompositionUpdate";
                break e;
            }
            On = void 0;
          }
        else
          mm ? w2(m, T) && (On = "onCompositionEnd") : m === "keydown" && T.keyCode === 229 && (On = "onCompositionStart");
        On && (Zw && T.locale !== "ko" && (mm || On !== "onCompositionStart" ? On === "onCompositionEnd" && mm && (rn = Be()) : (Ri = ft, ne = "value" in Ri ? Ri.value : Ri.textContent, mm = !0)), Wt = Dv(He, On), 0 < Wt.length && (On = new Gw(On, m, null, T, ft), mt.push({ event: On, listeners: Wt }), rn ? On.data = rn : (rn = Fb(T), rn !== null && (On.data = rn)))), (rn = Sv ? ym(m, T) : GN(m, T)) && (He = Dv(He, "onBeforeInput"), 0 < He.length && (ft = new Gw("onBeforeInput", "beforeinput", null, T, ft), mt.push({ event: ft, listeners: He }), ft.data = rn));
      }
      Wb(mt, v);
    });
  }
  function Mm(m, v, T) {
    return { instance: m, listener: v, currentTarget: T };
  }
  function Dv(m, v) {
    for (var T = v + "Capture", k = []; m !== null; ) {
      var L = m, B = L.stateNode;
      L.tag === 5 && B !== null && (L = B, B = _s(m, T), B != null && k.unshift(Mm(m, B, L)), B = _s(m, v), B != null && k.push(Mm(m, B, L))), m = m.return;
    }
    return k;
  }
  function zp(m) {
    if (m === null)
      return null;
    do
      m = m.return;
    while (m && m.tag !== 5);
    return m || null;
  }
  function zo(m, v, T, k, L) {
    for (var B = v._reactName, oe = []; T !== null && T !== k; ) {
      var me = T, Ee = me.alternate, He = me.stateNode;
      if (Ee !== null && Ee === k)
        break;
      me.tag === 5 && He !== null && (me = He, L ? (Ee = _s(T, B), Ee != null && oe.unshift(Mm(T, Ee, me))) : L || (Ee = _s(T, B), Ee != null && oe.push(Mm(T, Ee, me)))), T = T.return;
    }
    oe.length !== 0 && m.push({ event: v, listeners: oe });
  }
  var Ea = /\r\n?/g, KN = /\u0000|\uFFFD/g;
  function r_(m) {
    return (typeof m == "string" ? m : "" + m).replace(Ea, `
`).replace(KN, "");
  }
  function Av(m, v, T) {
    if (v = r_(v), r_(m) !== v && T)
      throw Error(n(425));
  }
  function Qb() {
  }
  var Ov = null, nc = null;
  function Fp(m, v) {
    return m === "textarea" || m === "noscript" || typeof v.children == "string" || typeof v.children == "number" || typeof v.dangerouslySetInnerHTML == "object" && v.dangerouslySetInnerHTML !== null && v.dangerouslySetInnerHTML.__html != null;
  }
  var pl = typeof setTimeout == "function" ? setTimeout : void 0, Tm = typeof clearTimeout == "function" ? clearTimeout : void 0, Bp = typeof Promise == "function" ? Promise : void 0, Cm = typeof queueMicrotask == "function" ? queueMicrotask : typeof Bp < "u" ? function(m) {
    return Bp.resolve(null).then(m).catch(Nm);
  } : pl;
  function Nm(m) {
    setTimeout(function() {
      throw m;
    });
  }
  function uh(m, v) {
    var T = v, k = 0;
    do {
      var L = T.nextSibling;
      if (m.removeChild(T), L && L.nodeType === 8)
        if (T = L.data, T === "/$") {
          if (k === 0) {
            m.removeChild(L), zr(v);
            return;
          }
          k--;
        } else
          T !== "$" && T !== "$?" && T !== "$!" || k++;
      T = L;
    } while (T);
    zr(v);
  }
  function rc(m) {
    for (; m != null; m = m.nextSibling) {
      var v = m.nodeType;
      if (v === 1 || v === 3)
        break;
      if (v === 8) {
        if (v = m.data, v === "$" || v === "$!" || v === "$?")
          break;
        if (v === "/$")
          return null;
      }
    }
    return m;
  }
  function Rv(m) {
    m = m.previousSibling;
    for (var v = 0; m; ) {
      if (m.nodeType === 8) {
        var T = m.data;
        if (T === "$" || T === "$!" || T === "$?") {
          if (v === 0)
            return m;
          v--;
        } else
          T === "/$" && v++;
      }
      m = m.previousSibling;
    }
    return null;
  }
  var lh = Math.random().toString(36).slice(2), Wc = "__reactFiber$" + lh, qc = "__reactProps$" + lh, Cu = "__reactContainer$" + lh, Xb = "__reactEvents$" + lh, ue = "__reactListeners$" + lh, ch = "__reactHandles$" + lh;
  function Ts(m) {
    var v = m[Wc];
    if (v)
      return v;
    for (var T = m.parentNode; T; ) {
      if (v = T[Cu] || T[Wc]) {
        if (T = v.alternate, v.child !== null || T !== null && T.child !== null)
          for (m = Rv(m); m !== null; ) {
            if (T = m[Wc])
              return T;
            m = Rv(m);
          }
        return v;
      }
      m = T, T = m.parentNode;
    }
    return null;
  }
  function us(m) {
    return m = m[Wc] || m[Cu], !m || m.tag !== 5 && m.tag !== 6 && m.tag !== 13 && m.tag !== 3 ? null : m;
  }
  function nr(m) {
    if (m.tag === 5 || m.tag === 6)
      return m.stateNode;
    throw Error(n(33));
  }
  function cn(m) {
    return m[qc] || null;
  }
  var fh = [], no = -1;
  function Tn(m) {
    return { current: m };
  }
  function Jr(m) {
    0 > no || (m.current = fh[no], fh[no] = null, no--);
  }
  function ai(m, v) {
    no++, fh[no] = m.current, m.current = v;
  }
  var Gc = {}, An = Tn(Gc), Ao = Tn(!1), Oo = Gc;
  function gl(m, v) {
    var T = m.type.contextTypes;
    if (!T)
      return Gc;
    var k = m.stateNode;
    if (k && k.__reactInternalMemoizedUnmaskedChildContext === v)
      return k.__reactInternalMemoizedMaskedChildContext;
    var L = {}, B;
    for (B in T)
      L[B] = v[B];
    return k && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = v, m.__reactInternalMemoizedMaskedChildContext = L), L;
  }
  function ao(m) {
    return m = m.childContextTypes, m != null;
  }
  function ml() {
    Jr(Ao), Jr(An);
  }
  function dh(m, v, T) {
    if (An.current !== Gc)
      throw Error(n(168));
    ai(An, v), ai(Ao, T);
  }
  function kv(m, v, T) {
    var k = m.stateNode;
    if (v = v.childContextTypes, typeof k.getChildContext != "function")
      return T;
    k = k.getChildContext();
    for (var L in k)
      if (!(L in v))
        throw Error(n(108, ke(m) || "Unknown", L));
    return H({}, T, k);
  }
  function yl(m) {
    return m = (m = m.stateNode) && m.__reactInternalMemoizedMergedChildContext || Gc, Oo = An.current, ai(An, m), ai(Ao, Ao.current), !0;
  }
  function N2(m, v, T) {
    var k = m.stateNode;
    if (!k)
      throw Error(n(169));
    T ? (m = kv(m, v, Oo), k.__reactInternalMemoizedMergedChildContext = m, Jr(Ao), Jr(An), ai(An, m)) : Jr(Ao), ai(Ao, T);
  }
  var Nu = null, Sa = !1, $v = !1;
  function i_(m) {
    Nu === null ? Nu = [m] : Nu.push(m);
  }
  function Zf(m) {
    Sa = !0, i_(m);
  }
  function ru() {
    if (!$v && Nu !== null) {
      $v = !0;
      var m = 0, v = Or;
      try {
        var T = Nu;
        for (Or = 1; m < T.length; m++) {
          var k = T[m];
          do
            k = k(!0);
          while (k !== null);
        }
        Nu = null, Sa = !1;
      } catch (L) {
        throw Nu !== null && (Nu = Nu.slice(m + 1)), wi(Kl, ru), L;
      } finally {
        Or = v, $v = !1;
      }
    }
    return null;
  }
  var hh = [], so = 0, Up = null, Dm = 0, iu = [], ls = 0, vl = null, Ma = 1, Qc = "";
  function Du(m, v) {
    hh[so++] = Dm, hh[so++] = Up, Up = m, Dm = v;
  }
  function o_(m, v, T) {
    iu[ls++] = Ma, iu[ls++] = Qc, iu[ls++] = vl, vl = m;
    var k = Ma;
    m = Qc;
    var L = 32 - Ss(k) - 1;
    k &= ~(1 << L), T += 1;
    var B = 32 - Ss(v) + L;
    if (30 < B) {
      var oe = L - L % 5;
      B = (k & (1 << oe) - 1).toString(32), k >>= oe, L -= oe, Ma = 1 << 32 - Ss(v) + L | T << L | k, Qc = B + m;
    } else
      Ma = 1 << B | T << L | k, Qc = m;
  }
  function Am(m) {
    m.return !== null && (Du(m, 1), o_(m, 1, 0));
  }
  function Yp(m) {
    for (; m === Up; )
      Up = hh[--so], hh[so] = null, Dm = hh[--so], hh[so] = null;
    for (; m === vl; )
      vl = iu[--ls], iu[ls] = null, Qc = iu[--ls], iu[ls] = null, Ma = iu[--ls], iu[ls] = null;
  }
  var cs = null, ou = null, Vi = !1, bl = null;
  function ic(m, v) {
    var T = ju(5, null, null, 0);
    T.elementType = "DELETED", T.stateNode = v, T.return = m, v = m.deletions, v === null ? (m.deletions = [T], m.flags |= 16) : v.push(T);
  }
  function Kb(m, v) {
    switch (m.tag) {
      case 5:
        var T = m.type;
        return v = v.nodeType !== 1 || T.toLowerCase() !== v.nodeName.toLowerCase() ? null : v, v !== null ? (m.stateNode = v, cs = m, ou = rc(v.firstChild), !0) : !1;
      case 6:
        return v = m.pendingProps === "" || v.nodeType !== 3 ? null : v, v !== null ? (m.stateNode = v, cs = m, ou = null, !0) : !1;
      case 13:
        return v = v.nodeType !== 8 ? null : v, v !== null ? (T = vl !== null ? { id: Ma, overflow: Qc } : null, m.memoizedState = { dehydrated: v, treeContext: T, retryLane: 1073741824 }, T = ju(18, null, null, 0), T.stateNode = v, T.return = m, m.child = T, cs = m, ou = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Xc(m) {
    return (m.mode & 1) !== 0 && (m.flags & 128) === 0;
  }
  function Cs(m) {
    if (Vi) {
      var v = ou;
      if (v) {
        var T = v;
        if (!Kb(m, v)) {
          if (Xc(m))
            throw Error(n(418));
          v = rc(T.nextSibling);
          var k = cs;
          v && Kb(m, v) ? ic(k, T) : (m.flags = m.flags & -4097 | 2, Vi = !1, cs = m);
        }
      } else {
        if (Xc(m))
          throw Error(n(418));
        m.flags = m.flags & -4097 | 2, Vi = !1, cs = m;
      }
    }
  }
  function D2(m) {
    for (m = m.return; m !== null && m.tag !== 5 && m.tag !== 3 && m.tag !== 13; )
      m = m.return;
    cs = m;
  }
  function Pv(m) {
    if (m !== cs)
      return !1;
    if (!Vi)
      return D2(m), Vi = !0, !1;
    var v;
    if ((v = m.tag !== 3) && !(v = m.tag !== 5) && (v = m.type, v = v !== "head" && v !== "body" && !Fp(m.type, m.memoizedProps)), v && (v = ou)) {
      if (Xc(m))
        throw a_(), Error(n(418));
      for (; v; )
        ic(m, v), v = rc(v.nextSibling);
    }
    if (D2(m), m.tag === 13) {
      if (m = m.memoizedState, m = m !== null ? m.dehydrated : null, !m)
        throw Error(n(317));
      e: {
        for (m = m.nextSibling, v = 0; m; ) {
          if (m.nodeType === 8) {
            var T = m.data;
            if (T === "/$") {
              if (v === 0) {
                ou = rc(m.nextSibling);
                break e;
              }
              v--;
            } else
              T !== "$" && T !== "$!" && T !== "$?" || v++;
          }
          m = m.nextSibling;
        }
        ou = null;
      }
    } else
      ou = cs ? rc(m.stateNode.nextSibling) : null;
    return !0;
  }
  function a_() {
    for (var m = ou; m; )
      m = rc(m.nextSibling);
  }
  function Pi() {
    ou = cs = null, Vi = !1;
  }
  function Kc(m) {
    bl === null ? bl = [m] : bl.push(m);
  }
  var Iv = O.ReactCurrentBatchConfig;
  function Au(m, v) {
    if (m && m.defaultProps) {
      v = H({}, v), m = m.defaultProps;
      for (var T in m)
        v[T] === void 0 && (v[T] = m[T]);
      return v;
    }
    return v;
  }
  var Ou = Tn(null), Zb = null, Jf = null, ca = null;
  function jv() {
    ca = Jf = Zb = null;
  }
  function ed(m) {
    var v = Ou.current;
    Jr(Ou), m._currentValue = v;
  }
  function Ii(m, v, T) {
    for (; m !== null; ) {
      var k = m.alternate;
      if ((m.childLanes & v) !== v ? (m.childLanes |= v, k !== null && (k.childLanes |= v)) : k !== null && (k.childLanes & v) !== v && (k.childLanes |= v), m === T)
        break;
      m = m.return;
    }
  }
  function Ct(m, v) {
    Zb = m, ca = Jf = null, m = m.dependencies, m !== null && m.firstContext !== null && (m.lanes & v && (Ro = !0), m.firstContext = null);
  }
  function uo(m) {
    var v = m._currentValue;
    if (ca !== m)
      if (m = { context: m, memoizedValue: v, next: null }, Jf === null) {
        if (Zb === null)
          throw Error(n(308));
        Jf = m, Zb.dependencies = { lanes: 0, firstContext: m };
      } else
        Jf = Jf.next = m;
    return v;
  }
  var bo = null;
  function Jb(m) {
    bo === null ? bo = [m] : bo.push(m);
  }
  function fs(m, v, T, k) {
    var L = v.interleaved;
    return L === null ? (T.next = T, Jb(v)) : (T.next = L.next, L.next = T), v.interleaved = T, oc(m, k);
  }
  function oc(m, v) {
    m.lanes |= v;
    var T = m.alternate;
    for (T !== null && (T.lanes |= v), T = m, m = m.return; m !== null; )
      m.childLanes |= v, T = m.alternate, T !== null && (T.childLanes |= v), T = m, m = m.return;
    return T.tag === 3 ? T.stateNode : null;
  }
  var ph = !1;
  function s_(m) {
    m.updateQueue = { baseState: m.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function fa(m, v) {
    m = m.updateQueue, v.updateQueue === m && (v.updateQueue = { baseState: m.baseState, firstBaseUpdate: m.firstBaseUpdate, lastBaseUpdate: m.lastBaseUpdate, shared: m.shared, effects: m.effects });
  }
  function ac(m, v) {
    return { eventTime: m, lane: v, tag: 0, payload: null, callback: null, next: null };
  }
  function gh(m, v, T) {
    var k = m.updateQueue;
    if (k === null)
      return null;
    if (k = k.shared, vr & 2) {
      var L = k.pending;
      return L === null ? v.next = v : (v.next = L.next, L.next = v), k.pending = v, oc(m, T);
    }
    return L = k.interleaved, L === null ? (v.next = v, Jb(k)) : (v.next = L.next, L.next = v), k.interleaved = v, oc(m, T);
  }
  function mh(m, v, T) {
    if (v = v.updateQueue, v !== null && (v = v.shared, (T & 4194240) !== 0)) {
      var k = v.lanes;
      k &= m.pendingLanes, T |= k, v.lanes = T, ul(m, T);
    }
  }
  function e1(m, v) {
    var T = m.updateQueue, k = m.alternate;
    if (k !== null && (k = k.updateQueue, T === k)) {
      var L = null, B = null;
      if (T = T.firstBaseUpdate, T !== null) {
        do {
          var oe = { eventTime: T.eventTime, lane: T.lane, tag: T.tag, payload: T.payload, callback: T.callback, next: null };
          B === null ? L = B = oe : B = B.next = oe, T = T.next;
        } while (T !== null);
        B === null ? L = B = v : B = B.next = v;
      } else
        L = B = v;
      T = { baseState: k.baseState, firstBaseUpdate: L, lastBaseUpdate: B, shared: k.shared, effects: k.effects }, m.updateQueue = T;
      return;
    }
    m = T.lastBaseUpdate, m === null ? T.firstBaseUpdate = v : m.next = v, T.lastBaseUpdate = v;
  }
  function yh(m, v, T, k) {
    var L = m.updateQueue;
    ph = !1;
    var B = L.firstBaseUpdate, oe = L.lastBaseUpdate, me = L.shared.pending;
    if (me !== null) {
      L.shared.pending = null;
      var Ee = me, He = Ee.next;
      Ee.next = null, oe === null ? B = He : oe.next = He, oe = Ee;
      var ft = m.alternate;
      ft !== null && (ft = ft.updateQueue, me = ft.lastBaseUpdate, me !== oe && (me === null ? ft.firstBaseUpdate = He : me.next = He, ft.lastBaseUpdate = Ee));
    }
    if (B !== null) {
      var mt = L.baseState;
      oe = 0, ft = He = Ee = null, me = B;
      do {
        var dt = me.lane, jt = me.eventTime;
        if ((k & dt) === dt) {
          ft !== null && (ft = ft.next = {
            eventTime: jt,
            lane: 0,
            tag: me.tag,
            payload: me.payload,
            callback: me.callback,
            next: null
          });
          e: {
            var qt = m, Xt = me;
            switch (dt = v, jt = T, Xt.tag) {
              case 1:
                if (qt = Xt.payload, typeof qt == "function") {
                  mt = qt.call(jt, mt, dt);
                  break e;
                }
                mt = qt;
                break e;
              case 3:
                qt.flags = qt.flags & -65537 | 128;
              case 0:
                if (qt = Xt.payload, dt = typeof qt == "function" ? qt.call(jt, mt, dt) : qt, dt == null)
                  break e;
                mt = H({}, mt, dt);
                break e;
              case 2:
                ph = !0;
            }
          }
          me.callback !== null && me.lane !== 0 && (m.flags |= 64, dt = L.effects, dt === null ? L.effects = [me] : dt.push(me));
        } else
          jt = { eventTime: jt, lane: dt, tag: me.tag, payload: me.payload, callback: me.callback, next: null }, ft === null ? (He = ft = jt, Ee = mt) : ft = ft.next = jt, oe |= dt;
        if (me = me.next, me === null) {
          if (me = L.shared.pending, me === null)
            break;
          dt = me, me = dt.next, dt.next = null, L.lastBaseUpdate = dt, L.shared.pending = null;
        }
      } while (1);
      if (ft === null && (Ee = mt), L.baseState = Ee, L.firstBaseUpdate = He, L.lastBaseUpdate = ft, v = L.shared.interleaved, v !== null) {
        L = v;
        do
          oe |= L.lane, L = L.next;
        while (L !== v);
      } else
        B === null && (L.shared.lanes = 0);
      nf |= oe, m.lanes = oe, m.memoizedState = mt;
    }
  }
  function Hp(m, v, T) {
    if (m = v.effects, v.effects = null, m !== null)
      for (v = 0; v < m.length; v++) {
        var k = m[v], L = k.callback;
        if (L !== null) {
          if (k.callback = null, k = T, typeof L != "function")
            throw Error(n(191, L));
          L.call(k);
        }
      }
  }
  var Om = new e.Component().refs;
  function u_(m, v, T, k) {
    v = m.memoizedState, T = T(k, v), T = T == null ? v : H({}, v, T), m.memoizedState = T, m.lanes === 0 && (m.updateQueue.baseState = T);
  }
  var t1 = { isMounted: function(m) {
    return (m = m._reactInternals) ? In(m) === m : !1;
  }, enqueueSetState: function(m, v, T) {
    m = m._reactInternals;
    var k = ps(), L = ea(m), B = ac(k, L);
    B.payload = v, T != null && (B.callback = T), v = gh(m, B, L), v !== null && (gs(v, m, L, k), mh(v, m, L));
  }, enqueueReplaceState: function(m, v, T) {
    m = m._reactInternals;
    var k = ps(), L = ea(m), B = ac(k, L);
    B.tag = 1, B.payload = v, T != null && (B.callback = T), v = gh(m, B, L), v !== null && (gs(v, m, L, k), mh(v, m, L));
  }, enqueueForceUpdate: function(m, v) {
    m = m._reactInternals;
    var T = ps(), k = ea(m), L = ac(T, k);
    L.tag = 2, v != null && (L.callback = v), v = gh(m, L, k), v !== null && (gs(v, m, k, T), mh(v, m, k));
  } };
  function n1(m, v, T, k, L, B, oe) {
    return m = m.stateNode, typeof m.shouldComponentUpdate == "function" ? m.shouldComponentUpdate(k, B, oe) : v.prototype && v.prototype.isPureReactComponent ? !It(T, k) || !It(L, B) : !0;
  }
  function l_(m, v, T) {
    var k = !1, L = Gc, B = v.contextType;
    return typeof B == "object" && B !== null ? B = uo(B) : (L = ao(v) ? Oo : An.current, k = v.contextTypes, B = (k = k != null) ? gl(m, L) : Gc), v = new v(T, B), m.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null, v.updater = t1, m.stateNode = v, v._reactInternals = m, k && (m = m.stateNode, m.__reactInternalMemoizedUnmaskedChildContext = L, m.__reactInternalMemoizedMaskedChildContext = B), v;
  }
  function A2(m, v, T, k) {
    m = v.state, typeof v.componentWillReceiveProps == "function" && v.componentWillReceiveProps(T, k), typeof v.UNSAFE_componentWillReceiveProps == "function" && v.UNSAFE_componentWillReceiveProps(T, k), v.state !== m && t1.enqueueReplaceState(v, v.state, null);
  }
  function r1(m, v, T, k) {
    var L = m.stateNode;
    L.props = T, L.state = m.memoizedState, L.refs = Om, s_(m);
    var B = v.contextType;
    typeof B == "object" && B !== null ? L.context = uo(B) : (B = ao(v) ? Oo : An.current, L.context = gl(m, B)), L.state = m.memoizedState, B = v.getDerivedStateFromProps, typeof B == "function" && (u_(m, v, B, T), L.state = m.memoizedState), typeof v.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function" || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (v = L.state, typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount(), v !== L.state && t1.enqueueReplaceState(L, L.state, null), yh(m, T, L, k), L.state = m.memoizedState), typeof L.componentDidMount == "function" && (m.flags |= 4194308);
  }
  function Rm(m, v, T) {
    if (m = T.ref, m !== null && typeof m != "function" && typeof m != "object") {
      if (T._owner) {
        if (T = T._owner, T) {
          if (T.tag !== 1)
            throw Error(n(309));
          var k = T.stateNode;
        }
        if (!k)
          throw Error(n(147, m));
        var L = k, B = "" + m;
        return v !== null && v.ref !== null && typeof v.ref == "function" && v.ref._stringRef === B ? v.ref : (v = function(oe) {
          var me = L.refs;
          me === Om && (me = L.refs = {}), oe === null ? delete me[B] : me[B] = oe;
        }, v._stringRef = B, v);
      }
      if (typeof m != "string")
        throw Error(n(284));
      if (!T._owner)
        throw Error(n(290, m));
    }
    return m;
  }
  function Lv(m, v) {
    throw m = Object.prototype.toString.call(v), Error(n(31, m === "[object Object]" ? "object with keys {" + Object.keys(v).join(", ") + "}" : m));
  }
  function i1(m) {
    var v = m._init;
    return v(m._payload);
  }
  function O2(m) {
    function v(Pe, Te) {
      if (m) {
        var Ie = Pe.deletions;
        Ie === null ? (Pe.deletions = [Te], Pe.flags |= 16) : Ie.push(Te);
      }
    }
    function T(Pe, Te) {
      if (!m)
        return null;
      for (; Te !== null; )
        v(Pe, Te), Te = Te.sibling;
      return null;
    }
    function k(Pe, Te) {
      for (Pe = /* @__PURE__ */ new Map(); Te !== null; )
        Te.key !== null ? Pe.set(Te.key, Te) : Pe.set(Te.index, Te), Te = Te.sibling;
      return Pe;
    }
    function L(Pe, Te) {
      return Pe = Ph(Pe, Te), Pe.index = 0, Pe.sibling = null, Pe;
    }
    function B(Pe, Te, Ie) {
      return Pe.index = Ie, m ? (Ie = Pe.alternate, Ie !== null ? (Ie = Ie.index, Ie < Te ? (Pe.flags |= 2, Te) : Ie) : (Pe.flags |= 2, Te)) : (Pe.flags |= 1048576, Te);
    }
    function oe(Pe) {
      return m && Pe.alternate === null && (Pe.flags |= 2), Pe;
    }
    function me(Pe, Te, Ie, wt) {
      return Te === null || Te.tag !== 6 ? (Te = i0(Ie, Pe.mode, wt), Te.return = Pe, Te) : (Te = L(Te, Ie), Te.return = Pe, Te);
    }
    function Ee(Pe, Te, Ie, wt) {
      var Jt = Ie.type;
      return Jt === $ ? ft(Pe, Te, Ie.props.children, wt, Ie.key) : Te !== null && (Te.elementType === Jt || typeof Jt == "object" && Jt !== null && Jt.$$typeof === te && i1(Jt) === Te.type) ? (wt = L(Te, Ie.props), wt.ref = Rm(Pe, Te, Ie), wt.return = Pe, wt) : (wt = M1(Ie.type, Ie.key, Ie.props, null, Pe.mode, wt), wt.ref = Rm(Pe, Te, Ie), wt.return = Pe, wt);
    }
    function He(Pe, Te, Ie, wt) {
      return Te === null || Te.tag !== 4 || Te.stateNode.containerInfo !== Ie.containerInfo || Te.stateNode.implementation !== Ie.implementation ? (Te = og(Ie, Pe.mode, wt), Te.return = Pe, Te) : (Te = L(Te, Ie.children || []), Te.return = Pe, Te);
    }
    function ft(Pe, Te, Ie, wt, Jt) {
      return Te === null || Te.tag !== 7 ? (Te = ig(Ie, Pe.mode, wt, Jt), Te.return = Pe, Te) : (Te = L(Te, Ie), Te.return = Pe, Te);
    }
    function mt(Pe, Te, Ie) {
      if (typeof Te == "string" && Te !== "" || typeof Te == "number")
        return Te = i0("" + Te, Pe.mode, Ie), Te.return = Pe, Te;
      if (typeof Te == "object" && Te !== null) {
        switch (Te.$$typeof) {
          case R:
            return Ie = M1(Te.type, Te.key, Te.props, null, Pe.mode, Ie), Ie.ref = Rm(Pe, null, Te), Ie.return = Pe, Ie;
          case j:
            return Te = og(Te, Pe.mode, Ie), Te.return = Pe, Te;
          case te:
            var wt = Te._init;
            return mt(Pe, wt(Te._payload), Ie);
        }
        if (tn(Te) || se(Te))
          return Te = ig(Te, Pe.mode, Ie, null), Te.return = Pe, Te;
        Lv(Pe, Te);
      }
      return null;
    }
    function dt(Pe, Te, Ie, wt) {
      var Jt = Te !== null ? Te.key : null;
      if (typeof Ie == "string" && Ie !== "" || typeof Ie == "number")
        return Jt !== null ? null : me(Pe, Te, "" + Ie, wt);
      if (typeof Ie == "object" && Ie !== null) {
        switch (Ie.$$typeof) {
          case R:
            return Ie.key === Jt ? Ee(Pe, Te, Ie, wt) : null;
          case j:
            return Ie.key === Jt ? He(Pe, Te, Ie, wt) : null;
          case te:
            return Jt = Ie._init, dt(
              Pe,
              Te,
              Jt(Ie._payload),
              wt
            );
        }
        if (tn(Ie) || se(Ie))
          return Jt !== null ? null : ft(Pe, Te, Ie, wt, null);
        Lv(Pe, Ie);
      }
      return null;
    }
    function jt(Pe, Te, Ie, wt, Jt) {
      if (typeof wt == "string" && wt !== "" || typeof wt == "number")
        return Pe = Pe.get(Ie) || null, me(Te, Pe, "" + wt, Jt);
      if (typeof wt == "object" && wt !== null) {
        switch (wt.$$typeof) {
          case R:
            return Pe = Pe.get(wt.key === null ? Ie : wt.key) || null, Ee(Te, Pe, wt, Jt);
          case j:
            return Pe = Pe.get(wt.key === null ? Ie : wt.key) || null, He(Te, Pe, wt, Jt);
          case te:
            var Wt = wt._init;
            return jt(Pe, Te, Ie, Wt(wt._payload), Jt);
        }
        if (tn(wt) || se(wt))
          return Pe = Pe.get(Ie) || null, ft(Te, Pe, wt, Jt, null);
        Lv(Te, wt);
      }
      return null;
    }
    function qt(Pe, Te, Ie, wt) {
      for (var Jt = null, Wt = null, rn = Te, On = Te = 0, Aa = null; rn !== null && On < Ie.length; On++) {
        rn.index > On ? (Aa = rn, rn = null) : Aa = rn.sibling;
        var Br = dt(Pe, rn, Ie[On], wt);
        if (Br === null) {
          rn === null && (rn = Aa);
          break;
        }
        m && rn && Br.alternate === null && v(Pe, rn), Te = B(Br, Te, On), Wt === null ? Jt = Br : Wt.sibling = Br, Wt = Br, rn = Aa;
      }
      if (On === Ie.length)
        return T(Pe, rn), Vi && Du(Pe, On), Jt;
      if (rn === null) {
        for (; On < Ie.length; On++)
          rn = mt(Pe, Ie[On], wt), rn !== null && (Te = B(rn, Te, On), Wt === null ? Jt = rn : Wt.sibling = rn, Wt = rn);
        return Vi && Du(Pe, On), Jt;
      }
      for (rn = k(Pe, rn); On < Ie.length; On++)
        Aa = jt(rn, Pe, On, Ie[On], wt), Aa !== null && (m && Aa.alternate !== null && rn.delete(Aa.key === null ? On : Aa.key), Te = B(Aa, Te, On), Wt === null ? Jt = Aa : Wt.sibling = Aa, Wt = Aa);
      return m && rn.forEach(function(Ih) {
        return v(Pe, Ih);
      }), Vi && Du(Pe, On), Jt;
    }
    function Xt(Pe, Te, Ie, wt) {
      var Jt = se(Ie);
      if (typeof Jt != "function")
        throw Error(n(150));
      if (Ie = Jt.call(Ie), Ie == null)
        throw Error(n(151));
      for (var Wt = Jt = null, rn = Te, On = Te = 0, Aa = null, Br = Ie.next(); rn !== null && !Br.done; On++, Br = Ie.next()) {
        rn.index > On ? (Aa = rn, rn = null) : Aa = rn.sibling;
        var Ih = dt(Pe, rn, Br.value, wt);
        if (Ih === null) {
          rn === null && (rn = Aa);
          break;
        }
        m && rn && Ih.alternate === null && v(Pe, rn), Te = B(Ih, Te, On), Wt === null ? Jt = Ih : Wt.sibling = Ih, Wt = Ih, rn = Aa;
      }
      if (Br.done)
        return T(
          Pe,
          rn
        ), Vi && Du(Pe, On), Jt;
      if (rn === null) {
        for (; !Br.done; On++, Br = Ie.next())
          Br = mt(Pe, Br.value, wt), Br !== null && (Te = B(Br, Te, On), Wt === null ? Jt = Br : Wt.sibling = Br, Wt = Br);
        return Vi && Du(Pe, On), Jt;
      }
      for (rn = k(Pe, rn); !Br.done; On++, Br = Ie.next())
        Br = jt(rn, Pe, On, Br.value, wt), Br !== null && (m && Br.alternate !== null && rn.delete(Br.key === null ? On : Br.key), Te = B(Br, Te, On), Wt === null ? Jt = Br : Wt.sibling = Br, Wt = Br);
      return m && rn.forEach(function(fD) {
        return v(Pe, fD);
      }), Vi && Du(Pe, On), Jt;
    }
    function Bo(Pe, Te, Ie, wt) {
      if (typeof Ie == "object" && Ie !== null && Ie.type === $ && Ie.key === null && (Ie = Ie.props.children), typeof Ie == "object" && Ie !== null) {
        switch (Ie.$$typeof) {
          case R:
            e: {
              for (var Jt = Ie.key, Wt = Te; Wt !== null; ) {
                if (Wt.key === Jt) {
                  if (Jt = Ie.type, Jt === $) {
                    if (Wt.tag === 7) {
                      T(Pe, Wt.sibling), Te = L(Wt, Ie.props.children), Te.return = Pe, Pe = Te;
                      break e;
                    }
                  } else if (Wt.elementType === Jt || typeof Jt == "object" && Jt !== null && Jt.$$typeof === te && i1(Jt) === Wt.type) {
                    T(Pe, Wt.sibling), Te = L(Wt, Ie.props), Te.ref = Rm(Pe, Wt, Ie), Te.return = Pe, Pe = Te;
                    break e;
                  }
                  T(Pe, Wt);
                  break;
                } else
                  v(Pe, Wt);
                Wt = Wt.sibling;
              }
              Ie.type === $ ? (Te = ig(Ie.props.children, Pe.mode, wt, Ie.key), Te.return = Pe, Pe = Te) : (wt = M1(Ie.type, Ie.key, Ie.props, null, Pe.mode, wt), wt.ref = Rm(Pe, Te, Ie), wt.return = Pe, Pe = wt);
            }
            return oe(Pe);
          case j:
            e: {
              for (Wt = Ie.key; Te !== null; ) {
                if (Te.key === Wt)
                  if (Te.tag === 4 && Te.stateNode.containerInfo === Ie.containerInfo && Te.stateNode.implementation === Ie.implementation) {
                    T(Pe, Te.sibling), Te = L(Te, Ie.children || []), Te.return = Pe, Pe = Te;
                    break e;
                  } else {
                    T(Pe, Te);
                    break;
                  }
                else
                  v(Pe, Te);
                Te = Te.sibling;
              }
              Te = og(Ie, Pe.mode, wt), Te.return = Pe, Pe = Te;
            }
            return oe(Pe);
          case te:
            return Wt = Ie._init, Bo(Pe, Te, Wt(Ie._payload), wt);
        }
        if (tn(Ie))
          return qt(Pe, Te, Ie, wt);
        if (se(Ie))
          return Xt(Pe, Te, Ie, wt);
        Lv(Pe, Ie);
      }
      return typeof Ie == "string" && Ie !== "" || typeof Ie == "number" ? (Ie = "" + Ie, Te !== null && Te.tag === 6 ? (T(Pe, Te.sibling), Te = L(Te, Ie), Te.return = Pe, Pe = Te) : (T(Pe, Te), Te = i0(Ie, Pe.mode, wt), Te.return = Pe, Pe = Te), oe(Pe)) : T(Pe, Te);
    }
    return Bo;
  }
  var vh = O2(!0), c_ = O2(!1), km = {}, xl = Tn(km), bh = Tn(km), $m = Tn(km);
  function xh(m) {
    if (m === km)
      throw Error(n(174));
    return m;
  }
  function o1(m, v) {
    switch (ai($m, v), ai(bh, m), ai(xl, km), m = v.nodeType, m) {
      case 9:
      case 11:
        v = (v = v.documentElement) ? v.namespaceURI : Un(null, "");
        break;
      default:
        m = m === 8 ? v.parentNode : v, v = m.namespaceURI || null, m = m.tagName, v = Un(v, m);
    }
    Jr(xl), ai(xl, v);
  }
  function wh() {
    Jr(xl), Jr(bh), Jr($m);
  }
  function hn(m) {
    xh($m.current);
    var v = xh(xl.current), T = Un(v, m.type);
    v !== T && (ai(bh, m), ai(xl, T));
  }
  function fr(m) {
    bh.current === m && (Jr(xl), Jr(bh));
  }
  var pn = Tn(0);
  function lo(m) {
    for (var v = m; v !== null; ) {
      if (v.tag === 13) {
        var T = v.memoizedState;
        if (T !== null && (T = T.dehydrated, T === null || T.data === "$?" || T.data === "$!"))
          return v;
      } else if (v.tag === 19 && v.memoizedProps.revealOrder !== void 0) {
        if (v.flags & 128)
          return v;
      } else if (v.child !== null) {
        v.child.return = v, v = v.child;
        continue;
      }
      if (v === m)
        break;
      for (; v.sibling === null; ) {
        if (v.return === null || v.return === m)
          return null;
        v = v.return;
      }
      v.sibling.return = v.return, v = v.sibling;
    }
    return null;
  }
  var au = [];
  function a1() {
    for (var m = 0; m < au.length; m++)
      au[m]._workInProgressVersionPrimary = null;
    au.length = 0;
  }
  var Pm = O.ReactCurrentDispatcher, rr = O.ReactCurrentBatchConfig, Vp = 0, ro = null, Xe = null, Er = null, En = !1, Zc = !1, co = 0, Wp = 0;
  function Ei() {
    throw Error(n(321));
  }
  function td(m, v) {
    if (v === null)
      return !1;
    for (var T = 0; T < v.length && T < m.length; T++)
      if (!Fe(m[T], v[T]))
        return !1;
    return !0;
  }
  function nd(m, v, T, k, L, B) {
    if (Vp = B, ro = v, v.memoizedState = null, v.updateQueue = null, v.lanes = 0, Pm.current = m === null || m.memoizedState === null ? Gv : JN, m = T(k, L), Zc) {
      B = 0;
      do {
        if (Zc = !1, co = 0, 25 <= B)
          throw Error(n(301));
        B += 1, Er = Xe = null, v.updateQueue = null, Pm.current = l1, m = T(k, L);
      } while (Zc);
    }
    if (Pm.current = sd, v = Xe !== null && Xe.next !== null, Vp = 0, Er = Xe = ro = null, En = !1, v)
      throw Error(n(300));
    return m;
  }
  function _h() {
    var m = co !== 0;
    return co = 0, m;
  }
  function fo() {
    var m = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Er === null ? ro.memoizedState = Er = m : Er = Er.next = m, Er;
  }
  function Fo() {
    if (Xe === null) {
      var m = ro.alternate;
      m = m !== null ? m.memoizedState : null;
    } else
      m = Xe.next;
    var v = Er === null ? ro.memoizedState : Er.next;
    if (v !== null)
      Er = v, Xe = m;
    else {
      if (m === null)
        throw Error(n(310));
      Xe = m, m = { memoizedState: Xe.memoizedState, baseState: Xe.baseState, baseQueue: Xe.baseQueue, queue: Xe.queue, next: null }, Er === null ? ro.memoizedState = Er = m : Er = Er.next = m;
    }
    return Er;
  }
  function rd(m, v) {
    return typeof v == "function" ? v(m) : v;
  }
  function Im(m) {
    var v = Fo(), T = v.queue;
    if (T === null)
      throw Error(n(311));
    T.lastRenderedReducer = m;
    var k = Xe, L = k.baseQueue, B = T.pending;
    if (B !== null) {
      if (L !== null) {
        var oe = L.next;
        L.next = B.next, B.next = oe;
      }
      k.baseQueue = L = B, T.pending = null;
    }
    if (L !== null) {
      B = L.next, k = k.baseState;
      var me = oe = null, Ee = null, He = B;
      do {
        var ft = He.lane;
        if ((Vp & ft) === ft)
          Ee !== null && (Ee = Ee.next = { lane: 0, action: He.action, hasEagerState: He.hasEagerState, eagerState: He.eagerState, next: null }), k = He.hasEagerState ? He.eagerState : m(k, He.action);
        else {
          var mt = {
            lane: ft,
            action: He.action,
            hasEagerState: He.hasEagerState,
            eagerState: He.eagerState,
            next: null
          };
          Ee === null ? (me = Ee = mt, oe = k) : Ee = Ee.next = mt, ro.lanes |= ft, nf |= ft;
        }
        He = He.next;
      } while (He !== null && He !== B);
      Ee === null ? oe = k : Ee.next = me, Fe(k, v.memoizedState) || (Ro = !0), v.memoizedState = k, v.baseState = oe, v.baseQueue = Ee, T.lastRenderedState = k;
    }
    if (m = T.interleaved, m !== null) {
      L = m;
      do
        B = L.lane, ro.lanes |= B, nf |= B, L = L.next;
      while (L !== m);
    } else
      L === null && (T.lanes = 0);
    return [v.memoizedState, T.dispatch];
  }
  function Eh(m) {
    var v = Fo(), T = v.queue;
    if (T === null)
      throw Error(n(311));
    T.lastRenderedReducer = m;
    var k = T.dispatch, L = T.pending, B = v.memoizedState;
    if (L !== null) {
      T.pending = null;
      var oe = L = L.next;
      do
        B = m(B, oe.action), oe = oe.next;
      while (oe !== L);
      Fe(B, v.memoizedState) || (Ro = !0), v.memoizedState = B, v.baseQueue === null && (v.baseState = B), T.lastRenderedState = B;
    }
    return [B, k];
  }
  function zv() {
  }
  function jm(m, v) {
    var T = ro, k = Fo(), L = v(), B = !Fe(k.memoizedState, L);
    if (B && (k.memoizedState = L, Ro = !0), k = k.queue, Uv(zm.bind(null, T, k, m), [m]), k.getSnapshot !== v || B || Er !== null && Er.memoizedState.tag & 1) {
      if (T.flags |= 2048, Sh(9, Lm.bind(null, T, k, L, v), void 0, null), xo === null)
        throw Error(n(349));
      Vp & 30 || Fv(T, v, L);
    }
    return L;
  }
  function Fv(m, v, T) {
    m.flags |= 16384, m = { getSnapshot: v, value: T }, v = ro.updateQueue, v === null ? (v = { lastEffect: null, stores: null }, ro.updateQueue = v, v.stores = [m]) : (T = v.stores, T === null ? v.stores = [m] : T.push(m));
  }
  function Lm(m, v, T, k) {
    v.value = T, v.getSnapshot = k, sc(v) && s1(m);
  }
  function zm(m, v, T) {
    return T(function() {
      sc(v) && s1(m);
    });
  }
  function sc(m) {
    var v = m.getSnapshot;
    m = m.value;
    try {
      var T = v();
      return !Fe(m, T);
    } catch {
      return !0;
    }
  }
  function s1(m) {
    var v = oc(m, 1);
    v !== null && gs(v, m, 1, -1);
  }
  function uc(m) {
    var v = fo();
    return typeof m == "function" && (m = m()), v.memoizedState = v.baseState = m, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: rd, lastRenderedState: m }, v.queue = m, m = m.dispatch = Wv.bind(null, ro, m), [v.memoizedState, m];
  }
  function Sh(m, v, T, k) {
    return m = { tag: m, create: v, destroy: T, deps: k, next: null }, v = ro.updateQueue, v === null ? (v = { lastEffect: null, stores: null }, ro.updateQueue = v, v.lastEffect = m.next = m) : (T = v.lastEffect, T === null ? v.lastEffect = m.next = m : (k = T.next, T.next = m, m.next = k, v.lastEffect = m)), m;
  }
  function Bv() {
    return Fo().memoizedState;
  }
  function id(m, v, T, k) {
    var L = fo();
    ro.flags |= m, L.memoizedState = Sh(1 | v, T, void 0, k === void 0 ? null : k);
  }
  function od(m, v, T, k) {
    var L = Fo();
    k = k === void 0 ? null : k;
    var B = void 0;
    if (Xe !== null) {
      var oe = Xe.memoizedState;
      if (B = oe.destroy, k !== null && td(k, oe.deps)) {
        L.memoizedState = Sh(v, T, B, k);
        return;
      }
    }
    ro.flags |= m, L.memoizedState = Sh(1 | v, T, B, k);
  }
  function u1(m, v) {
    return id(8390656, 8, m, v);
  }
  function Uv(m, v) {
    return od(2048, 8, m, v);
  }
  function Yv(m, v) {
    return od(4, 2, m, v);
  }
  function Hv(m, v) {
    return od(4, 4, m, v);
  }
  function f_(m, v) {
    if (typeof v == "function")
      return m = m(), v(m), function() {
        v(null);
      };
    if (v != null)
      return m = m(), v.current = m, function() {
        v.current = null;
      };
  }
  function qp(m, v, T) {
    return T = T != null ? T.concat([m]) : null, od(4, 4, f_.bind(null, v, m), T);
  }
  function Vv() {
  }
  function da(m, v) {
    var T = Fo();
    v = v === void 0 ? null : v;
    var k = T.memoizedState;
    return k !== null && v !== null && td(v, k[1]) ? k[0] : (T.memoizedState = [m, v], m);
  }
  function qa(m, v) {
    var T = Fo();
    v = v === void 0 ? null : v;
    var k = T.memoizedState;
    return k !== null && v !== null && td(v, k[1]) ? k[0] : (m = m(), T.memoizedState = [m, v], m);
  }
  function su(m, v, T) {
    return Vp & 21 ? (Fe(T, v) || (T = Dp(), ro.lanes |= T, nf |= T, m.baseState = !0), v) : (m.baseState && (m.baseState = !1, Ro = !0), m.memoizedState = T);
  }
  function ZN(m, v) {
    var T = Or;
    Or = T !== 0 && 4 > T ? T : 4, m(!0);
    var k = rr.transition;
    rr.transition = {};
    try {
      m(!1), v();
    } finally {
      Or = T, rr.transition = k;
    }
  }
  function si() {
    return Fo().memoizedState;
  }
  function ad(m, v, T) {
    var k = ea(m);
    if (T = { lane: k, action: T, hasEagerState: !1, eagerState: null, next: null }, Gp(m))
      qv(v, T);
    else if (T = fs(m, v, T, k), T !== null) {
      var L = ps();
      gs(T, m, k, L), d_(T, v, k);
    }
  }
  function Wv(m, v, T) {
    var k = ea(m), L = { lane: k, action: T, hasEagerState: !1, eagerState: null, next: null };
    if (Gp(m))
      qv(v, L);
    else {
      var B = m.alternate;
      if (m.lanes === 0 && (B === null || B.lanes === 0) && (B = v.lastRenderedReducer, B !== null))
        try {
          var oe = v.lastRenderedState, me = B(oe, T);
          if (L.hasEagerState = !0, L.eagerState = me, Fe(me, oe)) {
            var Ee = v.interleaved;
            Ee === null ? (L.next = L, Jb(v)) : (L.next = Ee.next, Ee.next = L), v.interleaved = L;
            return;
          }
        } catch {
        } finally {
        }
      T = fs(m, v, L, k), T !== null && (L = ps(), gs(T, m, k, L), d_(T, v, k));
    }
  }
  function Gp(m) {
    var v = m.alternate;
    return m === ro || v !== null && v === ro;
  }
  function qv(m, v) {
    Zc = En = !0;
    var T = m.pending;
    T === null ? v.next = v : (v.next = T.next, T.next = v), m.pending = v;
  }
  function d_(m, v, T) {
    if (T & 4194240) {
      var k = v.lanes;
      k &= m.pendingLanes, T |= k, v.lanes = T, ul(m, T);
    }
  }
  var sd = { readContext: uo, useCallback: Ei, useContext: Ei, useEffect: Ei, useImperativeHandle: Ei, useInsertionEffect: Ei, useLayoutEffect: Ei, useMemo: Ei, useReducer: Ei, useRef: Ei, useState: Ei, useDebugValue: Ei, useDeferredValue: Ei, useTransition: Ei, useMutableSource: Ei, useSyncExternalStore: Ei, useId: Ei, unstable_isNewReconciler: !1 }, Gv = { readContext: uo, useCallback: function(m, v) {
    return fo().memoizedState = [m, v === void 0 ? null : v], m;
  }, useContext: uo, useEffect: u1, useImperativeHandle: function(m, v, T) {
    return T = T != null ? T.concat([m]) : null, id(
      4194308,
      4,
      f_.bind(null, v, m),
      T
    );
  }, useLayoutEffect: function(m, v) {
    return id(4194308, 4, m, v);
  }, useInsertionEffect: function(m, v) {
    return id(4, 2, m, v);
  }, useMemo: function(m, v) {
    var T = fo();
    return v = v === void 0 ? null : v, m = m(), T.memoizedState = [m, v], m;
  }, useReducer: function(m, v, T) {
    var k = fo();
    return v = T !== void 0 ? T(v) : v, k.memoizedState = k.baseState = v, m = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: m, lastRenderedState: v }, k.queue = m, m = m.dispatch = ad.bind(null, ro, m), [k.memoizedState, m];
  }, useRef: function(m) {
    var v = fo();
    return m = { current: m }, v.memoizedState = m;
  }, useState: uc, useDebugValue: Vv, useDeferredValue: function(m) {
    return fo().memoizedState = m;
  }, useTransition: function() {
    var m = uc(!1), v = m[0];
    return m = ZN.bind(null, m[1]), fo().memoizedState = m, [v, m];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(m, v, T) {
    var k = ro, L = fo();
    if (Vi) {
      if (T === void 0)
        throw Error(n(407));
      T = T();
    } else {
      if (T = v(), xo === null)
        throw Error(n(349));
      Vp & 30 || Fv(k, v, T);
    }
    L.memoizedState = T;
    var B = { value: T, getSnapshot: v };
    return L.queue = B, u1(zm.bind(
      null,
      k,
      B,
      m
    ), [m]), k.flags |= 2048, Sh(9, Lm.bind(null, k, B, T, v), void 0, null), T;
  }, useId: function() {
    var m = fo(), v = xo.identifierPrefix;
    if (Vi) {
      var T = Qc, k = Ma;
      T = (k & ~(1 << 32 - Ss(k) - 1)).toString(32) + T, v = ":" + v + "R" + T, T = co++, 0 < T && (v += "H" + T.toString(32)), v += ":";
    } else
      T = Wp++, v = ":" + v + "r" + T.toString(32) + ":";
    return m.memoizedState = v;
  }, unstable_isNewReconciler: !1 }, JN = {
    readContext: uo,
    useCallback: da,
    useContext: uo,
    useEffect: Uv,
    useImperativeHandle: qp,
    useInsertionEffect: Yv,
    useLayoutEffect: Hv,
    useMemo: qa,
    useReducer: Im,
    useRef: Bv,
    useState: function() {
      return Im(rd);
    },
    useDebugValue: Vv,
    useDeferredValue: function(m) {
      var v = Fo();
      return su(v, Xe.memoizedState, m);
    },
    useTransition: function() {
      var m = Im(rd)[0], v = Fo().memoizedState;
      return [m, v];
    },
    useMutableSource: zv,
    useSyncExternalStore: jm,
    useId: si,
    unstable_isNewReconciler: !1
  }, l1 = { readContext: uo, useCallback: da, useContext: uo, useEffect: Uv, useImperativeHandle: qp, useInsertionEffect: Yv, useLayoutEffect: Hv, useMemo: qa, useReducer: Eh, useRef: Bv, useState: function() {
    return Eh(rd);
  }, useDebugValue: Vv, useDeferredValue: function(m) {
    var v = Fo();
    return Xe === null ? v.memoizedState = m : su(v, Xe.memoizedState, m);
  }, useTransition: function() {
    var m = Eh(rd)[0], v = Fo().memoizedState;
    return [m, v];
  }, useMutableSource: zv, useSyncExternalStore: jm, useId: si, unstable_isNewReconciler: !1 };
  function Qp(m, v) {
    try {
      var T = "", k = v;
      do
        T += Ne(k), k = k.return;
      while (k);
      var L = T;
    } catch (B) {
      L = `
Error generating stack: ` + B.message + `
` + B.stack;
    }
    return { value: m, source: v, stack: L, digest: null };
  }
  function Mh(m, v, T) {
    return { value: m, source: null, stack: T ?? null, digest: v ?? null };
  }
  function Qv(m, v) {
    try {
      console.error(v.value);
    } catch (T) {
      setTimeout(function() {
        throw T;
      });
    }
  }
  var c1 = typeof WeakMap == "function" ? WeakMap : Map;
  function f1(m, v, T) {
    T = ac(-1, T), T.tag = 3, T.payload = { element: null };
    var k = v.value;
    return T.callback = function() {
      v1 || (v1 = !0, eg = k), Qv(m, v);
    }, T;
  }
  function Th(m, v, T) {
    T = ac(-1, T), T.tag = 3;
    var k = m.type.getDerivedStateFromError;
    if (typeof k == "function") {
      var L = v.value;
      T.payload = function() {
        return k(L);
      }, T.callback = function() {
        Qv(m, v);
      };
    }
    var B = m.stateNode;
    return B !== null && typeof B.componentDidCatch == "function" && (T.callback = function() {
      Qv(m, v), typeof k != "function" && (rf === null ? rf = /* @__PURE__ */ new Set([this]) : rf.add(this));
      var oe = v.stack;
      this.componentDidCatch(v.value, { componentStack: oe !== null ? oe : "" });
    }), T;
  }
  function R2(m, v, T) {
    var k = m.pingCache;
    if (k === null) {
      k = m.pingCache = new c1();
      var L = /* @__PURE__ */ new Set();
      k.set(v, L);
    } else
      L = k.get(v), L === void 0 && (L = /* @__PURE__ */ new Set(), k.set(v, L));
    L.has(T) || (L.add(T), m = iD.bind(null, m, v, T), v.then(m, m));
  }
  function d1(m) {
    do {
      var v;
      if ((v = m.tag === 13) && (v = m.memoizedState, v = v !== null ? v.dehydrated !== null : !0), v)
        return m;
      m = m.return;
    } while (m !== null);
    return null;
  }
  function Fm(m, v, T, k, L) {
    return m.mode & 1 ? (m.flags |= 65536, m.lanes = L, m) : (m === v ? m.flags |= 65536 : (m.flags |= 128, T.flags |= 131072, T.flags &= -52805, T.tag === 1 && (T.alternate === null ? T.tag = 17 : (v = ac(-1, 1), v.tag = 2, gh(T, v, 1))), T.lanes |= 1), m);
  }
  var k2 = O.ReactCurrentOwner, Ro = !1;
  function ha(m, v, T, k) {
    v.child = m === null ? c_(v, null, T, k) : vh(v, m.child, T, k);
  }
  function ud(m, v, T, k, L) {
    T = T.render;
    var B = v.ref;
    return Ct(v, L), k = nd(m, v, T, k, B, L), T = _h(), m !== null && !Ro ? (v.updateQueue = m.updateQueue, v.flags &= -2053, m.lanes &= ~L, Ca(m, v, L)) : (Vi && T && Am(v), v.flags |= 1, ha(m, v, k, L), v.child);
  }
  function wl(m, v, T, k, L) {
    if (m === null) {
      var B = T.type;
      return typeof B == "function" && !A_(B) && B.defaultProps === void 0 && T.compare === null && T.defaultProps === void 0 ? (v.tag = 15, v.type = B, Ns(m, v, B, k, L)) : (m = M1(T.type, null, k, v, v.mode, L), m.ref = v.ref, m.return = v, v.child = m);
    }
    if (B = m.child, !(m.lanes & L)) {
      var oe = B.memoizedProps;
      if (T = T.compare, T = T !== null ? T : It, T(oe, k) && m.ref === v.ref)
        return Ca(m, v, L);
    }
    return v.flags |= 1, m = Ph(B, k), m.ref = v.ref, m.return = v, v.child = m;
  }
  function Ns(m, v, T, k, L) {
    if (m !== null) {
      var B = m.memoizedProps;
      if (It(B, k) && m.ref === v.ref)
        if (Ro = !1, v.pendingProps = k = B, (m.lanes & L) !== 0)
          m.flags & 131072 && (Ro = !0);
        else
          return v.lanes = m.lanes, Ca(m, v, L);
    }
    return Xp(m, v, T, k, L);
  }
  function Ch(m, v, T) {
    var k = v.pendingProps, L = k.children, B = m !== null ? m.memoizedState : null;
    if (k.mode === "hidden")
      if (!(v.mode & 1))
        v.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ai(qm, Iu), Iu |= T;
      else {
        if (!(T & 1073741824))
          return m = B !== null ? B.baseLanes | T : T, v.lanes = v.childLanes = 1073741824, v.memoizedState = { baseLanes: m, cachePool: null, transitions: null }, v.updateQueue = null, ai(qm, Iu), Iu |= m, null;
        v.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, k = B !== null ? B.baseLanes : T, ai(qm, Iu), Iu |= k;
      }
    else
      B !== null ? (k = B.baseLanes | T, v.memoizedState = null) : k = T, ai(qm, Iu), Iu |= k;
    return ha(m, v, L, T), v.child;
  }
  function Gn(m, v) {
    var T = v.ref;
    (m === null && T !== null || m !== null && m.ref !== T) && (v.flags |= 512, v.flags |= 2097152);
  }
  function Xp(m, v, T, k, L) {
    var B = ao(T) ? Oo : An.current;
    return B = gl(v, B), Ct(v, L), T = nd(m, v, T, k, B, L), k = _h(), m !== null && !Ro ? (v.updateQueue = m.updateQueue, v.flags &= -2053, m.lanes &= ~L, Ca(m, v, L)) : (Vi && k && Am(v), v.flags |= 1, ha(m, v, T, L), v.child);
  }
  function h_(m, v, T, k, L) {
    if (ao(T)) {
      var B = !0;
      yl(v);
    } else
      B = !1;
    if (Ct(v, L), v.stateNode === null)
      Ta(m, v), l_(v, T, k), r1(v, T, k, L), k = !0;
    else if (m === null) {
      var oe = v.stateNode, me = v.memoizedProps;
      oe.props = me;
      var Ee = oe.context, He = T.contextType;
      typeof He == "object" && He !== null ? He = uo(He) : (He = ao(T) ? Oo : An.current, He = gl(v, He));
      var ft = T.getDerivedStateFromProps, mt = typeof ft == "function" || typeof oe.getSnapshotBeforeUpdate == "function";
      mt || typeof oe.UNSAFE_componentWillReceiveProps != "function" && typeof oe.componentWillReceiveProps != "function" || (me !== k || Ee !== He) && A2(v, oe, k, He), ph = !1;
      var dt = v.memoizedState;
      oe.state = dt, yh(v, k, oe, L), Ee = v.memoizedState, me !== k || dt !== Ee || Ao.current || ph ? (typeof ft == "function" && (u_(v, T, ft, k), Ee = v.memoizedState), (me = ph || n1(v, T, me, k, dt, Ee, He)) ? (mt || typeof oe.UNSAFE_componentWillMount != "function" && typeof oe.componentWillMount != "function" || (typeof oe.componentWillMount == "function" && oe.componentWillMount(), typeof oe.UNSAFE_componentWillMount == "function" && oe.UNSAFE_componentWillMount()), typeof oe.componentDidMount == "function" && (v.flags |= 4194308)) : (typeof oe.componentDidMount == "function" && (v.flags |= 4194308), v.memoizedProps = k, v.memoizedState = Ee), oe.props = k, oe.state = Ee, oe.context = He, k = me) : (typeof oe.componentDidMount == "function" && (v.flags |= 4194308), k = !1);
    } else {
      oe = v.stateNode, fa(m, v), me = v.memoizedProps, He = v.type === v.elementType ? me : Au(v.type, me), oe.props = He, mt = v.pendingProps, dt = oe.context, Ee = T.contextType, typeof Ee == "object" && Ee !== null ? Ee = uo(Ee) : (Ee = ao(T) ? Oo : An.current, Ee = gl(v, Ee));
      var jt = T.getDerivedStateFromProps;
      (ft = typeof jt == "function" || typeof oe.getSnapshotBeforeUpdate == "function") || typeof oe.UNSAFE_componentWillReceiveProps != "function" && typeof oe.componentWillReceiveProps != "function" || (me !== mt || dt !== Ee) && A2(v, oe, k, Ee), ph = !1, dt = v.memoizedState, oe.state = dt, yh(v, k, oe, L);
      var qt = v.memoizedState;
      me !== mt || dt !== qt || Ao.current || ph ? (typeof jt == "function" && (u_(v, T, jt, k), qt = v.memoizedState), (He = ph || n1(v, T, He, k, dt, qt, Ee) || !1) ? (ft || typeof oe.UNSAFE_componentWillUpdate != "function" && typeof oe.componentWillUpdate != "function" || (typeof oe.componentWillUpdate == "function" && oe.componentWillUpdate(k, qt, Ee), typeof oe.UNSAFE_componentWillUpdate == "function" && oe.UNSAFE_componentWillUpdate(k, qt, Ee)), typeof oe.componentDidUpdate == "function" && (v.flags |= 4), typeof oe.getSnapshotBeforeUpdate == "function" && (v.flags |= 1024)) : (typeof oe.componentDidUpdate != "function" || me === m.memoizedProps && dt === m.memoizedState || (v.flags |= 4), typeof oe.getSnapshotBeforeUpdate != "function" || me === m.memoizedProps && dt === m.memoizedState || (v.flags |= 1024), v.memoizedProps = k, v.memoizedState = qt), oe.props = k, oe.state = qt, oe.context = Ee, k = He) : (typeof oe.componentDidUpdate != "function" || me === m.memoizedProps && dt === m.memoizedState || (v.flags |= 4), typeof oe.getSnapshotBeforeUpdate != "function" || me === m.memoizedProps && dt === m.memoizedState || (v.flags |= 1024), k = !1);
    }
    return $2(m, v, T, k, B, L);
  }
  function $2(m, v, T, k, L, B) {
    Gn(m, v);
    var oe = (v.flags & 128) !== 0;
    if (!k && !oe)
      return L && N2(v, T, !1), Ca(m, v, B);
    k = v.stateNode, k2.current = v;
    var me = oe && typeof T.getDerivedStateFromError != "function" ? null : k.render();
    return v.flags |= 1, m !== null && oe ? (v.child = vh(v, m.child, null, B), v.child = vh(v, null, me, B)) : ha(m, v, me, B), v.memoizedState = k.state, L && N2(v, T, !0), v.child;
  }
  function Jc(m) {
    var v = m.stateNode;
    v.pendingContext ? dh(m, v.pendingContext, v.pendingContext !== v.context) : v.context && dh(m, v.context, !1), o1(m, v.containerInfo);
  }
  function Bm(m, v, T, k, L) {
    return Pi(), Kc(L), v.flags |= 256, ha(m, v, T, k), v.child;
  }
  var ld = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Xv(m) {
    return { baseLanes: m, cachePool: null, transitions: null };
  }
  function Um(m, v, T) {
    var k = v.pendingProps, L = pn.current, B = !1, oe = (v.flags & 128) !== 0, me;
    if ((me = oe) || (me = m !== null && m.memoizedState === null ? !1 : (L & 2) !== 0), me ? (B = !0, v.flags &= -129) : (m === null || m.memoizedState !== null) && (L |= 1), ai(pn, L & 1), m === null)
      return Cs(v), m = v.memoizedState, m !== null && (m = m.dehydrated, m !== null) ? (v.mode & 1 ? m.data === "$!" ? v.lanes = 8 : v.lanes = 1073741824 : v.lanes = 1, null) : (oe = k.children, m = k.fallback, B ? (k = v.mode, B = v.child, oe = { mode: "hidden", children: oe }, !(k & 1) && B !== null ? (B.childLanes = 0, B.pendingProps = oe) : B = r0(oe, k, 0, null), m = ig(m, k, T, null), B.return = v, m.return = v, B.sibling = m, v.child = B, v.child.memoizedState = Xv(T), v.memoizedState = ld, m) : Nh(v, oe));
    if (L = m.memoizedState, L !== null && (me = L.dehydrated, me !== null))
      return h1(m, v, oe, k, me, L, T);
    if (B) {
      B = k.fallback, oe = v.mode, L = m.child, me = L.sibling;
      var Ee = { mode: "hidden", children: k.children };
      return !(oe & 1) && v.child !== L ? (k = v.child, k.childLanes = 0, k.pendingProps = Ee, v.deletions = null) : (k = Ph(L, Ee), k.subtreeFlags = L.subtreeFlags & 14680064), me !== null ? B = Ph(me, B) : (B = ig(B, oe, T, null), B.flags |= 2), B.return = v, k.return = v, k.sibling = B, v.child = k, k = B, B = v.child, oe = m.child.memoizedState, oe = oe === null ? Xv(T) : { baseLanes: oe.baseLanes | T, cachePool: null, transitions: oe.transitions }, B.memoizedState = oe, B.childLanes = m.childLanes & ~T, v.memoizedState = ld, k;
    }
    return B = m.child, m = B.sibling, k = Ph(B, { mode: "visible", children: k.children }), !(v.mode & 1) && (k.lanes = T), k.return = v, k.sibling = null, m !== null && (T = v.deletions, T === null ? (v.deletions = [m], v.flags |= 16) : T.push(m)), v.child = k, v.memoizedState = null, k;
  }
  function Nh(m, v) {
    return v = r0({ mode: "visible", children: v }, m.mode, 0, null), v.return = m, m.child = v;
  }
  function un(m, v, T, k) {
    return k !== null && Kc(k), vh(v, m.child, null, T), m = Nh(v, v.pendingProps.children), m.flags |= 2, v.memoizedState = null, m;
  }
  function h1(m, v, T, k, L, B, oe) {
    if (T)
      return v.flags & 256 ? (v.flags &= -257, k = Mh(Error(n(422))), un(m, v, oe, k)) : v.memoizedState !== null ? (v.child = m.child, v.flags |= 128, null) : (B = k.fallback, L = v.mode, k = r0({ mode: "visible", children: k.children }, L, 0, null), B = ig(B, L, oe, null), B.flags |= 2, k.return = v, B.return = v, k.sibling = B, v.child = k, v.mode & 1 && vh(v, m.child, null, oe), v.child.memoizedState = Xv(oe), v.memoizedState = ld, B);
    if (!(v.mode & 1))
      return un(m, v, oe, null);
    if (L.data === "$!") {
      if (k = L.nextSibling && L.nextSibling.dataset, k)
        var me = k.dgst;
      return k = me, B = Error(n(419)), k = Mh(B, k, void 0), un(m, v, oe, k);
    }
    if (me = (oe & m.childLanes) !== 0, Ro || me) {
      if (k = xo, k !== null) {
        switch (oe & -oe) {
          case 4:
            L = 2;
            break;
          case 16:
            L = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            L = 32;
            break;
          case 536870912:
            L = 268435456;
            break;
          default:
            L = 0;
        }
        L = L & (k.suspendedLanes | oe) ? 0 : L, L !== 0 && L !== B.retryLane && (B.retryLane = L, oc(m, L), gs(k, m, L, -1));
      }
      return T_(), k = Mh(Error(n(421))), un(m, v, oe, k);
    }
    return L.data === "$?" ? (v.flags |= 128, v.child = m.child, v = oD.bind(null, m), L._reactRetry = v, null) : (m = B.treeContext, ou = rc(L.nextSibling), cs = v, Vi = !0, bl = null, m !== null && (iu[ls++] = Ma, iu[ls++] = Qc, iu[ls++] = vl, Ma = m.id, Qc = m.overflow, vl = v), v = Nh(v, k.children), v.flags |= 4096, v);
  }
  function Kv(m, v, T) {
    m.lanes |= v;
    var k = m.alternate;
    k !== null && (k.lanes |= v), Ii(m.return, v, T);
  }
  function ef(m, v, T, k, L) {
    var B = m.memoizedState;
    B === null ? m.memoizedState = { isBackwards: v, rendering: null, renderingStartTime: 0, last: k, tail: T, tailMode: L } : (B.isBackwards = v, B.rendering = null, B.renderingStartTime = 0, B.last = k, B.tail = T, B.tailMode = L);
  }
  function p_(m, v, T) {
    var k = v.pendingProps, L = k.revealOrder, B = k.tail;
    if (ha(m, v, k.children, T), k = pn.current, k & 2)
      k = k & 1 | 2, v.flags |= 128;
    else {
      if (m !== null && m.flags & 128)
        e:
          for (m = v.child; m !== null; ) {
            if (m.tag === 13)
              m.memoizedState !== null && Kv(m, T, v);
            else if (m.tag === 19)
              Kv(m, T, v);
            else if (m.child !== null) {
              m.child.return = m, m = m.child;
              continue;
            }
            if (m === v)
              break e;
            for (; m.sibling === null; ) {
              if (m.return === null || m.return === v)
                break e;
              m = m.return;
            }
            m.sibling.return = m.return, m = m.sibling;
          }
      k &= 1;
    }
    if (ai(pn, k), !(v.mode & 1))
      v.memoizedState = null;
    else
      switch (L) {
        case "forwards":
          for (T = v.child, L = null; T !== null; )
            m = T.alternate, m !== null && lo(m) === null && (L = T), T = T.sibling;
          T = L, T === null ? (L = v.child, v.child = null) : (L = T.sibling, T.sibling = null), ef(v, !1, L, T, B);
          break;
        case "backwards":
          for (T = null, L = v.child, v.child = null; L !== null; ) {
            if (m = L.alternate, m !== null && lo(m) === null) {
              v.child = L;
              break;
            }
            m = L.sibling, L.sibling = T, T = L, L = m;
          }
          ef(v, !0, T, null, B);
          break;
        case "together":
          ef(v, !1, null, null, void 0);
          break;
        default:
          v.memoizedState = null;
      }
    return v.child;
  }
  function Ta(m, v) {
    !(v.mode & 1) && m !== null && (m.alternate = null, v.alternate = null, v.flags |= 2);
  }
  function Ca(m, v, T) {
    if (m !== null && (v.dependencies = m.dependencies), nf |= v.lanes, !(T & v.childLanes))
      return null;
    if (m !== null && v.child !== m.child)
      throw Error(n(153));
    if (v.child !== null) {
      for (m = v.child, T = Ph(m, m.pendingProps), v.child = T, T.return = v; m.sibling !== null; )
        m = m.sibling, T = T.sibling = Ph(m, m.pendingProps), T.return = v;
      T.sibling = null;
    }
    return v.child;
  }
  function ho(m, v, T) {
    switch (v.tag) {
      case 3:
        Jc(v), Pi();
        break;
      case 5:
        hn(v);
        break;
      case 1:
        ao(v.type) && yl(v);
        break;
      case 4:
        o1(v, v.stateNode.containerInfo);
        break;
      case 10:
        var k = v.type._context, L = v.memoizedProps.value;
        ai(Ou, k._currentValue), k._currentValue = L;
        break;
      case 13:
        if (k = v.memoizedState, k !== null)
          return k.dehydrated !== null ? (ai(pn, pn.current & 1), v.flags |= 128, null) : T & v.child.childLanes ? Um(m, v, T) : (ai(pn, pn.current & 1), m = Ca(m, v, T), m !== null ? m.sibling : null);
        ai(pn, pn.current & 1);
        break;
      case 19:
        if (k = (T & v.childLanes) !== 0, m.flags & 128) {
          if (k)
            return p_(m, v, T);
          v.flags |= 128;
        }
        if (L = v.memoizedState, L !== null && (L.rendering = null, L.tail = null, L.lastEffect = null), ai(pn, pn.current), k)
          break;
        return null;
      case 22:
      case 23:
        return v.lanes = 0, Ch(m, v, T);
    }
    return Ca(m, v, T);
  }
  var Zv, Kp, Ru, pa;
  Zv = function(m, v) {
    for (var T = v.child; T !== null; ) {
      if (T.tag === 5 || T.tag === 6)
        m.appendChild(T.stateNode);
      else if (T.tag !== 4 && T.child !== null) {
        T.child.return = T, T = T.child;
        continue;
      }
      if (T === v)
        break;
      for (; T.sibling === null; ) {
        if (T.return === null || T.return === v)
          return;
        T = T.return;
      }
      T.sibling.return = T.return, T = T.sibling;
    }
  }, Kp = function() {
  }, Ru = function(m, v, T, k) {
    var L = m.memoizedProps;
    if (L !== k) {
      m = v.stateNode, xh(xl.current);
      var B = null;
      switch (T) {
        case "input":
          L = $e(m, L), k = $e(m, k), B = [];
          break;
        case "select":
          L = H({}, L, { value: void 0 }), k = H({}, k, { value: void 0 }), B = [];
          break;
        case "textarea":
          L = qn(m, L), k = qn(m, k), B = [];
          break;
        default:
          typeof L.onClick != "function" && typeof k.onClick == "function" && (m.onclick = Qb);
      }
      di(T, k);
      var oe;
      T = null;
      for (He in L)
        if (!k.hasOwnProperty(He) && L.hasOwnProperty(He) && L[He] != null)
          if (He === "style") {
            var me = L[He];
            for (oe in me)
              me.hasOwnProperty(oe) && (T || (T = {}), T[oe] = "");
          } else
            He !== "dangerouslySetInnerHTML" && He !== "children" && He !== "suppressContentEditableWarning" && He !== "suppressHydrationWarning" && He !== "autoFocus" && (i.hasOwnProperty(He) ? B || (B = []) : (B = B || []).push(He, null));
      for (He in k) {
        var Ee = k[He];
        if (me = L != null ? L[He] : void 0, k.hasOwnProperty(He) && Ee !== me && (Ee != null || me != null))
          if (He === "style")
            if (me) {
              for (oe in me)
                !me.hasOwnProperty(oe) || Ee && Ee.hasOwnProperty(oe) || (T || (T = {}), T[oe] = "");
              for (oe in Ee)
                Ee.hasOwnProperty(oe) && me[oe] !== Ee[oe] && (T || (T = {}), T[oe] = Ee[oe]);
            } else
              T || (B || (B = []), B.push(
                He,
                T
              )), T = Ee;
          else
            He === "dangerouslySetInnerHTML" ? (Ee = Ee ? Ee.__html : void 0, me = me ? me.__html : void 0, Ee != null && me !== Ee && (B = B || []).push(He, Ee)) : He === "children" ? typeof Ee != "string" && typeof Ee != "number" || (B = B || []).push(He, "" + Ee) : He !== "suppressContentEditableWarning" && He !== "suppressHydrationWarning" && (i.hasOwnProperty(He) ? (Ee != null && He === "onScroll" && $i("scroll", m), B || me === Ee || (B = [])) : (B = B || []).push(He, Ee));
      }
      T && (B = B || []).push("style", T);
      var He = B;
      (v.updateQueue = He) && (v.flags |= 4);
    }
  }, pa = function(m, v, T, k) {
    T !== k && (v.flags |= 4);
  };
  function Ym(m, v) {
    if (!Vi)
      switch (m.tailMode) {
        case "hidden":
          v = m.tail;
          for (var T = null; v !== null; )
            v.alternate !== null && (T = v), v = v.sibling;
          T === null ? m.tail = null : T.sibling = null;
          break;
        case "collapsed":
          T = m.tail;
          for (var k = null; T !== null; )
            T.alternate !== null && (k = T), T = T.sibling;
          k === null ? v || m.tail === null ? m.tail = null : m.tail.sibling = null : k.sibling = null;
      }
  }
  function ds(m) {
    var v = m.alternate !== null && m.alternate.child === m.child, T = 0, k = 0;
    if (v)
      for (var L = m.child; L !== null; )
        T |= L.lanes | L.childLanes, k |= L.subtreeFlags & 14680064, k |= L.flags & 14680064, L.return = m, L = L.sibling;
    else
      for (L = m.child; L !== null; )
        T |= L.lanes | L.childLanes, k |= L.subtreeFlags, k |= L.flags, L.return = m, L = L.sibling;
    return m.subtreeFlags |= k, m.childLanes = T, v;
  }
  function eD(m, v, T) {
    var k = v.pendingProps;
    switch (Yp(v), v.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ds(v), null;
      case 1:
        return ao(v.type) && ml(), ds(v), null;
      case 3:
        return k = v.stateNode, wh(), Jr(Ao), Jr(An), a1(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (m === null || m.child === null) && (Pv(v) ? v.flags |= 4 : m === null || m.memoizedState.isDehydrated && !(v.flags & 256) || (v.flags |= 1024, bl !== null && (n0(bl), bl = null))), Kp(m, v), ds(v), null;
      case 5:
        fr(v);
        var L = xh($m.current);
        if (T = v.type, m !== null && v.stateNode != null)
          Ru(m, v, T, k, L), m.ref !== v.ref && (v.flags |= 512, v.flags |= 2097152);
        else {
          if (!k) {
            if (v.stateNode === null)
              throw Error(n(166));
            return ds(v), null;
          }
          if (m = xh(xl.current), Pv(v)) {
            k = v.stateNode, T = v.type;
            var B = v.memoizedProps;
            switch (k[Wc] = v, k[qc] = B, m = (v.mode & 1) !== 0, T) {
              case "dialog":
                $i("cancel", k), $i("close", k);
                break;
              case "iframe":
              case "object":
              case "embed":
                $i("load", k);
                break;
              case "video":
              case "audio":
                for (L = 0; L < Xf.length; L++)
                  $i(Xf[L], k);
                break;
              case "source":
                $i("error", k);
                break;
              case "img":
              case "image":
              case "link":
                $i(
                  "error",
                  k
                ), $i("load", k);
                break;
              case "details":
                $i("toggle", k);
                break;
              case "input":
                pt(k, B), $i("invalid", k);
                break;
              case "select":
                k._wrapperState = { wasMultiple: !!B.multiple }, $i("invalid", k);
                break;
              case "textarea":
                fn(k, B), $i("invalid", k);
            }
            di(T, B), L = null;
            for (var oe in B)
              if (B.hasOwnProperty(oe)) {
                var me = B[oe];
                oe === "children" ? typeof me == "string" ? k.textContent !== me && (B.suppressHydrationWarning !== !0 && Av(k.textContent, me, m), L = ["children", me]) : typeof me == "number" && k.textContent !== "" + me && (B.suppressHydrationWarning !== !0 && Av(
                  k.textContent,
                  me,
                  m
                ), L = ["children", "" + me]) : i.hasOwnProperty(oe) && me != null && oe === "onScroll" && $i("scroll", k);
              }
            switch (T) {
              case "input":
                ze(k), mn(k, B, !0);
                break;
              case "textarea":
                ze(k), Zn(k);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof B.onClick == "function" && (k.onclick = Qb);
            }
            k = L, v.updateQueue = k, k !== null && (v.flags |= 4);
          } else {
            oe = L.nodeType === 9 ? L : L.ownerDocument, m === "http://www.w3.org/1999/xhtml" && (m = xr(T)), m === "http://www.w3.org/1999/xhtml" ? T === "script" ? (m = oe.createElement("div"), m.innerHTML = "<script><\/script>", m = m.removeChild(m.firstChild)) : typeof k.is == "string" ? m = oe.createElement(T, { is: k.is }) : (m = oe.createElement(T), T === "select" && (oe = m, k.multiple ? oe.multiple = !0 : k.size && (oe.size = k.size))) : m = oe.createElementNS(m, T), m[Wc] = v, m[qc] = k, Zv(m, v, !1, !1), v.stateNode = m;
            e: {
              switch (oe = bi(T, k), T) {
                case "dialog":
                  $i("cancel", m), $i("close", m), L = k;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  $i("load", m), L = k;
                  break;
                case "video":
                case "audio":
                  for (L = 0; L < Xf.length; L++)
                    $i(Xf[L], m);
                  L = k;
                  break;
                case "source":
                  $i("error", m), L = k;
                  break;
                case "img":
                case "image":
                case "link":
                  $i(
                    "error",
                    m
                  ), $i("load", m), L = k;
                  break;
                case "details":
                  $i("toggle", m), L = k;
                  break;
                case "input":
                  pt(m, k), L = $e(m, k), $i("invalid", m);
                  break;
                case "option":
                  L = k;
                  break;
                case "select":
                  m._wrapperState = { wasMultiple: !!k.multiple }, L = H({}, k, { value: void 0 }), $i("invalid", m);
                  break;
                case "textarea":
                  fn(m, k), L = qn(m, k), $i("invalid", m);
                  break;
                default:
                  L = k;
              }
              di(T, L), me = L;
              for (B in me)
                if (me.hasOwnProperty(B)) {
                  var Ee = me[B];
                  B === "style" ? _n(m, Ee) : B === "dangerouslySetInnerHTML" ? (Ee = Ee ? Ee.__html : void 0, Ee != null && Ut(m, Ee)) : B === "children" ? typeof Ee == "string" ? (T !== "textarea" || Ee !== "") && er(m, Ee) : typeof Ee == "number" && er(m, "" + Ee) : B !== "suppressContentEditableWarning" && B !== "suppressHydrationWarning" && B !== "autoFocus" && (i.hasOwnProperty(B) ? Ee != null && B === "onScroll" && $i("scroll", m) : Ee != null && A(m, B, Ee, oe));
                }
              switch (T) {
                case "input":
                  ze(m), mn(m, k, !1);
                  break;
                case "textarea":
                  ze(m), Zn(m);
                  break;
                case "option":
                  k.value != null && m.setAttribute("value", "" + Me(k.value));
                  break;
                case "select":
                  m.multiple = !!k.multiple, B = k.value, B != null ? Zt(m, !!k.multiple, B, !1) : k.defaultValue != null && Zt(
                    m,
                    !!k.multiple,
                    k.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof L.onClick == "function" && (m.onclick = Qb);
              }
              switch (T) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k = !!k.autoFocus;
                  break e;
                case "img":
                  k = !0;
                  break e;
                default:
                  k = !1;
              }
            }
            k && (v.flags |= 4);
          }
          v.ref !== null && (v.flags |= 512, v.flags |= 2097152);
        }
        return ds(v), null;
      case 6:
        if (m && v.stateNode != null)
          pa(m, v, m.memoizedProps, k);
        else {
          if (typeof k != "string" && v.stateNode === null)
            throw Error(n(166));
          if (T = xh($m.current), xh(xl.current), Pv(v)) {
            if (k = v.stateNode, T = v.memoizedProps, k[Wc] = v, (B = k.nodeValue !== T) && (m = cs, m !== null))
              switch (m.tag) {
                case 3:
                  Av(k.nodeValue, T, (m.mode & 1) !== 0);
                  break;
                case 5:
                  m.memoizedProps.suppressHydrationWarning !== !0 && Av(k.nodeValue, T, (m.mode & 1) !== 0);
              }
            B && (v.flags |= 4);
          } else
            k = (T.nodeType === 9 ? T : T.ownerDocument).createTextNode(k), k[Wc] = v, v.stateNode = k;
        }
        return ds(v), null;
      case 13:
        if (Jr(pn), k = v.memoizedState, m === null || m.memoizedState !== null && m.memoizedState.dehydrated !== null) {
          if (Vi && ou !== null && v.mode & 1 && !(v.flags & 128))
            a_(), Pi(), v.flags |= 98560, B = !1;
          else if (B = Pv(v), k !== null && k.dehydrated !== null) {
            if (m === null) {
              if (!B)
                throw Error(n(318));
              if (B = v.memoizedState, B = B !== null ? B.dehydrated : null, !B)
                throw Error(n(317));
              B[Wc] = v;
            } else
              Pi(), !(v.flags & 128) && (v.memoizedState = null), v.flags |= 4;
            ds(v), B = !1;
          } else
            bl !== null && (n0(bl), bl = null), B = !0;
          if (!B)
            return v.flags & 65536 ? v : null;
        }
        return v.flags & 128 ? (v.lanes = T, v) : (k = k !== null, k !== (m !== null && m.memoizedState !== null) && k && (v.child.flags |= 8192, v.mode & 1 && (m === null || pn.current & 1 ? ga === 0 && (ga = 3) : T_())), v.updateQueue !== null && (v.flags |= 4), ds(v), null);
      case 4:
        return wh(), Kp(m, v), m === null && Kf(v.stateNode.containerInfo), ds(v), null;
      case 10:
        return ed(v.type._context), ds(v), null;
      case 17:
        return ao(v.type) && ml(), ds(v), null;
      case 19:
        if (Jr(pn), B = v.memoizedState, B === null)
          return ds(v), null;
        if (k = (v.flags & 128) !== 0, oe = B.rendering, oe === null)
          if (k)
            Ym(B, !1);
          else {
            if (ga !== 0 || m !== null && m.flags & 128)
              for (m = v.child; m !== null; ) {
                if (oe = lo(m), oe !== null) {
                  for (v.flags |= 128, Ym(B, !1), k = oe.updateQueue, k !== null && (v.updateQueue = k, v.flags |= 4), v.subtreeFlags = 0, k = T, T = v.child; T !== null; )
                    B = T, m = k, B.flags &= 14680066, oe = B.alternate, oe === null ? (B.childLanes = 0, B.lanes = m, B.child = null, B.subtreeFlags = 0, B.memoizedProps = null, B.memoizedState = null, B.updateQueue = null, B.dependencies = null, B.stateNode = null) : (B.childLanes = oe.childLanes, B.lanes = oe.lanes, B.child = oe.child, B.subtreeFlags = 0, B.deletions = null, B.memoizedProps = oe.memoizedProps, B.memoizedState = oe.memoizedState, B.updateQueue = oe.updateQueue, B.type = oe.type, m = oe.dependencies, B.dependencies = m === null ? null : { lanes: m.lanes, firstContext: m.firstContext }), T = T.sibling;
                  return ai(pn, pn.current & 1 | 2), v.child;
                }
                m = m.sibling;
              }
            B.tail !== null && mr() > Xm && (v.flags |= 128, k = !0, Ym(B, !1), v.lanes = 4194304);
          }
        else {
          if (!k)
            if (m = lo(oe), m !== null) {
              if (v.flags |= 128, k = !0, T = m.updateQueue, T !== null && (v.updateQueue = T, v.flags |= 4), Ym(B, !0), B.tail === null && B.tailMode === "hidden" && !oe.alternate && !Vi)
                return ds(v), null;
            } else
              2 * mr() - B.renderingStartTime > Xm && T !== 1073741824 && (v.flags |= 128, k = !0, Ym(B, !1), v.lanes = 4194304);
          B.isBackwards ? (oe.sibling = v.child, v.child = oe) : (T = B.last, T !== null ? T.sibling = oe : v.child = oe, B.last = oe);
        }
        return B.tail !== null ? (v = B.tail, B.rendering = v, B.tail = v.sibling, B.renderingStartTime = mr(), v.sibling = null, T = pn.current, ai(pn, k ? T & 1 | 2 : T & 1), v) : (ds(v), null);
      case 22:
      case 23:
        return M_(), k = v.memoizedState !== null, m !== null && m.memoizedState !== null !== k && (v.flags |= 8192), k && v.mode & 1 ? Iu & 1073741824 && (ds(v), v.subtreeFlags & 6 && (v.flags |= 8192)) : ds(v), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, v.tag));
  }
  function g_(m, v) {
    switch (Yp(v), v.tag) {
      case 1:
        return ao(v.type) && ml(), m = v.flags, m & 65536 ? (v.flags = m & -65537 | 128, v) : null;
      case 3:
        return wh(), Jr(Ao), Jr(An), a1(), m = v.flags, m & 65536 && !(m & 128) ? (v.flags = m & -65537 | 128, v) : null;
      case 5:
        return fr(v), null;
      case 13:
        if (Jr(pn), m = v.memoizedState, m !== null && m.dehydrated !== null) {
          if (v.alternate === null)
            throw Error(n(340));
          Pi();
        }
        return m = v.flags, m & 65536 ? (v.flags = m & -65537 | 128, v) : null;
      case 19:
        return Jr(pn), null;
      case 4:
        return wh(), null;
      case 10:
        return ed(v.type._context), null;
      case 22:
      case 23:
        return M_(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ku = !1, Fr = !1, p1 = typeof WeakSet == "function" ? WeakSet : Set, Vt = null;
  function Dh(m, v) {
    var T = m.ref;
    if (T !== null)
      if (typeof T == "function")
        try {
          T(null);
        } catch (k) {
          $o(m, v, k);
        }
      else
        T.current = null;
  }
  function Jv(m, v, T) {
    try {
      T();
    } catch (k) {
      $o(m, v, k);
    }
  }
  var P2 = !1;
  function Hm(m, v) {
    if (Ov = ll, m = oi(), tc(m)) {
      if ("selectionStart" in m)
        var T = { start: m.selectionStart, end: m.selectionEnd };
      else
        e: {
          T = (T = m.ownerDocument) && T.defaultView || window;
          var k = T.getSelection && T.getSelection();
          if (k && k.rangeCount !== 0) {
            T = k.anchorNode;
            var L = k.anchorOffset, B = k.focusNode;
            k = k.focusOffset;
            try {
              T.nodeType, B.nodeType;
            } catch {
              T = null;
              break e;
            }
            var oe = 0, me = -1, Ee = -1, He = 0, ft = 0, mt = m, dt = null;
            t:
              for (; ; ) {
                for (var jt; mt !== T || L !== 0 && mt.nodeType !== 3 || (me = oe + L), mt !== B || k !== 0 && mt.nodeType !== 3 || (Ee = oe + k), mt.nodeType === 3 && (oe += mt.nodeValue.length), (jt = mt.firstChild) !== null; )
                  dt = mt, mt = jt;
                for (; ; ) {
                  if (mt === m)
                    break t;
                  if (dt === T && ++He === L && (me = oe), dt === B && ++ft === k && (Ee = oe), (jt = mt.nextSibling) !== null)
                    break;
                  mt = dt, dt = mt.parentNode;
                }
                mt = jt;
              }
            T = me === -1 || Ee === -1 ? null : { start: me, end: Ee };
          } else
            T = null;
        }
      T = T || { start: 0, end: 0 };
    } else
      T = null;
    for (nc = { focusedElem: m, selectionRange: T }, ll = !1, Vt = v; Vt !== null; )
      if (v = Vt, m = v.child, (v.subtreeFlags & 1028) !== 0 && m !== null)
        m.return = v, Vt = m;
      else
        for (; Vt !== null; ) {
          v = Vt;
          try {
            var qt = v.alternate;
            if (v.flags & 1024)
              switch (v.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (qt !== null) {
                    var Xt = qt.memoizedProps, Bo = qt.memoizedState, Pe = v.stateNode, Te = Pe.getSnapshotBeforeUpdate(v.elementType === v.type ? Xt : Au(v.type, Xt), Bo);
                    Pe.__reactInternalSnapshotBeforeUpdate = Te;
                  }
                  break;
                case 3:
                  var Ie = v.stateNode.containerInfo;
                  Ie.nodeType === 1 ? Ie.textContent = "" : Ie.nodeType === 9 && Ie.documentElement && Ie.removeChild(Ie.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (wt) {
            $o(v, v.return, wt);
          }
          if (m = v.sibling, m !== null) {
            m.return = v.return, Vt = m;
            break;
          }
          Vt = v.return;
        }
    return qt = P2, P2 = !1, qt;
  }
  function Vm(m, v, T) {
    var k = v.updateQueue;
    if (k = k !== null ? k.lastEffect : null, k !== null) {
      var L = k = k.next;
      do {
        if ((L.tag & m) === m) {
          var B = L.destroy;
          L.destroy = void 0, B !== void 0 && Jv(v, T, B);
        }
        L = L.next;
      } while (L !== k);
    }
  }
  function Wm(m, v) {
    if (v = v.updateQueue, v = v !== null ? v.lastEffect : null, v !== null) {
      var T = v = v.next;
      do {
        if ((T.tag & m) === m) {
          var k = T.create;
          T.destroy = k();
        }
        T = T.next;
      } while (T !== v);
    }
  }
  function m_(m) {
    var v = m.ref;
    if (v !== null) {
      var T = m.stateNode;
      switch (m.tag) {
        case 5:
          m = T;
          break;
        default:
          m = T;
      }
      typeof v == "function" ? v(m) : v.current = m;
    }
  }
  function y_(m) {
    var v = m.alternate;
    v !== null && (m.alternate = null, y_(v)), m.child = null, m.deletions = null, m.sibling = null, m.tag === 5 && (v = m.stateNode, v !== null && (delete v[Wc], delete v[qc], delete v[Xb], delete v[ue], delete v[ch])), m.stateNode = null, m.return = null, m.dependencies = null, m.memoizedProps = null, m.memoizedState = null, m.pendingProps = null, m.stateNode = null, m.updateQueue = null;
  }
  function I2(m) {
    return m.tag === 5 || m.tag === 3 || m.tag === 4;
  }
  function g1(m) {
    e:
      for (; ; ) {
        for (; m.sibling === null; ) {
          if (m.return === null || I2(m.return))
            return null;
          m = m.return;
        }
        for (m.sibling.return = m.return, m = m.sibling; m.tag !== 5 && m.tag !== 6 && m.tag !== 18; ) {
          if (m.flags & 2 || m.child === null || m.tag === 4)
            continue e;
          m.child.return = m, m = m.child;
        }
        if (!(m.flags & 2))
          return m.stateNode;
      }
  }
  function Zp(m, v, T) {
    var k = m.tag;
    if (k === 5 || k === 6)
      m = m.stateNode, v ? T.nodeType === 8 ? T.parentNode.insertBefore(m, v) : T.insertBefore(m, v) : (T.nodeType === 8 ? (v = T.parentNode, v.insertBefore(m, T)) : (v = T, v.appendChild(m)), T = T._reactRootContainer, T != null || v.onclick !== null || (v.onclick = Qb));
    else if (k !== 4 && (m = m.child, m !== null))
      for (Zp(m, v, T), m = m.sibling; m !== null; )
        Zp(m, v, T), m = m.sibling;
  }
  function lc(m, v, T) {
    var k = m.tag;
    if (k === 5 || k === 6)
      m = m.stateNode, v ? T.insertBefore(m, v) : T.appendChild(m);
    else if (k !== 4 && (m = m.child, m !== null))
      for (lc(m, v, T), m = m.sibling; m !== null; )
        lc(m, v, T), m = m.sibling;
  }
  var po = null, Jo = !1;
  function $u(m, v, T) {
    for (T = T.child; T !== null; )
      tf(m, v, T), T = T.sibling;
  }
  function tf(m, v, T) {
    if (Zs && typeof Zs.onCommitFiberUnmount == "function")
      try {
        Zs.onCommitFiberUnmount(qd, T);
      } catch {
      }
    switch (T.tag) {
      case 5:
        Fr || Dh(T, v);
      case 6:
        var k = po, L = Jo;
        po = null, $u(m, v, T), po = k, Jo = L, po !== null && (Jo ? (m = po, T = T.stateNode, m.nodeType === 8 ? m.parentNode.removeChild(T) : m.removeChild(T)) : po.removeChild(T.stateNode));
        break;
      case 18:
        po !== null && (Jo ? (m = po, T = T.stateNode, m.nodeType === 8 ? uh(m.parentNode, T) : m.nodeType === 1 && uh(m, T), zr(m)) : uh(po, T.stateNode));
        break;
      case 4:
        k = po, L = Jo, po = T.stateNode.containerInfo, Jo = !0, $u(m, v, T), po = k, Jo = L;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Fr && (k = T.updateQueue, k !== null && (k = k.lastEffect, k !== null))) {
          L = k = k.next;
          do {
            var B = L, oe = B.destroy;
            B = B.tag, oe !== void 0 && (B & 2 || B & 4) && Jv(T, v, oe), L = L.next;
          } while (L !== k);
        }
        $u(m, v, T);
        break;
      case 1:
        if (!Fr && (Dh(T, v), k = T.stateNode, typeof k.componentWillUnmount == "function"))
          try {
            k.props = T.memoizedProps, k.state = T.memoizedState, k.componentWillUnmount();
          } catch (me) {
            $o(T, v, me);
          }
        $u(m, v, T);
        break;
      case 21:
        $u(m, v, T);
        break;
      case 22:
        T.mode & 1 ? (Fr = (k = Fr) || T.memoizedState !== null, $u(m, v, T), Fr = k) : $u(m, v, T);
        break;
      default:
        $u(m, v, T);
    }
  }
  function cc(m) {
    var v = m.updateQueue;
    if (v !== null) {
      m.updateQueue = null;
      var T = m.stateNode;
      T === null && (T = m.stateNode = new p1()), v.forEach(function(k) {
        var L = aD.bind(null, m, k);
        T.has(k) || (T.add(k), k.then(L, L));
      });
    }
  }
  function _l(m, v) {
    var T = v.deletions;
    if (T !== null)
      for (var k = 0; k < T.length; k++) {
        var L = T[k];
        try {
          var B = m, oe = v, me = oe;
          e:
            for (; me !== null; ) {
              switch (me.tag) {
                case 5:
                  po = me.stateNode, Jo = !1;
                  break e;
                case 3:
                  po = me.stateNode.containerInfo, Jo = !0;
                  break e;
                case 4:
                  po = me.stateNode.containerInfo, Jo = !0;
                  break e;
              }
              me = me.return;
            }
          if (po === null)
            throw Error(n(160));
          tf(B, oe, L), po = null, Jo = !1;
          var Ee = L.alternate;
          Ee !== null && (Ee.return = null), L.return = null;
        } catch (He) {
          $o(L, v, He);
        }
      }
    if (v.subtreeFlags & 12854)
      for (v = v.child; v !== null; )
        v_(v, m), v = v.sibling;
  }
  function v_(m, v) {
    var T = m.alternate, k = m.flags;
    switch (m.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (_l(v, m), Pu(m), k & 4) {
          try {
            Vm(3, m, m.return), Wm(3, m);
          } catch (Xt) {
            $o(m, m.return, Xt);
          }
          try {
            Vm(5, m, m.return);
          } catch (Xt) {
            $o(m, m.return, Xt);
          }
        }
        break;
      case 1:
        _l(v, m), Pu(m), k & 512 && T !== null && Dh(T, T.return);
        break;
      case 5:
        if (_l(v, m), Pu(m), k & 512 && T !== null && Dh(T, T.return), m.flags & 32) {
          var L = m.stateNode;
          try {
            er(L, "");
          } catch (Xt) {
            $o(m, m.return, Xt);
          }
        }
        if (k & 4 && (L = m.stateNode, L != null)) {
          var B = m.memoizedProps, oe = T !== null ? T.memoizedProps : B, me = m.type, Ee = m.updateQueue;
          if (m.updateQueue = null, Ee !== null)
            try {
              me === "input" && B.type === "radio" && B.name != null && _t(L, B), bi(me, oe);
              var He = bi(me, B);
              for (oe = 0; oe < Ee.length; oe += 2) {
                var ft = Ee[oe], mt = Ee[oe + 1];
                ft === "style" ? _n(L, mt) : ft === "dangerouslySetInnerHTML" ? Ut(L, mt) : ft === "children" ? er(L, mt) : A(L, ft, mt, He);
              }
              switch (me) {
                case "input":
                  Ot(L, B);
                  break;
                case "textarea":
                  gr(L, B);
                  break;
                case "select":
                  var dt = L._wrapperState.wasMultiple;
                  L._wrapperState.wasMultiple = !!B.multiple;
                  var jt = B.value;
                  jt != null ? Zt(L, !!B.multiple, jt, !1) : dt !== !!B.multiple && (B.defaultValue != null ? Zt(
                    L,
                    !!B.multiple,
                    B.defaultValue,
                    !0
                  ) : Zt(L, !!B.multiple, B.multiple ? [] : "", !1));
              }
              L[qc] = B;
            } catch (Xt) {
              $o(m, m.return, Xt);
            }
        }
        break;
      case 6:
        if (_l(v, m), Pu(m), k & 4) {
          if (m.stateNode === null)
            throw Error(n(162));
          L = m.stateNode, B = m.memoizedProps;
          try {
            L.nodeValue = B;
          } catch (Xt) {
            $o(m, m.return, Xt);
          }
        }
        break;
      case 3:
        if (_l(v, m), Pu(m), k & 4 && T !== null && T.memoizedState.isDehydrated)
          try {
            zr(v.containerInfo);
          } catch (Xt) {
            $o(m, m.return, Xt);
          }
        break;
      case 4:
        _l(v, m), Pu(m);
        break;
      case 13:
        _l(v, m), Pu(m), L = m.child, L.flags & 8192 && (B = L.memoizedState !== null, L.stateNode.isHidden = B, !B || L.alternate !== null && L.alternate.memoizedState !== null || (y1 = mr())), k & 4 && cc(m);
        break;
      case 22:
        if (ft = T !== null && T.memoizedState !== null, m.mode & 1 ? (Fr = (He = Fr) || ft, _l(v, m), Fr = He) : _l(v, m), Pu(m), k & 8192) {
          if (He = m.memoizedState !== null, (m.stateNode.isHidden = He) && !ft && m.mode & 1)
            for (Vt = m, ft = m.child; ft !== null; ) {
              for (mt = Vt = ft; Vt !== null; ) {
                switch (dt = Vt, jt = dt.child, dt.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Vm(4, dt, dt.return);
                    break;
                  case 1:
                    Dh(dt, dt.return);
                    var qt = dt.stateNode;
                    if (typeof qt.componentWillUnmount == "function") {
                      k = dt, T = dt.return;
                      try {
                        v = k, qt.props = v.memoizedProps, qt.state = v.memoizedState, qt.componentWillUnmount();
                      } catch (Xt) {
                        $o(k, T, Xt);
                      }
                    }
                    break;
                  case 5:
                    Dh(dt, dt.return);
                    break;
                  case 22:
                    if (dt.memoizedState !== null) {
                      x_(mt);
                      continue;
                    }
                }
                jt !== null ? (jt.return = dt, Vt = jt) : x_(mt);
              }
              ft = ft.sibling;
            }
          e:
            for (ft = null, mt = m; ; ) {
              if (mt.tag === 5) {
                if (ft === null) {
                  ft = mt;
                  try {
                    L = mt.stateNode, He ? (B = L.style, typeof B.setProperty == "function" ? B.setProperty("display", "none", "important") : B.display = "none") : (me = mt.stateNode, Ee = mt.memoizedProps.style, oe = Ee != null && Ee.hasOwnProperty("display") ? Ee.display : null, me.style.display = Ft("display", oe));
                  } catch (Xt) {
                    $o(m, m.return, Xt);
                  }
                }
              } else if (mt.tag === 6) {
                if (ft === null)
                  try {
                    mt.stateNode.nodeValue = He ? "" : mt.memoizedProps;
                  } catch (Xt) {
                    $o(m, m.return, Xt);
                  }
              } else if ((mt.tag !== 22 && mt.tag !== 23 || mt.memoizedState === null || mt === m) && mt.child !== null) {
                mt.child.return = mt, mt = mt.child;
                continue;
              }
              if (mt === m)
                break e;
              for (; mt.sibling === null; ) {
                if (mt.return === null || mt.return === m)
                  break e;
                ft === mt && (ft = null), mt = mt.return;
              }
              ft === mt && (ft = null), mt.sibling.return = mt.return, mt = mt.sibling;
            }
        }
        break;
      case 19:
        _l(v, m), Pu(m), k & 4 && cc(m);
        break;
      case 21:
        break;
      default:
        _l(
          v,
          m
        ), Pu(m);
    }
  }
  function Pu(m) {
    var v = m.flags;
    if (v & 2) {
      try {
        e: {
          for (var T = m.return; T !== null; ) {
            if (I2(T)) {
              var k = T;
              break e;
            }
            T = T.return;
          }
          throw Error(n(160));
        }
        switch (k.tag) {
          case 5:
            var L = k.stateNode;
            k.flags & 32 && (er(L, ""), k.flags &= -33);
            var B = g1(m);
            lc(m, B, L);
            break;
          case 3:
          case 4:
            var oe = k.stateNode.containerInfo, me = g1(m);
            Zp(m, me, oe);
            break;
          default:
            throw Error(n(161));
        }
      } catch (Ee) {
        $o(m, m.return, Ee);
      }
      m.flags &= -3;
    }
    v & 4096 && (m.flags &= -4097);
  }
  function b_(m, v, T) {
    Vt = m, Ds(m);
  }
  function Ds(m, v, T) {
    for (var k = (m.mode & 1) !== 0; Vt !== null; ) {
      var L = Vt, B = L.child;
      if (L.tag === 22 && k) {
        var oe = L.memoizedState !== null || ku;
        if (!oe) {
          var me = L.alternate, Ee = me !== null && me.memoizedState !== null || Fr;
          me = ku;
          var He = Fr;
          if (ku = oe, (Fr = Ee) && !He)
            for (Vt = L; Vt !== null; )
              oe = Vt, Ee = oe.child, oe.tag === 22 && oe.memoizedState !== null ? w_(L) : Ee !== null ? (Ee.return = oe, Vt = Ee) : w_(L);
          for (; B !== null; )
            Vt = B, Ds(B), B = B.sibling;
          Vt = L, ku = me, Fr = He;
        }
        Ah(m);
      } else
        L.subtreeFlags & 8772 && B !== null ? (B.return = L, Vt = B) : Ah(m);
    }
  }
  function Ah(m) {
    for (; Vt !== null; ) {
      var v = Vt;
      if (v.flags & 8772) {
        var T = v.alternate;
        try {
          if (v.flags & 8772)
            switch (v.tag) {
              case 0:
              case 11:
              case 15:
                Fr || Wm(5, v);
                break;
              case 1:
                var k = v.stateNode;
                if (v.flags & 4 && !Fr)
                  if (T === null)
                    k.componentDidMount();
                  else {
                    var L = v.elementType === v.type ? T.memoizedProps : Au(v.type, T.memoizedProps);
                    k.componentDidUpdate(L, T.memoizedState, k.__reactInternalSnapshotBeforeUpdate);
                  }
                var B = v.updateQueue;
                B !== null && Hp(v, B, k);
                break;
              case 3:
                var oe = v.updateQueue;
                if (oe !== null) {
                  if (T = null, v.child !== null)
                    switch (v.child.tag) {
                      case 5:
                        T = v.child.stateNode;
                        break;
                      case 1:
                        T = v.child.stateNode;
                    }
                  Hp(v, oe, T);
                }
                break;
              case 5:
                var me = v.stateNode;
                if (T === null && v.flags & 4) {
                  T = me;
                  var Ee = v.memoizedProps;
                  switch (v.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Ee.autoFocus && T.focus();
                      break;
                    case "img":
                      Ee.src && (T.src = Ee.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (v.memoizedState === null) {
                  var He = v.alternate;
                  if (He !== null) {
                    var ft = He.memoizedState;
                    if (ft !== null) {
                      var mt = ft.dehydrated;
                      mt !== null && zr(mt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          Fr || v.flags & 512 && m_(v);
        } catch (dt) {
          $o(v, v.return, dt);
        }
      }
      if (v === m) {
        Vt = null;
        break;
      }
      if (T = v.sibling, T !== null) {
        T.return = v.return, Vt = T;
        break;
      }
      Vt = v.return;
    }
  }
  function x_(m) {
    for (; Vt !== null; ) {
      var v = Vt;
      if (v === m) {
        Vt = null;
        break;
      }
      var T = v.sibling;
      if (T !== null) {
        T.return = v.return, Vt = T;
        break;
      }
      Vt = v.return;
    }
  }
  function w_(m) {
    for (; Vt !== null; ) {
      var v = Vt;
      try {
        switch (v.tag) {
          case 0:
          case 11:
          case 15:
            var T = v.return;
            try {
              Wm(4, v);
            } catch (Ee) {
              $o(v, T, Ee);
            }
            break;
          case 1:
            var k = v.stateNode;
            if (typeof k.componentDidMount == "function") {
              var L = v.return;
              try {
                k.componentDidMount();
              } catch (Ee) {
                $o(v, L, Ee);
              }
            }
            var B = v.return;
            try {
              m_(v);
            } catch (Ee) {
              $o(v, B, Ee);
            }
            break;
          case 5:
            var oe = v.return;
            try {
              m_(v);
            } catch (Ee) {
              $o(v, oe, Ee);
            }
        }
      } catch (Ee) {
        $o(v, v.return, Ee);
      }
      if (v === m) {
        Vt = null;
        break;
      }
      var me = v.sibling;
      if (me !== null) {
        me.return = v.return, Vt = me;
        break;
      }
      Vt = v.return;
    }
  }
  var m1 = Math.ceil, e0 = O.ReactCurrentDispatcher, __ = O.ReactCurrentOwner, hs = O.ReactCurrentBatchConfig, vr = 0, xo = null, ko = null, Na = 0, Iu = 0, qm = Tn(0), ga = 0, Gm = null, nf = 0, t0 = 0, Qm = 0, Jp = null, As = null, y1 = 0, Xm = 1 / 0, cd = null, v1 = !1, eg = null, rf = null, Oh = !1, ma = null, b1 = 0, Km = 0, x1 = null, Rh = -1, tg = 0;
  function ps() {
    return vr & 6 ? mr() : Rh !== -1 ? Rh : Rh = mr();
  }
  function ea(m) {
    return m.mode & 1 ? vr & 2 && Na !== 0 ? Na & -Na : Iv.transition !== null ? (tg === 0 && (tg = Dp()), tg) : (m = Or, m !== 0 || (m = window.event, m = m === void 0 ? 16 : xv(m.type)), m) : 1;
  }
  function gs(m, v, T, k) {
    if (50 < Km)
      throw Km = 0, x1 = null, Error(n(185));
    Vf(m, T, k), (!(vr & 2) || m !== xo) && (m === xo && (!(vr & 2) && (t0 |= T), ga === 4 && El(m, Na)), Da(m, k), T === 1 && vr === 0 && !(v.mode & 1) && (Xm = mr() + 500, Sa && ru()));
  }
  function Da(m, v) {
    var T = m.callbackNode;
    Xd(m, v);
    var k = wa(m, m === xo ? Na : 0);
    if (k === 0)
      T !== null && nn(T), m.callbackNode = null, m.callbackPriority = 0;
    else if (v = k & -k, m.callbackPriority !== v) {
      if (T != null && nn(T), v === 1)
        m.tag === 0 ? Zf(j2.bind(null, m)) : i_(j2.bind(null, m)), Cm(function() {
          !(vr & 6) && ru();
        }), T = null;
      else {
        switch (Jl(k)) {
          case 1:
            T = Kl;
            break;
          case 4:
            T = cr;
            break;
          case 16:
            T = Zl;
            break;
          case 536870912:
            T = Np;
            break;
          default:
            T = Zl;
        }
        T = D_(T, Zm.bind(null, m));
      }
      m.callbackPriority = v, m.callbackNode = T;
    }
  }
  function Zm(m, v) {
    if (Rh = -1, tg = 0, vr & 6)
      throw Error(n(327));
    var T = m.callbackNode;
    if ($h() && m.callbackNode !== T)
      return null;
    var k = wa(m, m === xo ? Na : 0);
    if (k === 0)
      return null;
    if (k & 30 || k & m.expiredLanes || v)
      v = _1(m, k);
    else {
      v = k;
      var L = vr;
      vr |= 2;
      var B = w1();
      (xo !== m || Na !== v) && (cd = null, Xm = mr() + 500, ng(m, v));
      do
        try {
          nD();
          break;
        } catch (me) {
          L2(m, me);
        }
      while (1);
      jv(), e0.current = B, vr = L, ko !== null ? v = 0 : (xo = null, Na = 0, v = ga);
    }
    if (v !== 0) {
      if (v === 2 && (L = Hf(m), L !== 0 && (k = L, v = E_(m, L))), v === 1)
        throw T = Gm, ng(m, 0), El(m, k), Da(m, mr()), T;
      if (v === 6)
        El(m, k);
      else {
        if (L = m.current.alternate, !(k & 30) && !S_(L) && (v = _1(m, k), v === 2 && (B = Hf(m), B !== 0 && (k = B, v = E_(m, B))), v === 1))
          throw T = Gm, ng(m, 0), El(m, k), Da(m, mr()), T;
        switch (m.finishedWork = L, m.finishedLanes = k, v) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            rg(m, As, cd);
            break;
          case 3:
            if (El(m, k), (k & 130023424) === k && (v = y1 + 500 - mr(), 10 < v)) {
              if (wa(m, 0) !== 0)
                break;
              if (L = m.suspendedLanes, (L & k) !== k) {
                ps(), m.pingedLanes |= m.suspendedLanes & L;
                break;
              }
              m.timeoutHandle = pl(rg.bind(null, m, As, cd), v);
              break;
            }
            rg(m, As, cd);
            break;
          case 4:
            if (El(m, k), (k & 4194240) === k)
              break;
            for (v = m.eventTimes, L = -1; 0 < k; ) {
              var oe = 31 - Ss(k);
              B = 1 << oe, oe = v[oe], oe > L && (L = oe), k &= ~B;
            }
            if (k = L, k = mr() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * m1(k / 1960)) - k, 10 < k) {
              m.timeoutHandle = pl(rg.bind(null, m, As, cd), k);
              break;
            }
            rg(m, As, cd);
            break;
          case 5:
            rg(m, As, cd);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return Da(m, mr()), m.callbackNode === T ? Zm.bind(null, m) : null;
  }
  function E_(m, v) {
    var T = Jp;
    return m.current.memoizedState.isDehydrated && (ng(m, v).flags |= 256), m = _1(m, v), m !== 2 && (v = As, As = T, v !== null && n0(v)), m;
  }
  function n0(m) {
    As === null ? As = m : As.push.apply(As, m);
  }
  function S_(m) {
    for (var v = m; ; ) {
      if (v.flags & 16384) {
        var T = v.updateQueue;
        if (T !== null && (T = T.stores, T !== null))
          for (var k = 0; k < T.length; k++) {
            var L = T[k], B = L.getSnapshot;
            L = L.value;
            try {
              if (!Fe(B(), L))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (T = v.child, v.subtreeFlags & 16384 && T !== null)
        T.return = v, v = T;
      else {
        if (v === m)
          break;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === m)
            return !0;
          v = v.return;
        }
        v.sibling.return = v.return, v = v.sibling;
      }
    }
    return !0;
  }
  function El(m, v) {
    for (v &= ~Qm, v &= ~t0, m.suspendedLanes |= v, m.pingedLanes &= ~v, m = m.expirationTimes; 0 < v; ) {
      var T = 31 - Ss(v), k = 1 << T;
      m[T] = -1, v &= ~k;
    }
  }
  function j2(m) {
    if (vr & 6)
      throw Error(n(327));
    $h();
    var v = wa(m, 0);
    if (!(v & 1))
      return Da(m, mr()), null;
    var T = _1(m, v);
    if (m.tag !== 0 && T === 2) {
      var k = Hf(m);
      k !== 0 && (v = k, T = E_(m, k));
    }
    if (T === 1)
      throw T = Gm, ng(m, 0), El(m, v), Da(m, mr()), T;
    if (T === 6)
      throw Error(n(345));
    return m.finishedWork = m.current.alternate, m.finishedLanes = v, rg(m, As, cd), Da(m, mr()), null;
  }
  function Jm(m, v) {
    var T = vr;
    vr |= 1;
    try {
      return m(v);
    } finally {
      vr = T, vr === 0 && (Xm = mr() + 500, Sa && ru());
    }
  }
  function kh(m) {
    ma !== null && ma.tag === 0 && !(vr & 6) && $h();
    var v = vr;
    vr |= 1;
    var T = hs.transition, k = Or;
    try {
      if (hs.transition = null, Or = 1, m)
        return m();
    } finally {
      Or = k, hs.transition = T, vr = v, !(vr & 6) && ru();
    }
  }
  function M_() {
    Iu = qm.current, Jr(qm);
  }
  function ng(m, v) {
    m.finishedWork = null, m.finishedLanes = 0;
    var T = m.timeoutHandle;
    if (T !== -1 && (m.timeoutHandle = -1, Tm(T)), ko !== null)
      for (T = ko.return; T !== null; ) {
        var k = T;
        switch (Yp(k), k.tag) {
          case 1:
            k = k.type.childContextTypes, k != null && ml();
            break;
          case 3:
            wh(), Jr(Ao), Jr(An), a1();
            break;
          case 5:
            fr(k);
            break;
          case 4:
            wh();
            break;
          case 13:
            Jr(pn);
            break;
          case 19:
            Jr(pn);
            break;
          case 10:
            ed(k.type._context);
            break;
          case 22:
          case 23:
            M_();
        }
        T = T.return;
      }
    if (xo = m, ko = m = Ph(m.current, null), Na = Iu = v, ga = 0, Gm = null, Qm = t0 = nf = 0, As = Jp = null, bo !== null) {
      for (v = 0; v < bo.length; v++)
        if (T = bo[v], k = T.interleaved, k !== null) {
          T.interleaved = null;
          var L = k.next, B = T.pending;
          if (B !== null) {
            var oe = B.next;
            B.next = L, k.next = oe;
          }
          T.pending = k;
        }
      bo = null;
    }
    return m;
  }
  function L2(m, v) {
    do {
      var T = ko;
      try {
        if (jv(), Pm.current = sd, En) {
          for (var k = ro.memoizedState; k !== null; ) {
            var L = k.queue;
            L !== null && (L.pending = null), k = k.next;
          }
          En = !1;
        }
        if (Vp = 0, Er = Xe = ro = null, Zc = !1, co = 0, __.current = null, T === null || T.return === null) {
          ga = 1, Gm = v, ko = null;
          break;
        }
        e: {
          var B = m, oe = T.return, me = T, Ee = v;
          if (v = Na, me.flags |= 32768, Ee !== null && typeof Ee == "object" && typeof Ee.then == "function") {
            var He = Ee, ft = me, mt = ft.tag;
            if (!(ft.mode & 1) && (mt === 0 || mt === 11 || mt === 15)) {
              var dt = ft.alternate;
              dt ? (ft.updateQueue = dt.updateQueue, ft.memoizedState = dt.memoizedState, ft.lanes = dt.lanes) : (ft.updateQueue = null, ft.memoizedState = null);
            }
            var jt = d1(oe);
            if (jt !== null) {
              jt.flags &= -257, Fm(jt, oe, me, B, v), jt.mode & 1 && R2(B, He, v), v = jt, Ee = He;
              var qt = v.updateQueue;
              if (qt === null) {
                var Xt = /* @__PURE__ */ new Set();
                Xt.add(Ee), v.updateQueue = Xt;
              } else
                qt.add(Ee);
              break e;
            } else {
              if (!(v & 1)) {
                R2(B, He, v), T_();
                break e;
              }
              Ee = Error(n(426));
            }
          } else if (Vi && me.mode & 1) {
            var Bo = d1(oe);
            if (Bo !== null) {
              !(Bo.flags & 65536) && (Bo.flags |= 256), Fm(Bo, oe, me, B, v), Kc(Qp(Ee, me));
              break e;
            }
          }
          B = Ee = Qp(Ee, me), ga !== 4 && (ga = 2), Jp === null ? Jp = [B] : Jp.push(B), B = oe;
          do {
            switch (B.tag) {
              case 3:
                B.flags |= 65536, v &= -v, B.lanes |= v;
                var Pe = f1(B, Ee, v);
                e1(B, Pe);
                break e;
              case 1:
                me = Ee;
                var Te = B.type, Ie = B.stateNode;
                if (!(B.flags & 128) && (typeof Te.getDerivedStateFromError == "function" || Ie !== null && typeof Ie.componentDidCatch == "function" && (rf === null || !rf.has(Ie)))) {
                  B.flags |= 65536, v &= -v, B.lanes |= v;
                  var wt = Th(B, me, v);
                  e1(B, wt);
                  break e;
                }
            }
            B = B.return;
          } while (B !== null);
        }
        C_(T);
      } catch (Jt) {
        v = Jt, ko === T && T !== null && (ko = T = T.return);
        continue;
      }
      break;
    } while (1);
  }
  function w1() {
    var m = e0.current;
    return e0.current = sd, m === null ? sd : m;
  }
  function T_() {
    (ga === 0 || ga === 3 || ga === 2) && (ga = 4), xo === null || !(nf & 268435455) && !(t0 & 268435455) || El(xo, Na);
  }
  function _1(m, v) {
    var T = vr;
    vr |= 2;
    var k = w1();
    (xo !== m || Na !== v) && (cd = null, ng(m, v));
    do
      try {
        tD();
        break;
      } catch (L) {
        L2(m, L);
      }
    while (1);
    if (jv(), vr = T, e0.current = k, ko !== null)
      throw Error(n(261));
    return xo = null, Na = 0, ga;
  }
  function tD() {
    for (; ko !== null; )
      z2(ko);
  }
  function nD() {
    for (; ko !== null && !Oi(); )
      z2(ko);
  }
  function z2(m) {
    var v = F2(m.alternate, m, Iu);
    m.memoizedProps = m.pendingProps, v === null ? C_(m) : ko = v, __.current = null;
  }
  function C_(m) {
    var v = m;
    do {
      var T = v.alternate;
      if (m = v.return, v.flags & 32768) {
        if (T = g_(T, v), T !== null) {
          T.flags &= 32767, ko = T;
          return;
        }
        if (m !== null)
          m.flags |= 32768, m.subtreeFlags = 0, m.deletions = null;
        else {
          ga = 6, ko = null;
          return;
        }
      } else if (T = eD(T, v, Iu), T !== null) {
        ko = T;
        return;
      }
      if (v = v.sibling, v !== null) {
        ko = v;
        return;
      }
      ko = v = m;
    } while (v !== null);
    ga === 0 && (ga = 5);
  }
  function rg(m, v, T) {
    var k = Or, L = hs.transition;
    try {
      hs.transition = null, Or = 1, rD(m, v, T, k);
    } finally {
      hs.transition = L, Or = k;
    }
    return null;
  }
  function rD(m, v, T, k) {
    do
      $h();
    while (ma !== null);
    if (vr & 6)
      throw Error(n(327));
    T = m.finishedWork;
    var L = m.finishedLanes;
    if (T === null)
      return null;
    if (m.finishedWork = null, m.finishedLanes = 0, T === m.current)
      throw Error(n(177));
    m.callbackNode = null, m.callbackPriority = 0;
    var B = T.lanes | T.childLanes;
    if ($b(m, B), m === xo && (ko = xo = null, Na = 0), !(T.subtreeFlags & 2064) && !(T.flags & 2064) || Oh || (Oh = !0, D_(Zl, function() {
      return $h(), null;
    })), B = (T.flags & 15990) !== 0, T.subtreeFlags & 15990 || B) {
      B = hs.transition, hs.transition = null;
      var oe = Or;
      Or = 1;
      var me = vr;
      vr |= 4, __.current = null, Hm(m, T), v_(T, m), Yb(nc), ll = !!Ov, nc = Ov = null, m.current = T, b_(T), lm(), vr = me, Or = oe, hs.transition = B;
    } else
      m.current = T;
    if (Oh && (Oh = !1, ma = m, b1 = L), B = m.pendingLanes, B === 0 && (rf = null), vv(T.stateNode), Da(m, mr()), v !== null)
      for (k = m.onRecoverableError, T = 0; T < v.length; T++)
        L = v[T], k(L.value, { componentStack: L.stack, digest: L.digest });
    if (v1)
      throw v1 = !1, m = eg, eg = null, m;
    return b1 & 1 && m.tag !== 0 && $h(), B = m.pendingLanes, B & 1 ? m === x1 ? Km++ : (Km = 0, x1 = m) : Km = 0, ru(), null;
  }
  function $h() {
    if (ma !== null) {
      var m = Jl(b1), v = hs.transition, T = Or;
      try {
        if (hs.transition = null, Or = 16 > m ? 16 : m, ma === null)
          var k = !1;
        else {
          if (m = ma, ma = null, b1 = 0, vr & 6)
            throw Error(n(331));
          var L = vr;
          for (vr |= 4, Vt = m.current; Vt !== null; ) {
            var B = Vt, oe = B.child;
            if (Vt.flags & 16) {
              var me = B.deletions;
              if (me !== null) {
                for (var Ee = 0; Ee < me.length; Ee++) {
                  var He = me[Ee];
                  for (Vt = He; Vt !== null; ) {
                    var ft = Vt;
                    switch (ft.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Vm(8, ft, B);
                    }
                    var mt = ft.child;
                    if (mt !== null)
                      mt.return = ft, Vt = mt;
                    else
                      for (; Vt !== null; ) {
                        ft = Vt;
                        var dt = ft.sibling, jt = ft.return;
                        if (y_(ft), ft === He) {
                          Vt = null;
                          break;
                        }
                        if (dt !== null) {
                          dt.return = jt, Vt = dt;
                          break;
                        }
                        Vt = jt;
                      }
                  }
                }
                var qt = B.alternate;
                if (qt !== null) {
                  var Xt = qt.child;
                  if (Xt !== null) {
                    qt.child = null;
                    do {
                      var Bo = Xt.sibling;
                      Xt.sibling = null, Xt = Bo;
                    } while (Xt !== null);
                  }
                }
                Vt = B;
              }
            }
            if (B.subtreeFlags & 2064 && oe !== null)
              oe.return = B, Vt = oe;
            else
              e:
                for (; Vt !== null; ) {
                  if (B = Vt, B.flags & 2048)
                    switch (B.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Vm(9, B, B.return);
                    }
                  var Pe = B.sibling;
                  if (Pe !== null) {
                    Pe.return = B.return, Vt = Pe;
                    break e;
                  }
                  Vt = B.return;
                }
          }
          var Te = m.current;
          for (Vt = Te; Vt !== null; ) {
            oe = Vt;
            var Ie = oe.child;
            if (oe.subtreeFlags & 2064 && Ie !== null)
              Ie.return = oe, Vt = Ie;
            else
              e:
                for (oe = Te; Vt !== null; ) {
                  if (me = Vt, me.flags & 2048)
                    try {
                      switch (me.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Wm(9, me);
                      }
                    } catch (Jt) {
                      $o(me, me.return, Jt);
                    }
                  if (me === oe) {
                    Vt = null;
                    break e;
                  }
                  var wt = me.sibling;
                  if (wt !== null) {
                    wt.return = me.return, Vt = wt;
                    break e;
                  }
                  Vt = me.return;
                }
          }
          if (vr = L, ru(), Zs && typeof Zs.onPostCommitFiberRoot == "function")
            try {
              Zs.onPostCommitFiberRoot(qd, m);
            } catch {
            }
          k = !0;
        }
        return k;
      } finally {
        Or = T, hs.transition = v;
      }
    }
    return !1;
  }
  function N_(m, v, T) {
    v = Qp(T, v), v = f1(m, v, 1), m = gh(m, v, 1), v = ps(), m !== null && (Vf(m, 1, v), Da(m, v));
  }
  function $o(m, v, T) {
    if (m.tag === 3)
      N_(m, m, T);
    else
      for (; v !== null; ) {
        if (v.tag === 3) {
          N_(v, m, T);
          break;
        } else if (v.tag === 1) {
          var k = v.stateNode;
          if (typeof v.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (rf === null || !rf.has(k))) {
            m = Qp(T, m), m = Th(v, m, 1), v = gh(v, m, 1), m = ps(), v !== null && (Vf(v, 1, m), Da(v, m));
            break;
          }
        }
        v = v.return;
      }
  }
  function iD(m, v, T) {
    var k = m.pingCache;
    k !== null && k.delete(v), v = ps(), m.pingedLanes |= m.suspendedLanes & T, xo === m && (Na & T) === T && (ga === 4 || ga === 3 && (Na & 130023424) === Na && 500 > mr() - y1 ? ng(m, 0) : Qm |= T), Da(m, v);
  }
  function E1(m, v) {
    v === 0 && (m.mode & 1 ? (v = Qd, Qd <<= 1, !(Qd & 130023424) && (Qd = 4194304)) : v = 1);
    var T = ps();
    m = oc(m, v), m !== null && (Vf(m, v, T), Da(m, T));
  }
  function oD(m) {
    var v = m.memoizedState, T = 0;
    v !== null && (T = v.retryLane), E1(m, T);
  }
  function aD(m, v) {
    var T = 0;
    switch (m.tag) {
      case 13:
        var k = m.stateNode, L = m.memoizedState;
        L !== null && (T = L.retryLane);
        break;
      case 19:
        k = m.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    k !== null && k.delete(v), E1(m, T);
  }
  var F2;
  F2 = function(m, v, T) {
    if (m !== null)
      if (m.memoizedProps !== v.pendingProps || Ao.current)
        Ro = !0;
      else {
        if (!(m.lanes & T) && !(v.flags & 128))
          return Ro = !1, ho(m, v, T);
        Ro = !!(m.flags & 131072);
      }
    else
      Ro = !1, Vi && v.flags & 1048576 && o_(v, Dm, v.index);
    switch (v.lanes = 0, v.tag) {
      case 2:
        var k = v.type;
        Ta(m, v), m = v.pendingProps;
        var L = gl(v, An.current);
        Ct(v, T), L = nd(null, v, k, m, L, T);
        var B = _h();
        return v.flags |= 1, typeof L == "object" && L !== null && typeof L.render == "function" && L.$$typeof === void 0 ? (v.tag = 1, v.memoizedState = null, v.updateQueue = null, ao(k) ? (B = !0, yl(v)) : B = !1, v.memoizedState = L.state !== null && L.state !== void 0 ? L.state : null, s_(v), L.updater = t1, v.stateNode = L, L._reactInternals = v, r1(v, k, m, T), v = $2(null, v, k, !0, B, T)) : (v.tag = 0, Vi && B && Am(v), ha(null, v, L, T), v = v.child), v;
      case 16:
        k = v.elementType;
        e: {
          switch (Ta(m, v), m = v.pendingProps, L = k._init, k = L(k._payload), v.type = k, L = v.tag = S1(k), m = Au(k, m), L) {
            case 0:
              v = Xp(null, v, k, m, T);
              break e;
            case 1:
              v = h_(null, v, k, m, T);
              break e;
            case 11:
              v = ud(null, v, k, m, T);
              break e;
            case 14:
              v = wl(null, v, k, Au(k.type, m), T);
              break e;
          }
          throw Error(n(
            306,
            k,
            ""
          ));
        }
        return v;
      case 0:
        return k = v.type, L = v.pendingProps, L = v.elementType === k ? L : Au(k, L), Xp(m, v, k, L, T);
      case 1:
        return k = v.type, L = v.pendingProps, L = v.elementType === k ? L : Au(k, L), h_(m, v, k, L, T);
      case 3:
        e: {
          if (Jc(v), m === null)
            throw Error(n(387));
          k = v.pendingProps, B = v.memoizedState, L = B.element, fa(m, v), yh(v, k, null, T);
          var oe = v.memoizedState;
          if (k = oe.element, B.isDehydrated)
            if (B = { element: k, isDehydrated: !1, cache: oe.cache, pendingSuspenseBoundaries: oe.pendingSuspenseBoundaries, transitions: oe.transitions }, v.updateQueue.baseState = B, v.memoizedState = B, v.flags & 256) {
              L = Qp(Error(n(423)), v), v = Bm(m, v, k, T, L);
              break e;
            } else if (k !== L) {
              L = Qp(Error(n(424)), v), v = Bm(m, v, k, T, L);
              break e;
            } else
              for (ou = rc(v.stateNode.containerInfo.firstChild), cs = v, Vi = !0, bl = null, T = c_(v, null, k, T), v.child = T; T; )
                T.flags = T.flags & -3 | 4096, T = T.sibling;
          else {
            if (Pi(), k === L) {
              v = Ca(m, v, T);
              break e;
            }
            ha(m, v, k, T);
          }
          v = v.child;
        }
        return v;
      case 5:
        return hn(v), m === null && Cs(v), k = v.type, L = v.pendingProps, B = m !== null ? m.memoizedProps : null, oe = L.children, Fp(k, L) ? oe = null : B !== null && Fp(k, B) && (v.flags |= 32), Gn(m, v), ha(m, v, oe, T), v.child;
      case 6:
        return m === null && Cs(v), null;
      case 13:
        return Um(m, v, T);
      case 4:
        return o1(v, v.stateNode.containerInfo), k = v.pendingProps, m === null ? v.child = vh(v, null, k, T) : ha(m, v, k, T), v.child;
      case 11:
        return k = v.type, L = v.pendingProps, L = v.elementType === k ? L : Au(k, L), ud(m, v, k, L, T);
      case 7:
        return ha(m, v, v.pendingProps, T), v.child;
      case 8:
        return ha(m, v, v.pendingProps.children, T), v.child;
      case 12:
        return ha(m, v, v.pendingProps.children, T), v.child;
      case 10:
        e: {
          if (k = v.type._context, L = v.pendingProps, B = v.memoizedProps, oe = L.value, ai(Ou, k._currentValue), k._currentValue = oe, B !== null)
            if (Fe(B.value, oe)) {
              if (B.children === L.children && !Ao.current) {
                v = Ca(m, v, T);
                break e;
              }
            } else
              for (B = v.child, B !== null && (B.return = v); B !== null; ) {
                var me = B.dependencies;
                if (me !== null) {
                  oe = B.child;
                  for (var Ee = me.firstContext; Ee !== null; ) {
                    if (Ee.context === k) {
                      if (B.tag === 1) {
                        Ee = ac(-1, T & -T), Ee.tag = 2;
                        var He = B.updateQueue;
                        if (He !== null) {
                          He = He.shared;
                          var ft = He.pending;
                          ft === null ? Ee.next = Ee : (Ee.next = ft.next, ft.next = Ee), He.pending = Ee;
                        }
                      }
                      B.lanes |= T, Ee = B.alternate, Ee !== null && (Ee.lanes |= T), Ii(
                        B.return,
                        T,
                        v
                      ), me.lanes |= T;
                      break;
                    }
                    Ee = Ee.next;
                  }
                } else if (B.tag === 10)
                  oe = B.type === v.type ? null : B.child;
                else if (B.tag === 18) {
                  if (oe = B.return, oe === null)
                    throw Error(n(341));
                  oe.lanes |= T, me = oe.alternate, me !== null && (me.lanes |= T), Ii(oe, T, v), oe = B.sibling;
                } else
                  oe = B.child;
                if (oe !== null)
                  oe.return = B;
                else
                  for (oe = B; oe !== null; ) {
                    if (oe === v) {
                      oe = null;
                      break;
                    }
                    if (B = oe.sibling, B !== null) {
                      B.return = oe.return, oe = B;
                      break;
                    }
                    oe = oe.return;
                  }
                B = oe;
              }
          ha(m, v, L.children, T), v = v.child;
        }
        return v;
      case 9:
        return L = v.type, k = v.pendingProps.children, Ct(v, T), L = uo(L), k = k(L), v.flags |= 1, ha(m, v, k, T), v.child;
      case 14:
        return k = v.type, L = Au(k, v.pendingProps), L = Au(k.type, L), wl(m, v, k, L, T);
      case 15:
        return Ns(m, v, v.type, v.pendingProps, T);
      case 17:
        return k = v.type, L = v.pendingProps, L = v.elementType === k ? L : Au(k, L), Ta(m, v), v.tag = 1, ao(k) ? (m = !0, yl(v)) : m = !1, Ct(v, T), l_(v, k, L), r1(v, k, L, T), $2(null, v, k, !0, m, T);
      case 19:
        return p_(m, v, T);
      case 22:
        return Ch(m, v, T);
    }
    throw Error(n(156, v.tag));
  };
  function D_(m, v) {
    return wi(m, v);
  }
  function sD(m, v, T, k) {
    this.tag = m, this.key = T, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = v, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function ju(m, v, T, k) {
    return new sD(m, v, T, k);
  }
  function A_(m) {
    return m = m.prototype, !(!m || !m.isReactComponent);
  }
  function S1(m) {
    if (typeof m == "function")
      return A_(m) ? 1 : 0;
    if (m != null) {
      if (m = m.$$typeof, m === ee)
        return 11;
      if (m === q)
        return 14;
    }
    return 2;
  }
  function Ph(m, v) {
    var T = m.alternate;
    return T === null ? (T = ju(m.tag, v, m.key, m.mode), T.elementType = m.elementType, T.type = m.type, T.stateNode = m.stateNode, T.alternate = m, m.alternate = T) : (T.pendingProps = v, T.type = m.type, T.flags = 0, T.subtreeFlags = 0, T.deletions = null), T.flags = m.flags & 14680064, T.childLanes = m.childLanes, T.lanes = m.lanes, T.child = m.child, T.memoizedProps = m.memoizedProps, T.memoizedState = m.memoizedState, T.updateQueue = m.updateQueue, v = m.dependencies, T.dependencies = v === null ? null : { lanes: v.lanes, firstContext: v.firstContext }, T.sibling = m.sibling, T.index = m.index, T.ref = m.ref, T;
  }
  function M1(m, v, T, k, L, B) {
    var oe = 2;
    if (k = m, typeof m == "function")
      A_(m) && (oe = 1);
    else if (typeof m == "string")
      oe = 5;
    else
      e:
        switch (m) {
          case $:
            return ig(T.children, L, B, v);
          case z:
            oe = 8, L |= 8;
            break;
          case W:
            return m = ju(12, T, v, L | 2), m.elementType = W, m.lanes = B, m;
          case K:
            return m = ju(13, T, v, L), m.elementType = K, m.lanes = B, m;
          case Q:
            return m = ju(19, T, v, L), m.elementType = Q, m.lanes = B, m;
          case X:
            return r0(T, L, B, v);
          default:
            if (typeof m == "object" && m !== null)
              switch (m.$$typeof) {
                case Y:
                  oe = 10;
                  break e;
                case V:
                  oe = 9;
                  break e;
                case ee:
                  oe = 11;
                  break e;
                case q:
                  oe = 14;
                  break e;
                case te:
                  oe = 16, k = null;
                  break e;
              }
            throw Error(n(130, m == null ? m : typeof m, ""));
        }
    return v = ju(oe, T, v, L), v.elementType = m, v.type = k, v.lanes = B, v;
  }
  function ig(m, v, T, k) {
    return m = ju(7, m, k, v), m.lanes = T, m;
  }
  function r0(m, v, T, k) {
    return m = ju(22, m, k, v), m.elementType = X, m.lanes = T, m.stateNode = { isHidden: !1 }, m;
  }
  function i0(m, v, T) {
    return m = ju(6, m, null, v), m.lanes = T, m;
  }
  function og(m, v, T) {
    return v = ju(4, m.children !== null ? m.children : [], m.key, v), v.lanes = T, v.stateNode = { containerInfo: m.containerInfo, pendingChildren: null, implementation: m.implementation }, v;
  }
  function uD(m, v, T, k, L) {
    this.tag = v, this.containerInfo = m, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Kd(0), this.expirationTimes = Kd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Kd(0), this.identifierPrefix = k, this.onRecoverableError = L, this.mutableSourceEagerHydrationData = null;
  }
  function T1(m, v, T, k, L, B, oe, me, Ee) {
    return m = new uD(m, v, T, me, Ee), v === 1 ? (v = 1, B === !0 && (v |= 8)) : v = 0, B = ju(3, null, null, v), m.current = B, B.stateNode = m, B.memoizedState = { element: k, isDehydrated: T, cache: null, transitions: null, pendingSuspenseBoundaries: null }, s_(B), m;
  }
  function B2(m, v, T) {
    var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: j, key: k == null ? null : "" + k, children: m, containerInfo: v, implementation: T };
  }
  function O_(m) {
    if (!m)
      return Gc;
    m = m._reactInternals;
    e: {
      if (In(m) !== m || m.tag !== 1)
        throw Error(n(170));
      var v = m;
      do {
        switch (v.tag) {
          case 3:
            v = v.stateNode.context;
            break e;
          case 1:
            if (ao(v.type)) {
              v = v.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        v = v.return;
      } while (v !== null);
      throw Error(n(171));
    }
    if (m.tag === 1) {
      var T = m.type;
      if (ao(T))
        return kv(m, T, v);
    }
    return v;
  }
  function U2(m, v, T, k, L, B, oe, me, Ee) {
    return m = T1(T, k, !0, m, L, B, oe, me, Ee), m.context = O_(null), T = m.current, k = ps(), L = ea(T), B = ac(k, L), B.callback = v ?? null, gh(T, B, L), m.current.lanes = L, Vf(m, L, k), Da(m, k), m;
  }
  function o0(m, v, T, k) {
    var L = v.current, B = ps(), oe = ea(L);
    return T = O_(T), v.context === null ? v.context = T : v.pendingContext = T, v = ac(B, oe), v.payload = { element: m }, k = k === void 0 ? null : k, k !== null && (v.callback = k), m = gh(L, v, oe), m !== null && (gs(m, L, oe, B), mh(m, L, oe)), oe;
  }
  function C1(m) {
    if (m = m.current, !m.child)
      return null;
    switch (m.child.tag) {
      case 5:
        return m.child.stateNode;
      default:
        return m.child.stateNode;
    }
  }
  function Y2(m, v) {
    if (m = m.memoizedState, m !== null && m.dehydrated !== null) {
      var T = m.retryLane;
      m.retryLane = T !== 0 && T < v ? T : v;
    }
  }
  function R_(m, v) {
    Y2(m, v), (m = m.alternate) && Y2(m, v);
  }
  function H2() {
    return null;
  }
  var N1 = typeof reportError == "function" ? reportError : function(m) {
    console.error(m);
  };
  function a0(m) {
    this._internalRoot = m;
  }
  fd.prototype.render = a0.prototype.render = function(m) {
    var v = this._internalRoot;
    if (v === null)
      throw Error(n(409));
    o0(m, v, null, null);
  }, fd.prototype.unmount = a0.prototype.unmount = function() {
    var m = this._internalRoot;
    if (m !== null) {
      this._internalRoot = null;
      var v = m.containerInfo;
      kh(function() {
        o0(null, m, null, null);
      }), v[Cu] = null;
    }
  };
  function fd(m) {
    this._internalRoot = m;
  }
  fd.prototype.unstable_scheduleHydration = function(m) {
    if (m) {
      var v = Op();
      m = { blockedOn: null, target: m, priority: v };
      for (var T = 0; T < ii.length && v !== 0 && v < ii[T].priority; T++)
        ;
      ii.splice(T, 0, m), T === 0 && Ib(m);
    }
  };
  function k_(m) {
    return !(!m || m.nodeType !== 1 && m.nodeType !== 9 && m.nodeType !== 11);
  }
  function D1(m) {
    return !(!m || m.nodeType !== 1 && m.nodeType !== 9 && m.nodeType !== 11 && (m.nodeType !== 8 || m.nodeValue !== " react-mount-point-unstable "));
  }
  function V2() {
  }
  function A1(m, v, T, k, L) {
    if (L) {
      if (typeof k == "function") {
        var B = k;
        k = function() {
          var He = C1(oe);
          B.call(He);
        };
      }
      var oe = U2(v, k, m, 0, null, !1, !1, "", V2);
      return m._reactRootContainer = oe, m[Cu] = oe.current, Kf(m.nodeType === 8 ? m.parentNode : m), kh(), oe;
    }
    for (; L = m.lastChild; )
      m.removeChild(L);
    if (typeof k == "function") {
      var me = k;
      k = function() {
        var He = C1(Ee);
        me.call(He);
      };
    }
    var Ee = T1(m, 0, !1, null, null, !1, !1, "", V2);
    return m._reactRootContainer = Ee, m[Cu] = Ee.current, Kf(m.nodeType === 8 ? m.parentNode : m), kh(function() {
      o0(v, Ee, T, k);
    }), Ee;
  }
  function O1(m, v, T, k, L) {
    var B = T._reactRootContainer;
    if (B) {
      var oe = B;
      if (typeof L == "function") {
        var me = L;
        L = function() {
          var Ee = C1(oe);
          me.call(Ee);
        };
      }
      o0(v, oe, m, L);
    } else
      oe = A1(T, v, m, L, k);
    return C1(oe);
  }
  Zd = function(m) {
    switch (m.tag) {
      case 3:
        var v = m.stateNode;
        if (v.current.memoizedState.isDehydrated) {
          var T = sl(v.pendingLanes);
          T !== 0 && (ul(v, T | 1), Da(v, mr()), !(vr & 6) && (Xm = mr() + 500, ru()));
        }
        break;
      case 13:
        kh(function() {
          var k = oc(m, 1);
          if (k !== null) {
            var L = ps();
            gs(k, m, 1, L);
          }
        }), R_(m, 1);
    }
  }, Ap = function(m) {
    if (m.tag === 13) {
      var v = oc(m, 134217728);
      if (v !== null) {
        var T = ps();
        gs(v, m, 134217728, T);
      }
      R_(m, 134217728);
    }
  }, Rr = function(m) {
    if (m.tag === 13) {
      var v = ea(m), T = oc(m, v);
      if (T !== null) {
        var k = ps();
        gs(T, m, v, k);
      }
      R_(m, v);
    }
  }, Op = function() {
    return Or;
  }, Rp = function(m, v) {
    var T = Or;
    try {
      return Or = m, v();
    } finally {
      Or = T;
    }
  }, Wa = function(m, v, T) {
    switch (v) {
      case "input":
        if (Ot(m, T), v = T.name, T.type === "radio" && v != null) {
          for (T = m; T.parentNode; )
            T = T.parentNode;
          for (T = T.querySelectorAll("input[name=" + JSON.stringify("" + v) + '][type="radio"]'), v = 0; v < T.length; v++) {
            var k = T[v];
            if (k !== m && k.form === m.form) {
              var L = cn(k);
              if (!L)
                throw Error(n(90));
              fe(k), Ot(k, L);
            }
          }
        }
        break;
      case "textarea":
        gr(m, T);
        break;
      case "select":
        v = T.value, v != null && Zt(m, !!T.multiple, v, !1);
    }
  }, Lc = Jm, zc = kh;
  var lD = { usingClientEntryPoint: !1, Events: [us, nr, cn, ws, Ql, Jm] }, ey = { findFiberByHostInstance: Ts, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, cD = { bundleType: ey.bundleType, version: ey.version, rendererPackageName: ey.rendererPackageName, rendererConfig: ey.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: O.ReactCurrentDispatcher, findHostInstanceByFiber: function(m) {
    return m = No(m), m === null ? null : m.stateNode;
  }, findFiberByHostInstance: ey.findFiberByHostInstance || H2, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var R1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!R1.isDisabled && R1.supportsFiber)
      try {
        qd = R1.inject(cD), Zs = R1;
      } catch {
      }
  }
  return cf.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lD, cf.createPortal = function(m, v) {
    var T = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!k_(v))
      throw Error(n(200));
    return B2(m, v, null, T);
  }, cf.createRoot = function(m, v) {
    if (!k_(m))
      throw Error(n(299));
    var T = !1, k = "", L = N1;
    return v != null && (v.unstable_strictMode === !0 && (T = !0), v.identifierPrefix !== void 0 && (k = v.identifierPrefix), v.onRecoverableError !== void 0 && (L = v.onRecoverableError)), v = T1(m, 1, !1, null, null, T, !1, k, L), m[Cu] = v.current, Kf(m.nodeType === 8 ? m.parentNode : m), new a0(v);
  }, cf.findDOMNode = function(m) {
    if (m == null)
      return null;
    if (m.nodeType === 1)
      return m;
    var v = m._reactInternals;
    if (v === void 0)
      throw typeof m.render == "function" ? Error(n(188)) : (m = Object.keys(m).join(","), Error(n(268, m)));
    return m = No(v), m = m === null ? null : m.stateNode, m;
  }, cf.flushSync = function(m) {
    return kh(m);
  }, cf.hydrate = function(m, v, T) {
    if (!D1(v))
      throw Error(n(200));
    return O1(null, m, v, !0, T);
  }, cf.hydrateRoot = function(m, v, T) {
    if (!k_(m))
      throw Error(n(405));
    var k = T != null && T.hydratedSources || null, L = !1, B = "", oe = N1;
    if (T != null && (T.unstable_strictMode === !0 && (L = !0), T.identifierPrefix !== void 0 && (B = T.identifierPrefix), T.onRecoverableError !== void 0 && (oe = T.onRecoverableError)), v = U2(v, null, m, 1, T ?? null, L, !1, B, oe), m[Cu] = v.current, Kf(m), k)
      for (m = 0; m < k.length; m++)
        T = k[m], L = T._getVersion, L = L(T._source), v.mutableSourceEagerHydrationData == null ? v.mutableSourceEagerHydrationData = [T, L] : v.mutableSourceEagerHydrationData.push(
          T,
          L
        );
    return new fd(v);
  }, cf.render = function(m, v, T) {
    if (!D1(v))
      throw Error(n(200));
    return O1(null, m, v, !1, T);
  }, cf.unmountComponentAtNode = function(m) {
    if (!D1(m))
      throw Error(n(40));
    return m._reactRootContainer ? (kh(function() {
      O1(null, null, m, !1, function() {
        m._reactRootContainer = null, m[Cu] = null;
      });
    }), !0) : !1;
  }, cf.unstable_batchedUpdates = Jm, cf.unstable_renderSubtreeIntoContainer = function(m, v, T, k) {
    if (!D1(T))
      throw Error(n(200));
    if (m == null || m._reactInternals === void 0)
      throw Error(n(38));
    return O1(m, v, T, !1, k);
  }, cf.version = "18.2.0-next-9e3b772b8-20220608", cf;
}
var ff = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tue;
function ize() {
  return tue || (tue = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = ae, t = Xve(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function i(c) {
      r = c;
    }
    function o(c) {
      if (!r) {
        for (var d = arguments.length, x = new Array(d > 1 ? d - 1 : 0), E = 1; E < d; E++)
          x[E - 1] = arguments[E];
        s("warn", c, x);
      }
    }
    function a(c) {
      if (!r) {
        for (var d = arguments.length, x = new Array(d > 1 ? d - 1 : 0), E = 1; E < d; E++)
          x[E - 1] = arguments[E];
        s("error", c, x);
      }
    }
    function s(c, d, x) {
      {
        var E = n.ReactDebugCurrentFrame, D = E.getStackAddendum();
        D !== "" && (d += "%s", x = x.concat([D]));
        var I = x.map(function(F) {
          return String(F);
        });
        I.unshift("Warning: " + d), Function.prototype.apply.call(console[c], console, I);
      }
    }
    var u = 0, l = 1, f = 2, h = 3, p = 4, g = 5, y = 6, b = 7, _ = 8, S = 9, C = 10, A = 11, O = 12, R = 13, j = 14, $ = 15, z = 16, W = 17, Y = 18, V = 19, ee = 21, K = 22, Q = 23, q = 24, te = 25, X = !0, Z = !1, se = !1, H = !1, ie = !1, he = !0, ye = !1, _e = !1, Ne = !0, Oe = !0, ke = !0, Me = /* @__PURE__ */ new Set(), we = {}, Ye = {};
    function ze(c, d) {
      fe(c, d), fe(c + "Capture", d);
    }
    function fe(c, d) {
      we[c] && a("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", c), we[c] = d;
      {
        var x = c.toLowerCase();
        Ye[x] = c, c === "onDoubleClick" && (Ye.ondblclick = c);
      }
      for (var E = 0; E < d.length; E++)
        Me.add(d[E]);
    }
    var Qe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", $e = Object.prototype.hasOwnProperty;
    function pt(c) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, x = d && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return x;
      }
    }
    function _t(c) {
      try {
        return Ot(c), !1;
      } catch {
        return !0;
      }
    }
    function Ot(c) {
      return "" + c;
    }
    function mn(c, d) {
      if (_t(c))
        return a("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", d, pt(c)), Ot(c);
    }
    function jr(c) {
      if (_t(c))
        return a("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", pt(c)), Ot(c);
    }
    function tn(c, d) {
      if (_t(c))
        return a("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", d, pt(c)), Ot(c);
    }
    function Zt(c, d) {
      if (_t(c))
        return a("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", d, pt(c)), Ot(c);
    }
    function qn(c) {
      if (_t(c))
        return a("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", pt(c)), Ot(c);
    }
    function fn(c) {
      if (_t(c))
        return a("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", pt(c)), Ot(c);
    }
    var gr = 0, Zn = 1, xr = 2, Un = 3, Qt = 4, Ut = 5, er = 6, We = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ht = We + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ft = new RegExp("^[" + We + "][" + ht + "]*$"), _n = {}, Dn = {};
    function di(c) {
      return $e.call(Dn, c) ? !0 : $e.call(_n, c) ? !1 : Ft.test(c) ? (Dn[c] = !0, !0) : (_n[c] = !0, a("Invalid attribute name: `%s`", c), !1);
    }
    function bi(c, d, x) {
      return d !== null ? d.type === gr : x ? !1 : c.length > 2 && (c[0] === "o" || c[0] === "O") && (c[1] === "n" || c[1] === "N");
    }
    function ua(c, d, x, E) {
      if (x !== null && x.type === gr)
        return !1;
      switch (typeof d) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (E)
            return !1;
          if (x !== null)
            return !x.acceptsBooleans;
          var D = c.toLowerCase().slice(0, 5);
          return D !== "data-" && D !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Zr(c, d, x, E) {
      if (d === null || typeof d > "u" || ua(c, d, x, E))
        return !0;
      if (E)
        return !1;
      if (x !== null)
        switch (x.type) {
          case Un:
            return !d;
          case Qt:
            return d === !1;
          case Ut:
            return isNaN(d);
          case er:
            return isNaN(d) || d < 1;
        }
      return !1;
    }
    function Wa(c) {
      return Ar.hasOwnProperty(c) ? Ar[c] : null;
    }
    function Lr(c, d, x, E, D, I, F) {
      this.acceptsBooleans = d === xr || d === Un || d === Qt, this.attributeName = E, this.attributeNamespace = D, this.mustUseProperty = x, this.propertyName = c, this.type = d, this.sanitizeURL = I, this.removeEmptyString = F;
    }
    var Ar = {}, Ks = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ks.forEach(function(c) {
      Ar[c] = new Lr(
        c,
        gr,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
      var d = c[0], x = c[1];
      Ar[d] = new Lr(
        d,
        Zn,
        !1,
        // mustUseProperty
        x,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        xr,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        xr,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        Un,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        Un,
        !0,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        Qt,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        er,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        Ut,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ws = /[\-\:]([a-z])/g, Ql = function(c) {
      return c[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var d = c.replace(ws, Ql);
      Ar[d] = new Lr(
        d,
        Zn,
        !1,
        // mustUseProperty
        c,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var d = c.replace(ws, Ql);
      Ar[d] = new Lr(
        d,
        Zn,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var d = c.replace(ws, Ql);
      Ar[d] = new Lr(
        d,
        Zn,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        Zn,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Lc = "xlinkHref";
    Ar[Lc] = new Lr(
      "xlinkHref",
      Zn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(c) {
      Ar[c] = new Lr(
        c,
        Zn,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var zc = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Xl = !1;
    function Fc(c) {
      !Xl && zc.test(c) && (Xl = !0, a("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(c)));
    }
    function _s(c, d, x, E) {
      if (E.mustUseProperty) {
        var D = E.propertyName;
        return c[D];
      } else {
        mn(x, d), E.sanitizeURL && Fc("" + x);
        var I = E.attributeName, F = null;
        if (E.type === Qt) {
          if (c.hasAttribute(I)) {
            var G = c.getAttribute(I);
            return G === "" ? !0 : Zr(d, x, E, !1) ? G : G === "" + x ? x : G;
          }
        } else if (c.hasAttribute(I)) {
          if (Zr(d, x, E, !1))
            return c.getAttribute(I);
          if (E.type === Un)
            return x;
          F = c.getAttribute(I);
        }
        return Zr(d, x, E, !1) ? F === null ? x : F : F === "" + x ? x : F;
      }
    }
    function as(c, d, x, E) {
      {
        if (!di(d))
          return;
        if (!c.hasAttribute(d))
          return x === void 0 ? void 0 : null;
        var D = c.getAttribute(d);
        return mn(x, d), D === "" + x ? x : D;
      }
    }
    function Es(c, d, x, E) {
      var D = Wa(d);
      if (!bi(d, D, E)) {
        if (Zr(d, x, D, E) && (x = null), E || D === null) {
          if (di(d)) {
            var I = d;
            x === null ? c.removeAttribute(I) : (mn(x, d), c.setAttribute(I, "" + x));
          }
          return;
        }
        var F = D.mustUseProperty;
        if (F) {
          var G = D.propertyName;
          if (x === null) {
            var J = D.type;
            c[G] = J === Un ? !1 : "";
          } else
            c[G] = x;
          return;
        }
        var le = D.attributeName, de = D.attributeNamespace;
        if (x === null)
          c.removeAttribute(le);
        else {
          var De = D.type, Ce;
          De === Un || De === Qt && x === !0 ? Ce = "" : (mn(x, le), Ce = "" + x, D.sanitizeURL && Fc(Ce.toString())), de ? c.setAttributeNS(de, le, Ce) : c.setAttribute(le, Ce);
        }
      }
    }
    var xa = Symbol.for("react.element"), la = Symbol.for("react.portal"), Hi = Symbol.for("react.fragment"), ss = Symbol.for("react.strict_mode"), xe = Symbol.for("react.profiler"), lt = Symbol.for("react.provider"), St = Symbol.for("react.context"), $t = Symbol.for("react.forward_ref"), In = Symbol.for("react.suspense"), lr = Symbol.for("react.suspense_list"), zn = Symbol.for("react.memo"), sn = Symbol.for("react.lazy"), No = Symbol.for("react.scope"), xi = Symbol.for("react.debug_trace_mode"), wi = Symbol.for("react.offscreen"), nn = Symbol.for("react.legacy_hidden"), Oi = Symbol.for("react.cache"), lm = Symbol.for("react.tracing_marker"), mr = Symbol.iterator, Vw = "@@iterator";
    function Kl(c) {
      if (c === null || typeof c != "object")
        return null;
      var d = mr && c[mr] || c[Vw];
      return typeof d == "function" ? d : null;
    }
    var cr = Object.assign, Zl = 0, Uf, Np, qd, Zs, vv, Ss, cm;
    function fm() {
    }
    fm.__reactDisabledLog = !0;
    function bv() {
      {
        if (Zl === 0) {
          Uf = console.log, Np = console.info, qd = console.warn, Zs = console.error, vv = console.group, Ss = console.groupCollapsed, cm = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: fm,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        Zl++;
      }
    }
    function Gd() {
      {
        if (Zl--, Zl === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: cr({}, c, {
              value: Uf
            }),
            info: cr({}, c, {
              value: Np
            }),
            warn: cr({}, c, {
              value: qd
            }),
            error: cr({}, c, {
              value: Zs
            }),
            group: cr({}, c, {
              value: vv
            }),
            groupCollapsed: cr({}, c, {
              value: Ss
            }),
            groupEnd: cr({}, c, {
              value: cm
            })
          });
        }
        Zl < 0 && a("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Qd = n.ReactCurrentDispatcher, sl;
    function wa(c, d, x) {
      {
        if (sl === void 0)
          try {
            throw Error();
          } catch (D) {
            var E = D.stack.trim().match(/\n( *(at )?)/);
            sl = E && E[1] || "";
          }
        return `
` + sl + c;
      }
    }
    var Yf = !1, Xd;
    {
      var Hf = typeof WeakMap == "function" ? WeakMap : Map;
      Xd = new Hf();
    }
    function Dp(c, d) {
      if (!c || Yf)
        return "";
      {
        var x = Xd.get(c);
        if (x !== void 0)
          return x;
      }
      var E;
      Yf = !0;
      var D = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var I;
      I = Qd.current, Qd.current = null, bv();
      try {
        if (d) {
          var F = function() {
            throw Error();
          };
          if (Object.defineProperty(F.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(F, []);
            } catch (Ve) {
              E = Ve;
            }
            Reflect.construct(c, [], F);
          } else {
            try {
              F.call();
            } catch (Ve) {
              E = Ve;
            }
            c.call(F.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ve) {
            E = Ve;
          }
          c();
        }
      } catch (Ve) {
        if (Ve && E && typeof Ve.stack == "string") {
          for (var G = Ve.stack.split(`
`), J = E.stack.split(`
`), le = G.length - 1, de = J.length - 1; le >= 1 && de >= 0 && G[le] !== J[de]; )
            de--;
          for (; le >= 1 && de >= 0; le--, de--)
            if (G[le] !== J[de]) {
              if (le !== 1 || de !== 1)
                do
                  if (le--, de--, de < 0 || G[le] !== J[de]) {
                    var De = `
` + G[le].replace(" at new ", " at ");
                    return c.displayName && De.includes("<anonymous>") && (De = De.replace("<anonymous>", c.displayName)), typeof c == "function" && Xd.set(c, De), De;
                  }
                while (le >= 1 && de >= 0);
              break;
            }
        }
      } finally {
        Yf = !1, Qd.current = I, Gd(), Error.prepareStackTrace = D;
      }
      var Ce = c ? c.displayName || c.name : "", Ue = Ce ? wa(Ce) : "";
      return typeof c == "function" && Xd.set(c, Ue), Ue;
    }
    function Kd(c, d, x) {
      return Dp(c, !0);
    }
    function Vf(c, d, x) {
      return Dp(c, !1);
    }
    function $b(c) {
      var d = c.prototype;
      return !!(d && d.isReactComponent);
    }
    function ul(c, d, x) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return Dp(c, $b(c));
      if (typeof c == "string")
        return wa(c);
      switch (c) {
        case In:
          return wa("Suspense");
        case lr:
          return wa("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case $t:
            return Vf(c.render);
          case zn:
            return ul(c.type, d, x);
          case sn: {
            var E = c, D = E._payload, I = E._init;
            try {
              return ul(I(D), d, x);
            } catch {
            }
          }
        }
      return "";
    }
    function Or(c) {
      switch (c._debugOwner && c._debugOwner.type, c._debugSource, c.tag) {
        case g:
          return wa(c.type);
        case z:
          return wa("Lazy");
        case R:
          return wa("Suspense");
        case V:
          return wa("SuspenseList");
        case u:
        case f:
        case $:
          return Vf(c.type);
        case A:
          return Vf(c.type.render);
        case l:
          return Kd(c.type);
        default:
          return "";
      }
    }
    function Jl(c) {
      try {
        var d = "", x = c;
        do
          d += Or(x), x = x.return;
        while (x);
        return d;
      } catch (E) {
        return `
Error generating stack: ` + E.message + `
` + E.stack;
      }
    }
    function Zd(c, d, x) {
      var E = c.displayName;
      if (E)
        return E;
      var D = d.displayName || d.name || "";
      return D !== "" ? x + "(" + D + ")" : x;
    }
    function Ap(c) {
      return c.displayName || "Context";
    }
    function Rr(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && a("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case Hi:
          return "Fragment";
        case la:
          return "Portal";
        case xe:
          return "Profiler";
        case ss:
          return "StrictMode";
        case In:
          return "Suspense";
        case lr:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case St:
            var d = c;
            return Ap(d) + ".Consumer";
          case lt:
            var x = c;
            return Ap(x._context) + ".Provider";
          case $t:
            return Zd(c, c.render, "ForwardRef");
          case zn:
            var E = c.displayName || null;
            return E !== null ? E : Rr(c.type) || "Memo";
          case sn: {
            var D = c, I = D._payload, F = D._init;
            try {
              return Rr(F(I));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Op(c, d, x) {
      var E = d.displayName || d.name || "";
      return c.displayName || (E !== "" ? x + "(" + E + ")" : x);
    }
    function Rp(c) {
      return c.displayName || "Context";
    }
    function jn(c) {
      var d = c.tag, x = c.type;
      switch (d) {
        case q:
          return "Cache";
        case S:
          var E = x;
          return Rp(E) + ".Consumer";
        case C:
          var D = x;
          return Rp(D._context) + ".Provider";
        case Y:
          return "DehydratedFragment";
        case A:
          return Op(x, x.render, "ForwardRef");
        case b:
          return "Fragment";
        case g:
          return x;
        case p:
          return "Portal";
        case h:
          return "Root";
        case y:
          return "Text";
        case z:
          return Rr(x);
        case _:
          return x === ss ? "StrictMode" : "Mode";
        case K:
          return "Offscreen";
        case O:
          return "Profiler";
        case ee:
          return "Scope";
        case R:
          return "Suspense";
        case V:
          return "SuspenseList";
        case te:
          return "TracingMarker";
        case l:
        case u:
        case W:
        case f:
        case j:
        case $:
          if (typeof x == "function")
            return x.displayName || x.name || null;
          if (typeof x == "string")
            return x;
          break;
      }
      return null;
    }
    var Jd = n.ReactDebugCurrentFrame, vo = null, Js = !1;
    function Ms() {
      {
        if (vo === null)
          return null;
        var c = vo._debugOwner;
        if (c !== null && typeof c < "u")
          return jn(c);
      }
      return null;
    }
    function Wf() {
      return vo === null ? "" : Jl(vo);
    }
    function Do() {
      Jd.getCurrentStack = null, vo = null, Js = !1;
    }
    function ii(c) {
      Jd.getCurrentStack = c === null ? null : Wf, vo = c, Js = !1;
    }
    function Pb() {
      return vo;
    }
    function eu(c) {
      Js = c;
    }
    function Ko(c) {
      return "" + c;
    }
    function Bc(c) {
      switch (typeof c) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return c;
        case "object":
          return fn(c), c;
        default:
          return "";
      }
    }
    var Ib = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function qf(c, d) {
      Ib[d.type] || d.onChange || d.onInput || d.readOnly || d.disabled || d.value == null || a("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), d.onChange || d.readOnly || d.disabled || d.checked == null || a("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function eh(c) {
      var d = c.type, x = c.nodeName;
      return x && x.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
    }
    function jb(c) {
      return c._valueTracker;
    }
    function wr(c) {
      c._valueTracker = null;
    }
    function zr(c) {
      var d = "";
      return c && (eh(c) ? d = c.checked ? "true" : "false" : d = c.value), d;
    }
    function th(c) {
      var d = eh(c) ? "checked" : "value", x = Object.getOwnPropertyDescriptor(c.constructor.prototype, d);
      fn(c[d]);
      var E = "" + c[d];
      if (!(c.hasOwnProperty(d) || typeof x > "u" || typeof x.get != "function" || typeof x.set != "function")) {
        var D = x.get, I = x.set;
        Object.defineProperty(c, d, {
          configurable: !0,
          get: function() {
            return D.call(this);
          },
          set: function(G) {
            fn(G), E = "" + G, I.call(this, G);
          }
        }), Object.defineProperty(c, d, {
          enumerable: x.enumerable
        });
        var F = {
          getValue: function() {
            return E;
          },
          setValue: function(G) {
            fn(G), E = "" + G;
          },
          stopTracking: function() {
            wr(c), delete c[d];
          }
        };
        return F;
      }
    }
    function ll(c) {
      jb(c) || (c._valueTracker = th(c));
    }
    function dm(c) {
      if (!c)
        return !1;
      var d = jb(c);
      if (!d)
        return !0;
      var x = d.getValue(), E = zr(c);
      return E !== x ? (d.setValue(E), !0) : !1;
    }
    function nh(c) {
      if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u")
        return null;
      try {
        return c.activeElement || c.body;
      } catch {
        return c.body;
      }
    }
    var rh = !1, kp = !1, $p = !1, xv = !1;
    function Ri(c) {
      var d = c.type === "checkbox" || c.type === "radio";
      return d ? c.checked != null : c.value != null;
    }
    function ne(c, d) {
      var x = c, E = d.checked, D = cr({}, d, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: E ?? x._wrapperState.initialChecked
      });
      return D;
    }
    function be(c, d) {
      qf("input", d), d.checked !== void 0 && d.defaultChecked !== void 0 && !kp && (a("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Ms() || "A component", d.type), kp = !0), d.value !== void 0 && d.defaultValue !== void 0 && !rh && (a("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Ms() || "A component", d.type), rh = !0);
      var x = c, E = d.defaultValue == null ? "" : d.defaultValue;
      x._wrapperState = {
        initialChecked: d.checked != null ? d.checked : d.defaultChecked,
        initialValue: Bc(d.value != null ? d.value : E),
        controlled: Ri(d)
      };
    }
    function Be(c, d) {
      var x = c, E = d.checked;
      E != null && Es(x, "checked", E, !1);
    }
    function qe(c, d) {
      var x = c;
      {
        var E = Ri(d);
        !x._wrapperState.controlled && E && !xv && (a("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), xv = !0), x._wrapperState.controlled && !E && !$p && (a("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), $p = !0);
      }
      Be(c, d);
      var D = Bc(d.value), I = d.type;
      if (D != null)
        I === "number" ? (D === 0 && x.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        x.value != D) && (x.value = Ko(D)) : x.value !== Ko(D) && (x.value = Ko(D));
      else if (I === "submit" || I === "reset") {
        x.removeAttribute("value");
        return;
      }
      d.hasOwnProperty("value") ? dn(x, d.type, D) : d.hasOwnProperty("defaultValue") && dn(x, d.type, Bc(d.defaultValue)), d.checked == null && d.defaultChecked != null && (x.defaultChecked = !!d.defaultChecked);
    }
    function gt(c, d, x) {
      var E = c;
      if (d.hasOwnProperty("value") || d.hasOwnProperty("defaultValue")) {
        var D = d.type, I = D === "submit" || D === "reset";
        if (I && (d.value === void 0 || d.value === null))
          return;
        var F = Ko(E._wrapperState.initialValue);
        x || F !== E.value && (E.value = F), E.defaultValue = F;
      }
      var G = E.name;
      G !== "" && (E.name = ""), E.defaultChecked = !E.defaultChecked, E.defaultChecked = !!E._wrapperState.initialChecked, G !== "" && (E.name = G);
    }
    function gn(c, d) {
      var x = c;
      qe(x, d), Dt(x, d);
    }
    function Dt(c, d) {
      var x = d.name;
      if (d.type === "radio" && x != null) {
        for (var E = c; E.parentNode; )
          E = E.parentNode;
        mn(x, "name");
        for (var D = E.querySelectorAll("input[name=" + JSON.stringify("" + x) + '][type="radio"]'), I = 0; I < D.length; I++) {
          var F = D[I];
          if (!(F === c || F.form !== c.form)) {
            var G = Sn(F);
            if (!G)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            dm(F), qe(F, G);
          }
        }
      }
    }
    function dn(c, d, x) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (d !== "number" || nh(c.ownerDocument) !== c) && (x == null ? c.defaultValue = Ko(c._wrapperState.initialValue) : c.defaultValue !== Ko(x) && (c.defaultValue = Ko(x)));
    }
    var sr = !1, Tr = !1, _i = !1;
    function tr(c, d) {
      d.value == null && (typeof d.children == "object" && d.children !== null ? e.Children.forEach(d.children, function(x) {
        x != null && (typeof x == "string" || typeof x == "number" || Tr || (Tr = !0, a("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : d.dangerouslySetInnerHTML != null && (_i || (_i = !0, a("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), d.selected != null && !sr && (a("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), sr = !0);
    }
    function ki(c, d) {
      d.value != null && c.setAttribute("value", Ko(Bc(d.value)));
    }
    var yr = Array.isArray;
    function _r(c) {
      return yr(c);
    }
    var Uc;
    Uc = !1;
    function Eu() {
      var c = Ms();
      return c ? `

Check the render method of \`` + c + "`." : "";
    }
    var ih = ["value", "defaultValue"];
    function wv(c) {
      {
        qf("select", c);
        for (var d = 0; d < ih.length; d++) {
          var x = ih[d];
          if (c[x] != null) {
            var E = _r(c[x]);
            c.multiple && !E ? a("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", x, Eu()) : !c.multiple && E && a("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", x, Eu());
          }
        }
      }
    }
    function kr(c, d, x, E) {
      var D = c.options;
      if (d) {
        for (var I = x, F = {}, G = 0; G < I.length; G++)
          F["$" + I[G]] = !0;
        for (var J = 0; J < D.length; J++) {
          var le = F.hasOwnProperty("$" + D[J].value);
          D[J].selected !== le && (D[J].selected = le), le && E && (D[J].defaultSelected = !0);
        }
      } else {
        for (var de = Ko(Bc(x)), De = null, Ce = 0; Ce < D.length; Ce++) {
          if (D[Ce].value === de) {
            D[Ce].selected = !0, E && (D[Ce].defaultSelected = !0);
            return;
          }
          De === null && !D[Ce].disabled && (De = D[Ce]);
        }
        De !== null && (De.selected = !0);
      }
    }
    function cl(c, d) {
      return cr({}, d, {
        value: void 0
      });
    }
    function Pp(c, d) {
      var x = c;
      wv(d), x._wrapperState = {
        wasMultiple: !!d.multiple
      }, d.value !== void 0 && d.defaultValue !== void 0 && !Uc && (a("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Uc = !0);
    }
    function Ww(c, d) {
      var x = c;
      x.multiple = !!d.multiple;
      var E = d.value;
      E != null ? kr(x, !!d.multiple, E, !1) : d.defaultValue != null && kr(x, !!d.multiple, d.defaultValue, !0);
    }
    function qw(c, d) {
      var x = c, E = x._wrapperState.wasMultiple;
      x._wrapperState.wasMultiple = !!d.multiple;
      var D = d.value;
      D != null ? kr(x, !!d.multiple, D, !1) : E !== !!d.multiple && (d.defaultValue != null ? kr(x, !!d.multiple, d.defaultValue, !0) : kr(x, !!d.multiple, d.multiple ? [] : "", !1));
    }
    function WN(c, d) {
      var x = c, E = d.value;
      E != null && kr(x, !!d.multiple, E, !1);
    }
    var Gw = !1;
    function Qw(c, d) {
      var x = c;
      if (d.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var E = cr({}, d, {
        value: void 0,
        defaultValue: void 0,
        children: Ko(x._wrapperState.initialValue)
      });
      return E;
    }
    function Xw(c, d) {
      var x = c;
      qf("textarea", d), d.value !== void 0 && d.defaultValue !== void 0 && !Gw && (a("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Ms() || "A component"), Gw = !0);
      var E = d.value;
      if (E == null) {
        var D = d.children, I = d.defaultValue;
        if (D != null) {
          a("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (I != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (_r(D)) {
              if (D.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              D = D[0];
            }
            I = D;
          }
        }
        I == null && (I = ""), E = I;
      }
      x._wrapperState = {
        initialValue: Bc(E)
      };
    }
    function _v(c, d) {
      var x = c, E = Bc(d.value), D = Bc(d.defaultValue);
      if (E != null) {
        var I = Ko(E);
        I !== x.value && (x.value = I), d.defaultValue == null && x.defaultValue !== I && (x.defaultValue = I);
      }
      D != null && (x.defaultValue = Ko(D));
    }
    function Ip(c, d) {
      var x = c, E = x.textContent;
      E === x._wrapperState.initialValue && E !== "" && E !== null && (x.value = E);
    }
    function Kw(c, d) {
      _v(c, d);
    }
    var Yc = "http://www.w3.org/1999/xhtml", b2 = "http://www.w3.org/1998/Math/MathML", Ev = "http://www.w3.org/2000/svg";
    function hm(c) {
      switch (c) {
        case "svg":
          return Ev;
        case "math":
          return b2;
        default:
          return Yc;
      }
    }
    function Lb(c, d) {
      return c == null || c === Yc ? hm(d) : c === Ev && d === "foreignObject" ? Yc : c;
    }
    var qN = function(c) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(d, x, E, D) {
        MSApp.execUnsafeLocalFunction(function() {
          return c(d, x, E, D);
        });
      } : c;
    }, pm, zb = qN(function(c, d) {
      if (c.namespaceURI === Ev && !("innerHTML" in c)) {
        pm = pm || document.createElement("div"), pm.innerHTML = "<svg>" + d.valueOf().toString() + "</svg>";
        for (var x = pm.firstChild; c.firstChild; )
          c.removeChild(c.firstChild);
        for (; x.firstChild; )
          c.appendChild(x.firstChild);
        return;
      }
      c.innerHTML = d;
    }), tu = 1, Hc = 3, Wr = 8, Su = 9, ec = 11, Sv = function(c, d) {
      if (d) {
        var x = c.firstChild;
        if (x && x === c.lastChild && x.nodeType === Hc) {
          x.nodeValue = d;
          return;
        }
      }
      c.textContent = d;
    }, Zw = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, gm = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function x2(c, d) {
      return c + d.charAt(0).toUpperCase() + d.substring(1);
    }
    var w2 = ["Webkit", "ms", "Moz", "O"];
    Object.keys(gm).forEach(function(c) {
      w2.forEach(function(d) {
        gm[x2(d, c)] = gm[c];
      });
    });
    function Fb(c, d, x) {
      var E = d == null || typeof d == "boolean" || d === "";
      return E ? "" : !x && typeof d == "number" && d !== 0 && !(gm.hasOwnProperty(c) && gm[c]) ? d + "px" : (Zt(d, c), ("" + d).trim());
    }
    var mm = /([A-Z])/g, ym = /^ms-/;
    function GN(c) {
      return c.replace(mm, "-$1").toLowerCase().replace(ym, "-ms-");
    }
    var _2 = function() {
    };
    {
      var Bb = /^(?:webkit|moz|o)[A-Z]/, Jw = /^-ms-/, fl = /-(.)/g, Gf = /;\s*$/, vm = {}, bm = {}, E2 = !1, oh = !1, Mu = function(c) {
        return c.replace(fl, function(d, x) {
          return x.toUpperCase();
        });
      }, Ub = function(c) {
        vm.hasOwnProperty(c) && vm[c] || (vm[c] = !0, a(
          "Unsupported style property %s. Did you mean %s?",
          c,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Mu(c.replace(Jw, "ms-"))
        ));
      }, S2 = function(c) {
        vm.hasOwnProperty(c) && vm[c] || (vm[c] = !0, a("Unsupported vendor-prefixed style property %s. Did you mean %s?", c, c.charAt(0).toUpperCase() + c.slice(1)));
      }, M2 = function(c, d) {
        bm.hasOwnProperty(d) && bm[d] || (bm[d] = !0, a(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, c, d.replace(Gf, "")));
      }, T2 = function(c, d) {
        E2 || (E2 = !0, a("`NaN` is an invalid value for the `%s` css style property.", c));
      }, QN = function(c, d) {
        oh || (oh = !0, a("`Infinity` is an invalid value for the `%s` css style property.", c));
      };
      _2 = function(c, d) {
        c.indexOf("-") > -1 ? Ub(c) : Bb.test(c) ? S2(c) : Gf.test(d) && M2(c, d), typeof d == "number" && (isNaN(d) ? T2(c, d) : isFinite(d) || QN(c, d));
      };
    }
    var XN = _2;
    function xm(c) {
      {
        var d = "", x = "";
        for (var E in c)
          if (c.hasOwnProperty(E)) {
            var D = c[E];
            if (D != null) {
              var I = E.indexOf("--") === 0;
              d += x + (I ? E : GN(E)) + ":", d += Fb(E, D, I), x = ";";
            }
          }
        return d || null;
      }
    }
    function Ae(c, d) {
      var x = c.style;
      for (var E in d)
        if (d.hasOwnProperty(E)) {
          var D = E.indexOf("--") === 0;
          D || XN(E, d[E]);
          var I = Fb(E, d[E], D);
          E === "float" && (E = "cssFloat"), D ? x.setProperty(E, I) : x[E] = I;
        }
    }
    function Ke(c) {
      return c == null || typeof c == "boolean" || c === "";
    }
    function Fe(c) {
      var d = {};
      for (var x in c)
        for (var E = Zw[x] || [x], D = 0; D < E.length; D++)
          d[E[D]] = x;
      return d;
    }
    function It(c, d) {
      {
        if (!d)
          return;
        var x = Fe(c), E = Fe(d), D = {};
        for (var I in x) {
          var F = x[I], G = E[I];
          if (G && F !== G) {
            var J = F + "," + G;
            if (D[J])
              continue;
            D[J] = !0, a("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Ke(c[F]) ? "Removing" : "Updating", F, G);
          }
        }
      }
    }
    var Yn = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, qr = cr({
      menuitem: !0
    }, Yn), Zo = "__html";
    function oi(c, d) {
      if (d) {
        if (qr[c] && (d.children != null || d.dangerouslySetInnerHTML != null))
          throw new Error(c + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (d.dangerouslySetInnerHTML != null) {
          if (d.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof d.dangerouslySetInnerHTML != "object" || !(Zo in d.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!d.suppressContentEditableWarning && d.contentEditable && d.children != null && a("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), d.style != null && typeof d.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function tc(c, d) {
      if (c.indexOf("-") === -1)
        return typeof d.is == "string";
      switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Yb = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Tu = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, nu = {}, e_ = new RegExp("^(aria)-[" + ht + "]*$"), Vc = new RegExp("^(aria)[A-Z][" + ht + "]*$");
    function wm(c, d) {
      {
        if ($e.call(nu, d) && nu[d])
          return !0;
        if (Vc.test(d)) {
          var x = "aria-" + d.slice(4).toLowerCase(), E = Tu.hasOwnProperty(x) ? x : null;
          if (E == null)
            return a("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", d), nu[d] = !0, !0;
          if (d !== E)
            return a("Invalid ARIA attribute `%s`. Did you mean `%s`?", d, E), nu[d] = !0, !0;
        }
        if (e_.test(d)) {
          var D = d.toLowerCase(), I = Tu.hasOwnProperty(D) ? D : null;
          if (I == null)
            return nu[d] = !0, !1;
          if (d !== I)
            return a("Unknown ARIA attribute `%s`. Did you mean `%s`?", d, I), nu[d] = !0, !0;
        }
      }
      return !0;
    }
    function Mv(c, d) {
      {
        var x = [];
        for (var E in d) {
          var D = wm(c, E);
          D || x.push(E);
        }
        var I = x.map(function(F) {
          return "`" + F + "`";
        }).join(", ");
        x.length === 1 ? a("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", I, c) : x.length > 1 && a("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", I, c);
      }
    }
    function Gr(c, d) {
      tc(c, d) || Mv(c, d);
    }
    var jp = !1;
    function Hb(c, d) {
      {
        if (c !== "input" && c !== "textarea" && c !== "select")
          return;
        d != null && d.value === null && !jp && (jp = !0, c === "select" && d.multiple ? a("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", c) : a("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", c));
      }
    }
    var _m = function() {
    };
    {
      var _a = {}, t_ = /^on./, C2 = /^on[^A-Z]/, Tv = new RegExp("^(aria)-[" + ht + "]*$"), Qf = new RegExp("^(aria)[A-Z][" + ht + "]*$");
      _m = function(c, d, x, E) {
        if ($e.call(_a, d) && _a[d])
          return !0;
        var D = d.toLowerCase();
        if (D === "onfocusin" || D === "onfocusout")
          return a("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), _a[d] = !0, !0;
        if (E != null) {
          var I = E.registrationNameDependencies, F = E.possibleRegistrationNames;
          if (I.hasOwnProperty(d))
            return !0;
          var G = F.hasOwnProperty(D) ? F[D] : null;
          if (G != null)
            return a("Invalid event handler property `%s`. Did you mean `%s`?", d, G), _a[d] = !0, !0;
          if (t_.test(d))
            return a("Unknown event handler property `%s`. It will be ignored.", d), _a[d] = !0, !0;
        } else if (t_.test(d))
          return C2.test(d) && a("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", d), _a[d] = !0, !0;
        if (Tv.test(d) || Qf.test(d))
          return !0;
        if (D === "innerhtml")
          return a("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), _a[d] = !0, !0;
        if (D === "aria")
          return a("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), _a[d] = !0, !0;
        if (D === "is" && x !== null && x !== void 0 && typeof x != "string")
          return a("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof x), _a[d] = !0, !0;
        if (typeof x == "number" && isNaN(x))
          return a("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", d), _a[d] = !0, !0;
        var J = Wa(d), le = J !== null && J.type === gr;
        if (Yb.hasOwnProperty(D)) {
          var de = Yb[D];
          if (de !== d)
            return a("Invalid DOM property `%s`. Did you mean `%s`?", d, de), _a[d] = !0, !0;
        } else if (!le && d !== D)
          return a("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", d, D), _a[d] = !0, !0;
        return typeof x == "boolean" && ua(d, x, J, !1) ? (x ? a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', x, d, d, x, d) : a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', x, d, d, x, d, d, d), _a[d] = !0, !0) : le ? !0 : ua(d, x, J, !1) ? (_a[d] = !0, !1) : ((x === "false" || x === "true") && J !== null && J.type === Un && (a("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", x, d, x === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', d, x), _a[d] = !0), !0);
      };
    }
    var Cv = function(c, d, x) {
      {
        var E = [];
        for (var D in d) {
          var I = _m(c, D, d[D], x);
          I || E.push(D);
        }
        var F = E.map(function(G) {
          return "`" + G + "`";
        }).join(", ");
        E.length === 1 ? a("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", F, c) : E.length > 1 && a("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", F, c);
      }
    };
    function n_(c, d, x) {
      tc(c, d) || Cv(c, d, x);
    }
    var dl = 1, Em = 2, ah = 4, Vb = dl | Em | ah, Sm = null;
    function Xf(c) {
      Sm !== null && a("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Sm = c;
    }
    function Lp() {
      Sm === null && a("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Sm = null;
    }
    function Nv(c) {
      return c === Sm;
    }
    function Wb(c) {
      var d = c.target || c.srcElement || window;
      return d.correspondingUseElement && (d = d.correspondingUseElement), d.nodeType === Hc ? d.parentNode : d;
    }
    var $i = null, sh = null, hl = null;
    function Kf(c) {
      var d = Nt(c);
      if (d) {
        if (typeof $i != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var x = d.stateNode;
        if (x) {
          var E = Sn(x);
          $i(d.stateNode, d.type, E);
        }
      }
    }
    function qb(c) {
      $i = c;
    }
    function Gb(c) {
      sh ? hl ? hl.push(c) : hl = [c] : sh = c;
    }
    function Mm() {
      return sh !== null || hl !== null;
    }
    function Dv() {
      if (sh) {
        var c = sh, d = hl;
        if (sh = null, hl = null, Kf(c), d)
          for (var x = 0; x < d.length; x++)
            Kf(d[x]);
      }
    }
    var zp = function(c, d) {
      return c(d);
    }, zo = function() {
    }, Ea = !1;
    function KN() {
      var c = Mm();
      c && (zo(), Dv());
    }
    function r_(c, d, x) {
      if (Ea)
        return c(d, x);
      Ea = !0;
      try {
        return zp(c, d, x);
      } finally {
        Ea = !1, KN();
      }
    }
    function Av(c, d, x) {
      zp = c, zo = x;
    }
    function Qb(c) {
      return c === "button" || c === "input" || c === "select" || c === "textarea";
    }
    function Ov(c, d, x) {
      switch (c) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(x.disabled && Qb(d));
        default:
          return !1;
      }
    }
    function nc(c, d) {
      var x = c.stateNode;
      if (x === null)
        return null;
      var E = Sn(x);
      if (E === null)
        return null;
      var D = E[d];
      if (Ov(d, c.type, E))
        return null;
      if (D && typeof D != "function")
        throw new Error("Expected `" + d + "` listener to be a function, instead got a value of `" + typeof D + "` type.");
      return D;
    }
    var Fp = !1;
    if (Qe)
      try {
        var pl = {};
        Object.defineProperty(pl, "passive", {
          get: function() {
            Fp = !0;
          }
        }), window.addEventListener("test", pl, pl), window.removeEventListener("test", pl, pl);
      } catch {
        Fp = !1;
      }
    function Tm(c, d, x, E, D, I, F, G, J) {
      var le = Array.prototype.slice.call(arguments, 3);
      try {
        d.apply(x, le);
      } catch (de) {
        this.onError(de);
      }
    }
    var Bp = Tm;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Cm = document.createElement("react");
      Bp = function(d, x, E, D, I, F, G, J, le) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var de = document.createEvent("Event"), De = !1, Ce = !0, Ue = window.event, Ve = Object.getOwnPropertyDescriptor(window, "event");
        function Ze() {
          Cm.removeEventListener(Je, yn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ue);
        }
        var Yt = Array.prototype.slice.call(arguments, 3);
        function yn() {
          De = !0, Ze(), x.apply(E, Yt), Ce = !1;
        }
        var on, Yr = !1, Nr = !1;
        function je(Le) {
          if (on = Le.error, Yr = !0, on === null && Le.colno === 0 && Le.lineno === 0 && (Nr = !0), Le.defaultPrevented && on != null && typeof on == "object")
            try {
              on._suppressLogging = !0;
            } catch {
            }
        }
        var Je = "react-" + (d || "invokeguardedcallback");
        if (window.addEventListener("error", je), Cm.addEventListener(Je, yn, !1), de.initEvent(Je, !1, !1), Cm.dispatchEvent(de), Ve && Object.defineProperty(window, "event", Ve), De && Ce && (Yr ? Nr && (on = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : on = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(on)), window.removeEventListener("error", je), !De)
          return Ze(), Tm.apply(this, arguments);
      };
    }
    var Nm = Bp, uh = !1, rc = null, Rv = !1, lh = null, Wc = {
      onError: function(c) {
        uh = !0, rc = c;
      }
    };
    function qc(c, d, x, E, D, I, F, G, J) {
      uh = !1, rc = null, Nm.apply(Wc, arguments);
    }
    function Cu(c, d, x, E, D, I, F, G, J) {
      if (qc.apply(this, arguments), uh) {
        var le = ch();
        Rv || (Rv = !0, lh = le);
      }
    }
    function Xb() {
      if (Rv) {
        var c = lh;
        throw Rv = !1, lh = null, c;
      }
    }
    function ue() {
      return uh;
    }
    function ch() {
      if (uh) {
        var c = rc;
        return uh = !1, rc = null, c;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ts(c) {
      return c._reactInternals;
    }
    function us(c) {
      return c._reactInternals !== void 0;
    }
    function nr(c, d) {
      c._reactInternals = d;
    }
    var cn = (
      /*                      */
      0
    ), fh = (
      /*                */
      1
    ), no = (
      /*                    */
      2
    ), Tn = (
      /*                       */
      4
    ), Jr = (
      /*                */
      16
    ), ai = (
      /*                 */
      32
    ), Gc = (
      /*                     */
      64
    ), An = (
      /*                   */
      128
    ), Ao = (
      /*            */
      256
    ), Oo = (
      /*                          */
      512
    ), gl = (
      /*                     */
      1024
    ), ao = (
      /*                      */
      2048
    ), ml = (
      /*                    */
      4096
    ), dh = (
      /*                   */
      8192
    ), kv = (
      /*             */
      16384
    ), yl = ao | Tn | Gc | Oo | gl | kv, N2 = (
      /*               */
      32767
    ), Nu = (
      /*                   */
      32768
    ), Sa = (
      /*                */
      65536
    ), $v = (
      /* */
      131072
    ), i_ = (
      /*                       */
      1048576
    ), Zf = (
      /*                    */
      2097152
    ), ru = (
      /*                 */
      4194304
    ), hh = (
      /*                */
      8388608
    ), so = (
      /*               */
      16777216
    ), Up = (
      /*              */
      33554432
    ), Dm = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Tn | gl | 0
    ), iu = no | Tn | Jr | ai | Oo | ml | dh, ls = Tn | Gc | Oo | dh, vl = ao | Jr, Ma = ru | hh | Zf, Qc = n.ReactCurrentOwner;
    function Du(c) {
      var d = c, x = c;
      if (c.alternate)
        for (; d.return; )
          d = d.return;
      else {
        var E = d;
        do
          d = E, (d.flags & (no | ml)) !== cn && (x = d.return), E = d.return;
        while (E);
      }
      return d.tag === h ? x : null;
    }
    function o_(c) {
      if (c.tag === R) {
        var d = c.memoizedState;
        if (d === null) {
          var x = c.alternate;
          x !== null && (d = x.memoizedState);
        }
        if (d !== null)
          return d.dehydrated;
      }
      return null;
    }
    function Am(c) {
      return c.tag === h ? c.stateNode.containerInfo : null;
    }
    function Yp(c) {
      return Du(c) === c;
    }
    function cs(c) {
      {
        var d = Qc.current;
        if (d !== null && d.tag === l) {
          var x = d, E = x.stateNode;
          E._warnedAboutRefsInRender || a("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", jn(x) || "A component"), E._warnedAboutRefsInRender = !0;
        }
      }
      var D = Ts(c);
      return D ? Du(D) === D : !1;
    }
    function ou(c) {
      if (Du(c) !== c)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Vi(c) {
      var d = c.alternate;
      if (!d) {
        var x = Du(c);
        if (x === null)
          throw new Error("Unable to find node on an unmounted component.");
        return x !== c ? null : c;
      }
      for (var E = c, D = d; ; ) {
        var I = E.return;
        if (I === null)
          break;
        var F = I.alternate;
        if (F === null) {
          var G = I.return;
          if (G !== null) {
            E = D = G;
            continue;
          }
          break;
        }
        if (I.child === F.child) {
          for (var J = I.child; J; ) {
            if (J === E)
              return ou(I), c;
            if (J === D)
              return ou(I), d;
            J = J.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (E.return !== D.return)
          E = I, D = F;
        else {
          for (var le = !1, de = I.child; de; ) {
            if (de === E) {
              le = !0, E = I, D = F;
              break;
            }
            if (de === D) {
              le = !0, D = I, E = F;
              break;
            }
            de = de.sibling;
          }
          if (!le) {
            for (de = F.child; de; ) {
              if (de === E) {
                le = !0, E = F, D = I;
                break;
              }
              if (de === D) {
                le = !0, D = F, E = I;
                break;
              }
              de = de.sibling;
            }
            if (!le)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (E.alternate !== D)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (E.tag !== h)
        throw new Error("Unable to find node on an unmounted component.");
      return E.stateNode.current === E ? c : d;
    }
    function bl(c) {
      var d = Vi(c);
      return d !== null ? ic(d) : null;
    }
    function ic(c) {
      if (c.tag === g || c.tag === y)
        return c;
      for (var d = c.child; d !== null; ) {
        var x = ic(d);
        if (x !== null)
          return x;
        d = d.sibling;
      }
      return null;
    }
    function Kb(c) {
      var d = Vi(c);
      return d !== null ? Xc(d) : null;
    }
    function Xc(c) {
      if (c.tag === g || c.tag === y)
        return c;
      for (var d = c.child; d !== null; ) {
        if (d.tag !== p) {
          var x = Xc(d);
          if (x !== null)
            return x;
        }
        d = d.sibling;
      }
      return null;
    }
    var Cs = t.unstable_scheduleCallback, D2 = t.unstable_cancelCallback, Pv = t.unstable_shouldYield, a_ = t.unstable_requestPaint, Pi = t.unstable_now, Kc = t.unstable_getCurrentPriorityLevel, Iv = t.unstable_ImmediatePriority, Au = t.unstable_UserBlockingPriority, Ou = t.unstable_NormalPriority, Zb = t.unstable_LowPriority, Jf = t.unstable_IdlePriority, ca = t.unstable_yieldValue, jv = t.unstable_setDisableYieldValue, ed = null, Ii = null, Ct = null, uo = !1, bo = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Jb(c) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (d.isDisabled)
        return !0;
      if (!d.supportsFiber)
        return a("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ne && (c = cr({}, c, {
          getLaneLabelMap: gh,
          injectProfilingHooks: ac
        })), ed = d.inject(c), Ii = d;
      } catch (x) {
        a("React instrumentation encountered an error: %s.", x);
      }
      return !!d.checkDCE;
    }
    function fs(c, d) {
      if (Ii && typeof Ii.onScheduleFiberRoot == "function")
        try {
          Ii.onScheduleFiberRoot(ed, c, d);
        } catch (x) {
          uo || (uo = !0, a("React instrumentation encountered an error: %s", x));
        }
    }
    function oc(c, d) {
      if (Ii && typeof Ii.onCommitFiberRoot == "function")
        try {
          var x = (c.current.flags & An) === An;
          if (Oe) {
            var E;
            switch (d) {
              case Ta:
                E = Iv;
                break;
              case Ca:
                E = Au;
                break;
              case ho:
                E = Ou;
                break;
              case Zv:
                E = Jf;
                break;
              default:
                E = Ou;
                break;
            }
            Ii.onCommitFiberRoot(ed, c, E, x);
          }
        } catch (D) {
          uo || (uo = !0, a("React instrumentation encountered an error: %s", D));
        }
    }
    function ph(c) {
      if (Ii && typeof Ii.onPostCommitFiberRoot == "function")
        try {
          Ii.onPostCommitFiberRoot(ed, c);
        } catch (d) {
          uo || (uo = !0, a("React instrumentation encountered an error: %s", d));
        }
    }
    function s_(c) {
      if (Ii && typeof Ii.onCommitFiberUnmount == "function")
        try {
          Ii.onCommitFiberUnmount(ed, c);
        } catch (d) {
          uo || (uo = !0, a("React instrumentation encountered an error: %s", d));
        }
    }
    function fa(c) {
      if (typeof ca == "function" && (jv(c), i(c)), Ii && typeof Ii.setStrictMode == "function")
        try {
          Ii.setStrictMode(ed, c);
        } catch (d) {
          uo || (uo = !0, a("React instrumentation encountered an error: %s", d));
        }
    }
    function ac(c) {
      Ct = c;
    }
    function gh() {
      {
        for (var c = /* @__PURE__ */ new Map(), d = 1, x = 0; x < ro; x++) {
          var E = ZN(d);
          c.set(d, E), d *= 2;
        }
        return c;
      }
    }
    function mh(c) {
      Ct !== null && typeof Ct.markCommitStarted == "function" && Ct.markCommitStarted(c);
    }
    function e1() {
      Ct !== null && typeof Ct.markCommitStopped == "function" && Ct.markCommitStopped();
    }
    function yh(c) {
      Ct !== null && typeof Ct.markComponentRenderStarted == "function" && Ct.markComponentRenderStarted(c);
    }
    function Hp() {
      Ct !== null && typeof Ct.markComponentRenderStopped == "function" && Ct.markComponentRenderStopped();
    }
    function Om(c) {
      Ct !== null && typeof Ct.markComponentPassiveEffectMountStarted == "function" && Ct.markComponentPassiveEffectMountStarted(c);
    }
    function u_() {
      Ct !== null && typeof Ct.markComponentPassiveEffectMountStopped == "function" && Ct.markComponentPassiveEffectMountStopped();
    }
    function t1(c) {
      Ct !== null && typeof Ct.markComponentPassiveEffectUnmountStarted == "function" && Ct.markComponentPassiveEffectUnmountStarted(c);
    }
    function n1() {
      Ct !== null && typeof Ct.markComponentPassiveEffectUnmountStopped == "function" && Ct.markComponentPassiveEffectUnmountStopped();
    }
    function l_(c) {
      Ct !== null && typeof Ct.markComponentLayoutEffectMountStarted == "function" && Ct.markComponentLayoutEffectMountStarted(c);
    }
    function A2() {
      Ct !== null && typeof Ct.markComponentLayoutEffectMountStopped == "function" && Ct.markComponentLayoutEffectMountStopped();
    }
    function r1(c) {
      Ct !== null && typeof Ct.markComponentLayoutEffectUnmountStarted == "function" && Ct.markComponentLayoutEffectUnmountStarted(c);
    }
    function Rm() {
      Ct !== null && typeof Ct.markComponentLayoutEffectUnmountStopped == "function" && Ct.markComponentLayoutEffectUnmountStopped();
    }
    function Lv(c, d, x) {
      Ct !== null && typeof Ct.markComponentErrored == "function" && Ct.markComponentErrored(c, d, x);
    }
    function i1(c, d, x) {
      Ct !== null && typeof Ct.markComponentSuspended == "function" && Ct.markComponentSuspended(c, d, x);
    }
    function O2(c) {
      Ct !== null && typeof Ct.markLayoutEffectsStarted == "function" && Ct.markLayoutEffectsStarted(c);
    }
    function vh() {
      Ct !== null && typeof Ct.markLayoutEffectsStopped == "function" && Ct.markLayoutEffectsStopped();
    }
    function c_(c) {
      Ct !== null && typeof Ct.markPassiveEffectsStarted == "function" && Ct.markPassiveEffectsStarted(c);
    }
    function km() {
      Ct !== null && typeof Ct.markPassiveEffectsStopped == "function" && Ct.markPassiveEffectsStopped();
    }
    function xl(c) {
      Ct !== null && typeof Ct.markRenderStarted == "function" && Ct.markRenderStarted(c);
    }
    function bh() {
      Ct !== null && typeof Ct.markRenderYielded == "function" && Ct.markRenderYielded();
    }
    function $m() {
      Ct !== null && typeof Ct.markRenderStopped == "function" && Ct.markRenderStopped();
    }
    function xh(c) {
      Ct !== null && typeof Ct.markRenderScheduled == "function" && Ct.markRenderScheduled(c);
    }
    function o1(c, d) {
      Ct !== null && typeof Ct.markForceUpdateScheduled == "function" && Ct.markForceUpdateScheduled(c, d);
    }
    function wh(c, d) {
      Ct !== null && typeof Ct.markStateUpdateScheduled == "function" && Ct.markStateUpdateScheduled(c, d);
    }
    var hn = (
      /*                         */
      0
    ), fr = (
      /*                 */
      1
    ), pn = (
      /*                    */
      2
    ), lo = (
      /*               */
      8
    ), au = (
      /*              */
      16
    ), a1 = Math.clz32 ? Math.clz32 : Vp, Pm = Math.log, rr = Math.LN2;
    function Vp(c) {
      var d = c >>> 0;
      return d === 0 ? 32 : 31 - (Pm(d) / rr | 0) | 0;
    }
    var ro = 31, Xe = (
      /*                        */
      0
    ), Er = (
      /*                          */
      0
    ), En = (
      /*                        */
      1
    ), Zc = (
      /*    */
      2
    ), co = (
      /*             */
      4
    ), Wp = (
      /*            */
      8
    ), Ei = (
      /*                     */
      16
    ), td = (
      /*                */
      32
    ), nd = (
      /*                       */
      4194240
    ), _h = (
      /*                        */
      64
    ), fo = (
      /*                        */
      128
    ), Fo = (
      /*                        */
      256
    ), rd = (
      /*                        */
      512
    ), Im = (
      /*                        */
      1024
    ), Eh = (
      /*                        */
      2048
    ), zv = (
      /*                        */
      4096
    ), jm = (
      /*                        */
      8192
    ), Fv = (
      /*                        */
      16384
    ), Lm = (
      /*                       */
      32768
    ), zm = (
      /*                       */
      65536
    ), sc = (
      /*                       */
      131072
    ), s1 = (
      /*                       */
      262144
    ), uc = (
      /*                       */
      524288
    ), Sh = (
      /*                       */
      1048576
    ), Bv = (
      /*                       */
      2097152
    ), id = (
      /*                            */
      130023424
    ), od = (
      /*                             */
      4194304
    ), u1 = (
      /*                             */
      8388608
    ), Uv = (
      /*                             */
      16777216
    ), Yv = (
      /*                             */
      33554432
    ), Hv = (
      /*                             */
      67108864
    ), f_ = od, qp = (
      /*          */
      134217728
    ), Vv = (
      /*                          */
      268435455
    ), da = (
      /*               */
      268435456
    ), qa = (
      /*                        */
      536870912
    ), su = (
      /*                   */
      1073741824
    );
    function ZN(c) {
      {
        if (c & En)
          return "Sync";
        if (c & Zc)
          return "InputContinuousHydration";
        if (c & co)
          return "InputContinuous";
        if (c & Wp)
          return "DefaultHydration";
        if (c & Ei)
          return "Default";
        if (c & td)
          return "TransitionHydration";
        if (c & nd)
          return "Transition";
        if (c & id)
          return "Retry";
        if (c & qp)
          return "SelectiveHydration";
        if (c & da)
          return "IdleHydration";
        if (c & qa)
          return "Idle";
        if (c & su)
          return "Offscreen";
      }
    }
    var si = -1, ad = _h, Wv = od;
    function Gp(c) {
      switch (Ro(c)) {
        case En:
          return En;
        case Zc:
          return Zc;
        case co:
          return co;
        case Wp:
          return Wp;
        case Ei:
          return Ei;
        case td:
          return td;
        case _h:
        case fo:
        case Fo:
        case rd:
        case Im:
        case Eh:
        case zv:
        case jm:
        case Fv:
        case Lm:
        case zm:
        case sc:
        case s1:
        case uc:
        case Sh:
        case Bv:
          return c & nd;
        case od:
        case u1:
        case Uv:
        case Yv:
        case Hv:
          return c & id;
        case qp:
          return qp;
        case da:
          return da;
        case qa:
          return qa;
        case su:
          return su;
        default:
          return a("Should have found matching lanes. This is a bug in React."), c;
      }
    }
    function qv(c, d) {
      var x = c.pendingLanes;
      if (x === Xe)
        return Xe;
      var E = Xe, D = c.suspendedLanes, I = c.pingedLanes, F = x & Vv;
      if (F !== Xe) {
        var G = F & ~D;
        if (G !== Xe)
          E = Gp(G);
        else {
          var J = F & I;
          J !== Xe && (E = Gp(J));
        }
      } else {
        var le = x & ~D;
        le !== Xe ? E = Gp(le) : I !== Xe && (E = Gp(I));
      }
      if (E === Xe)
        return Xe;
      if (d !== Xe && d !== E && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (d & D) === Xe) {
        var de = Ro(E), De = Ro(d);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          de >= De || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          de === Ei && (De & nd) !== Xe
        )
          return d;
      }
      (E & co) !== Xe && (E |= x & Ei);
      var Ce = c.entangledLanes;
      if (Ce !== Xe)
        for (var Ue = c.entanglements, Ve = E & Ce; Ve > 0; ) {
          var Ze = ud(Ve), Yt = 1 << Ze;
          E |= Ue[Ze], Ve &= ~Yt;
        }
      return E;
    }
    function d_(c, d) {
      for (var x = c.eventTimes, E = si; d > 0; ) {
        var D = ud(d), I = 1 << D, F = x[D];
        F > E && (E = F), d &= ~I;
      }
      return E;
    }
    function sd(c, d) {
      switch (c) {
        case En:
        case Zc:
        case co:
          return d + 250;
        case Wp:
        case Ei:
        case td:
        case _h:
        case fo:
        case Fo:
        case rd:
        case Im:
        case Eh:
        case zv:
        case jm:
        case Fv:
        case Lm:
        case zm:
        case sc:
        case s1:
        case uc:
        case Sh:
        case Bv:
          return d + 5e3;
        case od:
        case u1:
        case Uv:
        case Yv:
        case Hv:
          return si;
        case qp:
        case da:
        case qa:
        case su:
          return si;
        default:
          return a("Should have found matching lanes. This is a bug in React."), si;
      }
    }
    function Gv(c, d) {
      for (var x = c.pendingLanes, E = c.suspendedLanes, D = c.pingedLanes, I = c.expirationTimes, F = x; F > 0; ) {
        var G = ud(F), J = 1 << G, le = I[G];
        le === si ? ((J & E) === Xe || (J & D) !== Xe) && (I[G] = sd(J, d)) : le <= d && (c.expiredLanes |= J), F &= ~J;
      }
    }
    function JN(c) {
      return Gp(c.pendingLanes);
    }
    function l1(c) {
      var d = c.pendingLanes & ~su;
      return d !== Xe ? d : d & su ? su : Xe;
    }
    function Qp(c) {
      return (c & En) !== Xe;
    }
    function Mh(c) {
      return (c & Vv) !== Xe;
    }
    function Qv(c) {
      return (c & id) === c;
    }
    function c1(c) {
      var d = En | co | Ei;
      return (c & d) === Xe;
    }
    function f1(c) {
      return (c & nd) === c;
    }
    function Th(c, d) {
      var x = Zc | co | Wp | Ei;
      return (d & x) !== Xe;
    }
    function R2(c, d) {
      return (d & c.expiredLanes) !== Xe;
    }
    function d1(c) {
      return (c & nd) !== Xe;
    }
    function Fm() {
      var c = ad;
      return ad <<= 1, (ad & nd) === Xe && (ad = _h), c;
    }
    function k2() {
      var c = Wv;
      return Wv <<= 1, (Wv & id) === Xe && (Wv = od), c;
    }
    function Ro(c) {
      return c & -c;
    }
    function ha(c) {
      return Ro(c);
    }
    function ud(c) {
      return 31 - a1(c);
    }
    function wl(c) {
      return ud(c);
    }
    function Ns(c, d) {
      return (c & d) !== Xe;
    }
    function Ch(c, d) {
      return (c & d) === d;
    }
    function Gn(c, d) {
      return c | d;
    }
    function Xp(c, d) {
      return c & ~d;
    }
    function h_(c, d) {
      return c & d;
    }
    function $2(c) {
      return c;
    }
    function Jc(c, d) {
      return c !== Er && c < d ? c : d;
    }
    function Bm(c) {
      for (var d = [], x = 0; x < ro; x++)
        d.push(c);
      return d;
    }
    function ld(c, d, x) {
      c.pendingLanes |= d, d !== qa && (c.suspendedLanes = Xe, c.pingedLanes = Xe);
      var E = c.eventTimes, D = wl(d);
      E[D] = x;
    }
    function Xv(c, d) {
      c.suspendedLanes |= d, c.pingedLanes &= ~d;
      for (var x = c.expirationTimes, E = d; E > 0; ) {
        var D = ud(E), I = 1 << D;
        x[D] = si, E &= ~I;
      }
    }
    function Um(c, d, x) {
      c.pingedLanes |= c.suspendedLanes & d;
    }
    function Nh(c, d) {
      var x = c.pendingLanes & ~d;
      c.pendingLanes = d, c.suspendedLanes = Xe, c.pingedLanes = Xe, c.expiredLanes &= d, c.mutableReadLanes &= d, c.entangledLanes &= d;
      for (var E = c.entanglements, D = c.eventTimes, I = c.expirationTimes, F = x; F > 0; ) {
        var G = ud(F), J = 1 << G;
        E[G] = Xe, D[G] = si, I[G] = si, F &= ~J;
      }
    }
    function un(c, d) {
      for (var x = c.entangledLanes |= d, E = c.entanglements, D = x; D; ) {
        var I = ud(D), F = 1 << I;
        // Is this one of the newly entangled lanes?
        F & d | // Is this lane transitively entangled with the newly entangled lanes?
        E[I] & d && (E[I] |= d), D &= ~F;
      }
    }
    function h1(c, d) {
      var x = Ro(d), E;
      switch (x) {
        case co:
          E = Zc;
          break;
        case Ei:
          E = Wp;
          break;
        case _h:
        case fo:
        case Fo:
        case rd:
        case Im:
        case Eh:
        case zv:
        case jm:
        case Fv:
        case Lm:
        case zm:
        case sc:
        case s1:
        case uc:
        case Sh:
        case Bv:
        case od:
        case u1:
        case Uv:
        case Yv:
        case Hv:
          E = td;
          break;
        case qa:
          E = da;
          break;
        default:
          E = Er;
          break;
      }
      return (E & (c.suspendedLanes | d)) !== Er ? Er : E;
    }
    function Kv(c, d, x) {
      if (bo)
        for (var E = c.pendingUpdatersLaneMap; x > 0; ) {
          var D = wl(x), I = 1 << D, F = E[D];
          F.add(d), x &= ~I;
        }
    }
    function ef(c, d) {
      if (bo)
        for (var x = c.pendingUpdatersLaneMap, E = c.memoizedUpdaters; d > 0; ) {
          var D = wl(d), I = 1 << D, F = x[D];
          F.size > 0 && (F.forEach(function(G) {
            var J = G.alternate;
            (J === null || !E.has(J)) && E.add(G);
          }), F.clear()), d &= ~I;
        }
    }
    function p_(c, d) {
      return null;
    }
    var Ta = En, Ca = co, ho = Ei, Zv = qa, Kp = Er;
    function Ru() {
      return Kp;
    }
    function pa(c) {
      Kp = c;
    }
    function Ym(c, d) {
      var x = Kp;
      try {
        return Kp = c, d();
      } finally {
        Kp = x;
      }
    }
    function ds(c, d) {
      return c !== 0 && c < d ? c : d;
    }
    function eD(c, d) {
      return c === 0 || c > d ? c : d;
    }
    function g_(c, d) {
      return c !== 0 && c < d;
    }
    function ku(c) {
      var d = Ro(c);
      return g_(Ta, d) ? g_(Ca, d) ? Mh(d) ? ho : Zv : Ca : Ta;
    }
    function Fr(c) {
      var d = c.current.memoizedState;
      return d.isDehydrated;
    }
    var p1;
    function Vt(c) {
      p1 = c;
    }
    function Dh(c) {
      p1(c);
    }
    var Jv;
    function P2(c) {
      Jv = c;
    }
    var Hm;
    function Vm(c) {
      Hm = c;
    }
    var Wm;
    function m_(c) {
      Wm = c;
    }
    var y_;
    function I2(c) {
      y_ = c;
    }
    var g1 = !1, Zp = [], lc = null, po = null, Jo = null, $u = /* @__PURE__ */ new Map(), tf = /* @__PURE__ */ new Map(), cc = [], _l = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function v_(c) {
      return _l.indexOf(c) > -1;
    }
    function Pu(c, d, x, E, D) {
      return {
        blockedOn: c,
        domEventName: d,
        eventSystemFlags: x,
        nativeEvent: D,
        targetContainers: [E]
      };
    }
    function b_(c, d) {
      switch (c) {
        case "focusin":
        case "focusout":
          lc = null;
          break;
        case "dragenter":
        case "dragleave":
          po = null;
          break;
        case "mouseover":
        case "mouseout":
          Jo = null;
          break;
        case "pointerover":
        case "pointerout": {
          var x = d.pointerId;
          $u.delete(x);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var E = d.pointerId;
          tf.delete(E);
          break;
        }
      }
    }
    function Ds(c, d, x, E, D, I) {
      if (c === null || c.nativeEvent !== I) {
        var F = Pu(d, x, E, D, I);
        if (d !== null) {
          var G = Nt(d);
          G !== null && Jv(G);
        }
        return F;
      }
      c.eventSystemFlags |= E;
      var J = c.targetContainers;
      return D !== null && J.indexOf(D) === -1 && J.push(D), c;
    }
    function Ah(c, d, x, E, D) {
      switch (d) {
        case "focusin": {
          var I = D;
          return lc = Ds(lc, c, d, x, E, I), !0;
        }
        case "dragenter": {
          var F = D;
          return po = Ds(po, c, d, x, E, F), !0;
        }
        case "mouseover": {
          var G = D;
          return Jo = Ds(Jo, c, d, x, E, G), !0;
        }
        case "pointerover": {
          var J = D, le = J.pointerId;
          return $u.set(le, Ds($u.get(le) || null, c, d, x, E, J)), !0;
        }
        case "gotpointercapture": {
          var de = D, De = de.pointerId;
          return tf.set(De, Ds(tf.get(De) || null, c, d, x, E, de)), !0;
        }
      }
      return !1;
    }
    function x_(c) {
      var d = ct(c.target);
      if (d !== null) {
        var x = Du(d);
        if (x !== null) {
          var E = x.tag;
          if (E === R) {
            var D = o_(x);
            if (D !== null) {
              c.blockedOn = D, y_(c.priority, function() {
                Hm(x);
              });
              return;
            }
          } else if (E === h) {
            var I = x.stateNode;
            if (Fr(I)) {
              c.blockedOn = Am(x);
              return;
            }
          }
        }
      }
      c.blockedOn = null;
    }
    function w_(c) {
      for (var d = Wm(), x = {
        blockedOn: null,
        target: c,
        priority: d
      }, E = 0; E < cc.length && g_(d, cc[E].priority); E++)
        ;
      cc.splice(E, 0, x), E === 0 && x_(x);
    }
    function m1(c) {
      if (c.blockedOn !== null)
        return !1;
      for (var d = c.targetContainers; d.length > 0; ) {
        var x = d[0], E = Jp(c.domEventName, c.eventSystemFlags, x, c.nativeEvent);
        if (E === null) {
          var D = c.nativeEvent, I = new D.constructor(D.type, D);
          Xf(I), D.target.dispatchEvent(I), Lp();
        } else {
          var F = Nt(E);
          return F !== null && Jv(F), c.blockedOn = E, !1;
        }
        d.shift();
      }
      return !0;
    }
    function e0(c, d, x) {
      m1(c) && x.delete(d);
    }
    function __() {
      g1 = !1, lc !== null && m1(lc) && (lc = null), po !== null && m1(po) && (po = null), Jo !== null && m1(Jo) && (Jo = null), $u.forEach(e0), tf.forEach(e0);
    }
    function hs(c, d) {
      c.blockedOn === d && (c.blockedOn = null, g1 || (g1 = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, __)));
    }
    function vr(c) {
      if (Zp.length > 0) {
        hs(Zp[0], c);
        for (var d = 1; d < Zp.length; d++) {
          var x = Zp[d];
          x.blockedOn === c && (x.blockedOn = null);
        }
      }
      lc !== null && hs(lc, c), po !== null && hs(po, c), Jo !== null && hs(Jo, c);
      var E = function(G) {
        return hs(G, c);
      };
      $u.forEach(E), tf.forEach(E);
      for (var D = 0; D < cc.length; D++) {
        var I = cc[D];
        I.blockedOn === c && (I.blockedOn = null);
      }
      for (; cc.length > 0; ) {
        var F = cc[0];
        if (F.blockedOn !== null)
          break;
        x_(F), F.blockedOn === null && cc.shift();
      }
    }
    var xo = n.ReactCurrentBatchConfig, ko = !0;
    function Na(c) {
      ko = !!c;
    }
    function Iu() {
      return ko;
    }
    function qm(c, d, x) {
      var E = As(d), D;
      switch (E) {
        case Ta:
          D = ga;
          break;
        case Ca:
          D = Gm;
          break;
        case ho:
        default:
          D = nf;
          break;
      }
      return D.bind(null, d, x, c);
    }
    function ga(c, d, x, E) {
      var D = Ru(), I = xo.transition;
      xo.transition = null;
      try {
        pa(Ta), nf(c, d, x, E);
      } finally {
        pa(D), xo.transition = I;
      }
    }
    function Gm(c, d, x, E) {
      var D = Ru(), I = xo.transition;
      xo.transition = null;
      try {
        pa(Ca), nf(c, d, x, E);
      } finally {
        pa(D), xo.transition = I;
      }
    }
    function nf(c, d, x, E) {
      ko && t0(c, d, x, E);
    }
    function t0(c, d, x, E) {
      var D = Jp(c, d, x, E);
      if (D === null) {
        mD(c, d, E, Qm, x), b_(c, E);
        return;
      }
      if (Ah(D, c, d, x, E)) {
        E.stopPropagation();
        return;
      }
      if (b_(c, E), d & ah && v_(c)) {
        for (; D !== null; ) {
          var I = Nt(D);
          I !== null && Dh(I);
          var F = Jp(c, d, x, E);
          if (F === null && mD(c, d, E, Qm, x), F === D)
            break;
          D = F;
        }
        D !== null && E.stopPropagation();
        return;
      }
      mD(c, d, E, null, x);
    }
    var Qm = null;
    function Jp(c, d, x, E) {
      Qm = null;
      var D = Wb(E), I = ct(D);
      if (I !== null) {
        var F = Du(I);
        if (F === null)
          I = null;
        else {
          var G = F.tag;
          if (G === R) {
            var J = o_(F);
            if (J !== null)
              return J;
            I = null;
          } else if (G === h) {
            var le = F.stateNode;
            if (Fr(le))
              return Am(F);
            I = null;
          } else
            F !== I && (I = null);
        }
      }
      return Qm = I, null;
    }
    function As(c) {
      switch (c) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Ta;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Ca;
        case "message": {
          var d = Kc();
          switch (d) {
            case Iv:
              return Ta;
            case Au:
              return Ca;
            case Ou:
            case Zb:
              return ho;
            case Jf:
              return Zv;
            default:
              return ho;
          }
        }
        default:
          return ho;
      }
    }
    function y1(c, d, x) {
      return c.addEventListener(d, x, !1), x;
    }
    function Xm(c, d, x) {
      return c.addEventListener(d, x, !0), x;
    }
    function cd(c, d, x, E) {
      return c.addEventListener(d, x, {
        capture: !0,
        passive: E
      }), x;
    }
    function v1(c, d, x, E) {
      return c.addEventListener(d, x, {
        passive: E
      }), x;
    }
    var eg = null, rf = null, Oh = null;
    function ma(c) {
      return eg = c, rf = x1(), !0;
    }
    function b1() {
      eg = null, rf = null, Oh = null;
    }
    function Km() {
      if (Oh)
        return Oh;
      var c, d = rf, x = d.length, E, D = x1(), I = D.length;
      for (c = 0; c < x && d[c] === D[c]; c++)
        ;
      var F = x - c;
      for (E = 1; E <= F && d[x - E] === D[I - E]; E++)
        ;
      var G = E > 1 ? 1 - E : void 0;
      return Oh = D.slice(c, G), Oh;
    }
    function x1() {
      return "value" in eg ? eg.value : eg.textContent;
    }
    function Rh(c) {
      var d, x = c.keyCode;
      return "charCode" in c ? (d = c.charCode, d === 0 && x === 13 && (d = 13)) : d = x, d === 10 && (d = 13), d >= 32 || d === 13 ? d : 0;
    }
    function tg() {
      return !0;
    }
    function ps() {
      return !1;
    }
    function ea(c) {
      function d(x, E, D, I, F) {
        this._reactName = x, this._targetInst = D, this.type = E, this.nativeEvent = I, this.target = F, this.currentTarget = null;
        for (var G in c)
          if (c.hasOwnProperty(G)) {
            var J = c[G];
            J ? this[G] = J(I) : this[G] = I[G];
          }
        var le = I.defaultPrevented != null ? I.defaultPrevented : I.returnValue === !1;
        return le ? this.isDefaultPrevented = tg : this.isDefaultPrevented = ps, this.isPropagationStopped = ps, this;
      }
      return cr(d.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var x = this.nativeEvent;
          x && (x.preventDefault ? x.preventDefault() : typeof x.returnValue != "unknown" && (x.returnValue = !1), this.isDefaultPrevented = tg);
        },
        stopPropagation: function() {
          var x = this.nativeEvent;
          x && (x.stopPropagation ? x.stopPropagation() : typeof x.cancelBubble != "unknown" && (x.cancelBubble = !0), this.isPropagationStopped = tg);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: tg
      }), d;
    }
    var gs = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(c) {
        return c.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Da = ea(gs), Zm = cr({}, gs, {
      view: 0,
      detail: 0
    }), E_ = ea(Zm), n0, S_, El;
    function j2(c) {
      c !== El && (El && c.type === "mousemove" ? (n0 = c.screenX - El.screenX, S_ = c.screenY - El.screenY) : (n0 = 0, S_ = 0), El = c);
    }
    var Jm = cr({}, Zm, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: E1,
      button: 0,
      buttons: 0,
      relatedTarget: function(c) {
        return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
      },
      movementX: function(c) {
        return "movementX" in c ? c.movementX : (j2(c), n0);
      },
      movementY: function(c) {
        return "movementY" in c ? c.movementY : S_;
      }
    }), kh = ea(Jm), M_ = cr({}, Jm, {
      dataTransfer: 0
    }), ng = ea(M_), L2 = cr({}, Zm, {
      relatedTarget: 0
    }), w1 = ea(L2), T_ = cr({}, gs, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), _1 = ea(T_), tD = cr({}, gs, {
      clipboardData: function(c) {
        return "clipboardData" in c ? c.clipboardData : window.clipboardData;
      }
    }), nD = ea(tD), z2 = cr({}, gs, {
      data: 0
    }), C_ = ea(z2), rg = C_, rD = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, $h = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function N_(c) {
      if (c.key) {
        var d = rD[c.key] || c.key;
        if (d !== "Unidentified")
          return d;
      }
      if (c.type === "keypress") {
        var x = Rh(c);
        return x === 13 ? "Enter" : String.fromCharCode(x);
      }
      return c.type === "keydown" || c.type === "keyup" ? $h[c.keyCode] || "Unidentified" : "";
    }
    var $o = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function iD(c) {
      var d = this, x = d.nativeEvent;
      if (x.getModifierState)
        return x.getModifierState(c);
      var E = $o[c];
      return E ? !!x[E] : !1;
    }
    function E1(c) {
      return iD;
    }
    var oD = cr({}, Zm, {
      key: N_,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: E1,
      // Legacy Interface
      charCode: function(c) {
        return c.type === "keypress" ? Rh(c) : 0;
      },
      keyCode: function(c) {
        return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      },
      which: function(c) {
        return c.type === "keypress" ? Rh(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      }
    }), aD = ea(oD), F2 = cr({}, Jm, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), D_ = ea(F2), sD = cr({}, Zm, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: E1
    }), ju = ea(sD), A_ = cr({}, gs, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), S1 = ea(A_), Ph = cr({}, Jm, {
      deltaX: function(c) {
        return "deltaX" in c ? c.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in c ? -c.wheelDeltaX : 0
        );
      },
      deltaY: function(c) {
        return "deltaY" in c ? c.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in c ? -c.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in c ? -c.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), M1 = ea(Ph), ig = [9, 13, 27, 32], r0 = 229, i0 = Qe && "CompositionEvent" in window, og = null;
    Qe && "documentMode" in document && (og = document.documentMode);
    var uD = Qe && "TextEvent" in window && !og, T1 = Qe && (!i0 || og && og > 8 && og <= 11), B2 = 32, O_ = String.fromCharCode(B2);
    function U2() {
      ze("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ze("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ze("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ze("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var o0 = !1;
    function C1(c) {
      return (c.ctrlKey || c.altKey || c.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(c.ctrlKey && c.altKey);
    }
    function Y2(c) {
      switch (c) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function R_(c, d) {
      return c === "keydown" && d.keyCode === r0;
    }
    function H2(c, d) {
      switch (c) {
        case "keyup":
          return ig.indexOf(d.keyCode) !== -1;
        case "keydown":
          return d.keyCode !== r0;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function N1(c) {
      var d = c.detail;
      return typeof d == "object" && "data" in d ? d.data : null;
    }
    function a0(c) {
      return c.locale === "ko";
    }
    var fd = !1;
    function k_(c, d, x, E, D) {
      var I, F;
      if (i0 ? I = Y2(d) : fd ? H2(d, E) && (I = "onCompositionEnd") : R_(d, E) && (I = "onCompositionStart"), !I)
        return null;
      T1 && !a0(E) && (!fd && I === "onCompositionStart" ? fd = ma(D) : I === "onCompositionEnd" && fd && (F = Km()));
      var G = Jn(x, I);
      if (G.length > 0) {
        var J = new C_(I, d, null, E, D);
        if (c.push({
          event: J,
          listeners: G
        }), F)
          J.data = F;
        else {
          var le = N1(E);
          le !== null && (J.data = le);
        }
      }
    }
    function D1(c, d) {
      switch (c) {
        case "compositionend":
          return N1(d);
        case "keypress":
          var x = d.which;
          return x !== B2 ? null : (o0 = !0, O_);
        case "textInput":
          var E = d.data;
          return E === O_ && o0 ? null : E;
        default:
          return null;
      }
    }
    function V2(c, d) {
      if (fd) {
        if (c === "compositionend" || !i0 && H2(c, d)) {
          var x = Km();
          return b1(), fd = !1, x;
        }
        return null;
      }
      switch (c) {
        case "paste":
          return null;
        case "keypress":
          if (!C1(d)) {
            if (d.char && d.char.length > 1)
              return d.char;
            if (d.which)
              return String.fromCharCode(d.which);
          }
          return null;
        case "compositionend":
          return T1 && !a0(d) ? null : d.data;
        default:
          return null;
      }
    }
    function A1(c, d, x, E, D) {
      var I;
      if (uD ? I = D1(d, E) : I = V2(d, E), !I)
        return null;
      var F = Jn(x, "onBeforeInput");
      if (F.length > 0) {
        var G = new rg("onBeforeInput", "beforeinput", null, E, D);
        c.push({
          event: G,
          listeners: F
        }), G.data = I;
      }
    }
    function O1(c, d, x, E, D, I, F) {
      k_(c, d, x, E, D), A1(c, d, x, E, D);
    }
    var lD = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function ey(c) {
      var d = c && c.nodeName && c.nodeName.toLowerCase();
      return d === "input" ? !!lD[c.type] : d === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function cD(c) {
      if (!Qe)
        return !1;
      var d = "on" + c, x = d in document;
      if (!x) {
        var E = document.createElement("div");
        E.setAttribute(d, "return;"), x = typeof E[d] == "function";
      }
      return x;
    }
    function R1() {
      ze("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function m(c, d, x, E) {
      Gb(E);
      var D = Jn(d, "onChange");
      if (D.length > 0) {
        var I = new Da("onChange", "change", null, x, E);
        c.push({
          event: I,
          listeners: D
        });
      }
    }
    var v = null, T = null;
    function k(c) {
      var d = c.nodeName && c.nodeName.toLowerCase();
      return d === "select" || d === "input" && c.type === "file";
    }
    function L(c) {
      var d = [];
      m(d, T, c, Wb(c)), r_(B, d);
    }
    function B(c) {
      gD(c, 0);
    }
    function oe(c) {
      var d = Gt(c);
      if (dm(d))
        return c;
    }
    function me(c, d) {
      if (c === "change")
        return d;
    }
    var Ee = !1;
    Qe && (Ee = cD("input") && (!document.documentMode || document.documentMode > 9));
    function He(c, d) {
      v = c, T = d, v.attachEvent("onpropertychange", mt);
    }
    function ft() {
      v && (v.detachEvent("onpropertychange", mt), v = null, T = null);
    }
    function mt(c) {
      c.propertyName === "value" && oe(T) && L(c);
    }
    function dt(c, d, x) {
      c === "focusin" ? (ft(), He(d, x)) : c === "focusout" && ft();
    }
    function jt(c, d) {
      if (c === "selectionchange" || c === "keyup" || c === "keydown")
        return oe(T);
    }
    function qt(c) {
      var d = c.nodeName;
      return d && d.toLowerCase() === "input" && (c.type === "checkbox" || c.type === "radio");
    }
    function Xt(c, d) {
      if (c === "click")
        return oe(d);
    }
    function Bo(c, d) {
      if (c === "input" || c === "change")
        return oe(d);
    }
    function Pe(c) {
      var d = c._wrapperState;
      !d || !d.controlled || c.type !== "number" || dn(c, "number", c.value);
    }
    function Te(c, d, x, E, D, I, F) {
      var G = x ? Gt(x) : window, J, le;
      if (k(G) ? J = me : ey(G) ? Ee ? J = Bo : (J = jt, le = dt) : qt(G) && (J = Xt), J) {
        var de = J(d, x);
        if (de) {
          m(c, de, E, D);
          return;
        }
      }
      le && le(d, G, x), d === "focusout" && Pe(G);
    }
    function Ie() {
      fe("onMouseEnter", ["mouseout", "mouseover"]), fe("onMouseLeave", ["mouseout", "mouseover"]), fe("onPointerEnter", ["pointerout", "pointerover"]), fe("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function wt(c, d, x, E, D, I, F) {
      var G = d === "mouseover" || d === "pointerover", J = d === "mouseout" || d === "pointerout";
      if (G && !Nv(E)) {
        var le = E.relatedTarget || E.fromElement;
        if (le && (ct(le) || rt(le)))
          return;
      }
      if (!(!J && !G)) {
        var de;
        if (D.window === D)
          de = D;
        else {
          var De = D.ownerDocument;
          De ? de = De.defaultView || De.parentWindow : de = window;
        }
        var Ce, Ue;
        if (J) {
          var Ve = E.relatedTarget || E.toElement;
          if (Ce = x, Ue = Ve ? ct(Ve) : null, Ue !== null) {
            var Ze = Du(Ue);
            (Ue !== Ze || Ue.tag !== g && Ue.tag !== y) && (Ue = null);
          }
        } else
          Ce = null, Ue = x;
        if (Ce !== Ue) {
          var Yt = kh, yn = "onMouseLeave", on = "onMouseEnter", Yr = "mouse";
          (d === "pointerout" || d === "pointerover") && (Yt = D_, yn = "onPointerLeave", on = "onPointerEnter", Yr = "pointer");
          var Nr = Ce == null ? de : Gt(Ce), je = Ue == null ? de : Gt(Ue), Je = new Yt(yn, Yr + "leave", Ce, E, D);
          Je.target = Nr, Je.relatedTarget = je;
          var Le = null, vt = ct(D);
          if (vt === x) {
            var Ht = new Yt(on, Yr + "enter", Ue, E, D);
            Ht.target = je, Ht.relatedTarget = Nr, Le = Ht;
          }
          _9(c, Je, Le, Ce, Ue);
        }
      }
    }
    function Jt(c, d) {
      return c === d && (c !== 0 || 1 / c === 1 / d) || c !== c && d !== d;
    }
    var Wt = typeof Object.is == "function" ? Object.is : Jt;
    function rn(c, d) {
      if (Wt(c, d))
        return !0;
      if (typeof c != "object" || c === null || typeof d != "object" || d === null)
        return !1;
      var x = Object.keys(c), E = Object.keys(d);
      if (x.length !== E.length)
        return !1;
      for (var D = 0; D < x.length; D++) {
        var I = x[D];
        if (!$e.call(d, I) || !Wt(c[I], d[I]))
          return !1;
      }
      return !0;
    }
    function On(c) {
      for (; c && c.firstChild; )
        c = c.firstChild;
      return c;
    }
    function Aa(c) {
      for (; c; ) {
        if (c.nextSibling)
          return c.nextSibling;
        c = c.parentNode;
      }
    }
    function Br(c, d) {
      for (var x = On(c), E = 0, D = 0; x; ) {
        if (x.nodeType === Hc) {
          if (D = E + x.textContent.length, E <= d && D >= d)
            return {
              node: x,
              offset: d - E
            };
          E = D;
        }
        x = On(Aa(x));
      }
    }
    function Ih(c) {
      var d = c.ownerDocument, x = d && d.defaultView || window, E = x.getSelection && x.getSelection();
      if (!E || E.rangeCount === 0)
        return null;
      var D = E.anchorNode, I = E.anchorOffset, F = E.focusNode, G = E.focusOffset;
      try {
        D.nodeType, F.nodeType;
      } catch {
        return null;
      }
      return fD(c, D, I, F, G);
    }
    function fD(c, d, x, E, D) {
      var I = 0, F = -1, G = -1, J = 0, le = 0, de = c, De = null;
      e:
        for (; ; ) {
          for (var Ce = null; de === d && (x === 0 || de.nodeType === Hc) && (F = I + x), de === E && (D === 0 || de.nodeType === Hc) && (G = I + D), de.nodeType === Hc && (I += de.nodeValue.length), (Ce = de.firstChild) !== null; )
            De = de, de = Ce;
          for (; ; ) {
            if (de === c)
              break e;
            if (De === d && ++J === x && (F = I), De === E && ++le === D && (G = I), (Ce = de.nextSibling) !== null)
              break;
            de = De, De = de.parentNode;
          }
          de = Ce;
        }
      return F === -1 || G === -1 ? null : {
        start: F,
        end: G
      };
    }
    function l9(c, d) {
      var x = c.ownerDocument || document, E = x && x.defaultView || window;
      if (E.getSelection) {
        var D = E.getSelection(), I = c.textContent.length, F = Math.min(d.start, I), G = d.end === void 0 ? F : Math.min(d.end, I);
        if (!D.extend && F > G) {
          var J = G;
          G = F, F = J;
        }
        var le = Br(c, F), de = Br(c, G);
        if (le && de) {
          if (D.rangeCount === 1 && D.anchorNode === le.node && D.anchorOffset === le.offset && D.focusNode === de.node && D.focusOffset === de.offset)
            return;
          var De = x.createRange();
          De.setStart(le.node, le.offset), D.removeAllRanges(), F > G ? (D.addRange(De), D.extend(de.node, de.offset)) : (De.setEnd(de.node, de.offset), D.addRange(De));
        }
      }
    }
    function j4(c) {
      return c && c.nodeType === Hc;
    }
    function L4(c, d) {
      return !c || !d ? !1 : c === d ? !0 : j4(c) ? !1 : j4(d) ? L4(c, d.parentNode) : "contains" in c ? c.contains(d) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(d) & 16) : !1;
    }
    function c9(c) {
      return c && c.ownerDocument && L4(c.ownerDocument.documentElement, c);
    }
    function f9(c) {
      try {
        return typeof c.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function z4() {
      for (var c = window, d = nh(); d instanceof c.HTMLIFrameElement; ) {
        if (f9(d))
          c = d.contentWindow;
        else
          return d;
        d = nh(c.document);
      }
      return d;
    }
    function dD(c) {
      var d = c && c.nodeName && c.nodeName.toLowerCase();
      return d && (d === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || d === "textarea" || c.contentEditable === "true");
    }
    function dd() {
      var c = z4();
      return {
        focusedElem: c,
        selectionRange: dD(c) ? h9(c) : null
      };
    }
    function d9(c) {
      var d = z4(), x = c.focusedElem, E = c.selectionRange;
      if (d !== x && c9(x)) {
        E !== null && dD(x) && s0(x, E);
        for (var D = [], I = x; I = I.parentNode; )
          I.nodeType === tu && D.push({
            element: I,
            left: I.scrollLeft,
            top: I.scrollTop
          });
        typeof x.focus == "function" && x.focus();
        for (var F = 0; F < D.length; F++) {
          var G = D[F];
          G.element.scrollLeft = G.left, G.element.scrollTop = G.top;
        }
      }
    }
    function h9(c) {
      var d;
      return "selectionStart" in c ? d = {
        start: c.selectionStart,
        end: c.selectionEnd
      } : d = Ih(c), d || {
        start: 0,
        end: 0
      };
    }
    function s0(c, d) {
      var x = d.start, E = d.end;
      E === void 0 && (E = x), "selectionStart" in c ? (c.selectionStart = x, c.selectionEnd = Math.min(E, c.value.length)) : l9(c, d);
    }
    var ir = Qe && "documentMode" in document && document.documentMode <= 11;
    function p9() {
      ze("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Ga = null, Uo = null, $_ = null, jh = !1;
    function g9(c) {
      if ("selectionStart" in c && dD(c))
        return {
          start: c.selectionStart,
          end: c.selectionEnd
        };
      var d = c.ownerDocument && c.ownerDocument.defaultView || window, x = d.getSelection();
      return {
        anchorNode: x.anchorNode,
        anchorOffset: x.anchorOffset,
        focusNode: x.focusNode,
        focusOffset: x.focusOffset
      };
    }
    function m9(c) {
      return c.window === c ? c.document : c.nodeType === Su ? c : c.ownerDocument;
    }
    function F4(c, d, x) {
      var E = m9(x);
      if (!(jh || Ga == null || Ga !== nh(E))) {
        var D = g9(Ga);
        if (!$_ || !rn($_, D)) {
          $_ = D;
          var I = Jn(Uo, "onSelect");
          if (I.length > 0) {
            var F = new Da("onSelect", "select", null, d, x);
            c.push({
              event: F,
              listeners: I
            }), F.target = Ga;
          }
        }
      }
    }
    function y9(c, d, x, E, D, I, F) {
      var G = x ? Gt(x) : window;
      switch (d) {
        case "focusin":
          (ey(G) || G.contentEditable === "true") && (Ga = G, Uo = x, $_ = null);
          break;
        case "focusout":
          Ga = null, Uo = null, $_ = null;
          break;
        case "mousedown":
          jh = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          jh = !1, F4(c, E, D);
          break;
        case "selectionchange":
          if (ir)
            break;
        case "keydown":
        case "keyup":
          F4(c, E, D);
      }
    }
    function W2(c, d) {
      var x = {};
      return x[c.toLowerCase()] = d.toLowerCase(), x["Webkit" + c] = "webkit" + d, x["Moz" + c] = "moz" + d, x;
    }
    var ty = {
      animationend: W2("Animation", "AnimationEnd"),
      animationiteration: W2("Animation", "AnimationIteration"),
      animationstart: W2("Animation", "AnimationStart"),
      transitionend: W2("Transition", "TransitionEnd")
    }, hD = {}, Lh = {};
    Qe && (Lh = document.createElement("div").style, "AnimationEvent" in window || (delete ty.animationend.animation, delete ty.animationiteration.animation, delete ty.animationstart.animation), "TransitionEvent" in window || delete ty.transitionend.transition);
    function P_(c) {
      if (hD[c])
        return hD[c];
      if (!ty[c])
        return c;
      var d = ty[c];
      for (var x in d)
        if (d.hasOwnProperty(x) && x in Lh)
          return hD[c] = d[x];
      return c;
    }
    var I_ = P_("animationend"), Po = P_("animationiteration"), Yo = P_("animationstart"), pD = P_("transitionend"), B4 = /* @__PURE__ */ new Map(), U4 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function ny(c, d) {
      B4.set(c, d), ze(d, [c]);
    }
    function v9() {
      for (var c = 0; c < U4.length; c++) {
        var d = U4[c], x = d.toLowerCase(), E = d[0].toUpperCase() + d.slice(1);
        ny(x, "on" + E);
      }
      ny(I_, "onAnimationEnd"), ny(Po, "onAnimationIteration"), ny(Yo, "onAnimationStart"), ny("dblclick", "onDoubleClick"), ny("focusin", "onFocus"), ny("focusout", "onBlur"), ny(pD, "onTransitionEnd");
    }
    function b9(c, d, x, E, D, I, F) {
      var G = B4.get(d);
      if (G !== void 0) {
        var J = Da, le = d;
        switch (d) {
          case "keypress":
            if (Rh(E) === 0)
              return;
          case "keydown":
          case "keyup":
            J = aD;
            break;
          case "focusin":
            le = "focus", J = w1;
            break;
          case "focusout":
            le = "blur", J = w1;
            break;
          case "beforeblur":
          case "afterblur":
            J = w1;
            break;
          case "click":
            if (E.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            J = kh;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            J = ng;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            J = ju;
            break;
          case I_:
          case Po:
          case Yo:
            J = _1;
            break;
          case pD:
            J = S1;
            break;
          case "scroll":
            J = E_;
            break;
          case "wheel":
            J = M1;
            break;
          case "copy":
          case "cut":
          case "paste":
            J = nD;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            J = D_;
            break;
        }
        var de = (I & ah) !== 0;
        {
          var De = !de && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          d === "scroll", Ce = ag(x, G, E.type, de, De);
          if (Ce.length > 0) {
            var Ue = new J(G, le, null, E, D);
            c.push({
              event: Ue,
              listeners: Ce
            });
          }
        }
      }
    }
    v9(), Ie(), R1(), p9(), U2();
    function x9(c, d, x, E, D, I, F) {
      b9(c, d, x, E, D, I);
      var G = (I & Vb) === 0;
      G && (wt(c, d, x, E, D), Te(c, d, x, E, D), y9(c, d, x, E, D), O1(c, d, x, E, D));
    }
    var k1 = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], u0 = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(k1));
    function q2(c, d, x) {
      var E = c.type || "unknown-event";
      c.currentTarget = x, Cu(E, d, void 0, c), c.currentTarget = null;
    }
    function w9(c, d, x) {
      var E;
      if (x)
        for (var D = d.length - 1; D >= 0; D--) {
          var I = d[D], F = I.instance, G = I.currentTarget, J = I.listener;
          if (F !== E && c.isPropagationStopped())
            return;
          q2(c, J, G), E = F;
        }
      else
        for (var le = 0; le < d.length; le++) {
          var de = d[le], De = de.instance, Ce = de.currentTarget, Ue = de.listener;
          if (De !== E && c.isPropagationStopped())
            return;
          q2(c, Ue, Ce), E = De;
        }
    }
    function gD(c, d) {
      for (var x = (d & ah) !== 0, E = 0; E < c.length; E++) {
        var D = c[E], I = D.event, F = D.listeners;
        w9(I, F, x);
      }
      Xb();
    }
    function G2(c, d, x, E, D) {
      var I = Wb(x), F = [];
      x9(F, c, E, x, I, d), gD(F, d);
    }
    function Cr(c, d) {
      u0.has(c) || a('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', c);
      var x = !1, E = Rn(d), D = Si(c, x);
      E.has(D) || (Y4(d, c, Em, x), E.add(D));
    }
    function ry(c, d, x) {
      u0.has(c) && !d && a('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', c);
      var E = 0;
      d && (E |= ah), Y4(x, c, E, d);
    }
    var Q2 = "_reactListening" + Math.random().toString(36).slice(2);
    function j_(c) {
      if (!c[Q2]) {
        c[Q2] = !0, Me.forEach(function(x) {
          x !== "selectionchange" && (u0.has(x) || ry(x, !1, c), ry(x, !0, c));
        });
        var d = c.nodeType === Su ? c : c.ownerDocument;
        d !== null && (d[Q2] || (d[Q2] = !0, ry("selectionchange", !1, d)));
      }
    }
    function Y4(c, d, x, E, D) {
      var I = qm(c, d, x), F = void 0;
      Fp && (d === "touchstart" || d === "touchmove" || d === "wheel") && (F = !0), c = c, E ? F !== void 0 ? cd(c, d, I, F) : Xm(c, d, I) : F !== void 0 ? v1(c, d, I, F) : y1(c, d, I);
    }
    function H4(c, d) {
      return c === d || c.nodeType === Wr && c.parentNode === d;
    }
    function mD(c, d, x, E, D) {
      var I = E;
      if (!(d & dl) && !(d & Em)) {
        var F = D;
        if (E !== null) {
          var G = E;
          e:
            for (; ; ) {
              if (G === null)
                return;
              var J = G.tag;
              if (J === h || J === p) {
                var le = G.stateNode.containerInfo;
                if (H4(le, F))
                  break;
                if (J === p)
                  for (var de = G.return; de !== null; ) {
                    var De = de.tag;
                    if (De === h || De === p) {
                      var Ce = de.stateNode.containerInfo;
                      if (H4(Ce, F))
                        return;
                    }
                    de = de.return;
                  }
                for (; le !== null; ) {
                  var Ue = ct(le);
                  if (Ue === null)
                    return;
                  var Ve = Ue.tag;
                  if (Ve === g || Ve === y) {
                    G = I = Ue;
                    continue e;
                  }
                  le = le.parentNode;
                }
              }
              G = G.return;
            }
        }
      }
      r_(function() {
        return G2(c, d, x, I);
      });
    }
    function $1(c, d, x) {
      return {
        instance: c,
        listener: d,
        currentTarget: x
      };
    }
    function ag(c, d, x, E, D, I) {
      for (var F = d !== null ? d + "Capture" : null, G = E ? F : d, J = [], le = c, de = null; le !== null; ) {
        var De = le, Ce = De.stateNode, Ue = De.tag;
        if (Ue === g && Ce !== null && (de = Ce, G !== null)) {
          var Ve = nc(le, G);
          Ve != null && J.push($1(le, Ve, de));
        }
        if (D)
          break;
        le = le.return;
      }
      return J;
    }
    function Jn(c, d) {
      for (var x = d + "Capture", E = [], D = c; D !== null; ) {
        var I = D, F = I.stateNode, G = I.tag;
        if (G === g && F !== null) {
          var J = F, le = nc(D, x);
          le != null && E.unshift($1(D, le, J));
          var de = nc(D, d);
          de != null && E.push($1(D, de, J));
        }
        D = D.return;
      }
      return E;
    }
    function l0(c) {
      if (c === null)
        return null;
      do
        c = c.return;
      while (c && c.tag !== g);
      return c || null;
    }
    function of(c, d) {
      for (var x = c, E = d, D = 0, I = x; I; I = l0(I))
        D++;
      for (var F = 0, G = E; G; G = l0(G))
        F++;
      for (; D - F > 0; )
        x = l0(x), D--;
      for (; F - D > 0; )
        E = l0(E), F--;
      for (var J = D; J--; ) {
        if (x === E || E !== null && x === E.alternate)
          return x;
        x = l0(x), E = l0(E);
      }
      return null;
    }
    function yD(c, d, x, E, D) {
      for (var I = d._reactName, F = [], G = x; G !== null && G !== E; ) {
        var J = G, le = J.alternate, de = J.stateNode, De = J.tag;
        if (le !== null && le === E)
          break;
        if (De === g && de !== null) {
          var Ce = de;
          if (D) {
            var Ue = nc(G, I);
            Ue != null && F.unshift($1(G, Ue, Ce));
          } else if (!D) {
            var Ve = nc(G, I);
            Ve != null && F.push($1(G, Ve, Ce));
          }
        }
        G = G.return;
      }
      F.length !== 0 && c.push({
        event: d,
        listeners: F
      });
    }
    function _9(c, d, x, E, D) {
      var I = E && D ? of(E, D) : null;
      E !== null && yD(c, d, E, I, !1), D !== null && x !== null && yD(c, x, D, I, !0);
    }
    function Si(c, d) {
      return c + "__" + (d ? "capture" : "bubble");
    }
    var Sl = !1, P1 = "dangerouslySetInnerHTML", c0 = "suppressContentEditableWarning", iy = "suppressHydrationWarning", V4 = "autoFocus", f0 = "children", d0 = "style", X2 = "__html", vD, K2, L_, W4, Z2, q4, G4;
    vD = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, K2 = function(c, d) {
      Gr(c, d), Hb(c, d), n_(c, d, {
        registrationNameDependencies: we,
        possibleRegistrationNames: Ye
      });
    }, q4 = Qe && !document.documentMode, L_ = function(c, d, x) {
      if (!Sl) {
        var E = J2(x), D = J2(d);
        D !== E && (Sl = !0, a("Prop `%s` did not match. Server: %s Client: %s", c, JSON.stringify(D), JSON.stringify(E)));
      }
    }, W4 = function(c) {
      if (!Sl) {
        Sl = !0;
        var d = [];
        c.forEach(function(x) {
          d.push(x);
        }), a("Extra attributes from the server: %s", d);
      }
    }, Z2 = function(c, d) {
      d === !1 ? a("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", c, c, c) : a("Expected `%s` listener to be a function, instead got a value of `%s` type.", c, typeof d);
    }, G4 = function(c, d) {
      var x = c.namespaceURI === Yc ? c.ownerDocument.createElement(c.tagName) : c.ownerDocument.createElementNS(c.namespaceURI, c.tagName);
      return x.innerHTML = d, x.innerHTML;
    };
    var E9 = /\r\n?/g, bD = /\u0000|\uFFFD/g;
    function J2(c) {
      qn(c);
      var d = typeof c == "string" ? c : "" + c;
      return d.replace(E9, `
`).replace(bD, "");
    }
    function I1(c, d, x, E) {
      var D = J2(d), I = J2(c);
      if (I !== D && (E && (Sl || (Sl = !0, a('Text content did not match. Server: "%s" Client: "%s"', I, D))), x && X))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function Q4(c) {
      return c.nodeType === Su ? c : c.ownerDocument;
    }
    function S9() {
    }
    function eM(c) {
      c.onclick = S9;
    }
    function ms(c, d, x, E, D) {
      for (var I in E)
        if (E.hasOwnProperty(I)) {
          var F = E[I];
          if (I === d0)
            F && Object.freeze(F), Ae(d, F);
          else if (I === P1) {
            var G = F ? F[X2] : void 0;
            G != null && zb(d, G);
          } else if (I === f0)
            if (typeof F == "string") {
              var J = c !== "textarea" || F !== "";
              J && Sv(d, F);
            } else
              typeof F == "number" && Sv(d, "" + F);
          else
            I === c0 || I === iy || I === V4 || (we.hasOwnProperty(I) ? F != null && (typeof F != "function" && Z2(I, F), I === "onScroll" && Cr("scroll", d)) : F != null && Es(d, I, F, D));
        }
    }
    function Ml(c, d, x, E) {
      for (var D = 0; D < d.length; D += 2) {
        var I = d[D], F = d[D + 1];
        I === d0 ? Ae(c, F) : I === P1 ? zb(c, F) : I === f0 ? Sv(c, F) : Es(c, I, F, E);
      }
    }
    function M9(c, d, x, E) {
      var D, I = Q4(x), F, G = E;
      if (G === Yc && (G = hm(c)), G === Yc) {
        if (D = tc(c, d), !D && c !== c.toLowerCase() && a("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", c), c === "script") {
          var J = I.createElement("div");
          J.innerHTML = "<script><\/script>";
          var le = J.firstChild;
          F = J.removeChild(le);
        } else if (typeof d.is == "string")
          F = I.createElement(c, {
            is: d.is
          });
        else if (F = I.createElement(c), c === "select") {
          var de = F;
          d.multiple ? de.multiple = !0 : d.size && (de.size = d.size);
        }
      } else
        F = I.createElementNS(G, c);
      return G === Yc && !D && Object.prototype.toString.call(F) === "[object HTMLUnknownElement]" && !$e.call(vD, c) && (vD[c] = !0, a("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", c)), F;
    }
    function T9(c, d) {
      return Q4(d).createTextNode(c);
    }
    function C9(c, d, x, E) {
      var D = tc(d, x);
      K2(d, x);
      var I;
      switch (d) {
        case "dialog":
          Cr("cancel", c), Cr("close", c), I = x;
          break;
        case "iframe":
        case "object":
        case "embed":
          Cr("load", c), I = x;
          break;
        case "video":
        case "audio":
          for (var F = 0; F < k1.length; F++)
            Cr(k1[F], c);
          I = x;
          break;
        case "source":
          Cr("error", c), I = x;
          break;
        case "img":
        case "image":
        case "link":
          Cr("error", c), Cr("load", c), I = x;
          break;
        case "details":
          Cr("toggle", c), I = x;
          break;
        case "input":
          be(c, x), I = ne(c, x), Cr("invalid", c);
          break;
        case "option":
          tr(c, x), I = x;
          break;
        case "select":
          Pp(c, x), I = cl(c, x), Cr("invalid", c);
          break;
        case "textarea":
          Xw(c, x), I = Qw(c, x), Cr("invalid", c);
          break;
        default:
          I = x;
      }
      switch (oi(d, I), ms(d, c, E, I, D), d) {
        case "input":
          ll(c), gt(c, x, !1);
          break;
        case "textarea":
          ll(c), Ip(c);
          break;
        case "option":
          ki(c, x);
          break;
        case "select":
          Ww(c, x);
          break;
        default:
          typeof I.onClick == "function" && eM(c);
          break;
      }
    }
    function X4(c, d, x, E, D) {
      K2(d, E);
      var I = null, F, G;
      switch (d) {
        case "input":
          F = ne(c, x), G = ne(c, E), I = [];
          break;
        case "select":
          F = cl(c, x), G = cl(c, E), I = [];
          break;
        case "textarea":
          F = Qw(c, x), G = Qw(c, E), I = [];
          break;
        default:
          F = x, G = E, typeof F.onClick != "function" && typeof G.onClick == "function" && eM(c);
          break;
      }
      oi(d, G);
      var J, le, de = null;
      for (J in F)
        if (!(G.hasOwnProperty(J) || !F.hasOwnProperty(J) || F[J] == null))
          if (J === d0) {
            var De = F[J];
            for (le in De)
              De.hasOwnProperty(le) && (de || (de = {}), de[le] = "");
          } else
            J === P1 || J === f0 || J === c0 || J === iy || J === V4 || (we.hasOwnProperty(J) ? I || (I = []) : (I = I || []).push(J, null));
      for (J in G) {
        var Ce = G[J], Ue = F != null ? F[J] : void 0;
        if (!(!G.hasOwnProperty(J) || Ce === Ue || Ce == null && Ue == null))
          if (J === d0)
            if (Ce && Object.freeze(Ce), Ue) {
              for (le in Ue)
                Ue.hasOwnProperty(le) && (!Ce || !Ce.hasOwnProperty(le)) && (de || (de = {}), de[le] = "");
              for (le in Ce)
                Ce.hasOwnProperty(le) && Ue[le] !== Ce[le] && (de || (de = {}), de[le] = Ce[le]);
            } else
              de || (I || (I = []), I.push(J, de)), de = Ce;
          else if (J === P1) {
            var Ve = Ce ? Ce[X2] : void 0, Ze = Ue ? Ue[X2] : void 0;
            Ve != null && Ze !== Ve && (I = I || []).push(J, Ve);
          } else
            J === f0 ? (typeof Ce == "string" || typeof Ce == "number") && (I = I || []).push(J, "" + Ce) : J === c0 || J === iy || (we.hasOwnProperty(J) ? (Ce != null && (typeof Ce != "function" && Z2(J, Ce), J === "onScroll" && Cr("scroll", c)), !I && Ue !== Ce && (I = [])) : (I = I || []).push(J, Ce));
      }
      return de && (It(de, G[d0]), (I = I || []).push(d0, de)), I;
    }
    function N9(c, d, x, E, D) {
      x === "input" && D.type === "radio" && D.name != null && Be(c, D);
      var I = tc(x, E), F = tc(x, D);
      switch (Ml(c, d, I, F), x) {
        case "input":
          qe(c, D);
          break;
        case "textarea":
          _v(c, D);
          break;
        case "select":
          qw(c, D);
          break;
      }
    }
    function D9(c) {
      {
        var d = c.toLowerCase();
        return Yb.hasOwnProperty(d) && Yb[d] || null;
      }
    }
    function A9(c, d, x, E, D, I, F) {
      var G, J;
      switch (G = tc(d, x), K2(d, x), d) {
        case "dialog":
          Cr("cancel", c), Cr("close", c);
          break;
        case "iframe":
        case "object":
        case "embed":
          Cr("load", c);
          break;
        case "video":
        case "audio":
          for (var le = 0; le < k1.length; le++)
            Cr(k1[le], c);
          break;
        case "source":
          Cr("error", c);
          break;
        case "img":
        case "image":
        case "link":
          Cr("error", c), Cr("load", c);
          break;
        case "details":
          Cr("toggle", c);
          break;
        case "input":
          be(c, x), Cr("invalid", c);
          break;
        case "option":
          tr(c, x);
          break;
        case "select":
          Pp(c, x), Cr("invalid", c);
          break;
        case "textarea":
          Xw(c, x), Cr("invalid", c);
          break;
      }
      oi(d, x);
      {
        J = /* @__PURE__ */ new Set();
        for (var de = c.attributes, De = 0; De < de.length; De++) {
          var Ce = de[De].name.toLowerCase();
          switch (Ce) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              J.add(de[De].name);
          }
        }
      }
      var Ue = null;
      for (var Ve in x)
        if (x.hasOwnProperty(Ve)) {
          var Ze = x[Ve];
          if (Ve === f0)
            typeof Ze == "string" ? c.textContent !== Ze && (x[iy] !== !0 && I1(c.textContent, Ze, I, F), Ue = [f0, Ze]) : typeof Ze == "number" && c.textContent !== "" + Ze && (x[iy] !== !0 && I1(c.textContent, Ze, I, F), Ue = [f0, "" + Ze]);
          else if (we.hasOwnProperty(Ve))
            Ze != null && (typeof Ze != "function" && Z2(Ve, Ze), Ve === "onScroll" && Cr("scroll", c));
          else if (F && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof G == "boolean") {
            var Yt = void 0, yn = G && ye ? null : Wa(Ve);
            if (x[iy] !== !0) {
              if (!(Ve === c0 || Ve === iy || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Ve === "value" || Ve === "checked" || Ve === "selected")) {
                if (Ve === P1) {
                  var on = c.innerHTML, Yr = Ze ? Ze[X2] : void 0;
                  if (Yr != null) {
                    var Nr = G4(c, Yr);
                    Nr !== on && L_(Ve, on, Nr);
                  }
                } else if (Ve === d0) {
                  if (J.delete(Ve), q4) {
                    var je = xm(Ze);
                    Yt = c.getAttribute("style"), je !== Yt && L_(Ve, Yt, je);
                  }
                } else if (G && !ye)
                  J.delete(Ve.toLowerCase()), Yt = as(c, Ve, Ze), Ze !== Yt && L_(Ve, Yt, Ze);
                else if (!bi(Ve, yn, G) && !Zr(Ve, Ze, yn, G)) {
                  var Je = !1;
                  if (yn !== null)
                    J.delete(yn.attributeName), Yt = _s(c, Ve, Ze, yn);
                  else {
                    var Le = E;
                    if (Le === Yc && (Le = hm(d)), Le === Yc)
                      J.delete(Ve.toLowerCase());
                    else {
                      var vt = D9(Ve);
                      vt !== null && vt !== Ve && (Je = !0, J.delete(vt)), J.delete(Ve);
                    }
                    Yt = as(c, Ve, Ze);
                  }
                  var Ht = ye;
                  !Ht && Ze !== Yt && !Je && L_(Ve, Yt, Ze);
                }
              }
            }
          }
        }
      switch (F && // $FlowFixMe - Should be inferred as not undefined.
      J.size > 0 && x[iy] !== !0 && W4(J), d) {
        case "input":
          ll(c), gt(c, x, !0);
          break;
        case "textarea":
          ll(c), Ip(c);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof x.onClick == "function" && eM(c);
          break;
      }
      return Ue;
    }
    function K4(c, d, x) {
      var E = c.nodeValue !== d;
      return E;
    }
    function xD(c, d) {
      {
        if (Sl)
          return;
        Sl = !0, a("Did not expect server HTML to contain a <%s> in <%s>.", d.nodeName.toLowerCase(), c.nodeName.toLowerCase());
      }
    }
    function wD(c, d) {
      {
        if (Sl)
          return;
        Sl = !0, a('Did not expect server HTML to contain the text node "%s" in <%s>.', d.nodeValue, c.nodeName.toLowerCase());
      }
    }
    function _D(c, d, x) {
      {
        if (Sl)
          return;
        Sl = !0, a("Expected server HTML to contain a matching <%s> in <%s>.", d, c.nodeName.toLowerCase());
      }
    }
    function tM(c, d) {
      {
        if (d === "" || Sl)
          return;
        Sl = !0, a('Expected server HTML to contain a matching text node for "%s" in <%s>.', d, c.nodeName.toLowerCase());
      }
    }
    function Z4(c, d, x) {
      switch (d) {
        case "input":
          gn(c, x);
          return;
        case "textarea":
          Kw(c, x);
          return;
        case "select":
          WN(c, x);
          return;
      }
    }
    var z_ = function() {
    }, F_ = function() {
    };
    {
      var O9 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], J4 = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], j1 = J4.concat(["button"]), R9 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], eP = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      F_ = function(c, d) {
        var x = cr({}, c || eP), E = {
          tag: d
        };
        return J4.indexOf(d) !== -1 && (x.aTagInScope = null, x.buttonTagInScope = null, x.nobrTagInScope = null), j1.indexOf(d) !== -1 && (x.pTagInButtonScope = null), O9.indexOf(d) !== -1 && d !== "address" && d !== "div" && d !== "p" && (x.listItemTagAutoclosing = null, x.dlItemTagAutoclosing = null), x.current = E, d === "form" && (x.formTag = E), d === "a" && (x.aTagInScope = E), d === "button" && (x.buttonTagInScope = E), d === "nobr" && (x.nobrTagInScope = E), d === "p" && (x.pTagInButtonScope = E), d === "li" && (x.listItemTagAutoclosing = E), (d === "dd" || d === "dt") && (x.dlItemTagAutoclosing = E), x;
      };
      var k9 = function(c, d) {
        switch (d) {
          case "select":
            return c === "option" || c === "optgroup" || c === "#text";
          case "optgroup":
            return c === "option" || c === "#text";
          case "option":
            return c === "#text";
          case "tr":
            return c === "th" || c === "td" || c === "style" || c === "script" || c === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return c === "tr" || c === "style" || c === "script" || c === "template";
          case "colgroup":
            return c === "col" || c === "template";
          case "table":
            return c === "caption" || c === "colgroup" || c === "tbody" || c === "tfoot" || c === "thead" || c === "style" || c === "script" || c === "template";
          case "head":
            return c === "base" || c === "basefont" || c === "bgsound" || c === "link" || c === "meta" || c === "title" || c === "noscript" || c === "noframes" || c === "style" || c === "script" || c === "template";
          case "html":
            return c === "head" || c === "body" || c === "frameset";
          case "frameset":
            return c === "frame";
          case "#document":
            return c === "html";
        }
        switch (c) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return d !== "h1" && d !== "h2" && d !== "h3" && d !== "h4" && d !== "h5" && d !== "h6";
          case "rp":
          case "rt":
            return R9.indexOf(d) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return d == null;
        }
        return !0;
      }, $9 = function(c, d) {
        switch (c) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return d.pTagInButtonScope;
          case "form":
            return d.formTag || d.pTagInButtonScope;
          case "li":
            return d.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return d.dlItemTagAutoclosing;
          case "button":
            return d.buttonTagInScope;
          case "a":
            return d.aTagInScope;
          case "nobr":
            return d.nobrTagInScope;
        }
        return null;
      }, tP = {};
      z_ = function(c, d, x) {
        x = x || eP;
        var E = x.current, D = E && E.tag;
        d != null && (c != null && a("validateDOMNesting: when childText is passed, childTag should be null"), c = "#text");
        var I = k9(c, D) ? null : E, F = I ? null : $9(c, x), G = I || F;
        if (G) {
          var J = G.tag, le = !!I + "|" + c + "|" + J;
          if (!tP[le]) {
            tP[le] = !0;
            var de = c, De = "";
            if (c === "#text" ? /\S/.test(d) ? de = "Text nodes" : (de = "Whitespace text nodes", De = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : de = "<" + c + ">", I) {
              var Ce = "";
              J === "table" && c === "tr" && (Ce += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), a("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", de, J, De, Ce);
            } else
              a("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", de, J);
          }
        }
      };
    }
    var B_ = "suppressHydrationWarning", U_ = "$", nM = "/$", Y_ = "$?", H_ = "$!", P9 = "style", ED = null, SD = null;
    function I9(c) {
      var d, x, E = c.nodeType;
      switch (E) {
        case Su:
        case ec: {
          d = E === Su ? "#document" : "#fragment";
          var D = c.documentElement;
          x = D ? D.namespaceURI : Lb(null, "");
          break;
        }
        default: {
          var I = E === Wr ? c.parentNode : c, F = I.namespaceURI || null;
          d = I.tagName, x = Lb(F, d);
          break;
        }
      }
      {
        var G = d.toLowerCase(), J = F_(null, G);
        return {
          namespace: x,
          ancestorInfo: J
        };
      }
    }
    function j9(c, d, x) {
      {
        var E = c, D = Lb(E.namespace, d), I = F_(E.ancestorInfo, d);
        return {
          namespace: D,
          ancestorInfo: I
        };
      }
    }
    function Yie(c) {
      return c;
    }
    function L9(c) {
      ED = Iu(), SD = dd();
      var d = null;
      return Na(!1), d;
    }
    function z9(c) {
      d9(SD), Na(ED), ED = null, SD = null;
    }
    function F9(c, d, x, E, D) {
      var I;
      {
        var F = E;
        if (z_(c, null, F.ancestorInfo), typeof d.children == "string" || typeof d.children == "number") {
          var G = "" + d.children, J = F_(F.ancestorInfo, c);
          z_(null, G, J);
        }
        I = F.namespace;
      }
      var le = M9(c, d, x, I);
      return Se(D, le), ur(le, d), le;
    }
    function B9(c, d) {
      c.appendChild(d);
    }
    function U9(c, d, x, E, D) {
      switch (C9(c, d, x, E), d) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!x.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function Y9(c, d, x, E, D, I) {
      {
        var F = I;
        if (typeof E.children != typeof x.children && (typeof E.children == "string" || typeof E.children == "number")) {
          var G = "" + E.children, J = F_(F.ancestorInfo, d);
          z_(null, G, J);
        }
      }
      return X4(c, d, x, E);
    }
    function MD(c, d) {
      return c === "textarea" || c === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
    }
    function H9(c, d, x, E) {
      {
        var D = x;
        z_(null, c, D.ancestorInfo);
      }
      var I = T9(c, d);
      return Se(E, I), I;
    }
    function V9() {
      var c = window.event;
      return c === void 0 ? ho : As(c.type);
    }
    var TD = typeof setTimeout == "function" ? setTimeout : void 0, W9 = typeof clearTimeout == "function" ? clearTimeout : void 0, CD = -1, nP = typeof Promise == "function" ? Promise : void 0, q9 = typeof queueMicrotask == "function" ? queueMicrotask : typeof nP < "u" ? function(c) {
      return nP.resolve(null).then(c).catch(G9);
    } : TD;
    function G9(c) {
      setTimeout(function() {
        throw c;
      });
    }
    function Q9(c, d, x, E) {
      switch (d) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          x.autoFocus && c.focus();
          return;
        case "img": {
          x.src && (c.src = x.src);
          return;
        }
      }
    }
    function ND(c, d, x, E, D, I) {
      N9(c, d, x, E, D), ur(c, D);
    }
    function DD(c) {
      Sv(c, "");
    }
    function rP(c, d, x) {
      c.nodeValue = x;
    }
    function X9(c, d) {
      c.appendChild(d);
    }
    function K9(c, d) {
      var x;
      c.nodeType === Wr ? (x = c.parentNode, x.insertBefore(d, c)) : (x = c, x.appendChild(d));
      var E = c._reactRootContainer;
      E == null && x.onclick === null && eM(x);
    }
    function Z9(c, d, x) {
      c.insertBefore(d, x);
    }
    function AD(c, d, x) {
      c.nodeType === Wr ? c.parentNode.insertBefore(d, x) : c.insertBefore(d, x);
    }
    function J9(c, d) {
      c.removeChild(d);
    }
    function e7(c, d) {
      c.nodeType === Wr ? c.parentNode.removeChild(d) : c.removeChild(d);
    }
    function OD(c, d) {
      var x = d, E = 0;
      do {
        var D = x.nextSibling;
        if (c.removeChild(x), D && D.nodeType === Wr) {
          var I = D.data;
          if (I === nM)
            if (E === 0) {
              c.removeChild(D), vr(d);
              return;
            } else
              E--;
          else
            (I === U_ || I === Y_ || I === H_) && E++;
        }
        x = D;
      } while (x);
      vr(d);
    }
    function Tl(c, d) {
      c.nodeType === Wr ? OD(c.parentNode, d) : c.nodeType === tu && OD(c, d), vr(c);
    }
    function RD(c) {
      c = c;
      var d = c.style;
      typeof d.setProperty == "function" ? d.setProperty("display", "none", "important") : d.display = "none";
    }
    function t7(c) {
      c.nodeValue = "";
    }
    function n7(c, d) {
      c = c;
      var x = d[P9], E = x != null && x.hasOwnProperty("display") ? x.display : null;
      c.style.display = Fb("display", E);
    }
    function r7(c, d) {
      c.nodeValue = d;
    }
    function i7(c) {
      c.nodeType === tu ? c.textContent = "" : c.nodeType === Su && c.documentElement && c.removeChild(c.documentElement);
    }
    function kD(c, d, x) {
      return c.nodeType !== tu || d.toLowerCase() !== c.nodeName.toLowerCase() ? null : c;
    }
    function o7(c, d) {
      return d === "" || c.nodeType !== Hc ? null : c;
    }
    function $D(c) {
      return c.nodeType !== Wr ? null : c;
    }
    function iP(c) {
      return c.data === Y_;
    }
    function PD(c) {
      return c.data === H_;
    }
    function a7(c) {
      var d = c.nextSibling && c.nextSibling.dataset, x, E, D;
      return d && (x = d.dgst, E = d.msg, D = d.stck), {
        message: E,
        digest: x,
        stack: D
      };
    }
    function s7(c, d) {
      c._reactRetry = d;
    }
    function V_(c) {
      for (; c != null; c = c.nextSibling) {
        var d = c.nodeType;
        if (d === tu || d === Hc)
          break;
        if (d === Wr) {
          var x = c.data;
          if (x === U_ || x === H_ || x === Y_)
            break;
          if (x === nM)
            return null;
        }
      }
      return c;
    }
    function W_(c) {
      return V_(c.nextSibling);
    }
    function u7(c) {
      return V_(c.firstChild);
    }
    function l7(c) {
      return V_(c.firstChild);
    }
    function ID(c) {
      return V_(c.nextSibling);
    }
    function jD(c, d, x, E, D, I, F) {
      Se(I, c), ur(c, x);
      var G;
      {
        var J = D;
        G = J.namespace;
      }
      var le = (I.mode & fr) !== hn;
      return A9(c, d, x, G, E, le, F);
    }
    function c7(c, d, x, E) {
      return Se(x, c), x.mode & fr, K4(c, d);
    }
    function f7(c, d) {
      Se(d, c);
    }
    function d7(c) {
      for (var d = c.nextSibling, x = 0; d; ) {
        if (d.nodeType === Wr) {
          var E = d.data;
          if (E === nM) {
            if (x === 0)
              return W_(d);
            x--;
          } else
            (E === U_ || E === H_ || E === Y_) && x++;
        }
        d = d.nextSibling;
      }
      return null;
    }
    function oP(c) {
      for (var d = c.previousSibling, x = 0; d; ) {
        if (d.nodeType === Wr) {
          var E = d.data;
          if (E === U_ || E === H_ || E === Y_) {
            if (x === 0)
              return d;
            x--;
          } else
            E === nM && x++;
        }
        d = d.previousSibling;
      }
      return null;
    }
    function h7(c) {
      vr(c);
    }
    function p7(c) {
      vr(c);
    }
    function g7(c) {
      return c !== "head" && c !== "body";
    }
    function m7(c, d, x, E) {
      var D = !0;
      I1(d.nodeValue, x, E, D);
    }
    function y7(c, d, x, E, D, I) {
      if (d[B_] !== !0) {
        var F = !0;
        I1(E.nodeValue, D, I, F);
      }
    }
    function v7(c, d) {
      d.nodeType === tu ? xD(c, d) : d.nodeType === Wr || wD(c, d);
    }
    function b7(c, d) {
      {
        var x = c.parentNode;
        x !== null && (d.nodeType === tu ? xD(x, d) : d.nodeType === Wr || wD(x, d));
      }
    }
    function x7(c, d, x, E, D) {
      (D || d[B_] !== !0) && (E.nodeType === tu ? xD(x, E) : E.nodeType === Wr || wD(x, E));
    }
    function w7(c, d, x) {
      _D(c, d);
    }
    function _7(c, d) {
      tM(c, d);
    }
    function E7(c, d, x) {
      {
        var E = c.parentNode;
        E !== null && _D(E, d);
      }
    }
    function S7(c, d) {
      {
        var x = c.parentNode;
        x !== null && tM(x, d);
      }
    }
    function M7(c, d, x, E, D, I) {
      (I || d[B_] !== !0) && _D(x, E);
    }
    function T7(c, d, x, E, D) {
      (D || d[B_] !== !0) && tM(x, E);
    }
    function C7(c) {
      a("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", c.nodeName.toLowerCase());
    }
    function N7(c) {
      j_(c);
    }
    var L1 = Math.random().toString(36).slice(2), w = "__reactFiber$" + L1, M = "__reactProps$" + L1, P = "__reactContainer$" + L1, U = "__reactEvents$" + L1, re = "__reactListeners$" + L1, ce = "__reactHandles$" + L1;
    function ve(c) {
      delete c[w], delete c[M], delete c[U], delete c[re], delete c[ce];
    }
    function Se(c, d) {
      d[w] = c;
    }
    function Re(c, d) {
      d[P] = c;
    }
    function st(c) {
      c[P] = null;
    }
    function rt(c) {
      return !!c[P];
    }
    function ct(c) {
      var d = c[w];
      if (d)
        return d;
      for (var x = c.parentNode; x; ) {
        if (d = x[P] || x[w], d) {
          var E = d.alternate;
          if (d.child !== null || E !== null && E.child !== null)
            for (var D = oP(c); D !== null; ) {
              var I = D[w];
              if (I)
                return I;
              D = oP(D);
            }
          return d;
        }
        c = x, x = c.parentNode;
      }
      return null;
    }
    function Nt(c) {
      var d = c[w] || c[P];
      return d && (d.tag === g || d.tag === y || d.tag === R || d.tag === h) ? d : null;
    }
    function Gt(c) {
      if (c.tag === g || c.tag === y)
        return c.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Sn(c) {
      return c[M] || null;
    }
    function ur(c, d) {
      c[M] = d;
    }
    function Rn(c) {
      var d = c[U];
      return d === void 0 && (d = c[U] = /* @__PURE__ */ new Set()), d;
    }
    var Sr = {}, $r = n.ReactDebugCurrentFrame;
    function uu(c) {
      if (c) {
        var d = c._owner, x = ul(c.type, c._source, d ? d.type : null);
        $r.setExtraStackFrame(x);
      } else
        $r.setExtraStackFrame(null);
    }
    function wo(c, d, x, E, D) {
      {
        var I = Function.call.bind($e);
        for (var F in c)
          if (I(c, F)) {
            var G = void 0;
            try {
              if (typeof c[F] != "function") {
                var J = Error((E || "React class") + ": " + x + " type `" + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[F] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw J.name = "Invariant Violation", J;
              }
              G = c[F](d, F, E, x, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (le) {
              G = le;
            }
            G && !(G instanceof Error) && (uu(D), a("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", E || "React class", x, F, typeof G), uu(null)), G instanceof Error && !(G.message in Sr) && (Sr[G.message] = !0, uu(D), a("Failed %s type: %s", x, G.message), uu(null));
          }
      }
    }
    var Lu = [], Io;
    Io = [];
    var Qa = -1;
    function lu(c) {
      return {
        current: c
      };
    }
    function Os(c, d) {
      if (Qa < 0) {
        a("Unexpected pop.");
        return;
      }
      d !== Io[Qa] && a("Unexpected Fiber popped."), c.current = Lu[Qa], Lu[Qa] = null, Io[Qa] = null, Qa--;
    }
    function Cl(c, d, x) {
      Qa++, Lu[Qa] = c.current, Io[Qa] = x, c.current = d;
    }
    var D7;
    D7 = {};
    var hd = {};
    Object.freeze(hd);
    var h0 = lu(hd), oy = lu(!1), A7 = hd;
    function rM(c, d, x) {
      return x && ay(d) ? A7 : h0.current;
    }
    function Hie(c, d, x) {
      {
        var E = c.stateNode;
        E.__reactInternalMemoizedUnmaskedChildContext = d, E.__reactInternalMemoizedMaskedChildContext = x;
      }
    }
    function iM(c, d) {
      {
        var x = c.type, E = x.contextTypes;
        if (!E)
          return hd;
        var D = c.stateNode;
        if (D && D.__reactInternalMemoizedUnmaskedChildContext === d)
          return D.__reactInternalMemoizedMaskedChildContext;
        var I = {};
        for (var F in E)
          I[F] = d[F];
        {
          var G = jn(c) || "Unknown";
          wo(E, I, "context", G);
        }
        return D && Hie(c, d, I), I;
      }
    }
    function aP() {
      return oy.current;
    }
    function ay(c) {
      {
        var d = c.childContextTypes;
        return d != null;
      }
    }
    function sP(c) {
      Os(oy, c), Os(h0, c);
    }
    function O7(c) {
      Os(oy, c), Os(h0, c);
    }
    function Vie(c, d, x) {
      {
        if (h0.current !== hd)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Cl(h0, d, c), Cl(oy, x, c);
      }
    }
    function Wie(c, d, x) {
      {
        var E = c.stateNode, D = d.childContextTypes;
        if (typeof E.getChildContext != "function") {
          {
            var I = jn(c) || "Unknown";
            D7[I] || (D7[I] = !0, a("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", I, I));
          }
          return x;
        }
        var F = E.getChildContext();
        for (var G in F)
          if (!(G in D))
            throw new Error((jn(c) || "Unknown") + '.getChildContext(): key "' + G + '" is not defined in childContextTypes.');
        {
          var J = jn(c) || "Unknown";
          wo(D, F, "child context", J);
        }
        return cr({}, x, F);
      }
    }
    function uP(c) {
      {
        var d = c.stateNode, x = d && d.__reactInternalMemoizedMergedChildContext || hd;
        return A7 = h0.current, Cl(h0, x, c), Cl(oy, oy.current, c), !0;
      }
    }
    function qie(c, d, x) {
      {
        var E = c.stateNode;
        if (!E)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (x) {
          var D = Wie(c, d, A7);
          E.__reactInternalMemoizedMergedChildContext = D, Os(oy, c), Os(h0, c), Cl(h0, D, c), Cl(oy, x, c);
        } else
          Os(oy, c), Cl(oy, x, c);
      }
    }
    function n3e(c) {
      {
        if (!Yp(c) || c.tag !== l)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var d = c;
        do {
          switch (d.tag) {
            case h:
              return d.stateNode.context;
            case l: {
              var x = d.type;
              if (ay(x))
                return d.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          d = d.return;
        } while (d !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var z1 = 0, lP = 1, p0 = null, R7 = !1, k7 = !1;
    function Gie(c) {
      p0 === null ? p0 = [c] : p0.push(c);
    }
    function r3e(c) {
      R7 = !0, Gie(c);
    }
    function Qie() {
      R7 && F1();
    }
    function F1() {
      if (!k7 && p0 !== null) {
        k7 = !0;
        var c = 0, d = Ru();
        try {
          var x = !0, E = p0;
          for (pa(Ta); c < E.length; c++) {
            var D = E[c];
            do
              D = D(x);
            while (D !== null);
          }
          p0 = null, R7 = !1;
        } catch (I) {
          throw p0 !== null && (p0 = p0.slice(c + 1)), Cs(Iv, F1), I;
        } finally {
          pa(d), k7 = !1;
        }
      }
      return null;
    }
    var oM = [], aM = 0, cP = null, fP = 0, zh = [], Fh = 0, q_ = null, g0 = 1, m0 = "";
    function i3e(c) {
      return Q_(), (c.flags & i_) !== cn;
    }
    function o3e(c) {
      return Q_(), fP;
    }
    function a3e() {
      var c = m0, d = g0, x = d & ~s3e(d);
      return x.toString(32) + c;
    }
    function G_(c, d) {
      Q_(), oM[aM++] = fP, oM[aM++] = cP, cP = c, fP = d;
    }
    function Xie(c, d, x) {
      Q_(), zh[Fh++] = g0, zh[Fh++] = m0, zh[Fh++] = q_, q_ = c;
      var E = g0, D = m0, I = dP(E) - 1, F = E & ~(1 << I), G = x + 1, J = dP(d) + I;
      if (J > 30) {
        var le = I - I % 5, de = (1 << le) - 1, De = (F & de).toString(32), Ce = F >> le, Ue = I - le, Ve = dP(d) + Ue, Ze = G << Ue, Yt = Ze | Ce, yn = De + D;
        g0 = 1 << Ve | Yt, m0 = yn;
      } else {
        var on = G << I, Yr = on | F, Nr = D;
        g0 = 1 << J | Yr, m0 = Nr;
      }
    }
    function $7(c) {
      Q_();
      var d = c.return;
      if (d !== null) {
        var x = 1, E = 0;
        G_(c, x), Xie(c, x, E);
      }
    }
    function dP(c) {
      return 32 - a1(c);
    }
    function s3e(c) {
      return 1 << dP(c) - 1;
    }
    function P7(c) {
      for (; c === cP; )
        cP = oM[--aM], oM[aM] = null, fP = oM[--aM], oM[aM] = null;
      for (; c === q_; )
        q_ = zh[--Fh], zh[Fh] = null, m0 = zh[--Fh], zh[Fh] = null, g0 = zh[--Fh], zh[Fh] = null;
    }
    function u3e() {
      return Q_(), q_ !== null ? {
        id: g0,
        overflow: m0
      } : null;
    }
    function l3e(c, d) {
      Q_(), zh[Fh++] = g0, zh[Fh++] = m0, zh[Fh++] = q_, g0 = d.id, m0 = d.overflow, q_ = c;
    }
    function Q_() {
      Fu() || a("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var zu = null, Bh = null, sg = !1, X_ = !1, B1 = null;
    function c3e() {
      sg && a("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Kie() {
      X_ = !0;
    }
    function f3e() {
      return X_;
    }
    function d3e(c) {
      var d = c.stateNode.containerInfo;
      return Bh = l7(d), zu = c, sg = !0, B1 = null, X_ = !1, !0;
    }
    function h3e(c, d, x) {
      return Bh = ID(d), zu = c, sg = !0, B1 = null, X_ = !1, x !== null && l3e(c, x), !0;
    }
    function Zie(c, d) {
      switch (c.tag) {
        case h: {
          v7(c.stateNode.containerInfo, d);
          break;
        }
        case g: {
          var x = (c.mode & fr) !== hn;
          x7(
            c.type,
            c.memoizedProps,
            c.stateNode,
            d,
            // TODO: Delete this argument when we remove the legacy root API.
            x
          );
          break;
        }
        case R: {
          var E = c.memoizedState;
          E.dehydrated !== null && b7(E.dehydrated, d);
          break;
        }
      }
    }
    function Jie(c, d) {
      Zie(c, d);
      var x = m5e();
      x.stateNode = d, x.return = c;
      var E = c.deletions;
      E === null ? (c.deletions = [x], c.flags |= Jr) : E.push(x);
    }
    function I7(c, d) {
      {
        if (X_)
          return;
        switch (c.tag) {
          case h: {
            var x = c.stateNode.containerInfo;
            switch (d.tag) {
              case g:
                var E = d.type;
                d.pendingProps, w7(x, E);
                break;
              case y:
                var D = d.pendingProps;
                _7(x, D);
                break;
            }
            break;
          }
          case g: {
            var I = c.type, F = c.memoizedProps, G = c.stateNode;
            switch (d.tag) {
              case g: {
                var J = d.type, le = d.pendingProps, de = (c.mode & fr) !== hn;
                M7(
                  I,
                  F,
                  G,
                  J,
                  le,
                  // TODO: Delete this argument when we remove the legacy root API.
                  de
                );
                break;
              }
              case y: {
                var De = d.pendingProps, Ce = (c.mode & fr) !== hn;
                T7(
                  I,
                  F,
                  G,
                  De,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Ce
                );
                break;
              }
            }
            break;
          }
          case R: {
            var Ue = c.memoizedState, Ve = Ue.dehydrated;
            if (Ve !== null)
              switch (d.tag) {
                case g:
                  var Ze = d.type;
                  d.pendingProps, E7(Ve, Ze);
                  break;
                case y:
                  var Yt = d.pendingProps;
                  S7(Ve, Yt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function eoe(c, d) {
      d.flags = d.flags & ~ml | no, I7(c, d);
    }
    function toe(c, d) {
      switch (c.tag) {
        case g: {
          var x = c.type;
          c.pendingProps;
          var E = kD(d, x);
          return E !== null ? (c.stateNode = E, zu = c, Bh = u7(E), !0) : !1;
        }
        case y: {
          var D = c.pendingProps, I = o7(d, D);
          return I !== null ? (c.stateNode = I, zu = c, Bh = null, !0) : !1;
        }
        case R: {
          var F = $D(d);
          if (F !== null) {
            var G = {
              dehydrated: F,
              treeContext: u3e(),
              retryLane: su
            };
            c.memoizedState = G;
            var J = y5e(F);
            return J.return = c, c.child = J, zu = c, Bh = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function j7(c) {
      return (c.mode & fr) !== hn && (c.flags & An) === cn;
    }
    function L7(c) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function z7(c) {
      if (sg) {
        var d = Bh;
        if (!d) {
          j7(c) && (I7(zu, c), L7()), eoe(zu, c), sg = !1, zu = c;
          return;
        }
        var x = d;
        if (!toe(c, d)) {
          j7(c) && (I7(zu, c), L7()), d = W_(x);
          var E = zu;
          if (!d || !toe(c, d)) {
            eoe(zu, c), sg = !1, zu = c;
            return;
          }
          Jie(E, x);
        }
      }
    }
    function p3e(c, d, x) {
      var E = c.stateNode, D = !X_, I = jD(E, c.type, c.memoizedProps, d, x, c, D);
      return c.updateQueue = I, I !== null;
    }
    function g3e(c) {
      var d = c.stateNode, x = c.memoizedProps, E = c7(d, x, c);
      if (E) {
        var D = zu;
        if (D !== null)
          switch (D.tag) {
            case h: {
              var I = D.stateNode.containerInfo, F = (D.mode & fr) !== hn;
              m7(
                I,
                d,
                x,
                // TODO: Delete this argument when we remove the legacy root API.
                F
              );
              break;
            }
            case g: {
              var G = D.type, J = D.memoizedProps, le = D.stateNode, de = (D.mode & fr) !== hn;
              y7(
                G,
                J,
                le,
                d,
                x,
                // TODO: Delete this argument when we remove the legacy root API.
                de
              );
              break;
            }
          }
      }
      return E;
    }
    function m3e(c) {
      var d = c.memoizedState, x = d !== null ? d.dehydrated : null;
      if (!x)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      f7(x, c);
    }
    function y3e(c) {
      var d = c.memoizedState, x = d !== null ? d.dehydrated : null;
      if (!x)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return d7(x);
    }
    function noe(c) {
      for (var d = c.return; d !== null && d.tag !== g && d.tag !== h && d.tag !== R; )
        d = d.return;
      zu = d;
    }
    function hP(c) {
      if (c !== zu)
        return !1;
      if (!sg)
        return noe(c), sg = !0, !1;
      if (c.tag !== h && (c.tag !== g || g7(c.type) && !MD(c.type, c.memoizedProps))) {
        var d = Bh;
        if (d)
          if (j7(c))
            roe(c), L7();
          else
            for (; d; )
              Jie(c, d), d = W_(d);
      }
      return noe(c), c.tag === R ? Bh = y3e(c) : Bh = zu ? W_(c.stateNode) : null, !0;
    }
    function v3e() {
      return sg && Bh !== null;
    }
    function roe(c) {
      for (var d = Bh; d; )
        Zie(c, d), d = W_(d);
    }
    function sM() {
      zu = null, Bh = null, sg = !1, X_ = !1;
    }
    function ioe() {
      B1 !== null && (Zae(B1), B1 = null);
    }
    function Fu() {
      return sg;
    }
    function F7(c) {
      B1 === null ? B1 = [c] : B1.push(c);
    }
    var b3e = n.ReactCurrentBatchConfig, x3e = null;
    function w3e() {
      return b3e.transition;
    }
    var ug = {
      recordUnsafeLifecycleWarnings: function(c, d) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(c, d) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var _3e = function(c) {
        for (var d = null, x = c; x !== null; )
          x.mode & lo && (d = x), x = x.return;
        return d;
      }, K_ = function(c) {
        var d = [];
        return c.forEach(function(x) {
          d.push(x);
        }), d.sort().join(", ");
      }, LD = [], zD = [], FD = [], BD = [], UD = [], YD = [], Z_ = /* @__PURE__ */ new Set();
      ug.recordUnsafeLifecycleWarnings = function(c, d) {
        Z_.has(c.type) || (typeof d.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        d.componentWillMount.__suppressDeprecationWarning !== !0 && LD.push(c), c.mode & lo && typeof d.UNSAFE_componentWillMount == "function" && zD.push(c), typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && FD.push(c), c.mode & lo && typeof d.UNSAFE_componentWillReceiveProps == "function" && BD.push(c), typeof d.componentWillUpdate == "function" && d.componentWillUpdate.__suppressDeprecationWarning !== !0 && UD.push(c), c.mode & lo && typeof d.UNSAFE_componentWillUpdate == "function" && YD.push(c));
      }, ug.flushPendingUnsafeLifecycleWarnings = function() {
        var c = /* @__PURE__ */ new Set();
        LD.length > 0 && (LD.forEach(function(Ce) {
          c.add(jn(Ce) || "Component"), Z_.add(Ce.type);
        }), LD = []);
        var d = /* @__PURE__ */ new Set();
        zD.length > 0 && (zD.forEach(function(Ce) {
          d.add(jn(Ce) || "Component"), Z_.add(Ce.type);
        }), zD = []);
        var x = /* @__PURE__ */ new Set();
        FD.length > 0 && (FD.forEach(function(Ce) {
          x.add(jn(Ce) || "Component"), Z_.add(Ce.type);
        }), FD = []);
        var E = /* @__PURE__ */ new Set();
        BD.length > 0 && (BD.forEach(function(Ce) {
          E.add(jn(Ce) || "Component"), Z_.add(Ce.type);
        }), BD = []);
        var D = /* @__PURE__ */ new Set();
        UD.length > 0 && (UD.forEach(function(Ce) {
          D.add(jn(Ce) || "Component"), Z_.add(Ce.type);
        }), UD = []);
        var I = /* @__PURE__ */ new Set();
        if (YD.length > 0 && (YD.forEach(function(Ce) {
          I.add(jn(Ce) || "Component"), Z_.add(Ce.type);
        }), YD = []), d.size > 0) {
          var F = K_(d);
          a(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, F);
        }
        if (E.size > 0) {
          var G = K_(E);
          a(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, G);
        }
        if (I.size > 0) {
          var J = K_(I);
          a(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, J);
        }
        if (c.size > 0) {
          var le = K_(c);
          o(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, le);
        }
        if (x.size > 0) {
          var de = K_(x);
          o(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, de);
        }
        if (D.size > 0) {
          var De = K_(D);
          o(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, De);
        }
      };
      var pP = /* @__PURE__ */ new Map(), ooe = /* @__PURE__ */ new Set();
      ug.recordLegacyContextWarning = function(c, d) {
        var x = _3e(c);
        if (x === null) {
          a("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!ooe.has(c.type)) {
          var E = pP.get(x);
          (c.type.contextTypes != null || c.type.childContextTypes != null || d !== null && typeof d.getChildContext == "function") && (E === void 0 && (E = [], pP.set(x, E)), E.push(c));
        }
      }, ug.flushLegacyContextWarning = function() {
        pP.forEach(function(c, d) {
          if (c.length !== 0) {
            var x = c[0], E = /* @__PURE__ */ new Set();
            c.forEach(function(I) {
              E.add(jn(I) || "Component"), ooe.add(I.type);
            });
            var D = K_(E);
            try {
              ii(x), a(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, D);
            } finally {
              Do();
            }
          }
        });
      }, ug.discardPendingWarnings = function() {
        LD = [], zD = [], FD = [], BD = [], UD = [], YD = [], pP = /* @__PURE__ */ new Map();
      };
    }
    function lg(c, d) {
      if (c && c.defaultProps) {
        var x = cr({}, d), E = c.defaultProps;
        for (var D in E)
          x[D] === void 0 && (x[D] = E[D]);
        return x;
      }
      return d;
    }
    var B7 = lu(null), U7;
    U7 = {};
    var gP = null, uM = null, Y7 = null, mP = !1;
    function yP() {
      gP = null, uM = null, Y7 = null, mP = !1;
    }
    function aoe() {
      mP = !0;
    }
    function soe() {
      mP = !1;
    }
    function uoe(c, d, x) {
      Cl(B7, d._currentValue, c), d._currentValue = x, d._currentRenderer !== void 0 && d._currentRenderer !== null && d._currentRenderer !== U7 && a("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer = U7;
    }
    function H7(c, d) {
      var x = B7.current;
      Os(B7, d), c._currentValue = x;
    }
    function V7(c, d, x) {
      for (var E = c; E !== null; ) {
        var D = E.alternate;
        if (Ch(E.childLanes, d) ? D !== null && !Ch(D.childLanes, d) && (D.childLanes = Gn(D.childLanes, d)) : (E.childLanes = Gn(E.childLanes, d), D !== null && (D.childLanes = Gn(D.childLanes, d))), E === x)
          break;
        E = E.return;
      }
      E !== x && a("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function E3e(c, d, x) {
      S3e(c, d, x);
    }
    function S3e(c, d, x) {
      var E = c.child;
      for (E !== null && (E.return = c); E !== null; ) {
        var D = void 0, I = E.dependencies;
        if (I !== null) {
          D = E.child;
          for (var F = I.firstContext; F !== null; ) {
            if (F.context === d) {
              if (E.tag === l) {
                var G = ha(x), J = y0(si, G);
                J.tag = bP;
                var le = E.updateQueue;
                if (le !== null) {
                  var de = le.shared, De = de.pending;
                  De === null ? J.next = J : (J.next = De.next, De.next = J), de.pending = J;
                }
              }
              E.lanes = Gn(E.lanes, x);
              var Ce = E.alternate;
              Ce !== null && (Ce.lanes = Gn(Ce.lanes, x)), V7(E.return, x, c), I.lanes = Gn(I.lanes, x);
              break;
            }
            F = F.next;
          }
        } else if (E.tag === C)
          D = E.type === c.type ? null : E.child;
        else if (E.tag === Y) {
          var Ue = E.return;
          if (Ue === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ue.lanes = Gn(Ue.lanes, x);
          var Ve = Ue.alternate;
          Ve !== null && (Ve.lanes = Gn(Ve.lanes, x)), V7(Ue, x, c), D = E.sibling;
        } else
          D = E.child;
        if (D !== null)
          D.return = E;
        else
          for (D = E; D !== null; ) {
            if (D === c) {
              D = null;
              break;
            }
            var Ze = D.sibling;
            if (Ze !== null) {
              Ze.return = D.return, D = Ze;
              break;
            }
            D = D.return;
          }
        E = D;
      }
    }
    function lM(c, d) {
      gP = c, uM = null, Y7 = null;
      var x = c.dependencies;
      if (x !== null) {
        var E = x.firstContext;
        E !== null && (Ns(x.lanes, d) && rA(), x.firstContext = null);
      }
    }
    function ys(c) {
      mP && a("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var d = c._currentValue;
      if (Y7 !== c) {
        var x = {
          context: c,
          memoizedValue: d,
          next: null
        };
        if (uM === null) {
          if (gP === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          uM = x, gP.dependencies = {
            lanes: Xe,
            firstContext: x
          };
        } else
          uM = uM.next = x;
      }
      return d;
    }
    var J_ = null;
    function W7(c) {
      J_ === null ? J_ = [c] : J_.push(c);
    }
    function M3e() {
      if (J_ !== null) {
        for (var c = 0; c < J_.length; c++) {
          var d = J_[c], x = d.interleaved;
          if (x !== null) {
            d.interleaved = null;
            var E = x.next, D = d.pending;
            if (D !== null) {
              var I = D.next;
              D.next = E, x.next = I;
            }
            d.pending = x;
          }
        }
        J_ = null;
      }
    }
    function loe(c, d, x, E) {
      var D = d.interleaved;
      return D === null ? (x.next = x, W7(d)) : (x.next = D.next, D.next = x), d.interleaved = x, vP(c, E);
    }
    function T3e(c, d, x, E) {
      var D = d.interleaved;
      D === null ? (x.next = x, W7(d)) : (x.next = D.next, D.next = x), d.interleaved = x;
    }
    function C3e(c, d, x, E) {
      var D = d.interleaved;
      return D === null ? (x.next = x, W7(d)) : (x.next = D.next, D.next = x), d.interleaved = x, vP(c, E);
    }
    function af(c, d) {
      return vP(c, d);
    }
    var N3e = vP;
    function vP(c, d) {
      c.lanes = Gn(c.lanes, d);
      var x = c.alternate;
      x !== null && (x.lanes = Gn(x.lanes, d)), x === null && (c.flags & (no | ml)) !== cn && cse(c);
      for (var E = c, D = c.return; D !== null; )
        D.childLanes = Gn(D.childLanes, d), x = D.alternate, x !== null ? x.childLanes = Gn(x.childLanes, d) : (D.flags & (no | ml)) !== cn && cse(c), E = D, D = D.return;
      if (E.tag === h) {
        var I = E.stateNode;
        return I;
      } else
        return null;
    }
    var coe = 0, foe = 1, bP = 2, q7 = 3, xP = !1, G7, wP;
    G7 = !1, wP = null;
    function Q7(c) {
      var d = {
        baseState: c.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Xe
        },
        effects: null
      };
      c.updateQueue = d;
    }
    function doe(c, d) {
      var x = d.updateQueue, E = c.updateQueue;
      if (x === E) {
        var D = {
          baseState: E.baseState,
          firstBaseUpdate: E.firstBaseUpdate,
          lastBaseUpdate: E.lastBaseUpdate,
          shared: E.shared,
          effects: E.effects
        };
        d.updateQueue = D;
      }
    }
    function y0(c, d) {
      var x = {
        eventTime: c,
        lane: d,
        tag: coe,
        payload: null,
        callback: null,
        next: null
      };
      return x;
    }
    function U1(c, d, x) {
      var E = c.updateQueue;
      if (E === null)
        return null;
      var D = E.shared;
      if (wP === D && !G7 && (a("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), G7 = !0), NLe()) {
        var I = D.pending;
        return I === null ? d.next = d : (d.next = I.next, I.next = d), D.pending = d, N3e(c, x);
      } else
        return C3e(c, D, d, x);
    }
    function _P(c, d, x) {
      var E = d.updateQueue;
      if (E !== null) {
        var D = E.shared;
        if (d1(x)) {
          var I = D.lanes;
          I = h_(I, c.pendingLanes);
          var F = Gn(I, x);
          D.lanes = F, un(c, F);
        }
      }
    }
    function X7(c, d) {
      var x = c.updateQueue, E = c.alternate;
      if (E !== null) {
        var D = E.updateQueue;
        if (x === D) {
          var I = null, F = null, G = x.firstBaseUpdate;
          if (G !== null) {
            var J = G;
            do {
              var le = {
                eventTime: J.eventTime,
                lane: J.lane,
                tag: J.tag,
                payload: J.payload,
                callback: J.callback,
                next: null
              };
              F === null ? I = F = le : (F.next = le, F = le), J = J.next;
            } while (J !== null);
            F === null ? I = F = d : (F.next = d, F = d);
          } else
            I = F = d;
          x = {
            baseState: D.baseState,
            firstBaseUpdate: I,
            lastBaseUpdate: F,
            shared: D.shared,
            effects: D.effects
          }, c.updateQueue = x;
          return;
        }
      }
      var de = x.lastBaseUpdate;
      de === null ? x.firstBaseUpdate = d : de.next = d, x.lastBaseUpdate = d;
    }
    function D3e(c, d, x, E, D, I) {
      switch (x.tag) {
        case foe: {
          var F = x.payload;
          if (typeof F == "function") {
            aoe();
            var G = F.call(I, E, D);
            {
              if (c.mode & lo) {
                fa(!0);
                try {
                  F.call(I, E, D);
                } finally {
                  fa(!1);
                }
              }
              soe();
            }
            return G;
          }
          return F;
        }
        case q7:
          c.flags = c.flags & ~Sa | An;
        case coe: {
          var J = x.payload, le;
          if (typeof J == "function") {
            aoe(), le = J.call(I, E, D);
            {
              if (c.mode & lo) {
                fa(!0);
                try {
                  J.call(I, E, D);
                } finally {
                  fa(!1);
                }
              }
              soe();
            }
          } else
            le = J;
          return le == null ? E : cr({}, E, le);
        }
        case bP:
          return xP = !0, E;
      }
      return E;
    }
    function EP(c, d, x, E) {
      var D = c.updateQueue;
      xP = !1, wP = D.shared;
      var I = D.firstBaseUpdate, F = D.lastBaseUpdate, G = D.shared.pending;
      if (G !== null) {
        D.shared.pending = null;
        var J = G, le = J.next;
        J.next = null, F === null ? I = le : F.next = le, F = J;
        var de = c.alternate;
        if (de !== null) {
          var De = de.updateQueue, Ce = De.lastBaseUpdate;
          Ce !== F && (Ce === null ? De.firstBaseUpdate = le : Ce.next = le, De.lastBaseUpdate = J);
        }
      }
      if (I !== null) {
        var Ue = D.baseState, Ve = Xe, Ze = null, Yt = null, yn = null, on = I;
        do {
          var Yr = on.lane, Nr = on.eventTime;
          if (Ch(E, Yr)) {
            if (yn !== null) {
              var Je = {
                eventTime: Nr,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Er,
                tag: on.tag,
                payload: on.payload,
                callback: on.callback,
                next: null
              };
              yn = yn.next = Je;
            }
            Ue = D3e(c, D, on, Ue, d, x);
            var Le = on.callback;
            if (Le !== null && // If the update was already committed, we should not queue its
            // callback again.
            on.lane !== Er) {
              c.flags |= Gc;
              var vt = D.effects;
              vt === null ? D.effects = [on] : vt.push(on);
            }
          } else {
            var je = {
              eventTime: Nr,
              lane: Yr,
              tag: on.tag,
              payload: on.payload,
              callback: on.callback,
              next: null
            };
            yn === null ? (Yt = yn = je, Ze = Ue) : yn = yn.next = je, Ve = Gn(Ve, Yr);
          }
          if (on = on.next, on === null) {
            if (G = D.shared.pending, G === null)
              break;
            var Ht = G, Lt = Ht.next;
            Ht.next = null, on = Lt, D.lastBaseUpdate = Ht, D.shared.pending = null;
          }
        } while (!0);
        yn === null && (Ze = Ue), D.baseState = Ze, D.firstBaseUpdate = Yt, D.lastBaseUpdate = yn;
        var Ln = D.shared.interleaved;
        if (Ln !== null) {
          var Qn = Ln;
          do
            Ve = Gn(Ve, Qn.lane), Qn = Qn.next;
          while (Qn !== Ln);
        } else
          I === null && (D.shared.lanes = Xe);
        gA(Ve), c.lanes = Ve, c.memoizedState = Ue;
      }
      wP = null;
    }
    function A3e(c, d) {
      if (typeof c != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + c));
      c.call(d);
    }
    function hoe() {
      xP = !1;
    }
    function SP() {
      return xP;
    }
    function poe(c, d, x) {
      var E = d.effects;
      if (d.effects = null, E !== null)
        for (var D = 0; D < E.length; D++) {
          var I = E[D], F = I.callback;
          F !== null && (I.callback = null, A3e(F, x));
        }
    }
    var K7 = {}, goe = new e.Component().refs, Z7, J7, eB, tB, nB, moe, MP, rB, iB, oB;
    {
      Z7 = /* @__PURE__ */ new Set(), J7 = /* @__PURE__ */ new Set(), eB = /* @__PURE__ */ new Set(), tB = /* @__PURE__ */ new Set(), rB = /* @__PURE__ */ new Set(), nB = /* @__PURE__ */ new Set(), iB = /* @__PURE__ */ new Set(), oB = /* @__PURE__ */ new Set();
      var yoe = /* @__PURE__ */ new Set();
      MP = function(c, d) {
        if (!(c === null || typeof c == "function")) {
          var x = d + "_" + c;
          yoe.has(x) || (yoe.add(x), a("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, c));
        }
      }, moe = function(c, d) {
        if (d === void 0) {
          var x = Rr(c) || "Component";
          nB.has(x) || (nB.add(x), a("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", x));
        }
      }, Object.defineProperty(K7, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(K7);
    }
    function aB(c, d, x, E) {
      var D = c.memoizedState, I = x(E, D);
      {
        if (c.mode & lo) {
          fa(!0);
          try {
            I = x(E, D);
          } finally {
            fa(!1);
          }
        }
        moe(d, I);
      }
      var F = I == null ? D : cr({}, D, I);
      if (c.memoizedState = F, c.lanes === Xe) {
        var G = c.updateQueue;
        G.baseState = F;
      }
    }
    var sB = {
      isMounted: cs,
      enqueueSetState: function(c, d, x) {
        var E = Ts(c), D = hc(), I = X1(E), F = y0(D, I);
        F.payload = d, x != null && (MP(x, "setState"), F.callback = x);
        var G = U1(E, F, I);
        G !== null && (zs(G, E, I, D), _P(G, E, I)), wh(E, I);
      },
      enqueueReplaceState: function(c, d, x) {
        var E = Ts(c), D = hc(), I = X1(E), F = y0(D, I);
        F.tag = foe, F.payload = d, x != null && (MP(x, "replaceState"), F.callback = x);
        var G = U1(E, F, I);
        G !== null && (zs(G, E, I, D), _P(G, E, I)), wh(E, I);
      },
      enqueueForceUpdate: function(c, d) {
        var x = Ts(c), E = hc(), D = X1(x), I = y0(E, D);
        I.tag = bP, d != null && (MP(d, "forceUpdate"), I.callback = d);
        var F = U1(x, I, D);
        F !== null && (zs(F, x, D, E), _P(F, x, D)), o1(x, D);
      }
    };
    function voe(c, d, x, E, D, I, F) {
      var G = c.stateNode;
      if (typeof G.shouldComponentUpdate == "function") {
        var J = G.shouldComponentUpdate(E, I, F);
        {
          if (c.mode & lo) {
            fa(!0);
            try {
              J = G.shouldComponentUpdate(E, I, F);
            } finally {
              fa(!1);
            }
          }
          J === void 0 && a("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Rr(d) || "Component");
        }
        return J;
      }
      return d.prototype && d.prototype.isPureReactComponent ? !rn(x, E) || !rn(D, I) : !0;
    }
    function O3e(c, d, x) {
      var E = c.stateNode;
      {
        var D = Rr(d) || "Component", I = E.render;
        I || (d.prototype && typeof d.prototype.render == "function" ? a("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", D) : a("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", D)), E.getInitialState && !E.getInitialState.isReactClassApproved && !E.state && a("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", D), E.getDefaultProps && !E.getDefaultProps.isReactClassApproved && a("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", D), E.propTypes && a("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", D), E.contextType && a("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", D), E.contextTypes && a("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", D), d.contextType && d.contextTypes && !iB.has(d) && (iB.add(d), a("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", D)), typeof E.componentShouldUpdate == "function" && a("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", D), d.prototype && d.prototype.isPureReactComponent && typeof E.shouldComponentUpdate < "u" && a("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Rr(d) || "A pure component"), typeof E.componentDidUnmount == "function" && a("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", D), typeof E.componentDidReceiveProps == "function" && a("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", D), typeof E.componentWillRecieveProps == "function" && a("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", D), typeof E.UNSAFE_componentWillRecieveProps == "function" && a("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", D);
        var F = E.props !== x;
        E.props !== void 0 && F && a("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", D, D), E.defaultProps && a("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", D, D), typeof E.getSnapshotBeforeUpdate == "function" && typeof E.componentDidUpdate != "function" && !eB.has(d) && (eB.add(d), a("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Rr(d))), typeof E.getDerivedStateFromProps == "function" && a("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof E.getDerivedStateFromError == "function" && a("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof d.getSnapshotBeforeUpdate == "function" && a("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", D);
        var G = E.state;
        G && (typeof G != "object" || _r(G)) && a("%s.state: must be set to an object or null", D), typeof E.getChildContext == "function" && typeof d.childContextTypes != "object" && a("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", D);
      }
    }
    function boe(c, d) {
      d.updater = sB, c.stateNode = d, nr(d, c), d._reactInternalInstance = K7;
    }
    function xoe(c, d, x) {
      var E = !1, D = hd, I = hd, F = d.contextType;
      if ("contextType" in d) {
        var G = (
          // Allow null for conditional declaration
          F === null || F !== void 0 && F.$$typeof === St && F._context === void 0
        );
        if (!G && !oB.has(d)) {
          oB.add(d);
          var J = "";
          F === void 0 ? J = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof F != "object" ? J = " However, it is set to a " + typeof F + "." : F.$$typeof === lt ? J = " Did you accidentally pass the Context.Provider instead?" : F._context !== void 0 ? J = " Did you accidentally pass the Context.Consumer instead?" : J = " However, it is set to an object with keys {" + Object.keys(F).join(", ") + "}.", a("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Rr(d) || "Component", J);
        }
      }
      if (typeof F == "object" && F !== null)
        I = ys(F);
      else {
        D = rM(c, d, !0);
        var le = d.contextTypes;
        E = le != null, I = E ? iM(c, D) : hd;
      }
      var de = new d(x, I);
      if (c.mode & lo) {
        fa(!0);
        try {
          de = new d(x, I);
        } finally {
          fa(!1);
        }
      }
      var De = c.memoizedState = de.state !== null && de.state !== void 0 ? de.state : null;
      boe(c, de);
      {
        if (typeof d.getDerivedStateFromProps == "function" && De === null) {
          var Ce = Rr(d) || "Component";
          J7.has(Ce) || (J7.add(Ce), a("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Ce, de.state === null ? "null" : "undefined", Ce));
        }
        if (typeof d.getDerivedStateFromProps == "function" || typeof de.getSnapshotBeforeUpdate == "function") {
          var Ue = null, Ve = null, Ze = null;
          if (typeof de.componentWillMount == "function" && de.componentWillMount.__suppressDeprecationWarning !== !0 ? Ue = "componentWillMount" : typeof de.UNSAFE_componentWillMount == "function" && (Ue = "UNSAFE_componentWillMount"), typeof de.componentWillReceiveProps == "function" && de.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ve = "componentWillReceiveProps" : typeof de.UNSAFE_componentWillReceiveProps == "function" && (Ve = "UNSAFE_componentWillReceiveProps"), typeof de.componentWillUpdate == "function" && de.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ze = "componentWillUpdate" : typeof de.UNSAFE_componentWillUpdate == "function" && (Ze = "UNSAFE_componentWillUpdate"), Ue !== null || Ve !== null || Ze !== null) {
            var Yt = Rr(d) || "Component", yn = typeof d.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            tB.has(Yt) || (tB.add(Yt), a(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Yt, yn, Ue !== null ? `
  ` + Ue : "", Ve !== null ? `
  ` + Ve : "", Ze !== null ? `
  ` + Ze : ""));
          }
        }
      }
      return E && Hie(c, D, I), de;
    }
    function R3e(c, d) {
      var x = d.state;
      typeof d.componentWillMount == "function" && d.componentWillMount(), typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), x !== d.state && (a("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", jn(c) || "Component"), sB.enqueueReplaceState(d, d.state, null));
    }
    function woe(c, d, x, E) {
      var D = d.state;
      if (typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(x, E), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(x, E), d.state !== D) {
        {
          var I = jn(c) || "Component";
          Z7.has(I) || (Z7.add(I), a("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", I));
        }
        sB.enqueueReplaceState(d, d.state, null);
      }
    }
    function uB(c, d, x, E) {
      O3e(c, d, x);
      var D = c.stateNode;
      D.props = x, D.state = c.memoizedState, D.refs = goe, Q7(c);
      var I = d.contextType;
      if (typeof I == "object" && I !== null)
        D.context = ys(I);
      else {
        var F = rM(c, d, !0);
        D.context = iM(c, F);
      }
      {
        if (D.state === x) {
          var G = Rr(d) || "Component";
          rB.has(G) || (rB.add(G), a("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", G));
        }
        c.mode & lo && ug.recordLegacyContextWarning(c, D), ug.recordUnsafeLifecycleWarnings(c, D);
      }
      D.state = c.memoizedState;
      var J = d.getDerivedStateFromProps;
      if (typeof J == "function" && (aB(c, d, J, x), D.state = c.memoizedState), typeof d.getDerivedStateFromProps != "function" && typeof D.getSnapshotBeforeUpdate != "function" && (typeof D.UNSAFE_componentWillMount == "function" || typeof D.componentWillMount == "function") && (R3e(c, D), EP(c, x, D, E), D.state = c.memoizedState), typeof D.componentDidMount == "function") {
        var le = Tn;
        le |= ru, (c.mode & au) !== hn && (le |= so), c.flags |= le;
      }
    }
    function k3e(c, d, x, E) {
      var D = c.stateNode, I = c.memoizedProps;
      D.props = I;
      var F = D.context, G = d.contextType, J = hd;
      if (typeof G == "object" && G !== null)
        J = ys(G);
      else {
        var le = rM(c, d, !0);
        J = iM(c, le);
      }
      var de = d.getDerivedStateFromProps, De = typeof de == "function" || typeof D.getSnapshotBeforeUpdate == "function";
      !De && (typeof D.UNSAFE_componentWillReceiveProps == "function" || typeof D.componentWillReceiveProps == "function") && (I !== x || F !== J) && woe(c, D, x, J), hoe();
      var Ce = c.memoizedState, Ue = D.state = Ce;
      if (EP(c, x, D, E), Ue = c.memoizedState, I === x && Ce === Ue && !aP() && !SP()) {
        if (typeof D.componentDidMount == "function") {
          var Ve = Tn;
          Ve |= ru, (c.mode & au) !== hn && (Ve |= so), c.flags |= Ve;
        }
        return !1;
      }
      typeof de == "function" && (aB(c, d, de, x), Ue = c.memoizedState);
      var Ze = SP() || voe(c, d, I, x, Ce, Ue, J);
      if (Ze) {
        if (!De && (typeof D.UNSAFE_componentWillMount == "function" || typeof D.componentWillMount == "function") && (typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount()), typeof D.componentDidMount == "function") {
          var Yt = Tn;
          Yt |= ru, (c.mode & au) !== hn && (Yt |= so), c.flags |= Yt;
        }
      } else {
        if (typeof D.componentDidMount == "function") {
          var yn = Tn;
          yn |= ru, (c.mode & au) !== hn && (yn |= so), c.flags |= yn;
        }
        c.memoizedProps = x, c.memoizedState = Ue;
      }
      return D.props = x, D.state = Ue, D.context = J, Ze;
    }
    function $3e(c, d, x, E, D) {
      var I = d.stateNode;
      doe(c, d);
      var F = d.memoizedProps, G = d.type === d.elementType ? F : lg(d.type, F);
      I.props = G;
      var J = d.pendingProps, le = I.context, de = x.contextType, De = hd;
      if (typeof de == "object" && de !== null)
        De = ys(de);
      else {
        var Ce = rM(d, x, !0);
        De = iM(d, Ce);
      }
      var Ue = x.getDerivedStateFromProps, Ve = typeof Ue == "function" || typeof I.getSnapshotBeforeUpdate == "function";
      !Ve && (typeof I.UNSAFE_componentWillReceiveProps == "function" || typeof I.componentWillReceiveProps == "function") && (F !== J || le !== De) && woe(d, I, E, De), hoe();
      var Ze = d.memoizedState, Yt = I.state = Ze;
      if (EP(d, E, I, D), Yt = d.memoizedState, F === J && Ze === Yt && !aP() && !SP() && !se)
        return typeof I.componentDidUpdate == "function" && (F !== c.memoizedProps || Ze !== c.memoizedState) && (d.flags |= Tn), typeof I.getSnapshotBeforeUpdate == "function" && (F !== c.memoizedProps || Ze !== c.memoizedState) && (d.flags |= gl), !1;
      typeof Ue == "function" && (aB(d, x, Ue, E), Yt = d.memoizedState);
      var yn = SP() || voe(d, x, G, E, Ze, Yt, De) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      se;
      return yn ? (!Ve && (typeof I.UNSAFE_componentWillUpdate == "function" || typeof I.componentWillUpdate == "function") && (typeof I.componentWillUpdate == "function" && I.componentWillUpdate(E, Yt, De), typeof I.UNSAFE_componentWillUpdate == "function" && I.UNSAFE_componentWillUpdate(E, Yt, De)), typeof I.componentDidUpdate == "function" && (d.flags |= Tn), typeof I.getSnapshotBeforeUpdate == "function" && (d.flags |= gl)) : (typeof I.componentDidUpdate == "function" && (F !== c.memoizedProps || Ze !== c.memoizedState) && (d.flags |= Tn), typeof I.getSnapshotBeforeUpdate == "function" && (F !== c.memoizedProps || Ze !== c.memoizedState) && (d.flags |= gl), d.memoizedProps = E, d.memoizedState = Yt), I.props = E, I.state = Yt, I.context = De, yn;
    }
    var lB, cB, fB, dB, hB, _oe = function(c, d) {
    };
    lB = !1, cB = !1, fB = {}, dB = {}, hB = {}, _oe = function(c, d) {
      if (!(c === null || typeof c != "object") && !(!c._store || c._store.validated || c.key != null)) {
        if (typeof c._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        c._store.validated = !0;
        var x = jn(d) || "Component";
        dB[x] || (dB[x] = !0, a('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function HD(c, d, x) {
      var E = x.ref;
      if (E !== null && typeof E != "function" && typeof E != "object") {
        if ((c.mode & lo || _e) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(x._owner && x._self && x._owner.stateNode !== x._self)) {
          var D = jn(c) || "Component";
          fB[D] || (a('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', E), fB[D] = !0);
        }
        if (x._owner) {
          var I = x._owner, F;
          if (I) {
            var G = I;
            if (G.tag !== l)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            F = G.stateNode;
          }
          if (!F)
            throw new Error("Missing owner for string ref " + E + ". This error is likely caused by a bug in React. Please file an issue.");
          var J = F;
          tn(E, "ref");
          var le = "" + E;
          if (d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === le)
            return d.ref;
          var de = function(De) {
            var Ce = J.refs;
            Ce === goe && (Ce = J.refs = {}), De === null ? delete Ce[le] : Ce[le] = De;
          };
          return de._stringRef = le, de;
        } else {
          if (typeof E != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!x._owner)
            throw new Error("Element ref was specified as a string (" + E + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return E;
    }
    function TP(c, d) {
      var x = Object.prototype.toString.call(d);
      throw new Error("Objects are not valid as a React child (found: " + (x === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : x) + "). If you meant to render a collection of children, use an array instead.");
    }
    function CP(c) {
      {
        var d = jn(c) || "Component";
        if (hB[d])
          return;
        hB[d] = !0, a("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Eoe(c) {
      var d = c._payload, x = c._init;
      return x(d);
    }
    function Soe(c) {
      function d(je, Je) {
        if (c) {
          var Le = je.deletions;
          Le === null ? (je.deletions = [Je], je.flags |= Jr) : Le.push(Je);
        }
      }
      function x(je, Je) {
        if (!c)
          return null;
        for (var Le = Je; Le !== null; )
          d(je, Le), Le = Le.sibling;
        return null;
      }
      function E(je, Je) {
        for (var Le = /* @__PURE__ */ new Map(), vt = Je; vt !== null; )
          vt.key !== null ? Le.set(vt.key, vt) : Le.set(vt.index, vt), vt = vt.sibling;
        return Le;
      }
      function D(je, Je) {
        var Le = sE(je, Je);
        return Le.index = 0, Le.sibling = null, Le;
      }
      function I(je, Je, Le) {
        if (je.index = Le, !c)
          return je.flags |= i_, Je;
        var vt = je.alternate;
        if (vt !== null) {
          var Ht = vt.index;
          return Ht < Je ? (je.flags |= no, Je) : Ht;
        } else
          return je.flags |= no, Je;
      }
      function F(je) {
        return c && je.alternate === null && (je.flags |= no), je;
      }
      function G(je, Je, Le, vt) {
        if (Je === null || Je.tag !== y) {
          var Ht = FU(Le, je.mode, vt);
          return Ht.return = je, Ht;
        } else {
          var Lt = D(Je, Le);
          return Lt.return = je, Lt;
        }
      }
      function J(je, Je, Le, vt) {
        var Ht = Le.type;
        if (Ht === Hi)
          return de(je, Je, Le.props.children, vt, Le.key);
        if (Je !== null && (Je.elementType === Ht || // Keep this check inline so it only runs on the false path:
        pse(Je, Le) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Ht == "object" && Ht !== null && Ht.$$typeof === sn && Eoe(Ht) === Je.type)) {
          var Lt = D(Je, Le.props);
          return Lt.ref = HD(je, Je, Le), Lt.return = je, Lt._debugSource = Le._source, Lt._debugOwner = Le._owner, Lt;
        }
        var Ln = zU(Le, je.mode, vt);
        return Ln.ref = HD(je, Je, Le), Ln.return = je, Ln;
      }
      function le(je, Je, Le, vt) {
        if (Je === null || Je.tag !== p || Je.stateNode.containerInfo !== Le.containerInfo || Je.stateNode.implementation !== Le.implementation) {
          var Ht = BU(Le, je.mode, vt);
          return Ht.return = je, Ht;
        } else {
          var Lt = D(Je, Le.children || []);
          return Lt.return = je, Lt;
        }
      }
      function de(je, Je, Le, vt, Ht) {
        if (Je === null || Je.tag !== b) {
          var Lt = Z1(Le, je.mode, vt, Ht);
          return Lt.return = je, Lt;
        } else {
          var Ln = D(Je, Le);
          return Ln.return = je, Ln;
        }
      }
      function De(je, Je, Le) {
        if (typeof Je == "string" && Je !== "" || typeof Je == "number") {
          var vt = FU("" + Je, je.mode, Le);
          return vt.return = je, vt;
        }
        if (typeof Je == "object" && Je !== null) {
          switch (Je.$$typeof) {
            case xa: {
              var Ht = zU(Je, je.mode, Le);
              return Ht.ref = HD(je, null, Je), Ht.return = je, Ht;
            }
            case la: {
              var Lt = BU(Je, je.mode, Le);
              return Lt.return = je, Lt;
            }
            case sn: {
              var Ln = Je._payload, Qn = Je._init;
              return De(je, Qn(Ln), Le);
            }
          }
          if (_r(Je) || Kl(Je)) {
            var qi = Z1(Je, je.mode, Le, null);
            return qi.return = je, qi;
          }
          TP(je, Je);
        }
        return typeof Je == "function" && CP(je), null;
      }
      function Ce(je, Je, Le, vt) {
        var Ht = Je !== null ? Je.key : null;
        if (typeof Le == "string" && Le !== "" || typeof Le == "number")
          return Ht !== null ? null : G(je, Je, "" + Le, vt);
        if (typeof Le == "object" && Le !== null) {
          switch (Le.$$typeof) {
            case xa:
              return Le.key === Ht ? J(je, Je, Le, vt) : null;
            case la:
              return Le.key === Ht ? le(je, Je, Le, vt) : null;
            case sn: {
              var Lt = Le._payload, Ln = Le._init;
              return Ce(je, Je, Ln(Lt), vt);
            }
          }
          if (_r(Le) || Kl(Le))
            return Ht !== null ? null : de(je, Je, Le, vt, null);
          TP(je, Le);
        }
        return typeof Le == "function" && CP(je), null;
      }
      function Ue(je, Je, Le, vt, Ht) {
        if (typeof vt == "string" && vt !== "" || typeof vt == "number") {
          var Lt = je.get(Le) || null;
          return G(Je, Lt, "" + vt, Ht);
        }
        if (typeof vt == "object" && vt !== null) {
          switch (vt.$$typeof) {
            case xa: {
              var Ln = je.get(vt.key === null ? Le : vt.key) || null;
              return J(Je, Ln, vt, Ht);
            }
            case la: {
              var Qn = je.get(vt.key === null ? Le : vt.key) || null;
              return le(Je, Qn, vt, Ht);
            }
            case sn:
              var qi = vt._payload, ui = vt._init;
              return Ue(je, Je, Le, ui(qi), Ht);
          }
          if (_r(vt) || Kl(vt)) {
            var Xa = je.get(Le) || null;
            return de(Je, Xa, vt, Ht, null);
          }
          TP(Je, vt);
        }
        return typeof vt == "function" && CP(Je), null;
      }
      function Ve(je, Je, Le) {
        {
          if (typeof je != "object" || je === null)
            return Je;
          switch (je.$$typeof) {
            case xa:
            case la:
              _oe(je, Le);
              var vt = je.key;
              if (typeof vt != "string")
                break;
              if (Je === null) {
                Je = /* @__PURE__ */ new Set(), Je.add(vt);
                break;
              }
              if (!Je.has(vt)) {
                Je.add(vt);
                break;
              }
              a("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", vt);
              break;
            case sn:
              var Ht = je._payload, Lt = je._init;
              Ve(Lt(Ht), Je, Le);
              break;
          }
        }
        return Je;
      }
      function Ze(je, Je, Le, vt) {
        for (var Ht = null, Lt = 0; Lt < Le.length; Lt++) {
          var Ln = Le[Lt];
          Ht = Ve(Ln, Ht, je);
        }
        for (var Qn = null, qi = null, ui = Je, Xa = 0, li = 0, Oa = null; ui !== null && li < Le.length; li++) {
          ui.index > li ? (Oa = ui, ui = null) : Oa = ui.sibling;
          var Dl = Ce(je, ui, Le[li], vt);
          if (Dl === null) {
            ui === null && (ui = Oa);
            break;
          }
          c && ui && Dl.alternate === null && d(je, ui), Xa = I(Dl, Xa, li), qi === null ? Qn = Dl : qi.sibling = Dl, qi = Dl, ui = Oa;
        }
        if (li === Le.length) {
          if (x(je, ui), Fu()) {
            var qu = li;
            G_(je, qu);
          }
          return Qn;
        }
        if (ui === null) {
          for (; li < Le.length; li++) {
            var gd = De(je, Le[li], vt);
            gd !== null && (Xa = I(gd, Xa, li), qi === null ? Qn = gd : qi.sibling = gd, qi = gd);
          }
          if (Fu()) {
            var pc = li;
            G_(je, pc);
          }
          return Qn;
        }
        for (var gc = E(je, ui); li < Le.length; li++) {
          var Al = Ue(gc, je, li, Le[li], vt);
          Al !== null && (c && Al.alternate !== null && gc.delete(Al.key === null ? li : Al.key), Xa = I(Al, Xa, li), qi === null ? Qn = Al : qi.sibling = Al, qi = Al);
        }
        if (c && gc.forEach(function(TM) {
          return d(je, TM);
        }), Fu()) {
          var E0 = li;
          G_(je, E0);
        }
        return Qn;
      }
      function Yt(je, Je, Le, vt) {
        var Ht = Kl(Le);
        if (typeof Ht != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Le[Symbol.toStringTag] === "Generator" && (cB || a("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), cB = !0), Le.entries === Ht && (lB || a("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), lB = !0);
          var Lt = Ht.call(Le);
          if (Lt)
            for (var Ln = null, Qn = Lt.next(); !Qn.done; Qn = Lt.next()) {
              var qi = Qn.value;
              Ln = Ve(qi, Ln, je);
            }
        }
        var ui = Ht.call(Le);
        if (ui == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Xa = null, li = null, Oa = Je, Dl = 0, qu = 0, gd = null, pc = ui.next(); Oa !== null && !pc.done; qu++, pc = ui.next()) {
          Oa.index > qu ? (gd = Oa, Oa = null) : gd = Oa.sibling;
          var gc = Ce(je, Oa, pc.value, vt);
          if (gc === null) {
            Oa === null && (Oa = gd);
            break;
          }
          c && Oa && gc.alternate === null && d(je, Oa), Dl = I(gc, Dl, qu), li === null ? Xa = gc : li.sibling = gc, li = gc, Oa = gd;
        }
        if (pc.done) {
          if (x(je, Oa), Fu()) {
            var Al = qu;
            G_(je, Al);
          }
          return Xa;
        }
        if (Oa === null) {
          for (; !pc.done; qu++, pc = ui.next()) {
            var E0 = De(je, pc.value, vt);
            E0 !== null && (Dl = I(E0, Dl, qu), li === null ? Xa = E0 : li.sibling = E0, li = E0);
          }
          if (Fu()) {
            var TM = qu;
            G_(je, TM);
          }
          return Xa;
        }
        for (var xA = E(je, Oa); !pc.done; qu++, pc = ui.next()) {
          var py = Ue(xA, je, qu, pc.value, vt);
          py !== null && (c && py.alternate !== null && xA.delete(py.key === null ? qu : py.key), Dl = I(py, Dl, qu), li === null ? Xa = py : li.sibling = py, li = py);
        }
        if (c && xA.forEach(function(G5e) {
          return d(je, G5e);
        }), Fu()) {
          var q5e = qu;
          G_(je, q5e);
        }
        return Xa;
      }
      function yn(je, Je, Le, vt) {
        if (Je !== null && Je.tag === y) {
          x(je, Je.sibling);
          var Ht = D(Je, Le);
          return Ht.return = je, Ht;
        }
        x(je, Je);
        var Lt = FU(Le, je.mode, vt);
        return Lt.return = je, Lt;
      }
      function on(je, Je, Le, vt) {
        for (var Ht = Le.key, Lt = Je; Lt !== null; ) {
          if (Lt.key === Ht) {
            var Ln = Le.type;
            if (Ln === Hi) {
              if (Lt.tag === b) {
                x(je, Lt.sibling);
                var Qn = D(Lt, Le.props.children);
                return Qn.return = je, Qn._debugSource = Le._source, Qn._debugOwner = Le._owner, Qn;
              }
            } else if (Lt.elementType === Ln || // Keep this check inline so it only runs on the false path:
            pse(Lt, Le) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Ln == "object" && Ln !== null && Ln.$$typeof === sn && Eoe(Ln) === Lt.type) {
              x(je, Lt.sibling);
              var qi = D(Lt, Le.props);
              return qi.ref = HD(je, Lt, Le), qi.return = je, qi._debugSource = Le._source, qi._debugOwner = Le._owner, qi;
            }
            x(je, Lt);
            break;
          } else
            d(je, Lt);
          Lt = Lt.sibling;
        }
        if (Le.type === Hi) {
          var ui = Z1(Le.props.children, je.mode, vt, Le.key);
          return ui.return = je, ui;
        } else {
          var Xa = zU(Le, je.mode, vt);
          return Xa.ref = HD(je, Je, Le), Xa.return = je, Xa;
        }
      }
      function Yr(je, Je, Le, vt) {
        for (var Ht = Le.key, Lt = Je; Lt !== null; ) {
          if (Lt.key === Ht)
            if (Lt.tag === p && Lt.stateNode.containerInfo === Le.containerInfo && Lt.stateNode.implementation === Le.implementation) {
              x(je, Lt.sibling);
              var Ln = D(Lt, Le.children || []);
              return Ln.return = je, Ln;
            } else {
              x(je, Lt);
              break;
            }
          else
            d(je, Lt);
          Lt = Lt.sibling;
        }
        var Qn = BU(Le, je.mode, vt);
        return Qn.return = je, Qn;
      }
      function Nr(je, Je, Le, vt) {
        var Ht = typeof Le == "object" && Le !== null && Le.type === Hi && Le.key === null;
        if (Ht && (Le = Le.props.children), typeof Le == "object" && Le !== null) {
          switch (Le.$$typeof) {
            case xa:
              return F(on(je, Je, Le, vt));
            case la:
              return F(Yr(je, Je, Le, vt));
            case sn:
              var Lt = Le._payload, Ln = Le._init;
              return Nr(je, Je, Ln(Lt), vt);
          }
          if (_r(Le))
            return Ze(je, Je, Le, vt);
          if (Kl(Le))
            return Yt(je, Je, Le, vt);
          TP(je, Le);
        }
        return typeof Le == "string" && Le !== "" || typeof Le == "number" ? F(yn(je, Je, "" + Le, vt)) : (typeof Le == "function" && CP(je), x(je, Je));
      }
      return Nr;
    }
    var cM = Soe(!0), Moe = Soe(!1);
    function P3e(c, d) {
      if (c !== null && d.child !== c.child)
        throw new Error("Resuming work not yet implemented.");
      if (d.child !== null) {
        var x = d.child, E = sE(x, x.pendingProps);
        for (d.child = E, E.return = d; x.sibling !== null; )
          x = x.sibling, E = E.sibling = sE(x, x.pendingProps), E.return = d;
        E.sibling = null;
      }
    }
    function I3e(c, d) {
      for (var x = c.child; x !== null; )
        f5e(x, d), x = x.sibling;
    }
    var VD = {}, Y1 = lu(VD), WD = lu(VD), NP = lu(VD);
    function DP(c) {
      if (c === VD)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function Toe() {
      var c = DP(NP.current);
      return c;
    }
    function pB(c, d) {
      Cl(NP, d, c), Cl(WD, c, c), Cl(Y1, VD, c);
      var x = I9(d);
      Os(Y1, c), Cl(Y1, x, c);
    }
    function fM(c) {
      Os(Y1, c), Os(WD, c), Os(NP, c);
    }
    function gB() {
      var c = DP(Y1.current);
      return c;
    }
    function Coe(c) {
      DP(NP.current);
      var d = DP(Y1.current), x = j9(d, c.type);
      d !== x && (Cl(WD, c, c), Cl(Y1, x, c));
    }
    function mB(c) {
      WD.current === c && (Os(Y1, c), Os(WD, c));
    }
    var j3e = 0, Noe = 1, Doe = 1, qD = 2, cg = lu(j3e);
    function yB(c, d) {
      return (c & d) !== 0;
    }
    function dM(c) {
      return c & Noe;
    }
    function vB(c, d) {
      return c & Noe | d;
    }
    function L3e(c, d) {
      return c | d;
    }
    function H1(c, d) {
      Cl(cg, d, c);
    }
    function hM(c) {
      Os(cg, c);
    }
    function z3e(c, d) {
      var x = c.memoizedState;
      return x !== null ? x.dehydrated !== null : (c.memoizedProps, !0);
    }
    function AP(c) {
      for (var d = c; d !== null; ) {
        if (d.tag === R) {
          var x = d.memoizedState;
          if (x !== null) {
            var E = x.dehydrated;
            if (E === null || iP(E) || PD(E))
              return d;
          }
        } else if (d.tag === V && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        d.memoizedProps.revealOrder !== void 0) {
          var D = (d.flags & An) !== cn;
          if (D)
            return d;
        } else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === c)
          return null;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === c)
            return null;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return null;
    }
    var sf = (
      /*   */
      0
    ), Rs = (
      /* */
      1
    ), sy = (
      /*  */
      2
    ), ks = (
      /*    */
      4
    ), Bu = (
      /*   */
      8
    ), bB = [];
    function xB() {
      for (var c = 0; c < bB.length; c++) {
        var d = bB[c];
        d._workInProgressVersionPrimary = null;
      }
      bB.length = 0;
    }
    function F3e(c, d) {
      var x = d._getVersion, E = x(d._source);
      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [d, E] : c.mutableSourceEagerHydrationData.push(d, E);
    }
    var Bt = n.ReactCurrentDispatcher, GD = n.ReactCurrentBatchConfig, wB, pM;
    wB = /* @__PURE__ */ new Set();
    var eE = Xe, Wi = null, $s = null, Ps = null, OP = !1, QD = !1, XD = 0, B3e = 0, U3e = 25, at = null, Uh = null, V1 = -1, _B = !1;
    function Mi() {
      {
        var c = at;
        Uh === null ? Uh = [c] : Uh.push(c);
      }
    }
    function At() {
      {
        var c = at;
        Uh !== null && (V1++, Uh[V1] !== c && Y3e(c));
      }
    }
    function gM(c) {
      c != null && !_r(c) && a("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", at, typeof c);
    }
    function Y3e(c) {
      {
        var d = jn(Wi);
        if (!wB.has(d) && (wB.add(d), Uh !== null)) {
          for (var x = "", E = 30, D = 0; D <= V1; D++) {
            for (var I = Uh[D], F = D === V1 ? c : I, G = D + 1 + ". " + I; G.length < E; )
              G += " ";
            G += F + `
`, x += G;
          }
          a(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, d, x);
        }
      }
    }
    function Nl() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function EB(c, d) {
      if (_B)
        return !1;
      if (d === null)
        return a("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", at), !1;
      c.length !== d.length && a(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, at, "[" + d.join(", ") + "]", "[" + c.join(", ") + "]");
      for (var x = 0; x < d.length && x < c.length; x++)
        if (!Wt(c[x], d[x]))
          return !1;
      return !0;
    }
    function mM(c, d, x, E, D, I) {
      eE = I, Wi = d, Uh = c !== null ? c._debugHookTypes : null, V1 = -1, _B = c !== null && c.type !== d.type, d.memoizedState = null, d.updateQueue = null, d.lanes = Xe, c !== null && c.memoizedState !== null ? Bt.current = Koe : Uh !== null ? Bt.current = Xoe : Bt.current = Qoe;
      var F = x(E, D);
      if (QD) {
        var G = 0;
        do {
          if (QD = !1, XD = 0, G >= U3e)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          G += 1, _B = !1, $s = null, Ps = null, d.updateQueue = null, V1 = -1, Bt.current = Zoe, F = x(E, D);
        } while (QD);
      }
      Bt.current = HP, d._debugHookTypes = Uh;
      var J = $s !== null && $s.next !== null;
      if (eE = Xe, Wi = null, $s = null, Ps = null, at = null, Uh = null, V1 = -1, c !== null && (c.flags & Ma) !== (d.flags & Ma) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (c.mode & fr) !== hn && a("Internal React error: Expected static flag was missing. Please notify the React team."), OP = !1, J)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return F;
    }
    function yM() {
      var c = XD !== 0;
      return XD = 0, c;
    }
    function Aoe(c, d, x) {
      d.updateQueue = c.updateQueue, (d.mode & au) !== hn ? d.flags &= ~(Up | so | ao | Tn) : d.flags &= ~(ao | Tn), c.lanes = Xp(c.lanes, x);
    }
    function Ooe() {
      if (Bt.current = HP, OP) {
        for (var c = Wi.memoizedState; c !== null; ) {
          var d = c.queue;
          d !== null && (d.pending = null), c = c.next;
        }
        OP = !1;
      }
      eE = Xe, Wi = null, $s = null, Ps = null, Uh = null, V1 = -1, at = null, Hoe = !1, QD = !1, XD = 0;
    }
    function uy() {
      var c = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ps === null ? Wi.memoizedState = Ps = c : Ps = Ps.next = c, Ps;
    }
    function Yh() {
      var c;
      if ($s === null) {
        var d = Wi.alternate;
        d !== null ? c = d.memoizedState : c = null;
      } else
        c = $s.next;
      var x;
      if (Ps === null ? x = Wi.memoizedState : x = Ps.next, x !== null)
        Ps = x, x = Ps.next, $s = c;
      else {
        if (c === null)
          throw new Error("Rendered more hooks than during the previous render.");
        $s = c;
        var E = {
          memoizedState: $s.memoizedState,
          baseState: $s.baseState,
          baseQueue: $s.baseQueue,
          queue: $s.queue,
          next: null
        };
        Ps === null ? Wi.memoizedState = Ps = E : Ps = Ps.next = E;
      }
      return Ps;
    }
    function Roe() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function SB(c, d) {
      return typeof d == "function" ? d(c) : d;
    }
    function MB(c, d, x) {
      var E = uy(), D;
      x !== void 0 ? D = x(d) : D = d, E.memoizedState = E.baseState = D;
      var I = {
        pending: null,
        interleaved: null,
        lanes: Xe,
        dispatch: null,
        lastRenderedReducer: c,
        lastRenderedState: D
      };
      E.queue = I;
      var F = I.dispatch = q3e.bind(null, Wi, I);
      return [E.memoizedState, F];
    }
    function TB(c, d, x) {
      var E = Yh(), D = E.queue;
      if (D === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      D.lastRenderedReducer = c;
      var I = $s, F = I.baseQueue, G = D.pending;
      if (G !== null) {
        if (F !== null) {
          var J = F.next, le = G.next;
          F.next = le, G.next = J;
        }
        I.baseQueue !== F && a("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), I.baseQueue = F = G, D.pending = null;
      }
      if (F !== null) {
        var de = F.next, De = I.baseState, Ce = null, Ue = null, Ve = null, Ze = de;
        do {
          var Yt = Ze.lane;
          if (Ch(eE, Yt)) {
            if (Ve !== null) {
              var on = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Er,
                action: Ze.action,
                hasEagerState: Ze.hasEagerState,
                eagerState: Ze.eagerState,
                next: null
              };
              Ve = Ve.next = on;
            }
            if (Ze.hasEagerState)
              De = Ze.eagerState;
            else {
              var Yr = Ze.action;
              De = c(De, Yr);
            }
          } else {
            var yn = {
              lane: Yt,
              action: Ze.action,
              hasEagerState: Ze.hasEagerState,
              eagerState: Ze.eagerState,
              next: null
            };
            Ve === null ? (Ue = Ve = yn, Ce = De) : Ve = Ve.next = yn, Wi.lanes = Gn(Wi.lanes, Yt), gA(Yt);
          }
          Ze = Ze.next;
        } while (Ze !== null && Ze !== de);
        Ve === null ? Ce = De : Ve.next = Ue, Wt(De, E.memoizedState) || rA(), E.memoizedState = De, E.baseState = Ce, E.baseQueue = Ve, D.lastRenderedState = De;
      }
      var Nr = D.interleaved;
      if (Nr !== null) {
        var je = Nr;
        do {
          var Je = je.lane;
          Wi.lanes = Gn(Wi.lanes, Je), gA(Je), je = je.next;
        } while (je !== Nr);
      } else
        F === null && (D.lanes = Xe);
      var Le = D.dispatch;
      return [E.memoizedState, Le];
    }
    function CB(c, d, x) {
      var E = Yh(), D = E.queue;
      if (D === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      D.lastRenderedReducer = c;
      var I = D.dispatch, F = D.pending, G = E.memoizedState;
      if (F !== null) {
        D.pending = null;
        var J = F.next, le = J;
        do {
          var de = le.action;
          G = c(G, de), le = le.next;
        } while (le !== J);
        Wt(G, E.memoizedState) || rA(), E.memoizedState = G, E.baseQueue === null && (E.baseState = G), D.lastRenderedState = G;
      }
      return [G, I];
    }
    function n9t(c, d, x) {
    }
    function r9t(c, d, x) {
    }
    function NB(c, d, x) {
      var E = Wi, D = uy(), I, F = Fu();
      if (F) {
        if (x === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        I = x(), pM || I !== x() && (a("The result of getServerSnapshot should be cached to avoid an infinite loop"), pM = !0);
      } else {
        if (I = d(), !pM) {
          var G = d();
          Wt(I, G) || (a("The result of getSnapshot should be cached to avoid an infinite loop"), pM = !0);
        }
        var J = uI();
        if (J === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Th(J, eE) || koe(E, d, I);
      }
      D.memoizedState = I;
      var le = {
        value: I,
        getSnapshot: d
      };
      return D.queue = le, IP(Poe.bind(null, E, le, c), [c]), E.flags |= ao, KD(Rs | Bu, $oe.bind(null, E, le, I, d), void 0, null), I;
    }
    function RP(c, d, x) {
      var E = Wi, D = Yh(), I = d();
      if (!pM) {
        var F = d();
        Wt(I, F) || (a("The result of getSnapshot should be cached to avoid an infinite loop"), pM = !0);
      }
      var G = D.memoizedState, J = !Wt(G, I);
      J && (D.memoizedState = I, rA());
      var le = D.queue;
      if (JD(Poe.bind(null, E, le, c), [c]), le.getSnapshot !== d || J || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ps !== null && Ps.memoizedState.tag & Rs) {
        E.flags |= ao, KD(Rs | Bu, $oe.bind(null, E, le, I, d), void 0, null);
        var de = uI();
        if (de === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Th(de, eE) || koe(E, d, I);
      }
      return I;
    }
    function koe(c, d, x) {
      c.flags |= kv;
      var E = {
        getSnapshot: d,
        value: x
      }, D = Wi.updateQueue;
      if (D === null)
        D = Roe(), Wi.updateQueue = D, D.stores = [E];
      else {
        var I = D.stores;
        I === null ? D.stores = [E] : I.push(E);
      }
    }
    function $oe(c, d, x, E) {
      d.value = x, d.getSnapshot = E, Ioe(d) && joe(c);
    }
    function Poe(c, d, x) {
      var E = function() {
        Ioe(d) && joe(c);
      };
      return x(E);
    }
    function Ioe(c) {
      var d = c.getSnapshot, x = c.value;
      try {
        var E = d();
        return !Wt(x, E);
      } catch {
        return !0;
      }
    }
    function joe(c) {
      var d = af(c, En);
      d !== null && zs(d, c, En, si);
    }
    function kP(c) {
      var d = uy();
      typeof c == "function" && (c = c()), d.memoizedState = d.baseState = c;
      var x = {
        pending: null,
        interleaved: null,
        lanes: Xe,
        dispatch: null,
        lastRenderedReducer: SB,
        lastRenderedState: c
      };
      d.queue = x;
      var E = x.dispatch = G3e.bind(null, Wi, x);
      return [d.memoizedState, E];
    }
    function DB(c) {
      return TB(SB);
    }
    function AB(c) {
      return CB(SB);
    }
    function KD(c, d, x, E) {
      var D = {
        tag: c,
        create: d,
        destroy: x,
        deps: E,
        // Circular
        next: null
      }, I = Wi.updateQueue;
      if (I === null)
        I = Roe(), Wi.updateQueue = I, I.lastEffect = D.next = D;
      else {
        var F = I.lastEffect;
        if (F === null)
          I.lastEffect = D.next = D;
        else {
          var G = F.next;
          F.next = D, D.next = G, I.lastEffect = D;
        }
      }
      return D;
    }
    function OB(c) {
      var d = uy();
      {
        var x = {
          current: c
        };
        return d.memoizedState = x, x;
      }
    }
    function $P(c) {
      var d = Yh();
      return d.memoizedState;
    }
    function ZD(c, d, x, E) {
      var D = uy(), I = E === void 0 ? null : E;
      Wi.flags |= c, D.memoizedState = KD(Rs | d, x, void 0, I);
    }
    function PP(c, d, x, E) {
      var D = Yh(), I = E === void 0 ? null : E, F = void 0;
      if ($s !== null) {
        var G = $s.memoizedState;
        if (F = G.destroy, I !== null) {
          var J = G.deps;
          if (EB(I, J)) {
            D.memoizedState = KD(d, x, F, I);
            return;
          }
        }
      }
      Wi.flags |= c, D.memoizedState = KD(Rs | d, x, F, I);
    }
    function IP(c, d) {
      return (Wi.mode & au) !== hn ? ZD(Up | ao | hh, Bu, c, d) : ZD(ao | hh, Bu, c, d);
    }
    function JD(c, d) {
      return PP(ao, Bu, c, d);
    }
    function RB(c, d) {
      return ZD(Tn, sy, c, d);
    }
    function jP(c, d) {
      return PP(Tn, sy, c, d);
    }
    function kB(c, d) {
      var x = Tn;
      return x |= ru, (Wi.mode & au) !== hn && (x |= so), ZD(x, ks, c, d);
    }
    function LP(c, d) {
      return PP(Tn, ks, c, d);
    }
    function Loe(c, d) {
      if (typeof d == "function") {
        var x = d, E = c();
        return x(E), function() {
          x(null);
        };
      } else if (d != null) {
        var D = d;
        D.hasOwnProperty("current") || a("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(D).join(", ") + "}");
        var I = c();
        return D.current = I, function() {
          D.current = null;
        };
      }
    }
    function $B(c, d, x) {
      typeof d != "function" && a("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var E = x != null ? x.concat([c]) : null, D = Tn;
      return D |= ru, (Wi.mode & au) !== hn && (D |= so), ZD(D, ks, Loe.bind(null, d, c), E);
    }
    function zP(c, d, x) {
      typeof d != "function" && a("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var E = x != null ? x.concat([c]) : null;
      return PP(Tn, ks, Loe.bind(null, d, c), E);
    }
    function H3e(c, d) {
    }
    var FP = H3e;
    function PB(c, d) {
      var x = uy(), E = d === void 0 ? null : d;
      return x.memoizedState = [c, E], c;
    }
    function BP(c, d) {
      var x = Yh(), E = d === void 0 ? null : d, D = x.memoizedState;
      if (D !== null && E !== null) {
        var I = D[1];
        if (EB(E, I))
          return D[0];
      }
      return x.memoizedState = [c, E], c;
    }
    function IB(c, d) {
      var x = uy(), E = d === void 0 ? null : d, D = c();
      return x.memoizedState = [D, E], D;
    }
    function UP(c, d) {
      var x = Yh(), E = d === void 0 ? null : d, D = x.memoizedState;
      if (D !== null && E !== null) {
        var I = D[1];
        if (EB(E, I))
          return D[0];
      }
      var F = c();
      return x.memoizedState = [F, E], F;
    }
    function jB(c) {
      var d = uy();
      return d.memoizedState = c, c;
    }
    function zoe(c) {
      var d = Yh(), x = $s, E = x.memoizedState;
      return Boe(d, E, c);
    }
    function Foe(c) {
      var d = Yh();
      if ($s === null)
        return d.memoizedState = c, c;
      var x = $s.memoizedState;
      return Boe(d, x, c);
    }
    function Boe(c, d, x) {
      var E = !c1(eE);
      if (E) {
        if (!Wt(x, d)) {
          var D = Fm();
          Wi.lanes = Gn(Wi.lanes, D), gA(D), c.baseState = !0;
        }
        return d;
      } else
        return c.baseState && (c.baseState = !1, rA()), c.memoizedState = x, x;
    }
    function V3e(c, d, x) {
      var E = Ru();
      pa(ds(E, Ca)), c(!0);
      var D = GD.transition;
      GD.transition = {};
      var I = GD.transition;
      GD.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        c(!1), d();
      } finally {
        if (pa(E), GD.transition = D, D === null && I._updatedFibers) {
          var F = I._updatedFibers.size;
          F > 10 && o("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), I._updatedFibers.clear();
        }
      }
    }
    function LB() {
      var c = kP(!1), d = c[0], x = c[1], E = V3e.bind(null, x), D = uy();
      return D.memoizedState = E, [d, E];
    }
    function Uoe() {
      var c = DB(), d = c[0], x = Yh(), E = x.memoizedState;
      return [d, E];
    }
    function Yoe() {
      var c = AB(), d = c[0], x = Yh(), E = x.memoizedState;
      return [d, E];
    }
    var Hoe = !1;
    function W3e() {
      return Hoe;
    }
    function zB() {
      var c = uy(), d = uI(), x = d.identifierPrefix, E;
      if (Fu()) {
        var D = a3e();
        E = ":" + x + "R" + D;
        var I = XD++;
        I > 0 && (E += "H" + I.toString(32)), E += ":";
      } else {
        var F = B3e++;
        E = ":" + x + "r" + F.toString(32) + ":";
      }
      return c.memoizedState = E, E;
    }
    function YP() {
      var c = Yh(), d = c.memoizedState;
      return d;
    }
    function q3e(c, d, x) {
      typeof arguments[3] == "function" && a("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var E = X1(c), D = {
        lane: E,
        action: x,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Voe(c))
        Woe(d, D);
      else {
        var I = loe(c, d, D, E);
        if (I !== null) {
          var F = hc();
          zs(I, c, E, F), qoe(I, d, E);
        }
      }
      Goe(c, E);
    }
    function G3e(c, d, x) {
      typeof arguments[3] == "function" && a("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var E = X1(c), D = {
        lane: E,
        action: x,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Voe(c))
        Woe(d, D);
      else {
        var I = c.alternate;
        if (c.lanes === Xe && (I === null || I.lanes === Xe)) {
          var F = d.lastRenderedReducer;
          if (F !== null) {
            var G;
            G = Bt.current, Bt.current = fg;
            try {
              var J = d.lastRenderedState, le = F(J, x);
              if (D.hasEagerState = !0, D.eagerState = le, Wt(le, J)) {
                T3e(c, d, D, E);
                return;
              }
            } catch {
            } finally {
              Bt.current = G;
            }
          }
        }
        var de = loe(c, d, D, E);
        if (de !== null) {
          var De = hc();
          zs(de, c, E, De), qoe(de, d, E);
        }
      }
      Goe(c, E);
    }
    function Voe(c) {
      var d = c.alternate;
      return c === Wi || d !== null && d === Wi;
    }
    function Woe(c, d) {
      QD = OP = !0;
      var x = c.pending;
      x === null ? d.next = d : (d.next = x.next, x.next = d), c.pending = d;
    }
    function qoe(c, d, x) {
      if (d1(x)) {
        var E = d.lanes;
        E = h_(E, c.pendingLanes);
        var D = Gn(E, x);
        d.lanes = D, un(c, D);
      }
    }
    function Goe(c, d, x) {
      wh(c, d);
    }
    var HP = {
      readContext: ys,
      useCallback: Nl,
      useContext: Nl,
      useEffect: Nl,
      useImperativeHandle: Nl,
      useInsertionEffect: Nl,
      useLayoutEffect: Nl,
      useMemo: Nl,
      useReducer: Nl,
      useRef: Nl,
      useState: Nl,
      useDebugValue: Nl,
      useDeferredValue: Nl,
      useTransition: Nl,
      useMutableSource: Nl,
      useSyncExternalStore: Nl,
      useId: Nl,
      unstable_isNewReconciler: Z
    }, Qoe = null, Xoe = null, Koe = null, Zoe = null, ly = null, fg = null, VP = null;
    {
      var FB = function() {
        a("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Vn = function() {
        a("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Qoe = {
        readContext: function(c) {
          return ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", Mi(), gM(d), PB(c, d);
        },
        useContext: function(c) {
          return at = "useContext", Mi(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", Mi(), gM(d), IP(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", Mi(), gM(x), $B(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", Mi(), gM(d), RB(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", Mi(), gM(d), kB(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", Mi(), gM(d);
          var x = Bt.current;
          Bt.current = ly;
          try {
            return IB(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", Mi();
          var E = Bt.current;
          Bt.current = ly;
          try {
            return MB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", Mi(), OB(c);
        },
        useState: function(c) {
          at = "useState", Mi();
          var d = Bt.current;
          Bt.current = ly;
          try {
            return kP(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", Mi(), void 0;
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", Mi(), jB(c);
        },
        useTransition: function() {
          return at = "useTransition", Mi(), LB();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", Mi(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", Mi(), NB(c, d, x);
        },
        useId: function() {
          return at = "useId", Mi(), zB();
        },
        unstable_isNewReconciler: Z
      }, Xoe = {
        readContext: function(c) {
          return ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", At(), PB(c, d);
        },
        useContext: function(c) {
          return at = "useContext", At(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", At(), IP(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", At(), $B(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", At(), RB(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", At(), kB(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", At();
          var x = Bt.current;
          Bt.current = ly;
          try {
            return IB(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", At();
          var E = Bt.current;
          Bt.current = ly;
          try {
            return MB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", At(), OB(c);
        },
        useState: function(c) {
          at = "useState", At();
          var d = Bt.current;
          Bt.current = ly;
          try {
            return kP(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", At(), void 0;
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", At(), jB(c);
        },
        useTransition: function() {
          return at = "useTransition", At(), LB();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", At(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", At(), NB(c, d, x);
        },
        useId: function() {
          return at = "useId", At(), zB();
        },
        unstable_isNewReconciler: Z
      }, Koe = {
        readContext: function(c) {
          return ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", At(), BP(c, d);
        },
        useContext: function(c) {
          return at = "useContext", At(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", At(), JD(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", At(), zP(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", At(), jP(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", At(), LP(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", At();
          var x = Bt.current;
          Bt.current = fg;
          try {
            return UP(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", At();
          var E = Bt.current;
          Bt.current = fg;
          try {
            return TB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", At(), $P();
        },
        useState: function(c) {
          at = "useState", At();
          var d = Bt.current;
          Bt.current = fg;
          try {
            return DB(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", At(), FP();
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", At(), zoe(c);
        },
        useTransition: function() {
          return at = "useTransition", At(), Uoe();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", At(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", At(), RP(c, d);
        },
        useId: function() {
          return at = "useId", At(), YP();
        },
        unstable_isNewReconciler: Z
      }, Zoe = {
        readContext: function(c) {
          return ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", At(), BP(c, d);
        },
        useContext: function(c) {
          return at = "useContext", At(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", At(), JD(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", At(), zP(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", At(), jP(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", At(), LP(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", At();
          var x = Bt.current;
          Bt.current = VP;
          try {
            return UP(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", At();
          var E = Bt.current;
          Bt.current = VP;
          try {
            return CB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", At(), $P();
        },
        useState: function(c) {
          at = "useState", At();
          var d = Bt.current;
          Bt.current = VP;
          try {
            return AB(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", At(), FP();
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", At(), Foe(c);
        },
        useTransition: function() {
          return at = "useTransition", At(), Yoe();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", At(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", At(), RP(c, d);
        },
        useId: function() {
          return at = "useId", At(), YP();
        },
        unstable_isNewReconciler: Z
      }, ly = {
        readContext: function(c) {
          return FB(), ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", Vn(), Mi(), PB(c, d);
        },
        useContext: function(c) {
          return at = "useContext", Vn(), Mi(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", Vn(), Mi(), IP(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", Vn(), Mi(), $B(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", Vn(), Mi(), RB(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", Vn(), Mi(), kB(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", Vn(), Mi();
          var x = Bt.current;
          Bt.current = ly;
          try {
            return IB(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", Vn(), Mi();
          var E = Bt.current;
          Bt.current = ly;
          try {
            return MB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", Vn(), Mi(), OB(c);
        },
        useState: function(c) {
          at = "useState", Vn(), Mi();
          var d = Bt.current;
          Bt.current = ly;
          try {
            return kP(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", Vn(), Mi(), void 0;
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", Vn(), Mi(), jB(c);
        },
        useTransition: function() {
          return at = "useTransition", Vn(), Mi(), LB();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", Vn(), Mi(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", Vn(), Mi(), NB(c, d, x);
        },
        useId: function() {
          return at = "useId", Vn(), Mi(), zB();
        },
        unstable_isNewReconciler: Z
      }, fg = {
        readContext: function(c) {
          return FB(), ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", Vn(), At(), BP(c, d);
        },
        useContext: function(c) {
          return at = "useContext", Vn(), At(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", Vn(), At(), JD(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", Vn(), At(), zP(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", Vn(), At(), jP(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", Vn(), At(), LP(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", Vn(), At();
          var x = Bt.current;
          Bt.current = fg;
          try {
            return UP(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", Vn(), At();
          var E = Bt.current;
          Bt.current = fg;
          try {
            return TB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", Vn(), At(), $P();
        },
        useState: function(c) {
          at = "useState", Vn(), At();
          var d = Bt.current;
          Bt.current = fg;
          try {
            return DB(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", Vn(), At(), FP();
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", Vn(), At(), zoe(c);
        },
        useTransition: function() {
          return at = "useTransition", Vn(), At(), Uoe();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", Vn(), At(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", Vn(), At(), RP(c, d);
        },
        useId: function() {
          return at = "useId", Vn(), At(), YP();
        },
        unstable_isNewReconciler: Z
      }, VP = {
        readContext: function(c) {
          return FB(), ys(c);
        },
        useCallback: function(c, d) {
          return at = "useCallback", Vn(), At(), BP(c, d);
        },
        useContext: function(c) {
          return at = "useContext", Vn(), At(), ys(c);
        },
        useEffect: function(c, d) {
          return at = "useEffect", Vn(), At(), JD(c, d);
        },
        useImperativeHandle: function(c, d, x) {
          return at = "useImperativeHandle", Vn(), At(), zP(c, d, x);
        },
        useInsertionEffect: function(c, d) {
          return at = "useInsertionEffect", Vn(), At(), jP(c, d);
        },
        useLayoutEffect: function(c, d) {
          return at = "useLayoutEffect", Vn(), At(), LP(c, d);
        },
        useMemo: function(c, d) {
          at = "useMemo", Vn(), At();
          var x = Bt.current;
          Bt.current = fg;
          try {
            return UP(c, d);
          } finally {
            Bt.current = x;
          }
        },
        useReducer: function(c, d, x) {
          at = "useReducer", Vn(), At();
          var E = Bt.current;
          Bt.current = fg;
          try {
            return CB(c, d, x);
          } finally {
            Bt.current = E;
          }
        },
        useRef: function(c) {
          return at = "useRef", Vn(), At(), $P();
        },
        useState: function(c) {
          at = "useState", Vn(), At();
          var d = Bt.current;
          Bt.current = fg;
          try {
            return AB(c);
          } finally {
            Bt.current = d;
          }
        },
        useDebugValue: function(c, d) {
          return at = "useDebugValue", Vn(), At(), FP();
        },
        useDeferredValue: function(c) {
          return at = "useDeferredValue", Vn(), At(), Foe(c);
        },
        useTransition: function() {
          return at = "useTransition", Vn(), At(), Yoe();
        },
        useMutableSource: function(c, d, x) {
          return at = "useMutableSource", Vn(), At(), void 0;
        },
        useSyncExternalStore: function(c, d, x) {
          return at = "useSyncExternalStore", Vn(), At(), RP(c, d);
        },
        useId: function() {
          return at = "useId", Vn(), At(), YP();
        },
        unstable_isNewReconciler: Z
      };
    }
    var W1 = t.unstable_now, Joe = 0, WP = -1, eA = -1, qP = -1, BB = !1, GP = !1;
    function eae() {
      return BB;
    }
    function Q3e() {
      GP = !0;
    }
    function X3e() {
      BB = !1, GP = !1;
    }
    function K3e() {
      BB = GP, GP = !1;
    }
    function tae() {
      return Joe;
    }
    function nae() {
      Joe = W1();
    }
    function UB(c) {
      eA = W1(), c.actualStartTime < 0 && (c.actualStartTime = W1());
    }
    function rae(c) {
      eA = -1;
    }
    function QP(c, d) {
      if (eA >= 0) {
        var x = W1() - eA;
        c.actualDuration += x, d && (c.selfBaseDuration = x), eA = -1;
      }
    }
    function cy(c) {
      if (WP >= 0) {
        var d = W1() - WP;
        WP = -1;
        for (var x = c.return; x !== null; ) {
          switch (x.tag) {
            case h:
              var E = x.stateNode;
              E.effectDuration += d;
              return;
            case O:
              var D = x.stateNode;
              D.effectDuration += d;
              return;
          }
          x = x.return;
        }
      }
    }
    function YB(c) {
      if (qP >= 0) {
        var d = W1() - qP;
        qP = -1;
        for (var x = c.return; x !== null; ) {
          switch (x.tag) {
            case h:
              var E = x.stateNode;
              E !== null && (E.passiveEffectDuration += d);
              return;
            case O:
              var D = x.stateNode;
              D !== null && (D.passiveEffectDuration += d);
              return;
          }
          x = x.return;
        }
      }
    }
    function fy() {
      WP = W1();
    }
    function HB() {
      qP = W1();
    }
    function VB(c) {
      for (var d = c.child; d; )
        c.actualDuration += d.actualDuration, d = d.sibling;
    }
    function tE(c, d) {
      return {
        value: c,
        source: d,
        stack: Jl(d),
        digest: null
      };
    }
    function WB(c, d, x) {
      return {
        value: c,
        source: null,
        stack: x ?? null,
        digest: d ?? null
      };
    }
    function Z3e(c, d) {
      return !0;
    }
    function qB(c, d) {
      try {
        var x = Z3e(c, d);
        if (x === !1)
          return;
        var E = d.value, D = d.source, I = d.stack, F = I !== null ? I : "";
        if (E != null && E._suppressLogging) {
          if (c.tag === l)
            return;
          console.error(E);
        }
        var G = D ? jn(D) : null, J = G ? "The above error occurred in the <" + G + "> component:" : "The above error occurred in one of your React components:", le;
        if (c.tag === h)
          le = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var de = jn(c) || "Anonymous";
          le = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + de + ".");
        }
        var De = J + `
` + F + `

` + ("" + le);
        console.error(De);
      } catch (Ce) {
        setTimeout(function() {
          throw Ce;
        });
      }
    }
    var J3e = typeof WeakMap == "function" ? WeakMap : Map;
    function iae(c, d, x) {
      var E = y0(si, x);
      E.tag = q7, E.payload = {
        element: null
      };
      var D = d.value;
      return E.callback = function() {
        VLe(D), qB(c, d);
      }, E;
    }
    function GB(c, d, x) {
      var E = y0(si, x);
      E.tag = q7;
      var D = c.type.getDerivedStateFromError;
      if (typeof D == "function") {
        var I = d.value;
        E.payload = function() {
          return D(I);
        }, E.callback = function() {
          gse(c), qB(c, d);
        };
      }
      var F = c.stateNode;
      return F !== null && typeof F.componentDidCatch == "function" && (E.callback = function() {
        gse(c), qB(c, d), typeof D != "function" && YLe(this);
        var J = d.value, le = d.stack;
        this.componentDidCatch(J, {
          componentStack: le !== null ? le : ""
        }), typeof D != "function" && (Ns(c.lanes, En) || a("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", jn(c) || "Unknown"));
      }), E;
    }
    function oae(c, d, x) {
      var E = c.pingCache, D;
      if (E === null ? (E = c.pingCache = new J3e(), D = /* @__PURE__ */ new Set(), E.set(d, D)) : (D = E.get(d), D === void 0 && (D = /* @__PURE__ */ new Set(), E.set(d, D))), !D.has(x)) {
        D.add(x);
        var I = WLe.bind(null, c, d, x);
        bo && mA(c, x), d.then(I, I);
      }
    }
    function eje(c, d, x, E) {
      var D = c.updateQueue;
      if (D === null) {
        var I = /* @__PURE__ */ new Set();
        I.add(x), c.updateQueue = I;
      } else
        D.add(x);
    }
    function tje(c, d) {
      var x = c.tag;
      if ((c.mode & fr) === hn && (x === u || x === A || x === $)) {
        var E = c.alternate;
        E ? (c.updateQueue = E.updateQueue, c.memoizedState = E.memoizedState, c.lanes = E.lanes) : (c.updateQueue = null, c.memoizedState = null);
      }
    }
    function aae(c) {
      var d = c;
      do {
        if (d.tag === R && z3e(d))
          return d;
        d = d.return;
      } while (d !== null);
      return null;
    }
    function sae(c, d, x, E, D) {
      if ((c.mode & fr) === hn) {
        if (c === d)
          c.flags |= Sa;
        else {
          if (c.flags |= An, x.flags |= $v, x.flags &= ~(yl | Nu), x.tag === l) {
            var I = x.alternate;
            if (I === null)
              x.tag = W;
            else {
              var F = y0(si, En);
              F.tag = bP, U1(x, F, En);
            }
          }
          x.lanes = Gn(x.lanes, En);
        }
        return c;
      }
      return c.flags |= Sa, c.lanes = D, c;
    }
    function nje(c, d, x, E, D) {
      if (x.flags |= Nu, bo && mA(c, D), E !== null && typeof E == "object" && typeof E.then == "function") {
        var I = E;
        tje(x), Fu() && x.mode & fr && Kie();
        var F = aae(d);
        if (F !== null) {
          F.flags &= ~Ao, sae(F, d, x, c, D), F.mode & fr && oae(c, I, D), eje(F, c, I);
          return;
        } else {
          if (!Qp(D)) {
            oae(c, I, D), CU();
            return;
          }
          var G = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          E = G;
        }
      } else if (Fu() && x.mode & fr) {
        Kie();
        var J = aae(d);
        if (J !== null) {
          (J.flags & Sa) === cn && (J.flags |= Ao), sae(J, d, x, c, D), F7(tE(E, x));
          return;
        }
      }
      E = tE(E, x), PLe(E);
      var le = d;
      do {
        switch (le.tag) {
          case h: {
            var de = E;
            le.flags |= Sa;
            var De = ha(D);
            le.lanes = Gn(le.lanes, De);
            var Ce = iae(le, de, De);
            X7(le, Ce);
            return;
          }
          case l:
            var Ue = E, Ve = le.type, Ze = le.stateNode;
            if ((le.flags & An) === cn && (typeof Ve.getDerivedStateFromError == "function" || Ze !== null && typeof Ze.componentDidCatch == "function" && !ase(Ze))) {
              le.flags |= Sa;
              var Yt = ha(D);
              le.lanes = Gn(le.lanes, Yt);
              var yn = GB(le, Ue, Yt);
              X7(le, yn);
              return;
            }
            break;
        }
        le = le.return;
      } while (le !== null);
    }
    function rje() {
      return null;
    }
    var tA = n.ReactCurrentOwner, dg = !1, QB, nA, XB, KB, ZB, nE, JB, XP;
    QB = {}, nA = {}, XB = {}, KB = {}, ZB = {}, nE = !1, JB = {}, XP = {};
    function fc(c, d, x, E) {
      c === null ? d.child = Moe(d, null, x, E) : d.child = cM(d, c.child, x, E);
    }
    function ije(c, d, x, E) {
      d.child = cM(d, c.child, null, E), d.child = cM(d, null, x, E);
    }
    function uae(c, d, x, E, D) {
      if (d.type !== d.elementType) {
        var I = x.propTypes;
        I && wo(
          I,
          E,
          // Resolved props
          "prop",
          Rr(x)
        );
      }
      var F = x.render, G = d.ref, J, le;
      lM(d, D), yh(d);
      {
        if (tA.current = d, eu(!0), J = mM(c, d, F, E, G, D), le = yM(), d.mode & lo) {
          fa(!0);
          try {
            J = mM(c, d, F, E, G, D), le = yM();
          } finally {
            fa(!1);
          }
        }
        eu(!1);
      }
      return Hp(), c !== null && !dg ? (Aoe(c, d, D), v0(c, d, D)) : (Fu() && le && $7(d), d.flags |= fh, fc(c, d, J, D), d.child);
    }
    function lae(c, d, x, E, D) {
      if (c === null) {
        var I = x.type;
        if (l5e(I) && x.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        x.defaultProps === void 0) {
          var F = I;
          return F = MM(I), d.tag = $, d.type = F, nU(d, I), cae(c, d, F, E, D);
        }
        {
          var G = I.propTypes;
          G && wo(
            G,
            E,
            // Resolved props
            "prop",
            Rr(I)
          );
        }
        var J = LU(x.type, null, E, d, d.mode, D);
        return J.ref = d.ref, J.return = d, d.child = J, J;
      }
      {
        var le = x.type, de = le.propTypes;
        de && wo(
          de,
          E,
          // Resolved props
          "prop",
          Rr(le)
        );
      }
      var De = c.child, Ce = uU(c, D);
      if (!Ce) {
        var Ue = De.memoizedProps, Ve = x.compare;
        if (Ve = Ve !== null ? Ve : rn, Ve(Ue, E) && c.ref === d.ref)
          return v0(c, d, D);
      }
      d.flags |= fh;
      var Ze = sE(De, E);
      return Ze.ref = d.ref, Ze.return = d, d.child = Ze, Ze;
    }
    function cae(c, d, x, E, D) {
      if (d.type !== d.elementType) {
        var I = d.elementType;
        if (I.$$typeof === sn) {
          var F = I, G = F._payload, J = F._init;
          try {
            I = J(G);
          } catch {
            I = null;
          }
          var le = I && I.propTypes;
          le && wo(
            le,
            E,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Rr(I)
          );
        }
      }
      if (c !== null) {
        var de = c.memoizedProps;
        if (rn(de, E) && c.ref === d.ref && // Prevent bailout if the implementation changed due to hot reload.
        d.type === c.type)
          if (dg = !1, d.pendingProps = E = de, uU(c, D))
            (c.flags & $v) !== cn && (dg = !0);
          else
            return d.lanes = c.lanes, v0(c, d, D);
      }
      return eU(c, d, x, E, D);
    }
    function fae(c, d, x) {
      var E = d.pendingProps, D = E.children, I = c !== null ? c.memoizedState : null;
      if (E.mode === "hidden" || H)
        if ((d.mode & fr) === hn) {
          var F = {
            baseLanes: Xe,
            cachePool: null,
            transitions: null
          };
          d.memoizedState = F, lI(d, x);
        } else if (Ns(x, su)) {
          var De = {
            baseLanes: Xe,
            cachePool: null,
            transitions: null
          };
          d.memoizedState = De;
          var Ce = I !== null ? I.baseLanes : x;
          lI(d, Ce);
        } else {
          var G = null, J;
          if (I !== null) {
            var le = I.baseLanes;
            J = Gn(le, x);
          } else
            J = x;
          d.lanes = d.childLanes = su;
          var de = {
            baseLanes: J,
            cachePool: G,
            transitions: null
          };
          return d.memoizedState = de, d.updateQueue = null, lI(d, J), null;
        }
      else {
        var Ue;
        I !== null ? (Ue = Gn(I.baseLanes, x), d.memoizedState = null) : Ue = x, lI(d, Ue);
      }
      return fc(c, d, D, x), d.child;
    }
    function oje(c, d, x) {
      var E = d.pendingProps;
      return fc(c, d, E, x), d.child;
    }
    function aje(c, d, x) {
      var E = d.pendingProps.children;
      return fc(c, d, E, x), d.child;
    }
    function sje(c, d, x) {
      {
        d.flags |= Tn;
        {
          var E = d.stateNode;
          E.effectDuration = 0, E.passiveEffectDuration = 0;
        }
      }
      var D = d.pendingProps, I = D.children;
      return fc(c, d, I, x), d.child;
    }
    function dae(c, d) {
      var x = d.ref;
      (c === null && x !== null || c !== null && c.ref !== x) && (d.flags |= Oo, d.flags |= Zf);
    }
    function eU(c, d, x, E, D) {
      if (d.type !== d.elementType) {
        var I = x.propTypes;
        I && wo(
          I,
          E,
          // Resolved props
          "prop",
          Rr(x)
        );
      }
      var F;
      {
        var G = rM(d, x, !0);
        F = iM(d, G);
      }
      var J, le;
      lM(d, D), yh(d);
      {
        if (tA.current = d, eu(!0), J = mM(c, d, x, E, F, D), le = yM(), d.mode & lo) {
          fa(!0);
          try {
            J = mM(c, d, x, E, F, D), le = yM();
          } finally {
            fa(!1);
          }
        }
        eu(!1);
      }
      return Hp(), c !== null && !dg ? (Aoe(c, d, D), v0(c, d, D)) : (Fu() && le && $7(d), d.flags |= fh, fc(c, d, J, D), d.child);
    }
    function hae(c, d, x, E, D) {
      {
        switch (S5e(d)) {
          case !1: {
            var I = d.stateNode, F = d.type, G = new F(d.memoizedProps, I.context), J = G.state;
            I.updater.enqueueSetState(I, J, null);
            break;
          }
          case !0: {
            d.flags |= An, d.flags |= Sa;
            var le = new Error("Simulated error coming from DevTools"), de = ha(D);
            d.lanes = Gn(d.lanes, de);
            var De = GB(d, tE(le, d), de);
            X7(d, De);
            break;
          }
        }
        if (d.type !== d.elementType) {
          var Ce = x.propTypes;
          Ce && wo(
            Ce,
            E,
            // Resolved props
            "prop",
            Rr(x)
          );
        }
      }
      var Ue;
      ay(x) ? (Ue = !0, uP(d)) : Ue = !1, lM(d, D);
      var Ve = d.stateNode, Ze;
      Ve === null ? (ZP(c, d), xoe(d, x, E), uB(d, x, E, D), Ze = !0) : c === null ? Ze = k3e(d, x, E, D) : Ze = $3e(c, d, x, E, D);
      var Yt = tU(c, d, x, Ze, Ue, D);
      {
        var yn = d.stateNode;
        Ze && yn.props !== E && (nE || a("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", jn(d) || "a component"), nE = !0);
      }
      return Yt;
    }
    function tU(c, d, x, E, D, I) {
      dae(c, d);
      var F = (d.flags & An) !== cn;
      if (!E && !F)
        return D && qie(d, x, !1), v0(c, d, I);
      var G = d.stateNode;
      tA.current = d;
      var J;
      if (F && typeof x.getDerivedStateFromError != "function")
        J = null, rae();
      else {
        yh(d);
        {
          if (eu(!0), J = G.render(), d.mode & lo) {
            fa(!0);
            try {
              G.render();
            } finally {
              fa(!1);
            }
          }
          eu(!1);
        }
        Hp();
      }
      return d.flags |= fh, c !== null && F ? ije(c, d, J, I) : fc(c, d, J, I), d.memoizedState = G.state, D && qie(d, x, !0), d.child;
    }
    function pae(c) {
      var d = c.stateNode;
      d.pendingContext ? Vie(c, d.pendingContext, d.pendingContext !== d.context) : d.context && Vie(c, d.context, !1), pB(c, d.containerInfo);
    }
    function uje(c, d, x) {
      if (pae(d), c === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var E = d.pendingProps, D = d.memoizedState, I = D.element;
      doe(c, d), EP(d, E, null, x);
      var F = d.memoizedState;
      d.stateNode;
      var G = F.element;
      if (D.isDehydrated) {
        var J = {
          element: G,
          isDehydrated: !1,
          cache: F.cache,
          pendingSuspenseBoundaries: F.pendingSuspenseBoundaries,
          transitions: F.transitions
        }, le = d.updateQueue;
        if (le.baseState = J, d.memoizedState = J, d.flags & Ao) {
          var de = tE(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), d);
          return gae(c, d, G, x, de);
        } else if (G !== I) {
          var De = tE(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), d);
          return gae(c, d, G, x, De);
        } else {
          d3e(d);
          var Ce = Moe(d, null, G, x);
          d.child = Ce;
          for (var Ue = Ce; Ue; )
            Ue.flags = Ue.flags & ~no | ml, Ue = Ue.sibling;
        }
      } else {
        if (sM(), G === I)
          return v0(c, d, x);
        fc(c, d, G, x);
      }
      return d.child;
    }
    function gae(c, d, x, E, D) {
      return sM(), F7(D), d.flags |= Ao, fc(c, d, x, E), d.child;
    }
    function lje(c, d, x) {
      Coe(d), c === null && z7(d);
      var E = d.type, D = d.pendingProps, I = c !== null ? c.memoizedProps : null, F = D.children, G = MD(E, D);
      return G ? F = null : I !== null && MD(E, I) && (d.flags |= ai), dae(c, d), fc(c, d, F, x), d.child;
    }
    function cje(c, d) {
      return c === null && z7(d), null;
    }
    function fje(c, d, x, E) {
      ZP(c, d);
      var D = d.pendingProps, I = x, F = I._payload, G = I._init, J = G(F);
      d.type = J;
      var le = d.tag = c5e(J), de = lg(J, D), De;
      switch (le) {
        case u:
          return nU(d, J), d.type = J = MM(J), De = eU(null, d, J, de, E), De;
        case l:
          return d.type = J = RU(J), De = hae(null, d, J, de, E), De;
        case A:
          return d.type = J = kU(J), De = uae(null, d, J, de, E), De;
        case j: {
          if (d.type !== d.elementType) {
            var Ce = J.propTypes;
            Ce && wo(
              Ce,
              de,
              // Resolved for outer only
              "prop",
              Rr(J)
            );
          }
          return De = lae(
            null,
            d,
            J,
            lg(J.type, de),
            // The inner type can have defaults too
            E
          ), De;
        }
      }
      var Ue = "";
      throw J !== null && typeof J == "object" && J.$$typeof === sn && (Ue = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + J + ". " + ("Lazy element type must resolve to a class or function." + Ue));
    }
    function dje(c, d, x, E, D) {
      ZP(c, d), d.tag = l;
      var I;
      return ay(x) ? (I = !0, uP(d)) : I = !1, lM(d, D), xoe(d, x, E), uB(d, x, E, D), tU(null, d, x, !0, I, D);
    }
    function hje(c, d, x, E) {
      ZP(c, d);
      var D = d.pendingProps, I;
      {
        var F = rM(d, x, !1);
        I = iM(d, F);
      }
      lM(d, E);
      var G, J;
      yh(d);
      {
        if (x.prototype && typeof x.prototype.render == "function") {
          var le = Rr(x) || "Unknown";
          QB[le] || (a("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", le, le), QB[le] = !0);
        }
        d.mode & lo && ug.recordLegacyContextWarning(d, null), eu(!0), tA.current = d, G = mM(null, d, x, D, I, E), J = yM(), eu(!1);
      }
      if (Hp(), d.flags |= fh, typeof G == "object" && G !== null && typeof G.render == "function" && G.$$typeof === void 0) {
        var de = Rr(x) || "Unknown";
        nA[de] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", de, de, de), nA[de] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof G == "object" && G !== null && typeof G.render == "function" && G.$$typeof === void 0
      ) {
        {
          var De = Rr(x) || "Unknown";
          nA[De] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", De, De, De), nA[De] = !0);
        }
        d.tag = l, d.memoizedState = null, d.updateQueue = null;
        var Ce = !1;
        return ay(x) ? (Ce = !0, uP(d)) : Ce = !1, d.memoizedState = G.state !== null && G.state !== void 0 ? G.state : null, Q7(d), boe(d, G), uB(d, x, D, E), tU(null, d, x, !0, Ce, E);
      } else {
        if (d.tag = u, d.mode & lo) {
          fa(!0);
          try {
            G = mM(null, d, x, D, I, E), J = yM();
          } finally {
            fa(!1);
          }
        }
        return Fu() && J && $7(d), fc(null, d, G, E), nU(d, x), d.child;
      }
    }
    function nU(c, d) {
      {
        if (d && d.childContextTypes && a("%s(...): childContextTypes cannot be defined on a function component.", d.displayName || d.name || "Component"), c.ref !== null) {
          var x = "", E = Ms();
          E && (x += `

Check the render method of \`` + E + "`.");
          var D = E || "", I = c._debugSource;
          I && (D = I.fileName + ":" + I.lineNumber), ZB[D] || (ZB[D] = !0, a("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", x));
        }
        if (typeof d.getDerivedStateFromProps == "function") {
          var F = Rr(d) || "Unknown";
          KB[F] || (a("%s: Function components do not support getDerivedStateFromProps.", F), KB[F] = !0);
        }
        if (typeof d.contextType == "object" && d.contextType !== null) {
          var G = Rr(d) || "Unknown";
          XB[G] || (a("%s: Function components do not support contextType.", G), XB[G] = !0);
        }
      }
    }
    var rU = {
      dehydrated: null,
      treeContext: null,
      retryLane: Er
    };
    function iU(c) {
      return {
        baseLanes: c,
        cachePool: rje(),
        transitions: null
      };
    }
    function pje(c, d) {
      var x = null;
      return {
        baseLanes: Gn(c.baseLanes, d),
        cachePool: x,
        transitions: c.transitions
      };
    }
    function gje(c, d, x, E) {
      if (d !== null) {
        var D = d.memoizedState;
        if (D === null)
          return !1;
      }
      return yB(c, qD);
    }
    function mje(c, d) {
      return Xp(c.childLanes, d);
    }
    function mae(c, d, x) {
      var E = d.pendingProps;
      M5e(d) && (d.flags |= An);
      var D = cg.current, I = !1, F = (d.flags & An) !== cn;
      if (F || gje(D, c) ? (I = !0, d.flags &= ~An) : (c === null || c.memoizedState !== null) && (D = L3e(D, Doe)), D = dM(D), H1(d, D), c === null) {
        z7(d);
        var G = d.memoizedState;
        if (G !== null) {
          var J = G.dehydrated;
          if (J !== null)
            return wje(d, J);
        }
        var le = E.children, de = E.fallback;
        if (I) {
          var De = yje(d, le, de, x), Ce = d.child;
          return Ce.memoizedState = iU(x), d.memoizedState = rU, De;
        } else
          return oU(d, le);
      } else {
        var Ue = c.memoizedState;
        if (Ue !== null) {
          var Ve = Ue.dehydrated;
          if (Ve !== null)
            return _je(c, d, F, E, Ve, Ue, x);
        }
        if (I) {
          var Ze = E.fallback, Yt = E.children, yn = bje(c, d, Yt, Ze, x), on = d.child, Yr = c.child.memoizedState;
          return on.memoizedState = Yr === null ? iU(x) : pje(Yr, x), on.childLanes = mje(c, x), d.memoizedState = rU, yn;
        } else {
          var Nr = E.children, je = vje(c, d, Nr, x);
          return d.memoizedState = null, je;
        }
      }
    }
    function oU(c, d, x) {
      var E = c.mode, D = {
        mode: "visible",
        children: d
      }, I = aU(D, E);
      return I.return = c, c.child = I, I;
    }
    function yje(c, d, x, E) {
      var D = c.mode, I = c.child, F = {
        mode: "hidden",
        children: d
      }, G, J;
      return (D & fr) === hn && I !== null ? (G = I, G.childLanes = Xe, G.pendingProps = F, c.mode & pn && (G.actualDuration = 0, G.actualStartTime = -1, G.selfBaseDuration = 0, G.treeBaseDuration = 0), J = Z1(x, D, E, null)) : (G = aU(F, D), J = Z1(x, D, E, null)), G.return = c, J.return = c, G.sibling = J, c.child = G, J;
    }
    function aU(c, d, x) {
      return yse(c, d, Xe, null);
    }
    function yae(c, d) {
      return sE(c, d);
    }
    function vje(c, d, x, E) {
      var D = c.child, I = D.sibling, F = yae(D, {
        mode: "visible",
        children: x
      });
      if ((d.mode & fr) === hn && (F.lanes = E), F.return = d, F.sibling = null, I !== null) {
        var G = d.deletions;
        G === null ? (d.deletions = [I], d.flags |= Jr) : G.push(I);
      }
      return d.child = F, F;
    }
    function bje(c, d, x, E, D) {
      var I = d.mode, F = c.child, G = F.sibling, J = {
        mode: "hidden",
        children: x
      }, le;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (I & fr) === hn && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        d.child !== F
      ) {
        var de = d.child;
        le = de, le.childLanes = Xe, le.pendingProps = J, d.mode & pn && (le.actualDuration = 0, le.actualStartTime = -1, le.selfBaseDuration = F.selfBaseDuration, le.treeBaseDuration = F.treeBaseDuration), d.deletions = null;
      } else
        le = yae(F, J), le.subtreeFlags = F.subtreeFlags & Ma;
      var De;
      return G !== null ? De = sE(G, E) : (De = Z1(E, I, D, null), De.flags |= no), De.return = d, le.return = d, le.sibling = De, d.child = le, De;
    }
    function KP(c, d, x, E) {
      E !== null && F7(E), cM(d, c.child, null, x);
      var D = d.pendingProps, I = D.children, F = oU(d, I);
      return F.flags |= no, d.memoizedState = null, F;
    }
    function xje(c, d, x, E, D) {
      var I = d.mode, F = {
        mode: "visible",
        children: x
      }, G = aU(F, I), J = Z1(E, I, D, null);
      return J.flags |= no, G.return = d, J.return = d, G.sibling = J, d.child = G, (d.mode & fr) !== hn && cM(d, c.child, null, D), J;
    }
    function wje(c, d, x) {
      return (c.mode & fr) === hn ? (a("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), c.lanes = En) : PD(d) ? c.lanes = Wp : c.lanes = su, null;
    }
    function _je(c, d, x, E, D, I, F) {
      if (x)
        if (d.flags & Ao) {
          d.flags &= ~Ao;
          var je = WB(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return KP(c, d, F, je);
        } else {
          if (d.memoizedState !== null)
            return d.child = c.child, d.flags |= An, null;
          var Je = E.children, Le = E.fallback, vt = xje(c, d, Je, Le, F), Ht = d.child;
          return Ht.memoizedState = iU(F), d.memoizedState = rU, vt;
        }
      else {
        if (c3e(), (d.mode & fr) === hn)
          return KP(
            c,
            d,
            F,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (PD(D)) {
          var G, J, le;
          {
            var de = a7(D);
            G = de.digest, J = de.message, le = de.stack;
          }
          var De;
          J ? De = new Error(J) : De = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var Ce = WB(De, G, le);
          return KP(c, d, F, Ce);
        }
        var Ue = Ns(F, c.childLanes);
        if (dg || Ue) {
          var Ve = uI();
          if (Ve !== null) {
            var Ze = h1(Ve, F);
            if (Ze !== Er && Ze !== I.retryLane) {
              I.retryLane = Ze;
              var Yt = si;
              af(c, Ze), zs(Ve, c, Ze, Yt);
            }
          }
          CU();
          var yn = WB(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return KP(c, d, F, yn);
        } else if (iP(D)) {
          d.flags |= An, d.child = c.child;
          var on = qLe.bind(null, c);
          return s7(D, on), null;
        } else {
          h3e(d, D, I.treeContext);
          var Yr = E.children, Nr = oU(d, Yr);
          return Nr.flags |= ml, Nr;
        }
      }
    }
    function vae(c, d, x) {
      c.lanes = Gn(c.lanes, d);
      var E = c.alternate;
      E !== null && (E.lanes = Gn(E.lanes, d)), V7(c.return, d, x);
    }
    function Eje(c, d, x) {
      for (var E = d; E !== null; ) {
        if (E.tag === R) {
          var D = E.memoizedState;
          D !== null && vae(E, x, c);
        } else if (E.tag === V)
          vae(E, x, c);
        else if (E.child !== null) {
          E.child.return = E, E = E.child;
          continue;
        }
        if (E === c)
          return;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === c)
            return;
          E = E.return;
        }
        E.sibling.return = E.return, E = E.sibling;
      }
    }
    function Sje(c) {
      for (var d = c, x = null; d !== null; ) {
        var E = d.alternate;
        E !== null && AP(E) === null && (x = d), d = d.sibling;
      }
      return x;
    }
    function Mje(c) {
      if (c !== void 0 && c !== "forwards" && c !== "backwards" && c !== "together" && !JB[c])
        if (JB[c] = !0, typeof c == "string")
          switch (c.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              a('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', c, c.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              a('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', c, c.toLowerCase());
              break;
            }
            default:
              a('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
              break;
          }
        else
          a('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
    }
    function Tje(c, d) {
      c !== void 0 && !XP[c] && (c !== "collapsed" && c !== "hidden" ? (XP[c] = !0, a('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', c)) : d !== "forwards" && d !== "backwards" && (XP[c] = !0, a('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', c)));
    }
    function bae(c, d) {
      {
        var x = _r(c), E = !x && typeof Kl(c) == "function";
        if (x || E) {
          var D = x ? "array" : "iterable";
          return a("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", D, d, D), !1;
        }
      }
      return !0;
    }
    function Cje(c, d) {
      if ((d === "forwards" || d === "backwards") && c !== void 0 && c !== null && c !== !1)
        if (_r(c)) {
          for (var x = 0; x < c.length; x++)
            if (!bae(c[x], x))
              return;
        } else {
          var E = Kl(c);
          if (typeof E == "function") {
            var D = E.call(c);
            if (D)
              for (var I = D.next(), F = 0; !I.done; I = D.next()) {
                if (!bae(I.value, F))
                  return;
                F++;
              }
          } else
            a('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', d);
        }
    }
    function sU(c, d, x, E, D) {
      var I = c.memoizedState;
      I === null ? c.memoizedState = {
        isBackwards: d,
        rendering: null,
        renderingStartTime: 0,
        last: E,
        tail: x,
        tailMode: D
      } : (I.isBackwards = d, I.rendering = null, I.renderingStartTime = 0, I.last = E, I.tail = x, I.tailMode = D);
    }
    function xae(c, d, x) {
      var E = d.pendingProps, D = E.revealOrder, I = E.tail, F = E.children;
      Mje(D), Tje(I, D), Cje(F, D), fc(c, d, F, x);
      var G = cg.current, J = yB(G, qD);
      if (J)
        G = vB(G, qD), d.flags |= An;
      else {
        var le = c !== null && (c.flags & An) !== cn;
        le && Eje(d, d.child, x), G = dM(G);
      }
      if (H1(d, G), (d.mode & fr) === hn)
        d.memoizedState = null;
      else
        switch (D) {
          case "forwards": {
            var de = Sje(d.child), De;
            de === null ? (De = d.child, d.child = null) : (De = de.sibling, de.sibling = null), sU(
              d,
              !1,
              // isBackwards
              De,
              de,
              I
            );
            break;
          }
          case "backwards": {
            var Ce = null, Ue = d.child;
            for (d.child = null; Ue !== null; ) {
              var Ve = Ue.alternate;
              if (Ve !== null && AP(Ve) === null) {
                d.child = Ue;
                break;
              }
              var Ze = Ue.sibling;
              Ue.sibling = Ce, Ce = Ue, Ue = Ze;
            }
            sU(
              d,
              !0,
              // isBackwards
              Ce,
              null,
              // last
              I
            );
            break;
          }
          case "together": {
            sU(
              d,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            d.memoizedState = null;
        }
      return d.child;
    }
    function Nje(c, d, x) {
      pB(d, d.stateNode.containerInfo);
      var E = d.pendingProps;
      return c === null ? d.child = cM(d, null, E, x) : fc(c, d, E, x), d.child;
    }
    var wae = !1;
    function Dje(c, d, x) {
      var E = d.type, D = E._context, I = d.pendingProps, F = d.memoizedProps, G = I.value;
      {
        "value" in I || wae || (wae = !0, a("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var J = d.type.propTypes;
        J && wo(J, I, "prop", "Context.Provider");
      }
      if (uoe(d, D, G), F !== null) {
        var le = F.value;
        if (Wt(le, G)) {
          if (F.children === I.children && !aP())
            return v0(c, d, x);
        } else
          E3e(d, D, x);
      }
      var de = I.children;
      return fc(c, d, de, x), d.child;
    }
    var _ae = !1;
    function Aje(c, d, x) {
      var E = d.type;
      E._context === void 0 ? E !== E.Consumer && (_ae || (_ae = !0, a("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : E = E._context;
      var D = d.pendingProps, I = D.children;
      typeof I != "function" && a("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), lM(d, x);
      var F = ys(E);
      yh(d);
      var G;
      return tA.current = d, eu(!0), G = I(F), eu(!1), Hp(), d.flags |= fh, fc(c, d, G, x), d.child;
    }
    function rA() {
      dg = !0;
    }
    function ZP(c, d) {
      (d.mode & fr) === hn && c !== null && (c.alternate = null, d.alternate = null, d.flags |= no);
    }
    function v0(c, d, x) {
      return c !== null && (d.dependencies = c.dependencies), rae(), gA(d.lanes), Ns(x, d.childLanes) ? (P3e(c, d), d.child) : null;
    }
    function Oje(c, d, x) {
      {
        var E = d.return;
        if (E === null)
          throw new Error("Cannot swap the root fiber.");
        if (c.alternate = null, d.alternate = null, x.index = d.index, x.sibling = d.sibling, x.return = d.return, x.ref = d.ref, d === E.child)
          E.child = x;
        else {
          var D = E.child;
          if (D === null)
            throw new Error("Expected parent to have a child.");
          for (; D.sibling !== d; )
            if (D = D.sibling, D === null)
              throw new Error("Expected to find the previous sibling.");
          D.sibling = x;
        }
        var I = E.deletions;
        return I === null ? (E.deletions = [c], E.flags |= Jr) : I.push(c), x.flags |= no, x;
      }
    }
    function uU(c, d) {
      var x = c.lanes;
      return !!Ns(x, d);
    }
    function Rje(c, d, x) {
      switch (d.tag) {
        case h:
          pae(d), d.stateNode, sM();
          break;
        case g:
          Coe(d);
          break;
        case l: {
          var E = d.type;
          ay(E) && uP(d);
          break;
        }
        case p:
          pB(d, d.stateNode.containerInfo);
          break;
        case C: {
          var D = d.memoizedProps.value, I = d.type._context;
          uoe(d, I, D);
          break;
        }
        case O:
          {
            var F = Ns(x, d.childLanes);
            F && (d.flags |= Tn);
            {
              var G = d.stateNode;
              G.effectDuration = 0, G.passiveEffectDuration = 0;
            }
          }
          break;
        case R: {
          var J = d.memoizedState;
          if (J !== null) {
            if (J.dehydrated !== null)
              return H1(d, dM(cg.current)), d.flags |= An, null;
            var le = d.child, de = le.childLanes;
            if (Ns(x, de))
              return mae(c, d, x);
            H1(d, dM(cg.current));
            var De = v0(c, d, x);
            return De !== null ? De.sibling : null;
          } else
            H1(d, dM(cg.current));
          break;
        }
        case V: {
          var Ce = (c.flags & An) !== cn, Ue = Ns(x, d.childLanes);
          if (Ce) {
            if (Ue)
              return xae(c, d, x);
            d.flags |= An;
          }
          var Ve = d.memoizedState;
          if (Ve !== null && (Ve.rendering = null, Ve.tail = null, Ve.lastEffect = null), H1(d, cg.current), Ue)
            break;
          return null;
        }
        case K:
        case Q:
          return d.lanes = Xe, fae(c, d, x);
      }
      return v0(c, d, x);
    }
    function Eae(c, d, x) {
      if (d._debugNeedsRemount && c !== null)
        return Oje(c, d, LU(d.type, d.key, d.pendingProps, d._debugOwner || null, d.mode, d.lanes));
      if (c !== null) {
        var E = c.memoizedProps, D = d.pendingProps;
        if (E !== D || aP() || // Force a re-render if the implementation changed due to hot reload:
        d.type !== c.type)
          dg = !0;
        else {
          var I = uU(c, x);
          if (!I && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (d.flags & An) === cn)
            return dg = !1, Rje(c, d, x);
          (c.flags & $v) !== cn ? dg = !0 : dg = !1;
        }
      } else if (dg = !1, Fu() && i3e(d)) {
        var F = d.index, G = o3e();
        Xie(d, G, F);
      }
      switch (d.lanes = Xe, d.tag) {
        case f:
          return hje(c, d, d.type, x);
        case z: {
          var J = d.elementType;
          return fje(c, d, J, x);
        }
        case u: {
          var le = d.type, de = d.pendingProps, De = d.elementType === le ? de : lg(le, de);
          return eU(c, d, le, De, x);
        }
        case l: {
          var Ce = d.type, Ue = d.pendingProps, Ve = d.elementType === Ce ? Ue : lg(Ce, Ue);
          return hae(c, d, Ce, Ve, x);
        }
        case h:
          return uje(c, d, x);
        case g:
          return lje(c, d, x);
        case y:
          return cje(c, d);
        case R:
          return mae(c, d, x);
        case p:
          return Nje(c, d, x);
        case A: {
          var Ze = d.type, Yt = d.pendingProps, yn = d.elementType === Ze ? Yt : lg(Ze, Yt);
          return uae(c, d, Ze, yn, x);
        }
        case b:
          return oje(c, d, x);
        case _:
          return aje(c, d, x);
        case O:
          return sje(c, d, x);
        case C:
          return Dje(c, d, x);
        case S:
          return Aje(c, d, x);
        case j: {
          var on = d.type, Yr = d.pendingProps, Nr = lg(on, Yr);
          if (d.type !== d.elementType) {
            var je = on.propTypes;
            je && wo(
              je,
              Nr,
              // Resolved for outer only
              "prop",
              Rr(on)
            );
          }
          return Nr = lg(on.type, Nr), lae(c, d, on, Nr, x);
        }
        case $:
          return cae(c, d, d.type, d.pendingProps, x);
        case W: {
          var Je = d.type, Le = d.pendingProps, vt = d.elementType === Je ? Le : lg(Je, Le);
          return dje(c, d, Je, vt, x);
        }
        case V:
          return xae(c, d, x);
        case ee:
          break;
        case K:
          return fae(c, d, x);
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function vM(c) {
      c.flags |= Tn;
    }
    function Sae(c) {
      c.flags |= Oo, c.flags |= Zf;
    }
    var Mae, lU, Tae, Cae;
    Mae = function(c, d, x, E) {
      for (var D = d.child; D !== null; ) {
        if (D.tag === g || D.tag === y)
          B9(c, D.stateNode);
        else if (D.tag !== p) {
          if (D.child !== null) {
            D.child.return = D, D = D.child;
            continue;
          }
        }
        if (D === d)
          return;
        for (; D.sibling === null; ) {
          if (D.return === null || D.return === d)
            return;
          D = D.return;
        }
        D.sibling.return = D.return, D = D.sibling;
      }
    }, lU = function(c, d) {
    }, Tae = function(c, d, x, E, D) {
      var I = c.memoizedProps;
      if (I !== E) {
        var F = d.stateNode, G = gB(), J = Y9(F, x, I, E, D, G);
        d.updateQueue = J, J && vM(d);
      }
    }, Cae = function(c, d, x, E) {
      x !== E && vM(d);
    };
    function iA(c, d) {
      if (!Fu())
        switch (c.tailMode) {
          case "hidden": {
            for (var x = c.tail, E = null; x !== null; )
              x.alternate !== null && (E = x), x = x.sibling;
            E === null ? c.tail = null : E.sibling = null;
            break;
          }
          case "collapsed": {
            for (var D = c.tail, I = null; D !== null; )
              D.alternate !== null && (I = D), D = D.sibling;
            I === null ? !d && c.tail !== null ? c.tail.sibling = null : c.tail = null : I.sibling = null;
            break;
          }
        }
    }
    function Uu(c) {
      var d = c.alternate !== null && c.alternate.child === c.child, x = Xe, E = cn;
      if (d) {
        if ((c.mode & pn) !== hn) {
          for (var J = c.selfBaseDuration, le = c.child; le !== null; )
            x = Gn(x, Gn(le.lanes, le.childLanes)), E |= le.subtreeFlags & Ma, E |= le.flags & Ma, J += le.treeBaseDuration, le = le.sibling;
          c.treeBaseDuration = J;
        } else
          for (var de = c.child; de !== null; )
            x = Gn(x, Gn(de.lanes, de.childLanes)), E |= de.subtreeFlags & Ma, E |= de.flags & Ma, de.return = c, de = de.sibling;
        c.subtreeFlags |= E;
      } else {
        if ((c.mode & pn) !== hn) {
          for (var D = c.actualDuration, I = c.selfBaseDuration, F = c.child; F !== null; )
            x = Gn(x, Gn(F.lanes, F.childLanes)), E |= F.subtreeFlags, E |= F.flags, D += F.actualDuration, I += F.treeBaseDuration, F = F.sibling;
          c.actualDuration = D, c.treeBaseDuration = I;
        } else
          for (var G = c.child; G !== null; )
            x = Gn(x, Gn(G.lanes, G.childLanes)), E |= G.subtreeFlags, E |= G.flags, G.return = c, G = G.sibling;
        c.subtreeFlags |= E;
      }
      return c.childLanes = x, d;
    }
    function kje(c, d, x) {
      if (v3e() && (d.mode & fr) !== hn && (d.flags & An) === cn)
        return roe(d), sM(), d.flags |= Ao | Nu | Sa, !1;
      var E = hP(d);
      if (x !== null && x.dehydrated !== null)
        if (c === null) {
          if (!E)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (m3e(d), Uu(d), (d.mode & pn) !== hn) {
            var D = x !== null;
            if (D) {
              var I = d.child;
              I !== null && (d.treeBaseDuration -= I.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (sM(), (d.flags & An) === cn && (d.memoizedState = null), d.flags |= Tn, Uu(d), (d.mode & pn) !== hn) {
            var F = x !== null;
            if (F) {
              var G = d.child;
              G !== null && (d.treeBaseDuration -= G.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return ioe(), !0;
    }
    function Nae(c, d, x) {
      var E = d.pendingProps;
      switch (P7(d), d.tag) {
        case f:
        case z:
        case $:
        case u:
        case A:
        case b:
        case _:
        case O:
        case S:
        case j:
          return Uu(d), null;
        case l: {
          var D = d.type;
          return ay(D) && sP(d), Uu(d), null;
        }
        case h: {
          var I = d.stateNode;
          if (fM(d), O7(d), xB(), I.pendingContext && (I.context = I.pendingContext, I.pendingContext = null), c === null || c.child === null) {
            var F = hP(d);
            if (F)
              vM(d);
            else if (c !== null) {
              var G = c.memoizedState;
              // Check if this is a client root
              (!G.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (d.flags & Ao) !== cn) && (d.flags |= gl, ioe());
            }
          }
          return lU(c, d), Uu(d), null;
        }
        case g: {
          mB(d);
          var J = Toe(), le = d.type;
          if (c !== null && d.stateNode != null)
            Tae(c, d, le, E, J), c.ref !== d.ref && Sae(d);
          else {
            if (!E) {
              if (d.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Uu(d), null;
            }
            var de = gB(), De = hP(d);
            if (De)
              p3e(d, J, de) && vM(d);
            else {
              var Ce = F9(le, E, J, de, d);
              Mae(Ce, d, !1, !1), d.stateNode = Ce, U9(Ce, le, E, J) && vM(d);
            }
            d.ref !== null && Sae(d);
          }
          return Uu(d), null;
        }
        case y: {
          var Ue = E;
          if (c && d.stateNode != null) {
            var Ve = c.memoizedProps;
            Cae(c, d, Ve, Ue);
          } else {
            if (typeof Ue != "string" && d.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Ze = Toe(), Yt = gB(), yn = hP(d);
            yn ? g3e(d) && vM(d) : d.stateNode = H9(Ue, Ze, Yt, d);
          }
          return Uu(d), null;
        }
        case R: {
          hM(d);
          var on = d.memoizedState;
          if (c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
            var Yr = kje(c, d, on);
            if (!Yr)
              return d.flags & Sa ? d : null;
          }
          if ((d.flags & An) !== cn)
            return d.lanes = x, (d.mode & pn) !== hn && VB(d), d;
          var Nr = on !== null, je = c !== null && c.memoizedState !== null;
          if (Nr !== je && Nr) {
            var Je = d.child;
            if (Je.flags |= dh, (d.mode & fr) !== hn) {
              var Le = c === null && (d.memoizedProps.unstable_avoidThisFallback !== !0 || !ie);
              Le || yB(cg.current, Doe) ? $Le() : CU();
            }
          }
          var vt = d.updateQueue;
          if (vt !== null && (d.flags |= Tn), Uu(d), (d.mode & pn) !== hn && Nr) {
            var Ht = d.child;
            Ht !== null && (d.treeBaseDuration -= Ht.treeBaseDuration);
          }
          return null;
        }
        case p:
          return fM(d), lU(c, d), c === null && N7(d.stateNode.containerInfo), Uu(d), null;
        case C:
          var Lt = d.type._context;
          return H7(Lt, d), Uu(d), null;
        case W: {
          var Ln = d.type;
          return ay(Ln) && sP(d), Uu(d), null;
        }
        case V: {
          hM(d);
          var Qn = d.memoizedState;
          if (Qn === null)
            return Uu(d), null;
          var qi = (d.flags & An) !== cn, ui = Qn.rendering;
          if (ui === null)
            if (qi)
              iA(Qn, !1);
            else {
              var Xa = ILe() && (c === null || (c.flags & An) === cn);
              if (!Xa)
                for (var li = d.child; li !== null; ) {
                  var Oa = AP(li);
                  if (Oa !== null) {
                    qi = !0, d.flags |= An, iA(Qn, !1);
                    var Dl = Oa.updateQueue;
                    return Dl !== null && (d.updateQueue = Dl, d.flags |= Tn), d.subtreeFlags = cn, I3e(d, x), H1(d, vB(cg.current, qD)), d.child;
                  }
                  li = li.sibling;
                }
              Qn.tail !== null && Pi() > Qae() && (d.flags |= An, qi = !0, iA(Qn, !1), d.lanes = f_);
            }
          else {
            if (!qi) {
              var qu = AP(ui);
              if (qu !== null) {
                d.flags |= An, qi = !0;
                var gd = qu.updateQueue;
                if (gd !== null && (d.updateQueue = gd, d.flags |= Tn), iA(Qn, !0), Qn.tail === null && Qn.tailMode === "hidden" && !ui.alternate && !Fu())
                  return Uu(d), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Pi() * 2 - Qn.renderingStartTime > Qae() && x !== su && (d.flags |= An, qi = !0, iA(Qn, !1), d.lanes = f_);
            }
            if (Qn.isBackwards)
              ui.sibling = d.child, d.child = ui;
            else {
              var pc = Qn.last;
              pc !== null ? pc.sibling = ui : d.child = ui, Qn.last = ui;
            }
          }
          if (Qn.tail !== null) {
            var gc = Qn.tail;
            Qn.rendering = gc, Qn.tail = gc.sibling, Qn.renderingStartTime = Pi(), gc.sibling = null;
            var Al = cg.current;
            return qi ? Al = vB(Al, qD) : Al = dM(Al), H1(d, Al), gc;
          }
          return Uu(d), null;
        }
        case ee:
          break;
        case K:
        case Q: {
          TU(d);
          var E0 = d.memoizedState, TM = E0 !== null;
          if (c !== null) {
            var xA = c.memoizedState, py = xA !== null;
            py !== TM && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !H && (d.flags |= dh);
          }
          return !TM || (d.mode & fr) === hn ? Uu(d) : Ns(hy, su) && (Uu(d), d.subtreeFlags & (no | Tn) && (d.flags |= dh)), null;
        }
        case q:
          return null;
        case te:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function $je(c, d, x) {
      switch (P7(d), d.tag) {
        case l: {
          var E = d.type;
          ay(E) && sP(d);
          var D = d.flags;
          return D & Sa ? (d.flags = D & ~Sa | An, (d.mode & pn) !== hn && VB(d), d) : null;
        }
        case h: {
          d.stateNode, fM(d), O7(d), xB();
          var I = d.flags;
          return (I & Sa) !== cn && (I & An) === cn ? (d.flags = I & ~Sa | An, d) : null;
        }
        case g:
          return mB(d), null;
        case R: {
          hM(d);
          var F = d.memoizedState;
          if (F !== null && F.dehydrated !== null) {
            if (d.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            sM();
          }
          var G = d.flags;
          return G & Sa ? (d.flags = G & ~Sa | An, (d.mode & pn) !== hn && VB(d), d) : null;
        }
        case V:
          return hM(d), null;
        case p:
          return fM(d), null;
        case C:
          var J = d.type._context;
          return H7(J, d), null;
        case K:
        case Q:
          return TU(d), null;
        case q:
          return null;
        default:
          return null;
      }
    }
    function Dae(c, d, x) {
      switch (P7(d), d.tag) {
        case l: {
          var E = d.type.childContextTypes;
          E != null && sP(d);
          break;
        }
        case h: {
          d.stateNode, fM(d), O7(d), xB();
          break;
        }
        case g: {
          mB(d);
          break;
        }
        case p:
          fM(d);
          break;
        case R:
          hM(d);
          break;
        case V:
          hM(d);
          break;
        case C:
          var D = d.type._context;
          H7(D, d);
          break;
        case K:
        case Q:
          TU(d);
          break;
      }
    }
    var Aae = null;
    Aae = /* @__PURE__ */ new Set();
    var JP = !1, Yu = !1, Pje = typeof WeakSet == "function" ? WeakSet : Set, Kt = null, bM = null, xM = null;
    function Ije(c) {
      qc(null, function() {
        throw c;
      }), ch();
    }
    var jje = function(c, d) {
      if (d.props = c.memoizedProps, d.state = c.memoizedState, c.mode & pn)
        try {
          fy(), d.componentWillUnmount();
        } finally {
          cy(c);
        }
      else
        d.componentWillUnmount();
    };
    function Oae(c, d) {
      try {
        q1(ks, c);
      } catch (x) {
        _o(c, d, x);
      }
    }
    function cU(c, d, x) {
      try {
        jje(c, x);
      } catch (E) {
        _o(c, d, E);
      }
    }
    function Lje(c, d, x) {
      try {
        x.componentDidMount();
      } catch (E) {
        _o(c, d, E);
      }
    }
    function Rae(c, d) {
      try {
        $ae(c);
      } catch (x) {
        _o(c, d, x);
      }
    }
    function wM(c, d) {
      var x = c.ref;
      if (x !== null)
        if (typeof x == "function") {
          var E;
          try {
            if (Oe && ke && c.mode & pn)
              try {
                fy(), E = x(null);
              } finally {
                cy(c);
              }
            else
              E = x(null);
          } catch (D) {
            _o(c, d, D);
          }
          typeof E == "function" && a("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", jn(c));
        } else
          x.current = null;
    }
    function eI(c, d, x) {
      try {
        x();
      } catch (E) {
        _o(c, d, E);
      }
    }
    var kae = !1;
    function zje(c, d) {
      L9(c.containerInfo), Kt = d, Fje();
      var x = kae;
      return kae = !1, x;
    }
    function Fje() {
      for (; Kt !== null; ) {
        var c = Kt, d = c.child;
        (c.subtreeFlags & Dm) !== cn && d !== null ? (d.return = c, Kt = d) : Bje();
      }
    }
    function Bje() {
      for (; Kt !== null; ) {
        var c = Kt;
        ii(c);
        try {
          Uje(c);
        } catch (x) {
          _o(c, c.return, x);
        }
        Do();
        var d = c.sibling;
        if (d !== null) {
          d.return = c.return, Kt = d;
          return;
        }
        Kt = c.return;
      }
    }
    function Uje(c) {
      var d = c.alternate, x = c.flags;
      if ((x & gl) !== cn) {
        switch (ii(c), c.tag) {
          case u:
          case A:
          case $:
            break;
          case l: {
            if (d !== null) {
              var E = d.memoizedProps, D = d.memoizedState, I = c.stateNode;
              c.type === c.elementType && !nE && (I.props !== c.memoizedProps && a("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", jn(c) || "instance"), I.state !== c.memoizedState && a("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", jn(c) || "instance"));
              var F = I.getSnapshotBeforeUpdate(c.elementType === c.type ? E : lg(c.type, E), D);
              {
                var G = Aae;
                F === void 0 && !G.has(c.type) && (G.add(c.type), a("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", jn(c)));
              }
              I.__reactInternalSnapshotBeforeUpdate = F;
            }
            break;
          }
          case h: {
            {
              var J = c.stateNode;
              i7(J.containerInfo);
            }
            break;
          }
          case g:
          case y:
          case p:
          case W:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Do();
      }
    }
    function hg(c, d, x) {
      var E = d.updateQueue, D = E !== null ? E.lastEffect : null;
      if (D !== null) {
        var I = D.next, F = I;
        do {
          if ((F.tag & c) === c) {
            var G = F.destroy;
            F.destroy = void 0, G !== void 0 && ((c & Bu) !== sf ? t1(d) : (c & ks) !== sf && r1(d), (c & sy) !== sf && yA(!0), eI(d, x, G), (c & sy) !== sf && yA(!1), (c & Bu) !== sf ? n1() : (c & ks) !== sf && Rm());
          }
          F = F.next;
        } while (F !== I);
      }
    }
    function q1(c, d) {
      var x = d.updateQueue, E = x !== null ? x.lastEffect : null;
      if (E !== null) {
        var D = E.next, I = D;
        do {
          if ((I.tag & c) === c) {
            (c & Bu) !== sf ? Om(d) : (c & ks) !== sf && l_(d);
            var F = I.create;
            (c & sy) !== sf && yA(!0), I.destroy = F(), (c & sy) !== sf && yA(!1), (c & Bu) !== sf ? u_() : (c & ks) !== sf && A2();
            {
              var G = I.destroy;
              if (G !== void 0 && typeof G != "function") {
                var J = void 0;
                (I.tag & ks) !== cn ? J = "useLayoutEffect" : (I.tag & sy) !== cn ? J = "useInsertionEffect" : J = "useEffect";
                var le = void 0;
                G === null ? le = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof G.then == "function" ? le = `

It looks like you wrote ` + J + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + J + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : le = " You returned: " + G, a("%s must not return anything besides a function, which is used for clean-up.%s", J, le);
              }
            }
          }
          I = I.next;
        } while (I !== D);
      }
    }
    function Yje(c, d) {
      if ((d.flags & Tn) !== cn)
        switch (d.tag) {
          case O: {
            var x = d.stateNode.passiveEffectDuration, E = d.memoizedProps, D = E.id, I = E.onPostCommit, F = tae(), G = d.alternate === null ? "mount" : "update";
            eae() && (G = "nested-update"), typeof I == "function" && I(D, G, x, F);
            var J = d.return;
            e:
              for (; J !== null; ) {
                switch (J.tag) {
                  case h:
                    var le = J.stateNode;
                    le.passiveEffectDuration += x;
                    break e;
                  case O:
                    var de = J.stateNode;
                    de.passiveEffectDuration += x;
                    break e;
                }
                J = J.return;
              }
            break;
          }
        }
    }
    function Hje(c, d, x, E) {
      if ((x.flags & ls) !== cn)
        switch (x.tag) {
          case u:
          case A:
          case $: {
            if (!Yu)
              if (x.mode & pn)
                try {
                  fy(), q1(ks | Rs, x);
                } finally {
                  cy(x);
                }
              else
                q1(ks | Rs, x);
            break;
          }
          case l: {
            var D = x.stateNode;
            if (x.flags & Tn && !Yu)
              if (d === null)
                if (x.type === x.elementType && !nE && (D.props !== x.memoizedProps && a("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", jn(x) || "instance"), D.state !== x.memoizedState && a("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", jn(x) || "instance")), x.mode & pn)
                  try {
                    fy(), D.componentDidMount();
                  } finally {
                    cy(x);
                  }
                else
                  D.componentDidMount();
              else {
                var I = x.elementType === x.type ? d.memoizedProps : lg(x.type, d.memoizedProps), F = d.memoizedState;
                if (x.type === x.elementType && !nE && (D.props !== x.memoizedProps && a("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", jn(x) || "instance"), D.state !== x.memoizedState && a("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", jn(x) || "instance")), x.mode & pn)
                  try {
                    fy(), D.componentDidUpdate(I, F, D.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    cy(x);
                  }
                else
                  D.componentDidUpdate(I, F, D.__reactInternalSnapshotBeforeUpdate);
              }
            var G = x.updateQueue;
            G !== null && (x.type === x.elementType && !nE && (D.props !== x.memoizedProps && a("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", jn(x) || "instance"), D.state !== x.memoizedState && a("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", jn(x) || "instance")), poe(x, G, D));
            break;
          }
          case h: {
            var J = x.updateQueue;
            if (J !== null) {
              var le = null;
              if (x.child !== null)
                switch (x.child.tag) {
                  case g:
                    le = x.child.stateNode;
                    break;
                  case l:
                    le = x.child.stateNode;
                    break;
                }
              poe(x, J, le);
            }
            break;
          }
          case g: {
            var de = x.stateNode;
            if (d === null && x.flags & Tn) {
              var De = x.type, Ce = x.memoizedProps;
              Q9(de, De, Ce);
            }
            break;
          }
          case y:
            break;
          case p:
            break;
          case O: {
            {
              var Ue = x.memoizedProps, Ve = Ue.onCommit, Ze = Ue.onRender, Yt = x.stateNode.effectDuration, yn = tae(), on = d === null ? "mount" : "update";
              eae() && (on = "nested-update"), typeof Ze == "function" && Ze(x.memoizedProps.id, on, x.actualDuration, x.treeBaseDuration, x.actualStartTime, yn);
              {
                typeof Ve == "function" && Ve(x.memoizedProps.id, on, Yt, yn), BLe(x);
                var Yr = x.return;
                e:
                  for (; Yr !== null; ) {
                    switch (Yr.tag) {
                      case h:
                        var Nr = Yr.stateNode;
                        Nr.effectDuration += Yt;
                        break e;
                      case O:
                        var je = Yr.stateNode;
                        je.effectDuration += Yt;
                        break e;
                    }
                    Yr = Yr.return;
                  }
              }
            }
            break;
          }
          case R: {
            Zje(c, x);
            break;
          }
          case V:
          case W:
          case ee:
          case K:
          case Q:
          case te:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Yu || x.flags & Oo && $ae(x);
    }
    function Vje(c) {
      switch (c.tag) {
        case u:
        case A:
        case $: {
          if (c.mode & pn)
            try {
              fy(), Oae(c, c.return);
            } finally {
              cy(c);
            }
          else
            Oae(c, c.return);
          break;
        }
        case l: {
          var d = c.stateNode;
          typeof d.componentDidMount == "function" && Lje(c, c.return, d), Rae(c, c.return);
          break;
        }
        case g: {
          Rae(c, c.return);
          break;
        }
      }
    }
    function Wje(c, d) {
      for (var x = null, E = c; ; ) {
        if (E.tag === g) {
          if (x === null) {
            x = E;
            try {
              var D = E.stateNode;
              d ? RD(D) : n7(E.stateNode, E.memoizedProps);
            } catch (F) {
              _o(c, c.return, F);
            }
          }
        } else if (E.tag === y) {
          if (x === null)
            try {
              var I = E.stateNode;
              d ? t7(I) : r7(I, E.memoizedProps);
            } catch (F) {
              _o(c, c.return, F);
            }
        } else if (!((E.tag === K || E.tag === Q) && E.memoizedState !== null && E !== c)) {
          if (E.child !== null) {
            E.child.return = E, E = E.child;
            continue;
          }
        }
        if (E === c)
          return;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === c)
            return;
          x === E && (x = null), E = E.return;
        }
        x === E && (x = null), E.sibling.return = E.return, E = E.sibling;
      }
    }
    function $ae(c) {
      var d = c.ref;
      if (d !== null) {
        var x = c.stateNode, E;
        switch (c.tag) {
          case g:
            E = x;
            break;
          default:
            E = x;
        }
        if (typeof d == "function") {
          var D;
          if (c.mode & pn)
            try {
              fy(), D = d(E);
            } finally {
              cy(c);
            }
          else
            D = d(E);
          typeof D == "function" && a("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", jn(c));
        } else
          d.hasOwnProperty("current") || a("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", jn(c)), d.current = E;
      }
    }
    function qje(c) {
      var d = c.alternate;
      d !== null && (d.return = null), c.return = null;
    }
    function Pae(c) {
      var d = c.alternate;
      d !== null && (c.alternate = null, Pae(d));
      {
        if (c.child = null, c.deletions = null, c.sibling = null, c.tag === g) {
          var x = c.stateNode;
          x !== null && ve(x);
        }
        c.stateNode = null, c._debugOwner = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
      }
    }
    function Gje(c) {
      for (var d = c.return; d !== null; ) {
        if (Iae(d))
          return d;
        d = d.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Iae(c) {
      return c.tag === g || c.tag === h || c.tag === p;
    }
    function jae(c) {
      var d = c;
      e:
        for (; ; ) {
          for (; d.sibling === null; ) {
            if (d.return === null || Iae(d.return))
              return null;
            d = d.return;
          }
          for (d.sibling.return = d.return, d = d.sibling; d.tag !== g && d.tag !== y && d.tag !== Y; ) {
            if (d.flags & no || d.child === null || d.tag === p)
              continue e;
            d.child.return = d, d = d.child;
          }
          if (!(d.flags & no))
            return d.stateNode;
        }
    }
    function Qje(c) {
      var d = Gje(c);
      switch (d.tag) {
        case g: {
          var x = d.stateNode;
          d.flags & ai && (DD(x), d.flags &= ~ai);
          var E = jae(c);
          dU(c, E, x);
          break;
        }
        case h:
        case p: {
          var D = d.stateNode.containerInfo, I = jae(c);
          fU(c, I, D);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function fU(c, d, x) {
      var E = c.tag, D = E === g || E === y;
      if (D) {
        var I = c.stateNode;
        d ? AD(x, I, d) : K9(x, I);
      } else if (E !== p) {
        var F = c.child;
        if (F !== null) {
          fU(F, d, x);
          for (var G = F.sibling; G !== null; )
            fU(G, d, x), G = G.sibling;
        }
      }
    }
    function dU(c, d, x) {
      var E = c.tag, D = E === g || E === y;
      if (D) {
        var I = c.stateNode;
        d ? Z9(x, I, d) : X9(x, I);
      } else if (E !== p) {
        var F = c.child;
        if (F !== null) {
          dU(F, d, x);
          for (var G = F.sibling; G !== null; )
            dU(G, d, x), G = G.sibling;
        }
      }
    }
    var Hu = null, pg = !1;
    function Xje(c, d, x) {
      {
        var E = d;
        e:
          for (; E !== null; ) {
            switch (E.tag) {
              case g: {
                Hu = E.stateNode, pg = !1;
                break e;
              }
              case h: {
                Hu = E.stateNode.containerInfo, pg = !0;
                break e;
              }
              case p: {
                Hu = E.stateNode.containerInfo, pg = !0;
                break e;
              }
            }
            E = E.return;
          }
        if (Hu === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        Lae(c, d, x), Hu = null, pg = !1;
      }
      qje(x);
    }
    function G1(c, d, x) {
      for (var E = x.child; E !== null; )
        Lae(c, d, E), E = E.sibling;
    }
    function Lae(c, d, x) {
      switch (s_(x), x.tag) {
        case g:
          Yu || wM(x, d);
        case y: {
          {
            var E = Hu, D = pg;
            Hu = null, G1(c, d, x), Hu = E, pg = D, Hu !== null && (pg ? e7(Hu, x.stateNode) : J9(Hu, x.stateNode));
          }
          return;
        }
        case Y: {
          Hu !== null && (pg ? Tl(Hu, x.stateNode) : OD(Hu, x.stateNode));
          return;
        }
        case p: {
          {
            var I = Hu, F = pg;
            Hu = x.stateNode.containerInfo, pg = !0, G1(c, d, x), Hu = I, pg = F;
          }
          return;
        }
        case u:
        case A:
        case j:
        case $: {
          if (!Yu) {
            var G = x.updateQueue;
            if (G !== null) {
              var J = G.lastEffect;
              if (J !== null) {
                var le = J.next, de = le;
                do {
                  var De = de, Ce = De.destroy, Ue = De.tag;
                  Ce !== void 0 && ((Ue & sy) !== sf ? eI(x, d, Ce) : (Ue & ks) !== sf && (r1(x), x.mode & pn ? (fy(), eI(x, d, Ce), cy(x)) : eI(x, d, Ce), Rm())), de = de.next;
                } while (de !== le);
              }
            }
          }
          G1(c, d, x);
          return;
        }
        case l: {
          if (!Yu) {
            wM(x, d);
            var Ve = x.stateNode;
            typeof Ve.componentWillUnmount == "function" && cU(x, d, Ve);
          }
          G1(c, d, x);
          return;
        }
        case ee: {
          G1(c, d, x);
          return;
        }
        case K: {
          if (
            // TODO: Remove this dead flag
            x.mode & fr
          ) {
            var Ze = Yu;
            Yu = Ze || x.memoizedState !== null, G1(c, d, x), Yu = Ze;
          } else
            G1(c, d, x);
          break;
        }
        default: {
          G1(c, d, x);
          return;
        }
      }
    }
    function Kje(c) {
      c.memoizedState;
    }
    function Zje(c, d) {
      var x = d.memoizedState;
      if (x === null) {
        var E = d.alternate;
        if (E !== null) {
          var D = E.memoizedState;
          if (D !== null) {
            var I = D.dehydrated;
            I !== null && p7(I);
          }
        }
      }
    }
    function zae(c) {
      var d = c.updateQueue;
      if (d !== null) {
        c.updateQueue = null;
        var x = c.stateNode;
        x === null && (x = c.stateNode = new Pje()), d.forEach(function(E) {
          var D = GLe.bind(null, c, E);
          if (!x.has(E)) {
            if (x.add(E), bo)
              if (bM !== null && xM !== null)
                mA(xM, bM);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            E.then(D, D);
          }
        });
      }
    }
    function Jje(c, d, x) {
      bM = x, xM = c, ii(d), Fae(d, c), ii(d), bM = null, xM = null;
    }
    function gg(c, d, x) {
      var E = d.deletions;
      if (E !== null)
        for (var D = 0; D < E.length; D++) {
          var I = E[D];
          try {
            Xje(c, d, I);
          } catch (J) {
            _o(I, d, J);
          }
        }
      var F = Pb();
      if (d.subtreeFlags & iu)
        for (var G = d.child; G !== null; )
          ii(G), Fae(G, c), G = G.sibling;
      ii(F);
    }
    function Fae(c, d, x) {
      var E = c.alternate, D = c.flags;
      switch (c.tag) {
        case u:
        case A:
        case j:
        case $: {
          if (gg(d, c), dy(c), D & Tn) {
            try {
              hg(sy | Rs, c, c.return), q1(sy | Rs, c);
            } catch (Ln) {
              _o(c, c.return, Ln);
            }
            if (c.mode & pn) {
              try {
                fy(), hg(ks | Rs, c, c.return);
              } catch (Ln) {
                _o(c, c.return, Ln);
              }
              cy(c);
            } else
              try {
                hg(ks | Rs, c, c.return);
              } catch (Ln) {
                _o(c, c.return, Ln);
              }
          }
          return;
        }
        case l: {
          gg(d, c), dy(c), D & Oo && E !== null && wM(E, E.return);
          return;
        }
        case g: {
          gg(d, c), dy(c), D & Oo && E !== null && wM(E, E.return);
          {
            if (c.flags & ai) {
              var I = c.stateNode;
              try {
                DD(I);
              } catch (Ln) {
                _o(c, c.return, Ln);
              }
            }
            if (D & Tn) {
              var F = c.stateNode;
              if (F != null) {
                var G = c.memoizedProps, J = E !== null ? E.memoizedProps : G, le = c.type, de = c.updateQueue;
                if (c.updateQueue = null, de !== null)
                  try {
                    ND(F, de, le, J, G, c);
                  } catch (Ln) {
                    _o(c, c.return, Ln);
                  }
              }
            }
          }
          return;
        }
        case y: {
          if (gg(d, c), dy(c), D & Tn) {
            if (c.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var De = c.stateNode, Ce = c.memoizedProps, Ue = E !== null ? E.memoizedProps : Ce;
            try {
              rP(De, Ue, Ce);
            } catch (Ln) {
              _o(c, c.return, Ln);
            }
          }
          return;
        }
        case h: {
          if (gg(d, c), dy(c), D & Tn && E !== null) {
            var Ve = E.memoizedState;
            if (Ve.isDehydrated)
              try {
                h7(d.containerInfo);
              } catch (Ln) {
                _o(c, c.return, Ln);
              }
          }
          return;
        }
        case p: {
          gg(d, c), dy(c);
          return;
        }
        case R: {
          gg(d, c), dy(c);
          var Ze = c.child;
          if (Ze.flags & dh) {
            var Yt = Ze.stateNode, yn = Ze.memoizedState, on = yn !== null;
            if (Yt.isHidden = on, on) {
              var Yr = Ze.alternate !== null && Ze.alternate.memoizedState !== null;
              Yr || kLe();
            }
          }
          if (D & Tn) {
            try {
              Kje(c);
            } catch (Ln) {
              _o(c, c.return, Ln);
            }
            zae(c);
          }
          return;
        }
        case K: {
          var Nr = E !== null && E.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            c.mode & fr
          ) {
            var je = Yu;
            Yu = je || Nr, gg(d, c), Yu = je;
          } else
            gg(d, c);
          if (dy(c), D & dh) {
            var Je = c.stateNode, Le = c.memoizedState, vt = Le !== null, Ht = c;
            if (Je.isHidden = vt, vt && !Nr && (Ht.mode & fr) !== hn) {
              Kt = Ht;
              for (var Lt = Ht.child; Lt !== null; )
                Kt = Lt, tLe(Lt), Lt = Lt.sibling;
            }
            Wje(Ht, vt);
          }
          return;
        }
        case V: {
          gg(d, c), dy(c), D & Tn && zae(c);
          return;
        }
        case ee:
          return;
        default: {
          gg(d, c), dy(c);
          return;
        }
      }
    }
    function dy(c) {
      var d = c.flags;
      if (d & no) {
        try {
          Qje(c);
        } catch (x) {
          _o(c, c.return, x);
        }
        c.flags &= ~no;
      }
      d & ml && (c.flags &= ~ml);
    }
    function eLe(c, d, x) {
      bM = x, xM = d, Kt = c, Bae(c, d, x), bM = null, xM = null;
    }
    function Bae(c, d, x) {
      for (var E = (c.mode & fr) !== hn; Kt !== null; ) {
        var D = Kt, I = D.child;
        if (D.tag === K && E) {
          var F = D.memoizedState !== null, G = F || JP;
          if (G) {
            hU(c, d, x);
            continue;
          } else {
            var J = D.alternate, le = J !== null && J.memoizedState !== null, de = le || Yu, De = JP, Ce = Yu;
            JP = G, Yu = de, Yu && !Ce && (Kt = D, nLe(D));
            for (var Ue = I; Ue !== null; )
              Kt = Ue, Bae(
                Ue,
                // New root; bubble back up to here and stop.
                d,
                x
              ), Ue = Ue.sibling;
            Kt = D, JP = De, Yu = Ce, hU(c, d, x);
            continue;
          }
        }
        (D.subtreeFlags & ls) !== cn && I !== null ? (I.return = D, Kt = I) : hU(c, d, x);
      }
    }
    function hU(c, d, x) {
      for (; Kt !== null; ) {
        var E = Kt;
        if ((E.flags & ls) !== cn) {
          var D = E.alternate;
          ii(E);
          try {
            Hje(d, D, E, x);
          } catch (F) {
            _o(E, E.return, F);
          }
          Do();
        }
        if (E === c) {
          Kt = null;
          return;
        }
        var I = E.sibling;
        if (I !== null) {
          I.return = E.return, Kt = I;
          return;
        }
        Kt = E.return;
      }
    }
    function tLe(c) {
      for (; Kt !== null; ) {
        var d = Kt, x = d.child;
        switch (d.tag) {
          case u:
          case A:
          case j:
          case $: {
            if (d.mode & pn)
              try {
                fy(), hg(ks, d, d.return);
              } finally {
                cy(d);
              }
            else
              hg(ks, d, d.return);
            break;
          }
          case l: {
            wM(d, d.return);
            var E = d.stateNode;
            typeof E.componentWillUnmount == "function" && cU(d, d.return, E);
            break;
          }
          case g: {
            wM(d, d.return);
            break;
          }
          case K: {
            var D = d.memoizedState !== null;
            if (D) {
              Uae(c);
              continue;
            }
            break;
          }
        }
        x !== null ? (x.return = d, Kt = x) : Uae(c);
      }
    }
    function Uae(c) {
      for (; Kt !== null; ) {
        var d = Kt;
        if (d === c) {
          Kt = null;
          return;
        }
        var x = d.sibling;
        if (x !== null) {
          x.return = d.return, Kt = x;
          return;
        }
        Kt = d.return;
      }
    }
    function nLe(c) {
      for (; Kt !== null; ) {
        var d = Kt, x = d.child;
        if (d.tag === K) {
          var E = d.memoizedState !== null;
          if (E) {
            Yae(c);
            continue;
          }
        }
        x !== null ? (x.return = d, Kt = x) : Yae(c);
      }
    }
    function Yae(c) {
      for (; Kt !== null; ) {
        var d = Kt;
        ii(d);
        try {
          Vje(d);
        } catch (E) {
          _o(d, d.return, E);
        }
        if (Do(), d === c) {
          Kt = null;
          return;
        }
        var x = d.sibling;
        if (x !== null) {
          x.return = d.return, Kt = x;
          return;
        }
        Kt = d.return;
      }
    }
    function rLe(c, d, x, E) {
      Kt = d, iLe(d, c, x, E);
    }
    function iLe(c, d, x, E) {
      for (; Kt !== null; ) {
        var D = Kt, I = D.child;
        (D.subtreeFlags & vl) !== cn && I !== null ? (I.return = D, Kt = I) : oLe(c, d, x, E);
      }
    }
    function oLe(c, d, x, E) {
      for (; Kt !== null; ) {
        var D = Kt;
        if ((D.flags & ao) !== cn) {
          ii(D);
          try {
            aLe(d, D, x, E);
          } catch (F) {
            _o(D, D.return, F);
          }
          Do();
        }
        if (D === c) {
          Kt = null;
          return;
        }
        var I = D.sibling;
        if (I !== null) {
          I.return = D.return, Kt = I;
          return;
        }
        Kt = D.return;
      }
    }
    function aLe(c, d, x, E) {
      switch (d.tag) {
        case u:
        case A:
        case $: {
          if (d.mode & pn) {
            HB();
            try {
              q1(Bu | Rs, d);
            } finally {
              YB(d);
            }
          } else
            q1(Bu | Rs, d);
          break;
        }
      }
    }
    function sLe(c) {
      Kt = c, uLe();
    }
    function uLe() {
      for (; Kt !== null; ) {
        var c = Kt, d = c.child;
        if ((Kt.flags & Jr) !== cn) {
          var x = c.deletions;
          if (x !== null) {
            for (var E = 0; E < x.length; E++) {
              var D = x[E];
              Kt = D, fLe(D, c);
            }
            {
              var I = c.alternate;
              if (I !== null) {
                var F = I.child;
                if (F !== null) {
                  I.child = null;
                  do {
                    var G = F.sibling;
                    F.sibling = null, F = G;
                  } while (F !== null);
                }
              }
            }
            Kt = c;
          }
        }
        (c.subtreeFlags & vl) !== cn && d !== null ? (d.return = c, Kt = d) : lLe();
      }
    }
    function lLe() {
      for (; Kt !== null; ) {
        var c = Kt;
        (c.flags & ao) !== cn && (ii(c), cLe(c), Do());
        var d = c.sibling;
        if (d !== null) {
          d.return = c.return, Kt = d;
          return;
        }
        Kt = c.return;
      }
    }
    function cLe(c) {
      switch (c.tag) {
        case u:
        case A:
        case $: {
          c.mode & pn ? (HB(), hg(Bu | Rs, c, c.return), YB(c)) : hg(Bu | Rs, c, c.return);
          break;
        }
      }
    }
    function fLe(c, d) {
      for (; Kt !== null; ) {
        var x = Kt;
        ii(x), hLe(x, d), Do();
        var E = x.child;
        E !== null ? (E.return = x, Kt = E) : dLe(c);
      }
    }
    function dLe(c) {
      for (; Kt !== null; ) {
        var d = Kt, x = d.sibling, E = d.return;
        if (Pae(d), d === c) {
          Kt = null;
          return;
        }
        if (x !== null) {
          x.return = E, Kt = x;
          return;
        }
        Kt = E;
      }
    }
    function hLe(c, d) {
      switch (c.tag) {
        case u:
        case A:
        case $: {
          c.mode & pn ? (HB(), hg(Bu, c, d), YB(c)) : hg(Bu, c, d);
          break;
        }
      }
    }
    function pLe(c) {
      switch (c.tag) {
        case u:
        case A:
        case $: {
          try {
            q1(ks | Rs, c);
          } catch (x) {
            _o(c, c.return, x);
          }
          break;
        }
        case l: {
          var d = c.stateNode;
          try {
            d.componentDidMount();
          } catch (x) {
            _o(c, c.return, x);
          }
          break;
        }
      }
    }
    function gLe(c) {
      switch (c.tag) {
        case u:
        case A:
        case $: {
          try {
            q1(Bu | Rs, c);
          } catch (d) {
            _o(c, c.return, d);
          }
          break;
        }
      }
    }
    function mLe(c) {
      switch (c.tag) {
        case u:
        case A:
        case $: {
          try {
            hg(ks | Rs, c, c.return);
          } catch (x) {
            _o(c, c.return, x);
          }
          break;
        }
        case l: {
          var d = c.stateNode;
          typeof d.componentWillUnmount == "function" && cU(c, c.return, d);
          break;
        }
      }
    }
    function yLe(c) {
      switch (c.tag) {
        case u:
        case A:
        case $:
          try {
            hg(Bu | Rs, c, c.return);
          } catch (d) {
            _o(c, c.return, d);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var oA = Symbol.for;
      oA("selector.component"), oA("selector.has_pseudo_class"), oA("selector.role"), oA("selector.test_id"), oA("selector.text");
    }
    var vLe = [];
    function bLe() {
      vLe.forEach(function(c) {
        return c();
      });
    }
    var xLe = n.ReactCurrentActQueue;
    function wLe(c) {
      {
        var d = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), x = typeof jest < "u";
        return x && d !== !1;
      }
    }
    function Hae() {
      {
        var c = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !c && xLe.current !== null && a("The current testing environment is not configured to support act(...)"), c;
      }
    }
    var _Le = Math.ceil, pU = n.ReactCurrentDispatcher, gU = n.ReactCurrentOwner, Vu = n.ReactCurrentBatchConfig, mg = n.ReactCurrentActQueue, Is = (
      /*             */
      0
    ), Vae = (
      /*               */
      1
    ), Wu = (
      /*                */
      2
    ), Hh = (
      /*                */
      4
    ), b0 = 0, aA = 1, rE = 2, tI = 3, sA = 4, Wae = 5, mU = 6, Ur = Is, dc = null, ya = null, js = Xe, hy = Xe, yU = lu(Xe), Ls = b0, uA = null, nI = Xe, lA = Xe, rI = Xe, cA = null, uf = null, vU = 0, qae = 500, Gae = 1 / 0, ELe = 500, x0 = null;
    function fA() {
      Gae = Pi() + ELe;
    }
    function Qae() {
      return Gae;
    }
    var iI = !1, bU = null, _M = null, iE = !1, Q1 = null, dA = Xe, xU = [], wU = null, SLe = 50, hA = 0, _U = null, EU = !1, oI = !1, MLe = 50, EM = 0, aI = null, pA = si, sI = Xe, Xae = !1;
    function uI() {
      return dc;
    }
    function hc() {
      return (Ur & (Wu | Hh)) !== Is ? Pi() : (pA !== si || (pA = Pi()), pA);
    }
    function X1(c) {
      var d = c.mode;
      if ((d & fr) === hn)
        return En;
      if ((Ur & Wu) !== Is && js !== Xe)
        return ha(js);
      var x = w3e() !== x3e;
      if (x) {
        if (Vu.transition !== null) {
          var E = Vu.transition;
          E._updatedFibers || (E._updatedFibers = /* @__PURE__ */ new Set()), E._updatedFibers.add(c);
        }
        return sI === Er && (sI = Fm()), sI;
      }
      var D = Ru();
      if (D !== Er)
        return D;
      var I = V9();
      return I;
    }
    function TLe(c) {
      var d = c.mode;
      return (d & fr) === hn ? En : k2();
    }
    function zs(c, d, x, E) {
      XLe(), Xae && a("useInsertionEffect must not schedule updates."), EU && (oI = !0), ld(c, x, E), (Ur & Wu) !== Xe && c === dc ? JLe(d) : (bo && Kv(c, d, x), e5e(d), c === dc && ((Ur & Wu) === Is && (lA = Gn(lA, x)), Ls === sA && K1(c, js)), lf(c, E), x === En && Ur === Is && (d.mode & fr) === hn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !mg.isBatchingLegacy && (fA(), Qie()));
    }
    function CLe(c, d, x) {
      var E = c.current;
      E.lanes = d, ld(c, d, x), lf(c, x);
    }
    function NLe(c) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Ur & Wu) !== Is
      );
    }
    function lf(c, d) {
      var x = c.callbackNode;
      Gv(c, d);
      var E = qv(c, c === dc ? js : Xe);
      if (E === Xe) {
        x !== null && dse(x), c.callbackNode = null, c.callbackPriority = Er;
        return;
      }
      var D = Ro(E), I = c.callbackPriority;
      if (I === D && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(mg.current !== null && x !== AU)) {
        x == null && I !== En && a("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      x != null && dse(x);
      var F;
      if (D === En)
        c.tag === z1 ? (mg.isBatchingLegacy !== null && (mg.didScheduleLegacyUpdate = !0), r3e(Jae.bind(null, c))) : Gie(Jae.bind(null, c)), mg.current !== null ? mg.current.push(F1) : q9(function() {
          (Ur & (Wu | Hh)) === Is && F1();
        }), F = null;
      else {
        var G;
        switch (ku(E)) {
          case Ta:
            G = Iv;
            break;
          case Ca:
            G = Au;
            break;
          case ho:
            G = Ou;
            break;
          case Zv:
            G = Jf;
            break;
          default:
            G = Ou;
            break;
        }
        F = OU(G, Kae.bind(null, c));
      }
      c.callbackPriority = D, c.callbackNode = F;
    }
    function Kae(c, d) {
      if (X3e(), pA = si, sI = Xe, (Ur & (Wu | Hh)) !== Is)
        throw new Error("Should not already be working.");
      var x = c.callbackNode, E = _0();
      if (E && c.callbackNode !== x)
        return null;
      var D = qv(c, c === dc ? js : Xe);
      if (D === Xe)
        return null;
      var I = !Th(c, D) && !R2(c, D) && !d, F = I ? LLe(c, D) : cI(c, D);
      if (F !== b0) {
        if (F === rE) {
          var G = l1(c);
          G !== Xe && (D = G, F = SU(c, G));
        }
        if (F === aA) {
          var J = uA;
          throw oE(c, Xe), K1(c, D), lf(c, Pi()), J;
        }
        if (F === mU)
          K1(c, D);
        else {
          var le = !Th(c, D), de = c.current.alternate;
          if (le && !ALe(de)) {
            if (F = cI(c, D), F === rE) {
              var De = l1(c);
              De !== Xe && (D = De, F = SU(c, De));
            }
            if (F === aA) {
              var Ce = uA;
              throw oE(c, Xe), K1(c, D), lf(c, Pi()), Ce;
            }
          }
          c.finishedWork = de, c.finishedLanes = D, DLe(c, F, D);
        }
      }
      return lf(c, Pi()), c.callbackNode === x ? Kae.bind(null, c) : null;
    }
    function SU(c, d) {
      var x = cA;
      if (Fr(c)) {
        var E = oE(c, d);
        E.flags |= Ao, C7(c.containerInfo);
      }
      var D = cI(c, d);
      if (D !== rE) {
        var I = uf;
        uf = x, I !== null && Zae(I);
      }
      return D;
    }
    function Zae(c) {
      uf === null ? uf = c : uf.push.apply(uf, c);
    }
    function DLe(c, d, x) {
      switch (d) {
        case b0:
        case aA:
          throw new Error("Root did not complete. This is a bug in React.");
        case rE: {
          aE(c, uf, x0);
          break;
        }
        case tI: {
          if (K1(c, x), Qv(x) && // do not delay if we're inside an act() scope
          !hse()) {
            var E = vU + qae - Pi();
            if (E > 10) {
              var D = qv(c, Xe);
              if (D !== Xe)
                break;
              var I = c.suspendedLanes;
              if (!Ch(I, x)) {
                hc(), Um(c, I);
                break;
              }
              c.timeoutHandle = TD(aE.bind(null, c, uf, x0), E);
              break;
            }
          }
          aE(c, uf, x0);
          break;
        }
        case sA: {
          if (K1(c, x), f1(x))
            break;
          if (!hse()) {
            var F = d_(c, x), G = F, J = Pi() - G, le = QLe(J) - J;
            if (le > 10) {
              c.timeoutHandle = TD(aE.bind(null, c, uf, x0), le);
              break;
            }
          }
          aE(c, uf, x0);
          break;
        }
        case Wae: {
          aE(c, uf, x0);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function ALe(c) {
      for (var d = c; ; ) {
        if (d.flags & kv) {
          var x = d.updateQueue;
          if (x !== null) {
            var E = x.stores;
            if (E !== null)
              for (var D = 0; D < E.length; D++) {
                var I = E[D], F = I.getSnapshot, G = I.value;
                try {
                  if (!Wt(F(), G))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var J = d.child;
        if (d.subtreeFlags & kv && J !== null) {
          J.return = d, d = J;
          continue;
        }
        if (d === c)
          return !0;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === c)
            return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !0;
    }
    function K1(c, d) {
      d = Xp(d, rI), d = Xp(d, lA), Xv(c, d);
    }
    function Jae(c) {
      if (K3e(), (Ur & (Wu | Hh)) !== Is)
        throw new Error("Should not already be working.");
      _0();
      var d = qv(c, Xe);
      if (!Ns(d, En))
        return lf(c, Pi()), null;
      var x = cI(c, d);
      if (c.tag !== z1 && x === rE) {
        var E = l1(c);
        E !== Xe && (d = E, x = SU(c, E));
      }
      if (x === aA) {
        var D = uA;
        throw oE(c, Xe), K1(c, d), lf(c, Pi()), D;
      }
      if (x === mU)
        throw new Error("Root did not complete. This is a bug in React.");
      var I = c.current.alternate;
      return c.finishedWork = I, c.finishedLanes = d, aE(c, uf, x0), lf(c, Pi()), null;
    }
    function OLe(c, d) {
      d !== Xe && (un(c, Gn(d, En)), lf(c, Pi()), (Ur & (Wu | Hh)) === Is && (fA(), F1()));
    }
    function MU(c, d) {
      var x = Ur;
      Ur |= Vae;
      try {
        return c(d);
      } finally {
        Ur = x, Ur === Is && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !mg.isBatchingLegacy && (fA(), Qie());
      }
    }
    function RLe(c, d, x, E, D) {
      var I = Ru(), F = Vu.transition;
      try {
        return Vu.transition = null, pa(Ta), c(d, x, E, D);
      } finally {
        pa(I), Vu.transition = F, Ur === Is && fA();
      }
    }
    function w0(c) {
      Q1 !== null && Q1.tag === z1 && (Ur & (Wu | Hh)) === Is && _0();
      var d = Ur;
      Ur |= Vae;
      var x = Vu.transition, E = Ru();
      try {
        return Vu.transition = null, pa(Ta), c ? c() : void 0;
      } finally {
        pa(E), Vu.transition = x, Ur = d, (Ur & (Wu | Hh)) === Is && F1();
      }
    }
    function ese() {
      return (Ur & (Wu | Hh)) !== Is;
    }
    function lI(c, d) {
      Cl(yU, hy, c), hy = Gn(hy, d);
    }
    function TU(c) {
      hy = yU.current, Os(yU, c);
    }
    function oE(c, d) {
      c.finishedWork = null, c.finishedLanes = Xe;
      var x = c.timeoutHandle;
      if (x !== CD && (c.timeoutHandle = CD, W9(x)), ya !== null)
        for (var E = ya.return; E !== null; ) {
          var D = E.alternate;
          Dae(D, E), E = E.return;
        }
      dc = c;
      var I = sE(c.current, null);
      return ya = I, js = hy = d, Ls = b0, uA = null, nI = Xe, lA = Xe, rI = Xe, cA = null, uf = null, M3e(), ug.discardPendingWarnings(), I;
    }
    function tse(c, d) {
      do {
        var x = ya;
        try {
          if (yP(), Ooe(), Do(), gU.current = null, x === null || x.return === null) {
            Ls = aA, uA = d, ya = null;
            return;
          }
          if (Oe && x.mode & pn && QP(x, !0), Ne)
            if (Hp(), d !== null && typeof d == "object" && typeof d.then == "function") {
              var E = d;
              i1(x, E, js);
            } else
              Lv(x, d, js);
          nje(c, x.return, x, d, js), ose(x);
        } catch (D) {
          d = D, ya === x && x !== null ? (x = x.return, ya = x) : x = ya;
          continue;
        }
        return;
      } while (!0);
    }
    function nse() {
      var c = pU.current;
      return pU.current = HP, c === null ? HP : c;
    }
    function rse(c) {
      pU.current = c;
    }
    function kLe() {
      vU = Pi();
    }
    function gA(c) {
      nI = Gn(c, nI);
    }
    function $Le() {
      Ls === b0 && (Ls = tI);
    }
    function CU() {
      (Ls === b0 || Ls === tI || Ls === rE) && (Ls = sA), dc !== null && (Mh(nI) || Mh(lA)) && K1(dc, js);
    }
    function PLe(c) {
      Ls !== sA && (Ls = rE), cA === null ? cA = [c] : cA.push(c);
    }
    function ILe() {
      return Ls === b0;
    }
    function cI(c, d) {
      var x = Ur;
      Ur |= Wu;
      var E = nse();
      if (dc !== c || js !== d) {
        if (bo) {
          var D = c.memoizedUpdaters;
          D.size > 0 && (mA(c, js), D.clear()), ef(c, d);
        }
        x0 = p_(), oE(c, d);
      }
      xl(d);
      do
        try {
          jLe();
          break;
        } catch (I) {
          tse(c, I);
        }
      while (!0);
      if (yP(), Ur = x, rse(E), ya !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return $m(), dc = null, js = Xe, Ls;
    }
    function jLe() {
      for (; ya !== null; )
        ise(ya);
    }
    function LLe(c, d) {
      var x = Ur;
      Ur |= Wu;
      var E = nse();
      if (dc !== c || js !== d) {
        if (bo) {
          var D = c.memoizedUpdaters;
          D.size > 0 && (mA(c, js), D.clear()), ef(c, d);
        }
        x0 = p_(), fA(), oE(c, d);
      }
      xl(d);
      do
        try {
          zLe();
          break;
        } catch (I) {
          tse(c, I);
        }
      while (!0);
      return yP(), rse(E), Ur = x, ya !== null ? (bh(), b0) : ($m(), dc = null, js = Xe, Ls);
    }
    function zLe() {
      for (; ya !== null && !Pv(); )
        ise(ya);
    }
    function ise(c) {
      var d = c.alternate;
      ii(c);
      var x;
      (c.mode & pn) !== hn ? (UB(c), x = NU(d, c, hy), QP(c, !0)) : x = NU(d, c, hy), Do(), c.memoizedProps = c.pendingProps, x === null ? ose(c) : ya = x, gU.current = null;
    }
    function ose(c) {
      var d = c;
      do {
        var x = d.alternate, E = d.return;
        if ((d.flags & Nu) === cn) {
          ii(d);
          var D = void 0;
          if ((d.mode & pn) === hn ? D = Nae(x, d, hy) : (UB(d), D = Nae(x, d, hy), QP(d, !1)), Do(), D !== null) {
            ya = D;
            return;
          }
        } else {
          var I = $je(x, d);
          if (I !== null) {
            I.flags &= N2, ya = I;
            return;
          }
          if ((d.mode & pn) !== hn) {
            QP(d, !1);
            for (var F = d.actualDuration, G = d.child; G !== null; )
              F += G.actualDuration, G = G.sibling;
            d.actualDuration = F;
          }
          if (E !== null)
            E.flags |= Nu, E.subtreeFlags = cn, E.deletions = null;
          else {
            Ls = mU, ya = null;
            return;
          }
        }
        var J = d.sibling;
        if (J !== null) {
          ya = J;
          return;
        }
        d = E, ya = d;
      } while (d !== null);
      Ls === b0 && (Ls = Wae);
    }
    function aE(c, d, x) {
      var E = Ru(), D = Vu.transition;
      try {
        Vu.transition = null, pa(Ta), FLe(c, d, x, E);
      } finally {
        Vu.transition = D, pa(E);
      }
      return null;
    }
    function FLe(c, d, x, E) {
      do
        _0();
      while (Q1 !== null);
      if (KLe(), (Ur & (Wu | Hh)) !== Is)
        throw new Error("Should not already be working.");
      var D = c.finishedWork, I = c.finishedLanes;
      if (mh(I), D === null)
        return e1(), null;
      if (I === Xe && a("root.finishedLanes should not be empty during a commit. This is a bug in React."), c.finishedWork = null, c.finishedLanes = Xe, D === c.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      c.callbackNode = null, c.callbackPriority = Er;
      var F = Gn(D.lanes, D.childLanes);
      Nh(c, F), c === dc && (dc = null, ya = null, js = Xe), ((D.subtreeFlags & vl) !== cn || (D.flags & vl) !== cn) && (iE || (iE = !0, wU = x, OU(Ou, function() {
        return _0(), null;
      })));
      var G = (D.subtreeFlags & (Dm | iu | ls | vl)) !== cn, J = (D.flags & (Dm | iu | ls | vl)) !== cn;
      if (G || J) {
        var le = Vu.transition;
        Vu.transition = null;
        var de = Ru();
        pa(Ta);
        var De = Ur;
        Ur |= Hh, gU.current = null, zje(c, D), nae(), Jje(c, D, I), z9(c.containerInfo), c.current = D, O2(I), eLe(D, c, I), vh(), a_(), Ur = De, pa(de), Vu.transition = le;
      } else
        c.current = D, nae();
      var Ce = iE;
      if (iE ? (iE = !1, Q1 = c, dA = I) : (EM = 0, aI = null), F = c.pendingLanes, F === Xe && (_M = null), Ce || lse(c.current, !1), oc(D.stateNode, E), bo && c.memoizedUpdaters.clear(), bLe(), lf(c, Pi()), d !== null)
        for (var Ue = c.onRecoverableError, Ve = 0; Ve < d.length; Ve++) {
          var Ze = d[Ve], Yt = Ze.stack, yn = Ze.digest;
          Ue(Ze.value, {
            componentStack: Yt,
            digest: yn
          });
        }
      if (iI) {
        iI = !1;
        var on = bU;
        throw bU = null, on;
      }
      return Ns(dA, En) && c.tag !== z1 && _0(), F = c.pendingLanes, Ns(F, En) ? (Q3e(), c === _U ? hA++ : (hA = 0, _U = c)) : hA = 0, F1(), e1(), null;
    }
    function _0() {
      if (Q1 !== null) {
        var c = ku(dA), d = eD(ho, c), x = Vu.transition, E = Ru();
        try {
          return Vu.transition = null, pa(d), ULe();
        } finally {
          pa(E), Vu.transition = x;
        }
      }
      return !1;
    }
    function BLe(c) {
      xU.push(c), iE || (iE = !0, OU(Ou, function() {
        return _0(), null;
      }));
    }
    function ULe() {
      if (Q1 === null)
        return !1;
      var c = wU;
      wU = null;
      var d = Q1, x = dA;
      if (Q1 = null, dA = Xe, (Ur & (Wu | Hh)) !== Is)
        throw new Error("Cannot flush passive effects while already rendering.");
      EU = !0, oI = !1, c_(x);
      var E = Ur;
      Ur |= Hh, sLe(d.current), rLe(d, d.current, x, c);
      {
        var D = xU;
        xU = [];
        for (var I = 0; I < D.length; I++) {
          var F = D[I];
          Yje(d, F);
        }
      }
      km(), lse(d.current, !0), Ur = E, F1(), oI ? d === aI ? EM++ : (EM = 0, aI = d) : EM = 0, EU = !1, oI = !1, ph(d);
      {
        var G = d.current.stateNode;
        G.effectDuration = 0, G.passiveEffectDuration = 0;
      }
      return !0;
    }
    function ase(c) {
      return _M !== null && _M.has(c);
    }
    function YLe(c) {
      _M === null ? _M = /* @__PURE__ */ new Set([c]) : _M.add(c);
    }
    function HLe(c) {
      iI || (iI = !0, bU = c);
    }
    var VLe = HLe;
    function sse(c, d, x) {
      var E = tE(x, d), D = iae(c, E, En), I = U1(c, D, En), F = hc();
      I !== null && (ld(I, En, F), lf(I, F));
    }
    function _o(c, d, x) {
      if (Ije(x), yA(!1), c.tag === h) {
        sse(c, c, x);
        return;
      }
      var E = null;
      for (E = d; E !== null; ) {
        if (E.tag === h) {
          sse(E, c, x);
          return;
        } else if (E.tag === l) {
          var D = E.type, I = E.stateNode;
          if (typeof D.getDerivedStateFromError == "function" || typeof I.componentDidCatch == "function" && !ase(I)) {
            var F = tE(x, c), G = GB(E, F, En), J = U1(E, G, En), le = hc();
            J !== null && (ld(J, En, le), lf(J, le));
            return;
          }
        }
        E = E.return;
      }
      a(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, x);
    }
    function WLe(c, d, x) {
      var E = c.pingCache;
      E !== null && E.delete(d);
      var D = hc();
      Um(c, x), t5e(c), dc === c && Ch(js, x) && (Ls === sA || Ls === tI && Qv(js) && Pi() - vU < qae ? oE(c, Xe) : rI = Gn(rI, x)), lf(c, D);
    }
    function use(c, d) {
      d === Er && (d = TLe(c));
      var x = hc(), E = af(c, d);
      E !== null && (ld(E, d, x), lf(E, x));
    }
    function qLe(c) {
      var d = c.memoizedState, x = Er;
      d !== null && (x = d.retryLane), use(c, x);
    }
    function GLe(c, d) {
      var x = Er, E;
      switch (c.tag) {
        case R:
          E = c.stateNode;
          var D = c.memoizedState;
          D !== null && (x = D.retryLane);
          break;
        case V:
          E = c.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      E !== null && E.delete(d), use(c, x);
    }
    function QLe(c) {
      return c < 120 ? 120 : c < 480 ? 480 : c < 1080 ? 1080 : c < 1920 ? 1920 : c < 3e3 ? 3e3 : c < 4320 ? 4320 : _Le(c / 1960) * 1960;
    }
    function XLe() {
      if (hA > SLe)
        throw hA = 0, _U = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      EM > MLe && (EM = 0, aI = null, a("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function KLe() {
      ug.flushLegacyContextWarning(), ug.flushPendingUnsafeLifecycleWarnings();
    }
    function lse(c, d) {
      ii(c), fI(c, so, mLe), d && fI(c, Up, yLe), fI(c, so, pLe), d && fI(c, Up, gLe), Do();
    }
    function fI(c, d, x) {
      for (var E = c, D = null; E !== null; ) {
        var I = E.subtreeFlags & d;
        E !== D && E.child !== null && I !== cn ? E = E.child : ((E.flags & d) !== cn && x(E), E.sibling !== null ? E = E.sibling : E = D = E.return);
      }
    }
    var dI = null;
    function cse(c) {
      {
        if ((Ur & Wu) !== Is || !(c.mode & fr))
          return;
        var d = c.tag;
        if (d !== f && d !== h && d !== l && d !== u && d !== A && d !== j && d !== $)
          return;
        var x = jn(c) || "ReactComponent";
        if (dI !== null) {
          if (dI.has(x))
            return;
          dI.add(x);
        } else
          dI = /* @__PURE__ */ new Set([x]);
        var E = vo;
        try {
          ii(c), a("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          E ? ii(c) : Do();
        }
      }
    }
    var NU;
    {
      var ZLe = null;
      NU = function(c, d, x) {
        var E = vse(ZLe, d);
        try {
          return Eae(c, d, x);
        } catch (I) {
          if (f3e() || I !== null && typeof I == "object" && typeof I.then == "function")
            throw I;
          if (yP(), Ooe(), Dae(c, d), vse(d, E), d.mode & pn && UB(d), qc(null, Eae, null, c, d, x), ue()) {
            var D = ch();
            typeof D == "object" && D !== null && D._suppressLogging && typeof I == "object" && I !== null && !I._suppressLogging && (I._suppressLogging = !0);
          }
          throw I;
        }
      };
    }
    var fse = !1, DU;
    DU = /* @__PURE__ */ new Set();
    function JLe(c) {
      if (Js && !W3e())
        switch (c.tag) {
          case u:
          case A:
          case $: {
            var d = ya && jn(ya) || "Unknown", x = d;
            if (!DU.has(x)) {
              DU.add(x);
              var E = jn(c) || "Unknown";
              a("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", E, d, d);
            }
            break;
          }
          case l: {
            fse || (a("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), fse = !0);
            break;
          }
        }
    }
    function mA(c, d) {
      if (bo) {
        var x = c.memoizedUpdaters;
        x.forEach(function(E) {
          Kv(c, E, d);
        });
      }
    }
    var AU = {};
    function OU(c, d) {
      {
        var x = mg.current;
        return x !== null ? (x.push(d), AU) : Cs(c, d);
      }
    }
    function dse(c) {
      if (c !== AU)
        return D2(c);
    }
    function hse() {
      return mg.current !== null;
    }
    function e5e(c) {
      {
        if (c.mode & fr) {
          if (!Hae())
            return;
        } else if (!wLe() || Ur !== Is || c.tag !== u && c.tag !== A && c.tag !== $)
          return;
        if (mg.current === null) {
          var d = vo;
          try {
            ii(c), a(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, jn(c));
          } finally {
            d ? ii(c) : Do();
          }
        }
      }
    }
    function t5e(c) {
      c.tag !== z1 && Hae() && mg.current === null && a(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function yA(c) {
      Xae = c;
    }
    var Vh = null, SM = null, n5e = function(c) {
      Vh = c;
    };
    function MM(c) {
      {
        if (Vh === null)
          return c;
        var d = Vh(c);
        return d === void 0 ? c : d.current;
      }
    }
    function RU(c) {
      return MM(c);
    }
    function kU(c) {
      {
        if (Vh === null)
          return c;
        var d = Vh(c);
        if (d === void 0) {
          if (c != null && typeof c.render == "function") {
            var x = MM(c.render);
            if (c.render !== x) {
              var E = {
                $$typeof: $t,
                render: x
              };
              return c.displayName !== void 0 && (E.displayName = c.displayName), E;
            }
          }
          return c;
        }
        return d.current;
      }
    }
    function pse(c, d) {
      {
        if (Vh === null)
          return !1;
        var x = c.elementType, E = d.type, D = !1, I = typeof E == "object" && E !== null ? E.$$typeof : null;
        switch (c.tag) {
          case l: {
            typeof E == "function" && (D = !0);
            break;
          }
          case u: {
            (typeof E == "function" || I === sn) && (D = !0);
            break;
          }
          case A: {
            (I === $t || I === sn) && (D = !0);
            break;
          }
          case j:
          case $: {
            (I === zn || I === sn) && (D = !0);
            break;
          }
          default:
            return !1;
        }
        if (D) {
          var F = Vh(x);
          if (F !== void 0 && F === Vh(E))
            return !0;
        }
        return !1;
      }
    }
    function gse(c) {
      {
        if (Vh === null || typeof WeakSet != "function")
          return;
        SM === null && (SM = /* @__PURE__ */ new WeakSet()), SM.add(c);
      }
    }
    var r5e = function(c, d) {
      {
        if (Vh === null)
          return;
        var x = d.staleFamilies, E = d.updatedFamilies;
        _0(), w0(function() {
          $U(c.current, E, x);
        });
      }
    }, i5e = function(c, d) {
      {
        if (c.context !== hd)
          return;
        _0(), w0(function() {
          vA(d, c, null, null);
        });
      }
    };
    function $U(c, d, x) {
      {
        var E = c.alternate, D = c.child, I = c.sibling, F = c.tag, G = c.type, J = null;
        switch (F) {
          case u:
          case $:
          case l:
            J = G;
            break;
          case A:
            J = G.render;
            break;
        }
        if (Vh === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var le = !1, de = !1;
        if (J !== null) {
          var De = Vh(J);
          De !== void 0 && (x.has(De) ? de = !0 : d.has(De) && (F === l ? de = !0 : le = !0));
        }
        if (SM !== null && (SM.has(c) || E !== null && SM.has(E)) && (de = !0), de && (c._debugNeedsRemount = !0), de || le) {
          var Ce = af(c, En);
          Ce !== null && zs(Ce, c, En, si);
        }
        D !== null && !de && $U(D, d, x), I !== null && $U(I, d, x);
      }
    }
    var o5e = function(c, d) {
      {
        var x = /* @__PURE__ */ new Set(), E = new Set(d.map(function(D) {
          return D.current;
        }));
        return PU(c.current, E, x), x;
      }
    };
    function PU(c, d, x) {
      {
        var E = c.child, D = c.sibling, I = c.tag, F = c.type, G = null;
        switch (I) {
          case u:
          case $:
          case l:
            G = F;
            break;
          case A:
            G = F.render;
            break;
        }
        var J = !1;
        G !== null && d.has(G) && (J = !0), J ? a5e(c, x) : E !== null && PU(E, d, x), D !== null && PU(D, d, x);
      }
    }
    function a5e(c, d) {
      {
        var x = s5e(c, d);
        if (x)
          return;
        for (var E = c; ; ) {
          switch (E.tag) {
            case g:
              d.add(E.stateNode);
              return;
            case p:
              d.add(E.stateNode.containerInfo);
              return;
            case h:
              d.add(E.stateNode.containerInfo);
              return;
          }
          if (E.return === null)
            throw new Error("Expected to reach root first.");
          E = E.return;
        }
      }
    }
    function s5e(c, d) {
      for (var x = c, E = !1; ; ) {
        if (x.tag === g)
          E = !0, d.add(x.stateNode);
        else if (x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === c)
          return E;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === c)
            return E;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
      return !1;
    }
    var IU;
    {
      IU = !1;
      try {
        var mse = Object.preventExtensions({});
      } catch {
        IU = !0;
      }
    }
    function u5e(c, d, x, E) {
      this.tag = c, this.key = x, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = d, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = E, this.flags = cn, this.subtreeFlags = cn, this.deletions = null, this.lanes = Xe, this.childLanes = Xe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !IU && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var pd = function(c, d, x, E) {
      return new u5e(c, d, x, E);
    };
    function jU(c) {
      var d = c.prototype;
      return !!(d && d.isReactComponent);
    }
    function l5e(c) {
      return typeof c == "function" && !jU(c) && c.defaultProps === void 0;
    }
    function c5e(c) {
      if (typeof c == "function")
        return jU(c) ? l : u;
      if (c != null) {
        var d = c.$$typeof;
        if (d === $t)
          return A;
        if (d === zn)
          return j;
      }
      return f;
    }
    function sE(c, d) {
      var x = c.alternate;
      x === null ? (x = pd(c.tag, d, c.key, c.mode), x.elementType = c.elementType, x.type = c.type, x.stateNode = c.stateNode, x._debugSource = c._debugSource, x._debugOwner = c._debugOwner, x._debugHookTypes = c._debugHookTypes, x.alternate = c, c.alternate = x) : (x.pendingProps = d, x.type = c.type, x.flags = cn, x.subtreeFlags = cn, x.deletions = null, x.actualDuration = 0, x.actualStartTime = -1), x.flags = c.flags & Ma, x.childLanes = c.childLanes, x.lanes = c.lanes, x.child = c.child, x.memoizedProps = c.memoizedProps, x.memoizedState = c.memoizedState, x.updateQueue = c.updateQueue;
      var E = c.dependencies;
      switch (x.dependencies = E === null ? null : {
        lanes: E.lanes,
        firstContext: E.firstContext
      }, x.sibling = c.sibling, x.index = c.index, x.ref = c.ref, x.selfBaseDuration = c.selfBaseDuration, x.treeBaseDuration = c.treeBaseDuration, x._debugNeedsRemount = c._debugNeedsRemount, x.tag) {
        case f:
        case u:
        case $:
          x.type = MM(c.type);
          break;
        case l:
          x.type = RU(c.type);
          break;
        case A:
          x.type = kU(c.type);
          break;
      }
      return x;
    }
    function f5e(c, d) {
      c.flags &= Ma | no;
      var x = c.alternate;
      if (x === null)
        c.childLanes = Xe, c.lanes = d, c.child = null, c.subtreeFlags = cn, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null, c.selfBaseDuration = 0, c.treeBaseDuration = 0;
      else {
        c.childLanes = x.childLanes, c.lanes = x.lanes, c.child = x.child, c.subtreeFlags = cn, c.deletions = null, c.memoizedProps = x.memoizedProps, c.memoizedState = x.memoizedState, c.updateQueue = x.updateQueue, c.type = x.type;
        var E = x.dependencies;
        c.dependencies = E === null ? null : {
          lanes: E.lanes,
          firstContext: E.firstContext
        }, c.selfBaseDuration = x.selfBaseDuration, c.treeBaseDuration = x.treeBaseDuration;
      }
      return c;
    }
    function d5e(c, d, x) {
      var E;
      return c === lP ? (E = fr, d === !0 && (E |= lo, E |= au)) : E = hn, bo && (E |= pn), pd(h, null, null, E);
    }
    function LU(c, d, x, E, D, I) {
      var F = f, G = c;
      if (typeof c == "function")
        jU(c) ? (F = l, G = RU(G)) : G = MM(G);
      else if (typeof c == "string")
        F = g;
      else
        e:
          switch (c) {
            case Hi:
              return Z1(x.children, D, I, d);
            case ss:
              F = _, D |= lo, (D & fr) !== hn && (D |= au);
              break;
            case xe:
              return h5e(x, D, I, d);
            case In:
              return p5e(x, D, I, d);
            case lr:
              return g5e(x, D, I, d);
            case wi:
              return yse(x, D, I, d);
            case nn:
            case No:
            case Oi:
            case lm:
            case xi:
            default: {
              if (typeof c == "object" && c !== null)
                switch (c.$$typeof) {
                  case lt:
                    F = C;
                    break e;
                  case St:
                    F = S;
                    break e;
                  case $t:
                    F = A, G = kU(G);
                    break e;
                  case zn:
                    F = j;
                    break e;
                  case sn:
                    F = z, G = null;
                    break e;
                }
              var J = "";
              {
                (c === void 0 || typeof c == "object" && c !== null && Object.keys(c).length === 0) && (J += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var le = E ? jn(E) : null;
                le && (J += `

Check the render method of \`` + le + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (c == null ? c : typeof c) + "." + J));
            }
          }
      var de = pd(F, x, d, D);
      return de.elementType = c, de.type = G, de.lanes = I, de._debugOwner = E, de;
    }
    function zU(c, d, x) {
      var E = null;
      E = c._owner;
      var D = c.type, I = c.key, F = c.props, G = LU(D, I, F, E, d, x);
      return G._debugSource = c._source, G._debugOwner = c._owner, G;
    }
    function Z1(c, d, x, E) {
      var D = pd(b, c, E, d);
      return D.lanes = x, D;
    }
    function h5e(c, d, x, E) {
      typeof c.id != "string" && a('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof c.id);
      var D = pd(O, c, E, d | pn);
      return D.elementType = xe, D.lanes = x, D.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, D;
    }
    function p5e(c, d, x, E) {
      var D = pd(R, c, E, d);
      return D.elementType = In, D.lanes = x, D;
    }
    function g5e(c, d, x, E) {
      var D = pd(V, c, E, d);
      return D.elementType = lr, D.lanes = x, D;
    }
    function yse(c, d, x, E) {
      var D = pd(K, c, E, d);
      D.elementType = wi, D.lanes = x;
      var I = {
        isHidden: !1
      };
      return D.stateNode = I, D;
    }
    function FU(c, d, x) {
      var E = pd(y, c, null, d);
      return E.lanes = x, E;
    }
    function m5e() {
      var c = pd(g, null, null, hn);
      return c.elementType = "DELETED", c;
    }
    function y5e(c) {
      var d = pd(Y, null, null, hn);
      return d.stateNode = c, d;
    }
    function BU(c, d, x) {
      var E = c.children !== null ? c.children : [], D = pd(p, E, c.key, d);
      return D.lanes = x, D.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: c.implementation
      }, D;
    }
    function vse(c, d) {
      return c === null && (c = pd(f, null, null, hn)), c.tag = d.tag, c.key = d.key, c.elementType = d.elementType, c.type = d.type, c.stateNode = d.stateNode, c.return = d.return, c.child = d.child, c.sibling = d.sibling, c.index = d.index, c.ref = d.ref, c.pendingProps = d.pendingProps, c.memoizedProps = d.memoizedProps, c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.dependencies = d.dependencies, c.mode = d.mode, c.flags = d.flags, c.subtreeFlags = d.subtreeFlags, c.deletions = d.deletions, c.lanes = d.lanes, c.childLanes = d.childLanes, c.alternate = d.alternate, c.actualDuration = d.actualDuration, c.actualStartTime = d.actualStartTime, c.selfBaseDuration = d.selfBaseDuration, c.treeBaseDuration = d.treeBaseDuration, c._debugSource = d._debugSource, c._debugOwner = d._debugOwner, c._debugNeedsRemount = d._debugNeedsRemount, c._debugHookTypes = d._debugHookTypes, c;
    }
    function v5e(c, d, x, E, D) {
      this.tag = d, this.containerInfo = c, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = CD, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Er, this.eventTimes = Bm(Xe), this.expirationTimes = Bm(si), this.pendingLanes = Xe, this.suspendedLanes = Xe, this.pingedLanes = Xe, this.expiredLanes = Xe, this.mutableReadLanes = Xe, this.finishedLanes = Xe, this.entangledLanes = Xe, this.entanglements = Bm(Xe), this.identifierPrefix = E, this.onRecoverableError = D, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var I = this.pendingUpdatersLaneMap = [], F = 0; F < ro; F++)
          I.push(/* @__PURE__ */ new Set());
      }
      switch (d) {
        case lP:
          this._debugRootType = x ? "hydrateRoot()" : "createRoot()";
          break;
        case z1:
          this._debugRootType = x ? "hydrate()" : "render()";
          break;
      }
    }
    function bse(c, d, x, E, D, I, F, G, J, le) {
      var de = new v5e(c, d, x, G, J), De = d5e(d, I);
      de.current = De, De.stateNode = de;
      {
        var Ce = {
          element: E,
          isDehydrated: x,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        De.memoizedState = Ce;
      }
      return Q7(De), de;
    }
    var UU = "18.2.0";
    function b5e(c, d, x) {
      var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return jr(E), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: la,
        key: E == null ? null : "" + E,
        children: c,
        containerInfo: d,
        implementation: x
      };
    }
    var YU, HU;
    YU = !1, HU = {};
    function xse(c) {
      if (!c)
        return hd;
      var d = Ts(c), x = n3e(d);
      if (d.tag === l) {
        var E = d.type;
        if (ay(E))
          return Wie(d, E, x);
      }
      return x;
    }
    function x5e(c, d) {
      {
        var x = Ts(c);
        if (x === void 0) {
          if (typeof c.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var E = Object.keys(c).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + E);
        }
        var D = bl(x);
        if (D === null)
          return null;
        if (D.mode & lo) {
          var I = jn(x) || "Component";
          if (!HU[I]) {
            HU[I] = !0;
            var F = vo;
            try {
              ii(D), x.mode & lo ? a("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, I) : a("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, I);
            } finally {
              F ? ii(F) : Do();
            }
          }
        }
        return D.stateNode;
      }
    }
    function wse(c, d, x, E, D, I, F, G) {
      var J = !1, le = null;
      return bse(c, d, J, le, x, E, D, I, F);
    }
    function _se(c, d, x, E, D, I, F, G, J, le) {
      var de = !0, De = bse(x, E, de, c, D, I, F, G, J);
      De.context = xse(null);
      var Ce = De.current, Ue = hc(), Ve = X1(Ce), Ze = y0(Ue, Ve);
      return Ze.callback = d ?? null, U1(Ce, Ze, Ve), CLe(De, Ve, Ue), De;
    }
    function vA(c, d, x, E) {
      fs(d, c);
      var D = d.current, I = hc(), F = X1(D);
      xh(F);
      var G = xse(x);
      d.context === null ? d.context = G : d.pendingContext = G, Js && vo !== null && !YU && (YU = !0, a(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, jn(vo) || "Unknown"));
      var J = y0(I, F);
      J.payload = {
        element: c
      }, E = E === void 0 ? null : E, E !== null && (typeof E != "function" && a("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", E), J.callback = E);
      var le = U1(D, J, F);
      return le !== null && (zs(le, D, F, I), _P(le, D, F)), F;
    }
    function hI(c) {
      var d = c.current;
      if (!d.child)
        return null;
      switch (d.child.tag) {
        case g:
          return d.child.stateNode;
        default:
          return d.child.stateNode;
      }
    }
    function w5e(c) {
      switch (c.tag) {
        case h: {
          var d = c.stateNode;
          if (Fr(d)) {
            var x = JN(d);
            OLe(d, x);
          }
          break;
        }
        case R: {
          w0(function() {
            var D = af(c, En);
            if (D !== null) {
              var I = hc();
              zs(D, c, En, I);
            }
          });
          var E = En;
          VU(c, E);
          break;
        }
      }
    }
    function Ese(c, d) {
      var x = c.memoizedState;
      x !== null && x.dehydrated !== null && (x.retryLane = Jc(x.retryLane, d));
    }
    function VU(c, d) {
      Ese(c, d);
      var x = c.alternate;
      x && Ese(x, d);
    }
    function _5e(c) {
      if (c.tag === R) {
        var d = qp, x = af(c, d);
        if (x !== null) {
          var E = hc();
          zs(x, c, d, E);
        }
        VU(c, d);
      }
    }
    function E5e(c) {
      if (c.tag === R) {
        var d = X1(c), x = af(c, d);
        if (x !== null) {
          var E = hc();
          zs(x, c, d, E);
        }
        VU(c, d);
      }
    }
    function Sse(c) {
      var d = Kb(c);
      return d === null ? null : d.stateNode;
    }
    var Mse = function(c) {
      return null;
    };
    function S5e(c) {
      return Mse(c);
    }
    var Tse = function(c) {
      return !1;
    };
    function M5e(c) {
      return Tse(c);
    }
    var Cse = null, Nse = null, Dse = null, Ase = null, Ose = null, Rse = null, kse = null, $se = null, Pse = null;
    {
      var Ise = function(c, d, x) {
        var E = d[x], D = _r(c) ? c.slice() : cr({}, c);
        return x + 1 === d.length ? (_r(D) ? D.splice(E, 1) : delete D[E], D) : (D[E] = Ise(c[E], d, x + 1), D);
      }, jse = function(c, d) {
        return Ise(c, d, 0);
      }, Lse = function(c, d, x, E) {
        var D = d[E], I = _r(c) ? c.slice() : cr({}, c);
        if (E + 1 === d.length) {
          var F = x[E];
          I[F] = I[D], _r(I) ? I.splice(D, 1) : delete I[D];
        } else
          I[D] = Lse(
            // $FlowFixMe number or string is fine here
            c[D],
            d,
            x,
            E + 1
          );
        return I;
      }, zse = function(c, d, x) {
        if (d.length !== x.length) {
          o("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var E = 0; E < x.length - 1; E++)
            if (d[E] !== x[E]) {
              o("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return Lse(c, d, x, 0);
      }, Fse = function(c, d, x, E) {
        if (x >= d.length)
          return E;
        var D = d[x], I = _r(c) ? c.slice() : cr({}, c);
        return I[D] = Fse(c[D], d, x + 1, E), I;
      }, Bse = function(c, d, x) {
        return Fse(c, d, 0, x);
      }, WU = function(c, d) {
        for (var x = c.memoizedState; x !== null && d > 0; )
          x = x.next, d--;
        return x;
      };
      Cse = function(c, d, x, E) {
        var D = WU(c, d);
        if (D !== null) {
          var I = Bse(D.memoizedState, x, E);
          D.memoizedState = I, D.baseState = I, c.memoizedProps = cr({}, c.memoizedProps);
          var F = af(c, En);
          F !== null && zs(F, c, En, si);
        }
      }, Nse = function(c, d, x) {
        var E = WU(c, d);
        if (E !== null) {
          var D = jse(E.memoizedState, x);
          E.memoizedState = D, E.baseState = D, c.memoizedProps = cr({}, c.memoizedProps);
          var I = af(c, En);
          I !== null && zs(I, c, En, si);
        }
      }, Dse = function(c, d, x, E) {
        var D = WU(c, d);
        if (D !== null) {
          var I = zse(D.memoizedState, x, E);
          D.memoizedState = I, D.baseState = I, c.memoizedProps = cr({}, c.memoizedProps);
          var F = af(c, En);
          F !== null && zs(F, c, En, si);
        }
      }, Ase = function(c, d, x) {
        c.pendingProps = Bse(c.memoizedProps, d, x), c.alternate && (c.alternate.pendingProps = c.pendingProps);
        var E = af(c, En);
        E !== null && zs(E, c, En, si);
      }, Ose = function(c, d) {
        c.pendingProps = jse(c.memoizedProps, d), c.alternate && (c.alternate.pendingProps = c.pendingProps);
        var x = af(c, En);
        x !== null && zs(x, c, En, si);
      }, Rse = function(c, d, x) {
        c.pendingProps = zse(c.memoizedProps, d, x), c.alternate && (c.alternate.pendingProps = c.pendingProps);
        var E = af(c, En);
        E !== null && zs(E, c, En, si);
      }, kse = function(c) {
        var d = af(c, En);
        d !== null && zs(d, c, En, si);
      }, $se = function(c) {
        Mse = c;
      }, Pse = function(c) {
        Tse = c;
      };
    }
    function T5e(c) {
      var d = bl(c);
      return d === null ? null : d.stateNode;
    }
    function C5e(c) {
      return null;
    }
    function N5e() {
      return vo;
    }
    function D5e(c) {
      var d = c.findFiberByHostInstance, x = n.ReactCurrentDispatcher;
      return Jb({
        bundleType: c.bundleType,
        version: c.version,
        rendererPackageName: c.rendererPackageName,
        rendererConfig: c.rendererConfig,
        overrideHookState: Cse,
        overrideHookStateDeletePath: Nse,
        overrideHookStateRenamePath: Dse,
        overrideProps: Ase,
        overridePropsDeletePath: Ose,
        overridePropsRenamePath: Rse,
        setErrorHandler: $se,
        setSuspenseHandler: Pse,
        scheduleUpdate: kse,
        currentDispatcherRef: x,
        findHostInstanceByFiber: T5e,
        findFiberByHostInstance: d || C5e,
        // React Refresh
        findHostInstancesForRefresh: o5e,
        scheduleRefresh: r5e,
        scheduleRoot: i5e,
        setRefreshHandler: n5e,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: N5e,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: UU
      });
    }
    var Use = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(c) {
      console.error(c);
    };
    function qU(c) {
      this._internalRoot = c;
    }
    pI.prototype.render = qU.prototype.render = function(c) {
      var d = this._internalRoot;
      if (d === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? a("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : gI(arguments[1]) ? a("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && a("You passed a second argument to root.render(...) but it only accepts one argument.");
        var x = d.containerInfo;
        if (x.nodeType !== Wr) {
          var E = Sse(d.current);
          E && E.parentNode !== x && a("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      vA(c, d, null, null);
    }, pI.prototype.unmount = qU.prototype.unmount = function() {
      typeof arguments[0] == "function" && a("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var c = this._internalRoot;
      if (c !== null) {
        this._internalRoot = null;
        var d = c.containerInfo;
        ese() && a("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), w0(function() {
          vA(null, c, null, null);
        }), st(d);
      }
    };
    function A5e(c, d) {
      if (!gI(c))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      Yse(c);
      var x = !1, E = !1, D = "", I = Use;
      d != null && (d.hydrate ? o("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof d == "object" && d !== null && d.$$typeof === xa && a(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), d.unstable_strictMode === !0 && (x = !0), d.identifierPrefix !== void 0 && (D = d.identifierPrefix), d.onRecoverableError !== void 0 && (I = d.onRecoverableError), d.transitionCallbacks !== void 0 && d.transitionCallbacks);
      var F = wse(c, lP, null, x, E, D, I);
      Re(F.current, c);
      var G = c.nodeType === Wr ? c.parentNode : c;
      return j_(G), new qU(F);
    }
    function pI(c) {
      this._internalRoot = c;
    }
    function O5e(c) {
      c && w_(c);
    }
    pI.prototype.unstable_scheduleHydration = O5e;
    function R5e(c, d, x) {
      if (!gI(c))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      Yse(c), d === void 0 && a("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var E = x ?? null, D = x != null && x.hydratedSources || null, I = !1, F = !1, G = "", J = Use;
      x != null && (x.unstable_strictMode === !0 && (I = !0), x.identifierPrefix !== void 0 && (G = x.identifierPrefix), x.onRecoverableError !== void 0 && (J = x.onRecoverableError));
      var le = _se(d, null, c, lP, E, I, F, G, J);
      if (Re(le.current, c), j_(c), D)
        for (var de = 0; de < D.length; de++) {
          var De = D[de];
          F3e(le, De);
        }
      return new pI(le);
    }
    function gI(c) {
      return !!(c && (c.nodeType === tu || c.nodeType === Su || c.nodeType === ec || !he));
    }
    function bA(c) {
      return !!(c && (c.nodeType === tu || c.nodeType === Su || c.nodeType === ec || c.nodeType === Wr && c.nodeValue === " react-mount-point-unstable "));
    }
    function Yse(c) {
      c.nodeType === tu && c.tagName && c.tagName.toUpperCase() === "BODY" && a("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), rt(c) && (c._reactRootContainer ? a("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : a("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var k5e = n.ReactCurrentOwner, Hse;
    Hse = function(c) {
      if (c._reactRootContainer && c.nodeType !== Wr) {
        var d = Sse(c._reactRootContainer.current);
        d && d.parentNode !== c && a("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var x = !!c._reactRootContainer, E = GU(c), D = !!(E && Nt(E));
      D && !x && a("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), c.nodeType === tu && c.tagName && c.tagName.toUpperCase() === "BODY" && a("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function GU(c) {
      return c ? c.nodeType === Su ? c.documentElement : c.firstChild : null;
    }
    function Vse() {
    }
    function $5e(c, d, x, E, D) {
      if (D) {
        if (typeof E == "function") {
          var I = E;
          E = function() {
            var Ce = hI(F);
            I.call(Ce);
          };
        }
        var F = _se(
          d,
          E,
          c,
          z1,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          Vse
        );
        c._reactRootContainer = F, Re(F.current, c);
        var G = c.nodeType === Wr ? c.parentNode : c;
        return j_(G), w0(), F;
      } else {
        for (var J; J = c.lastChild; )
          c.removeChild(J);
        if (typeof E == "function") {
          var le = E;
          E = function() {
            var Ce = hI(de);
            le.call(Ce);
          };
        }
        var de = wse(
          c,
          z1,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          Vse
        );
        c._reactRootContainer = de, Re(de.current, c);
        var De = c.nodeType === Wr ? c.parentNode : c;
        return j_(De), w0(function() {
          vA(d, de, x, E);
        }), de;
      }
    }
    function P5e(c, d) {
      c !== null && typeof c != "function" && a("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, c);
    }
    function mI(c, d, x, E, D) {
      Hse(x), P5e(D === void 0 ? null : D, "render");
      var I = x._reactRootContainer, F;
      if (!I)
        F = $5e(x, d, c, D, E);
      else {
        if (F = I, typeof D == "function") {
          var G = D;
          D = function() {
            var J = hI(F);
            G.call(J);
          };
        }
        vA(d, F, c, D);
      }
      return hI(F);
    }
    function I5e(c) {
      {
        var d = k5e.current;
        if (d !== null && d.stateNode !== null) {
          var x = d.stateNode._warnedAboutRefsInRender;
          x || a("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Rr(d.type) || "A component"), d.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return c == null ? null : c.nodeType === tu ? c : x5e(c, "findDOMNode");
    }
    function j5e(c, d, x) {
      if (a("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !bA(d))
        throw new Error("Target container is not a DOM element.");
      {
        var E = rt(d) && d._reactRootContainer === void 0;
        E && a("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return mI(null, c, d, !0, x);
    }
    function L5e(c, d, x) {
      if (a("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !bA(d))
        throw new Error("Target container is not a DOM element.");
      {
        var E = rt(d) && d._reactRootContainer === void 0;
        E && a("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return mI(null, c, d, !1, x);
    }
    function z5e(c, d, x, E) {
      if (a("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !bA(x))
        throw new Error("Target container is not a DOM element.");
      if (c == null || !us(c))
        throw new Error("parentComponent must be a valid React Component");
      return mI(c, d, x, !1, E);
    }
    function F5e(c) {
      if (!bA(c))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var d = rt(c) && c._reactRootContainer === void 0;
        d && a("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (c._reactRootContainer) {
        {
          var x = GU(c), E = x && !Nt(x);
          E && a("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return w0(function() {
          mI(null, null, c, !1, function() {
            c._reactRootContainer = null, st(c);
          });
        }), !0;
      } else {
        {
          var D = GU(c), I = !!(D && Nt(D)), F = c.nodeType === tu && bA(c.parentNode) && !!c.parentNode._reactRootContainer;
          I && a("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", F ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Vt(w5e), P2(_5e), Vm(E5e), m_(Ru), I2(Ym), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && a("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), qb(Z4), Av(MU, RLe, w0);
    function B5e(c, d) {
      var x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!gI(d))
        throw new Error("Target container is not a DOM element.");
      return b5e(c, d, null, x);
    }
    function U5e(c, d, x, E) {
      return z5e(c, d, x, E);
    }
    var QU = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Nt, Gt, Sn, Gb, Dv, MU]
    };
    function Y5e(c, d) {
      return QU.usingClientEntryPoint || a('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), A5e(c, d);
    }
    function H5e(c, d, x) {
      return QU.usingClientEntryPoint || a('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), R5e(c, d, x);
    }
    function V5e(c) {
      return ese() && a("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), w0(c);
    }
    var W5e = D5e({
      findFiberByHostInstance: ct,
      bundleType: 1,
      version: UU,
      rendererPackageName: "react-dom"
    });
    if (!W5e && Qe && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var Wse = window.location.protocol;
      /^(https?|file):$/.test(Wse) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (Wse === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ff.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = QU, ff.createPortal = B5e, ff.createRoot = Y5e, ff.findDOMNode = I5e, ff.flushSync = V5e, ff.hydrate = j5e, ff.hydrateRoot = H5e, ff.render = L5e, ff.unmountComponentAtNode = F5e, ff.unstable_batchedUpdates = MU, ff.unstable_renderSubtreeIntoContainer = U5e, ff.version = UU, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ff;
}
function Kve() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Kve);
    } catch (e) {
      console.error(e);
    }
  }
}
process.env.NODE_ENV === "production" ? (Kve(), ZV.exports = rze()) : ZV.exports = ize();
var Cz = ZV.exports;
const vI = /* @__PURE__ */ KC(Cz);
var SA = Cz;
if (process.env.NODE_ENV === "production")
  _O.createRoot = SA.createRoot, _O.hydrateRoot = SA.hydrateRoot;
else {
  var bI = SA.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  _O.createRoot = function(e, t) {
    bI.usingClientEntryPoint = !0;
    try {
      return SA.createRoot(e, t);
    } finally {
      bI.usingClientEntryPoint = !1;
    }
  }, _O.hydrateRoot = function(e, t, n) {
    bI.usingClientEntryPoint = !0;
    try {
      return SA.hydrateRoot(e, t, n);
    } finally {
      bI.usingClientEntryPoint = !1;
    }
  };
}
const oze = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjc1IiBoZWlnaHQ9IjI3NSIgdmlld0JveD0iMCAwIDI3NSAyNzUiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjEzNy41IiBjeT0iMTM3LjUiIHI9IjEyNy41IiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSIjRjlGOUY5IiBzdHJva2Utd2lkdGg9IjIwIi8+CjxwYXRoIGQ9Ik0yMDIuOTE3IDkxLjM2MDhMMTg5LjYzOSA3OC4wODMzTDEzNyAxMzAuNzIzTDg0LjM2MDkgNzguMDgzM0w3MS4wODM0IDkxLjM2MDhMMTIzLjcyMyAxNDRMNzEuMDgzNCAxOTYuNjM5TDg0LjM2MDkgMjA5LjkxN0wxMzcgMTU3LjI3OEwxODkuNjM5IDIwOS45MTdMMjAyLjkxNyAxOTYuNjM5TDE1MC4yNzggMTQ0TDIwMi45MTcgOTEuMzYwOFoiIGZpbGw9IiNGOUY5RjkiLz4KPHBhdGggZD0iTTY2Ljc2NDkgMTc0LjcwOUM2NS4wMTc5IDE3NC43MDkgNjMuNjkyMiAxNzQuMjU3IDYyLjc4NzcgMTczLjM1MkM2MS44ODMzIDE3Mi40NDggNjEuNDMxIDE3MS4xMTYgNjEuNDMxIDE2OS4zNTZWMTYyLjMzMUM2MS40MzEgMTYyLjAzNCA2MS41MTc4IDE2MS43OTggNjEuNjkxMiAxNjEuNjI1QzYxLjg2NDcgMTYxLjQ1MSA2Mi4wOTM5IDE2MS4zNjUgNjIuMzc4OSAxNjEuMzY1QzYyLjY2MzggMTYxLjM2NSA2Mi44OTMxIDE2MS40NTEgNjMuMDY2NSAxNjEuNjI1QzYzLjI0IDE2MS43OTggNjMuMzI2NyAxNjIuMDM0IDYzLjMyNjcgMTYyLjMzMVYxNjkuNDg2QzYzLjMyNjcgMTcwLjY4OCA2My42MTE3IDE3MS41OTkgNjQuMTgxNiAxNzIuMjE4QzY0Ljc2NCAxNzIuODM4IDY1LjYyNTEgMTczLjE0OCA2Ni43NjQ5IDE3My4xNDhDNjcuODkyNCAxNzMuMTQ4IDY4Ljc0NzMgMTcyLjgzOCA2OS4zMjk3IDE3Mi4yMThDNjkuOTEyIDE3MS41OTkgNzAuMjAzMiAxNzAuNjg4IDcwLjIwMzIgMTY5LjQ4NlYxNjIuMzMxQzcwLjIwMzIgMTYyLjA0NiA3MC4yODk5IDE2MS44MTcgNzAuNDYzNCAxNjEuNjQzQzcwLjYzNjggMTYxLjQ1OCA3MC44NjYgMTYxLjM2NSA3MS4xNTEgMTYxLjM2NUM3MS40MzYgMTYxLjM2NSA3MS42NjUyIDE2MS40NTEgNzEuODM4NiAxNjEuNjI1QzcyLjAxMjEgMTYxLjc5OCA3Mi4wOTg4IDE2Mi4wMzQgNzIuMDk4OCAxNjIuMzMxVjE2OS4zNTZDNzIuMDk4OCAxNzEuMTAzIDcxLjY0MDQgMTcyLjQzNSA3MC43MjM1IDE3My4zNTJDNjkuODE5MSAxNzQuMjU3IDY4LjQ5OTUgMTc0LjcwOSA2Ni43NjQ5IDE3NC43MDlaTTc5LjcxMDEgMTY1LjI2OEM4MS44Nzg0IDE2NS4yNjggODIuOTYyNSAxNjYuNDg4IDgyLjk2MjUgMTY4LjkyOVYxNzMuNzYxQzgyLjk2MjUgMTc0LjA0NiA4Mi44NzU4IDE3NC4yNjkgODIuNzAyMyAxNzQuNDNDODIuNTQxMiAxNzQuNTc5IDgyLjMxMiAxNzQuNjUzIDgyLjAxNDcgMTc0LjY1M0M4MS43Mjk3IDE3NC42NTMgODEuNTAwNSAxNzQuNTcyIDgxLjMyNyAxNzQuNDExQzgxLjE2NTkgMTc0LjI1IDgxLjA4NTQgMTc0LjAzMyA4MS4wODU0IDE3My43NjFWMTY5LjAyMkM4MS4wODU0IDE2OC4yNTQgODAuOTMwNSAxNjcuNjkgODAuNjIwOCAxNjcuMzNDODAuMzIzNCAxNjYuOTcxIDc5Ljg1MjYgMTY2Ljc5MiA3OS4yMDgzIDE2Ni43OTJDNzguNDUyNSAxNjYuNzkyIDc3Ljg0NTQgMTY3LjAyNyA3Ny4zODcgMTY3LjQ5OEM3Ni45Mjg2IDE2Ny45NjkgNzYuNjk5MyAxNjguNiA3Ni42OTkzIDE2OS4zOTNWMTczLjc2MUM3Ni42OTkzIDE3NC4wMzMgNzYuNjEyNiAxNzQuMjUgNzYuNDM5MiAxNzQuNDExQzc2LjI3ODEgMTc0LjU3MiA3Ni4wNTUxIDE3NC42NTMgNzUuNzcwMSAxNzQuNjUzQzc1LjQ4NTEgMTc0LjY1MyA3NS4yNTU5IDE3NC41NzIgNzUuMDgyNCAxNzQuNDExQzc0LjkwOSAxNzQuMjUgNzQuODIyMyAxNzQuMDMzIDc0LjgyMjMgMTczLjc2MVYxNjYuMTk3Qzc0LjgyMjMgMTY1LjkzNyA3NC45MDkgMTY1LjcyNiA3NS4wODI0IDE2NS41NjVDNzUuMjY4MyAxNjUuMzkxIDc1LjQ5NzUgMTY1LjMwNSA3NS43NzAxIDE2NS4zMDVDNzYuMDQyNyAxNjUuMzA1IDc2LjI1OTUgMTY1LjM4NSA3Ni40MjA2IDE2NS41NDZDNzYuNTgxNiAxNjUuNzA3IDc2LjY2MjIgMTY1LjkxOCA3Ni42NjIyIDE2Ni4xNzhWMTY2Ljk0Qzc2Ljk1OTUgMTY2LjM5NSA3Ny4zNzQ2IDE2NS45OCA3Ny45MDc0IDE2NS42OTVDNzguNDQwMSAxNjUuNDEgNzkuMDQxMSAxNjUuMjY4IDc5LjcxMDEgMTY1LjI2OFpNODkuMzQwMyAxNjUuMjY4QzkwLjU0MjIgMTY1LjI2OCA5MS40MzQyIDE2NS41NzEgOTIuMDE2NiAxNjYuMTc4QzkyLjYxMTMgMTY2Ljc4NSA5Mi45MDg3IDE2Ny43MDggOTIuOTA4NyAxNjguOTQ3VjE3My43NjFDOTIuOTA4NyAxNzQuMDQ2IDkyLjgyODEgMTc0LjI2OSA5Mi42NjcgMTc0LjQzQzkyLjUwNiAxNzQuNTc5IDkyLjI4MyAxNzQuNjUzIDkxLjk5OCAxNzQuNjUzQzkxLjcyNTQgMTc0LjY1MyA5MS41MDg2IDE3NC41NzIgOTEuMzQ3NSAxNzQuNDExQzkxLjE4NjQgMTc0LjI1IDkxLjEwNTkgMTc0LjAzMyA5MS4xMDU5IDE3My43NjFWMTczLjA3M0M5MC44NzA1IDE3My41OTQgOTAuNTE3NCAxNzMuOTk2IDkwLjA0NjYgMTc0LjI4MUM4OS41ODgxIDE3NC41NTQgODkuMDQ5MiAxNzQuNjkgODguNDI5NyAxNzQuNjlDODcuODM0OSAxNzQuNjkgODcuMjg5OCAxNzQuNTcyIDg2Ljc5NDIgMTc0LjMzN0M4Ni4zMTEgMTc0LjA4OSA4NS45MjY5IDE3My43NTUgODUuNjQxOSAxNzMuMzMzQzg1LjM1NjkgMTcyLjkxMiA4NS4yMTQ1IDE3Mi40MzUgODUuMjE0NSAxNzEuOTAyQzg1LjIwMjEgMTcxLjIzMyA4NS4zNjkzIDE3MC43MTMgODUuNzE2MyAxNzAuMzQxQzg2LjA2MzIgMTY5Ljk1NyA4Ni42MjY5IDE2OS42ODUgODcuNDA3NSAxNjkuNTI0Qzg4LjE4ODEgMTY5LjM1IDg5LjI3MjIgMTY5LjI2MyA5MC42NTk5IDE2OS4yNjNIOTEuMDg3M1YxNjguNzI0QzkxLjA4NzMgMTY4LjAzMSA5MC45NDQ4IDE2Ny41MjkgOTAuNjU5OSAxNjcuMjE5QzkwLjM3NDkgMTY2LjkwOSA4OS45MTY1IDE2Ni43NTQgODkuMjg0NiAxNjYuNzU0Qzg4Ljg1MDkgMTY2Ljc1NCA4OC40NDIxIDE2Ni44MSA4OC4wNTggMTY2LjkyMkM4Ny42NzM5IDE2Ny4wMzMgODcuMjUyNiAxNjcuMTk0IDg2Ljc5NDIgMTY3LjQwNUM4Ni40NTk3IDE2Ny41OTEgODYuMjI0MiAxNjcuNjg0IDg2LjA4OCAxNjcuNjg0Qzg1LjkwMjEgMTY3LjY4NCA4NS43NDcyIDE2Ny42MTUgODUuNjIzMyAxNjcuNDc5Qzg1LjUxMTggMTY3LjM0MyA4NS40NTYxIDE2Ny4xNjkgODUuNDU2MSAxNjYuOTU5Qzg1LjQ1NjEgMTY2Ljc3MyA4NS41MDU2IDE2Ni42MTIgODUuNjA0NyAxNjYuNDc2Qzg1LjcxNjMgMTY2LjMyNyA4NS44ODk3IDE2Ni4xODQgODYuMTI1MSAxNjYuMDQ4Qzg2LjU1ODggMTY1LjgxMyA4Ny4wNjY4IDE2NS42MjcgODcuNjQ5MSAxNjUuNDkxQzg4LjIzMTQgMTY1LjM0MiA4OC43OTUyIDE2NS4yNjggODkuMzQwMyAxNjUuMjY4Wk04OC43NjQyIDE3My4yOTZDODkuNDQ1NiAxNzMuMjk2IDkwLjAwMzIgMTczLjA2NyA5MC40MzY4IDE3Mi42MDlDOTAuODcwNSAxNzIuMTM4IDkxLjA4NzMgMTcxLjUzNyA5MS4wODczIDE3MC44MDZWMTcwLjMyM0g5MC43NTI4Qzg5Ljc4NjQgMTcwLjMyMyA4OS4wNDMgMTcwLjM2NiA4OC41MjI2IDE3MC40NTNDODguMDAyMiAxNzAuNTQgODcuNjMwNSAxNzAuNjg4IDg3LjQwNzUgMTcwLjg5OUM4Ny4xODQ1IDE3MS4wOTcgODcuMDczIDE3MS4zODggODcuMDczIDE3MS43NzJDODcuMDczIDE3Mi4yMTggODcuMjM0IDE3Mi41ODQgODcuNTU2MiAxNzIuODY5Qzg3Ljg3ODMgMTczLjE1NCA4OC4yODEgMTczLjI5NiA4OC43NjQyIDE3My4yOTZaTTEwMi41MDEgMTY1LjMwNUMxMDIuNzg2IDE2NS4zMDUgMTAzLjAwOSAxNjUuMzg1IDEwMy4xNyAxNjUuNTQ2QzEwMy4zNDQgMTY1LjcwNyAxMDMuNDMxIDE2NS45MyAxMDMuNDMxIDE2Ni4yMTVWMTczLjc3OUMxMDMuNDMxIDE3NC4wNCAxMDMuMzQ0IDE3NC4yNSAxMDMuMTcgMTc0LjQxMUMxMDIuOTk3IDE3NC41NzIgMTAyLjc2OCAxNzQuNjUzIDEwMi40ODMgMTc0LjY1M0MxMDIuMjIzIDE3NC42NTMgMTAyLjAxMiAxNzQuNTc5IDEwMS44NTEgMTc0LjQzQzEwMS42OSAxNzQuMjY5IDEwMS42MDkgMTc0LjA1OCAxMDEuNjA5IDE3My43OThWMTczLjA5MkMxMDEuMzI0IDE3My42MTIgMTAwLjkyOCAxNzQuMDA5IDEwMC40MiAxNzQuMjgxQzk5LjkyNDMgMTc0LjU1NCA5OS4zNjY3IDE3NC42OSA5OC43NDcyIDE3NC42OUM5Ni41NDE4IDE3NC42OSA5NS40MzkxIDE3My40NzYgOTUuNDM5MSAxNzEuMDQ3VjE2Ni4yMTVDOTUuNDM5MSAxNjUuOTMgOTUuNTE5NiAxNjUuNzA3IDk1LjY4MDcgMTY1LjU0NkM5NS44NTQyIDE2NS4zODUgOTYuMDg5NiAxNjUuMzA1IDk2LjM4NjkgMTY1LjMwNUM5Ni42NzE5IDE2NS4zMDUgOTYuODk0OSAxNjUuMzg1IDk3LjA1NiAxNjUuNTQ2Qzk3LjIyOTUgMTY1LjcwNyA5Ny4zMTYyIDE2NS45MyA5Ny4zMTYyIDE2Ni4yMTVWMTcxLjAyOUM5Ny4zMTYyIDE3MS43NiA5Ny40NjQ5IDE3Mi4yOTkgOTcuNzYyMiAxNzIuNjQ2Qzk4LjA1OTYgMTcyLjk5MyA5OC41MTggMTczLjE2NiA5OS4xMzc1IDE3My4xNjZDOTkuODY4NSAxNzMuMTY2IDEwMC40NTEgMTcyLjkzMSAxMDAuODg1IDE3Mi40NkMxMDEuMzMxIDE3MS45ODkgMTAxLjU1NCAxNzEuMzYzIDEwMS41NTQgMTcwLjU4M1YxNjYuMjE1QzEwMS41NTQgMTY1Ljk0MyAxMDEuNjQgMTY1LjcyNiAxMDEuODE0IDE2NS41NjVDMTAxLjk4NyAxNjUuMzkxIDEwMi4yMTYgMTY1LjMwNSAxMDIuNTAxIDE2NS4zMDVaTTExMC40OTkgMTczLjIyMkMxMTAuNzcyIDE3My4yNDcgMTEwLjk2NCAxNzMuMzIxIDExMS4wNzUgMTczLjQ0NUMxMTEuMTk5IDE3My41NTYgMTExLjI2MSAxNzMuNzE4IDExMS4yNjEgMTczLjkyOEMxMTEuMjYxIDE3NC4xNzYgMTExLjE2MiAxNzQuMzY4IDExMC45NjQgMTc0LjUwNEMxMTAuNzc4IDE3NC42MjggMTEwLjQ5OSAxNzQuNjc4IDExMC4xMjggMTc0LjY1M0wxMDkuNjI2IDE3NC42MTZDMTA4LjYyMiAxNzQuNTQxIDEwNy44NzMgMTc0LjIzOCAxMDcuMzc3IDE3My43MDVDMTA2Ljg4MSAxNzMuMTYgMTA2LjYzNCAxNzIuMzYxIDEwNi42MzQgMTcxLjMwOFYxNjYuOTRIMTA1LjUxOEMxMDQuOTczIDE2Ni45NCAxMDQuNzAxIDE2Ni42OTkgMTA0LjcwMSAxNjYuMjE1QzEwNC43MDEgMTY1Ljk5MiAxMDQuNzY5IDE2NS44MTkgMTA0LjkwNSAxNjUuNjk1QzEwNS4wNTQgMTY1LjU1OSAxMDUuMjU4IDE2NS40OTEgMTA1LjUxOCAxNjUuNDkxSDEwNi42MzRWMTYzLjU3NkMxMDYuNjM0IDE2My4yOTEgMTA2LjcxNCAxNjMuMDY4IDEwNi44NzUgMTYyLjkwN0MxMDcuMDQ5IDE2Mi43NDYgMTA3LjI3OCAxNjIuNjY2IDEwNy41NjMgMTYyLjY2NkMxMDcuODQ4IDE2Mi42NjYgMTA4LjA3NyAxNjIuNzQ2IDEwOC4yNSAxNjIuOTA3QzEwOC40MjQgMTYzLjA2OCAxMDguNTExIDE2My4yOTEgMTA4LjUxMSAxNjMuNTc2VjE2NS40OTFIMTEwLjM1MUMxMTAuNjExIDE2NS40OTEgMTEwLjgwOSAxNjUuNTU5IDExMC45NDUgMTY1LjY5NUMxMTEuMDk0IDE2NS44MTkgMTExLjE2OCAxNjUuOTkyIDExMS4xNjggMTY2LjIxNUMxMTEuMTY4IDE2Ni40NTEgMTExLjA5NCAxNjYuNjMgMTEwLjk0NSAxNjYuNzU0QzExMC44MDkgMTY2Ljg3OCAxMTAuNjExIDE2Ni45NCAxMTAuMzUxIDE2Ni45NEgxMDguNTExVjE3MS40MzhDMTA4LjUxMSAxNzIuMDIgMTA4LjYyOCAxNzIuNDQ4IDEwOC44NjQgMTcyLjcyQzEwOS4xMTIgMTcyLjk5MyAxMDkuNDgzIDE3My4xNDggMTA5Ljk3OSAxNzMuMTg1TDExMC40OTkgMTczLjIyMlpNMTE3LjUxNiAxNjUuMjY4QzExOS42NzIgMTY1LjI2OCAxMjAuNzUgMTY2LjQ4OCAxMjAuNzUgMTY4LjkyOVYxNzMuNzYxQzEyMC43NSAxNzQuMDMzIDEyMC42NjMgMTc0LjI1IDEyMC40ODkgMTc0LjQxMUMxMjAuMzE2IDE3NC41NzIgMTIwLjA4NyAxNzQuNjUzIDExOS44MDIgMTc0LjY1M0MxMTkuNTE3IDE3NC42NTMgMTE5LjI4OCAxNzQuNTcyIDExOS4xMTQgMTc0LjQxMUMxMTguOTUzIDE3NC4yNSAxMTguODcyIDE3NC4wMzMgMTE4Ljg3MiAxNzMuNzYxVjE2OC45NDdDMTE4Ljg3MiAxNjguMjA0IDExOC43MTggMTY3LjY1OSAxMTguNDA4IDE2Ny4zMTJDMTE4LjExIDE2Ni45NjUgMTE3LjY0IDE2Ni43OTIgMTE2Ljk5NSAxNjYuNzkyQzExNi4yNCAxNjYuNzkyIDExNS42MzIgMTY3LjAyNyAxMTUuMTc0IDE2Ny40OThDMTE0LjcxNiAxNjcuOTY5IDExNC40ODYgMTY4LjYgMTE0LjQ4NiAxNjkuMzkzVjE3My43NjFDMTE0LjQ4NiAxNzQuMDMzIDExNC40IDE3NC4yNSAxMTQuMjI2IDE3NC40MTFDMTE0LjA2NSAxNzQuNTcyIDExMy44NDIgMTc0LjY1MyAxMTMuNTU3IDE3NC42NTNDMTEzLjI3MiAxNzQuNjUzIDExMy4wNDMgMTc0LjU3MiAxMTIuODcgMTc0LjQxMUMxMTIuNjk2IDE3NC4yNSAxMTIuNjA5IDE3NC4wMzMgMTEyLjYwOSAxNzMuNzYxVjE2Mi4yNTdDMTEyLjYwOSAxNjEuOTg0IDExMi42OTYgMTYxLjc2NyAxMTIuODcgMTYxLjYwNkMxMTMuMDU1IDE2MS40NDUgMTEzLjI5MSAxNjEuMzY1IDExMy41NzYgMTYxLjM2NUMxMTMuODQ4IDE2MS4zNjUgMTE0LjA2NSAxNjEuNDQ1IDExNC4yMjYgMTYxLjYwNkMxMTQuNCAxNjEuNzU1IDExNC40ODYgMTYxLjk1OSAxMTQuNDg2IDE2Mi4yMlYxNjYuODY2QzExNC43OTYgMTY2LjM0NSAxMTUuMjExIDE2NS45NDkgMTE1LjczMiAxNjUuNjc2QzExNi4yNTIgMTY1LjQwNCAxMTYuODQ3IDE2NS4yNjggMTE3LjUxNiAxNjUuMjY4Wk0xMjcuMjU3IDE3NC42OUMxMjYuMzY1IDE3NC42OSAxMjUuNTc5IDE3NC40OTggMTI0Ljg5NyAxNzQuMTE0QzEyNC4yMjggMTczLjczIDEyMy43MDggMTczLjE4NSAxMjMuMzM2IDE3Mi40NzlDMTIyLjk3NyAxNzEuNzYgMTIyLjc5NyAxNzAuOTMgMTIyLjc5NyAxNjkuOTg4QzEyMi43OTcgMTY5LjAzNCAxMjIuOTc3IDE2OC4yMDQgMTIzLjMzNiAxNjcuNDk4QzEyMy43MDggMTY2Ljc3OSAxMjQuMjI4IDE2Ni4yMjggMTI0Ljg5NyAxNjUuODQ0QzEyNS41NzkgMTY1LjQ2IDEyNi4zNjUgMTY1LjI2OCAxMjcuMjU3IDE2NS4yNjhDMTI4LjE1IDE2NS4yNjggMTI4LjkzIDE2NS40NiAxMjkuNTk5IDE2NS44NDRDMTMwLjI4MSAxNjYuMjI4IDEzMC44MDEgMTY2Ljc3OSAxMzEuMTYgMTY3LjQ5OEMxMzEuNTMyIDE2OC4yMDQgMTMxLjcxOCAxNjkuMDM0IDEzMS43MTggMTY5Ljk4OEMxMzEuNzE4IDE3MC45MyAxMzEuNTMyIDE3MS43NiAxMzEuMTYgMTcyLjQ3OUMxMzAuODAxIDE3My4xODUgMTMwLjI4MSAxNzMuNzMgMTI5LjU5OSAxNzQuMTE0QzEyOC45MyAxNzQuNDk4IDEyOC4xNSAxNzQuNjkgMTI3LjI1NyAxNzQuNjlaTTEyNy4yNTcgMTczLjIwM0MxMjguMDg4IDE3My4yMDMgMTI4LjcyIDE3Mi45MzEgMTI5LjE1MyAxNzIuMzg2QzEyOS41OTkgMTcxLjg0IDEyOS44MjIgMTcxLjA0MSAxMjkuODIyIDE2OS45ODhDMTI5LjgyMiAxNjguOTQ3IDEyOS41OTkgMTY4LjE1NCAxMjkuMTUzIDE2Ny42MDlDMTI4LjcwNyAxNjcuMDUyIDEyOC4wNzUgMTY2Ljc3MyAxMjcuMjU3IDE2Ni43NzNDMTI2LjQ0IDE2Ni43NzMgMTI1LjgwOCAxNjcuMDUyIDEyNS4zNjIgMTY3LjYwOUMxMjQuOTE2IDE2OC4xNTQgMTI0LjY5MyAxNjguOTQ3IDEyNC42OTMgMTY5Ljk4OEMxMjQuNjkzIDE3MS4wNDEgMTI0LjkxIDE3MS44NCAxMjUuMzQzIDE3Mi4zODZDMTI1Ljc4OSAxNzIuOTMxIDEyNi40MjcgMTczLjIwMyAxMjcuMjU3IDE3My4yMDNaTTEzOC41NjYgMTY1LjMwNUMxMzkuMTYgMTY1LjI2OCAxMzkuNDU4IDE2NS41MjIgMTM5LjQ1OCAxNjYuMDY3QzEzOS40NTggMTY2LjMzOSAxMzkuMzkgMTY2LjU0NCAxMzkuMjUzIDE2Ni42OEMxMzkuMTE3IDE2Ni44MTYgMTM4Ljg4MiAxNjYuODk3IDEzOC41NDcgMTY2LjkyMkwxMzcuOTg5IDE2Ni45NzdDMTM3LjIwOSAxNjcuMDUyIDEzNi42MjcgMTY3LjMyNCAxMzYuMjQyIDE2Ny43OTVDMTM1Ljg3MSAxNjguMjY2IDEzNS42ODUgMTY4LjgzNiAxMzUuNjg1IDE2OS41MDVWMTczLjc2MUMxMzUuNjg1IDE3NC4wNTggMTM1LjU5OCAxNzQuMjgxIDEzNS40MjUgMTc0LjQzQzEzNS4yNTEgMTc0LjU3OSAxMzUuMDI4IDE3NC42NTMgMTM0Ljc1NiAxNzQuNjUzQzEzNC40ODMgMTc0LjY1MyAxMzQuMjU0IDE3NC41NzkgMTM0LjA2OCAxNzQuNDNDMTMzLjg5NSAxNzQuMjgxIDEzMy44MDggMTc0LjA1OCAxMzMuODA4IDE3My43NjFWMTY2LjE5N0MxMzMuODA4IDE2NS45MTIgMTMzLjg5NSAxNjUuNjk1IDEzNC4wNjggMTY1LjU0NkMxMzQuMjU0IDE2NS4zODUgMTM0LjQ4MyAxNjUuMzA1IDEzNC43NTYgMTY1LjMwNUMxMzUuMDAzIDE2NS4zMDUgMTM1LjIwOCAxNjUuMzg1IDEzNS4zNjkgMTY1LjU0NkMxMzUuNTQyIDE2NS42OTUgMTM1LjYyOSAxNjUuOTA2IDEzNS42MjkgMTY2LjE3OFYxNjcuMDdDMTM1Ljg3NyAxNjYuNTI1IDEzNi4yMzYgMTY2LjExIDEzNi43MDcgMTY1LjgyNUMxMzcuMTc4IDE2NS41NCAxMzcuNzExIDE2NS4zNzMgMTM4LjMwNSAxNjUuMzIzTDEzOC41NjYgMTY1LjMwNVpNMTQxLjU2MiAxNzQuNjUzQzE0MS4yODkgMTc0LjY1MyAxNDEuMDYgMTc0LjU3OSAxNDAuODc0IDE3NC40M0MxNDAuNzAxIDE3NC4yODEgMTQwLjYxNCAxNzQuMDU4IDE0MC42MTQgMTczLjc2MVYxNjYuMjE1QzE0MC42MTQgMTY1LjkxOCAxNDAuNzAxIDE2NS42OTUgMTQwLjg3NCAxNjUuNTQ2QzE0MS4wNiAxNjUuMzg1IDE0MS4yODkgMTY1LjMwNSAxNDEuNTYyIDE2NS4zMDVDMTQxLjgzNCAxNjUuMzA1IDE0Mi4wNTcgMTY1LjM4NSAxNDIuMjMxIDE2NS41NDZDMTQyLjQwNCAxNjUuNjk1IDE0Mi40OTEgMTY1LjkxOCAxNDIuNDkxIDE2Ni4yMTVWMTczLjc2MUMxNDIuNDkxIDE3NC4wNTggMTQyLjQwNCAxNzQuMjgxIDE0Mi4yMzEgMTc0LjQzQzE0Mi4wNTcgMTc0LjU3OSAxNDEuODM0IDE3NC42NTMgMTQxLjU2MiAxNzQuNjUzWk0xNDEuNTYyIDE2My40ODNDMTQxLjIwMiAxNjMuNDgzIDE0MC45MTcgMTYzLjM4NCAxNDAuNzA3IDE2My4xODZDMTQwLjQ5NiAxNjIuOTg4IDE0MC4zOTEgMTYyLjcyOCAxNDAuMzkxIDE2Mi40MDVDMTQwLjM5MSAxNjIuMDgzIDE0MC40OTYgMTYxLjgyOSAxNDAuNzA3IDE2MS42NDNDMTQwLjkxNyAxNjEuNDQ1IDE0MS4yMDIgMTYxLjM0NiAxNDEuNTYyIDE2MS4zNDZDMTQxLjkwOSAxNjEuMzQ2IDE0Mi4xODcgMTYxLjQ0NSAxNDIuMzk4IDE2MS42NDNDMTQyLjYyMSAxNjEuODI5IDE0Mi43MzMgMTYyLjA4MyAxNDIuNzMzIDE2Mi40MDVDMTQyLjczMyAxNjIuNzI4IDE0Mi42MjcgMTYyLjk4OCAxNDIuNDE3IDE2My4xODZDMTQyLjIwNiAxNjMuMzg0IDE0MS45MjEgMTYzLjQ4MyAxNDEuNTYyIDE2My40ODNaTTE1MS44MjQgMTczLjExQzE1Mi4wOTcgMTczLjExIDE1Mi4zMDEgMTczLjE3OSAxNTIuNDM3IDE3My4zMTVDMTUyLjU4NiAxNzMuNDM5IDE1Mi42NiAxNzMuNjEyIDE1Mi42NiAxNzMuODM1QzE1Mi42NiAxNzQuMDU4IDE1Mi41ODYgMTc0LjIzOCAxNTIuNDM3IDE3NC4zNzRDMTUyLjMwMSAxNzQuNDk4IDE1Mi4wOTcgMTc0LjU2IDE1MS44MjQgMTc0LjU2SDE0NS40NjhDMTQ1LjE5NSAxNzQuNTYgMTQ0Ljk3OSAxNzQuNDg2IDE0NC44MTggMTc0LjMzN0MxNDQuNjU2IDE3NC4xNzYgMTQ0LjU3NiAxNzMuOTc4IDE0NC41NzYgMTczLjc0MkMxNDQuNTc2IDE3My41MDcgMTQ0LjY2OSAxNzMuMjc4IDE0NC44NTUgMTczLjA1NUwxNTAuMDIxIDE2Ni45NEgxNDUuMzU3QzE0NS4wOTYgMTY2Ljk0IDE0NC44OTIgMTY2Ljg3OCAxNDQuNzQzIDE2Ni43NTRDMTQ0LjYwNyAxNjYuNjE4IDE0NC41MzkgMTY2LjQzOCAxNDQuNTM5IDE2Ni4yMTVDMTQ0LjUzOSAxNjUuOTkyIDE0NC42MDcgMTY1LjgxOSAxNDQuNzQzIDE2NS42OTVDMTQ0Ljg5MiAxNjUuNTU5IDE0NS4wOTYgMTY1LjQ5MSAxNDUuMzU3IDE2NS40OTFIMTUxLjUyN0MxNTEuNzg3IDE2NS40OTEgMTUxLjk5OCAxNjUuNTcxIDE1Mi4xNTkgMTY1LjczMkMxNTIuMzMyIDE2NS44OTMgMTUyLjQxOSAxNjYuMDg1IDE1Mi40MTkgMTY2LjMwOEMxNTIuNDE5IDE2Ni41NDQgMTUyLjMyNiAxNjYuNzczIDE1Mi4xNCAxNjYuOTk2TDE0Ni45NzMgMTczLjExSDE1MS44MjRaTTE2MS4zOTggMTcyLjI3NEMxNjEuNTcxIDE3Mi4yNzQgMTYxLjcxNCAxNzIuMzQyIDE2MS44MjUgMTcyLjQ3OUMxNjEuOTM3IDE3Mi42MTUgMTYxLjk5MyAxNzIuNzg4IDE2MS45OTMgMTcyLjk5OUMxNjEuOTkzIDE3My4zNTggMTYxLjc3IDE3My42NjIgMTYxLjMyNCAxNzMuOTFDMTYwLjg5IDE3NC4xNTcgMTYwLjQxMyAxNzQuMzQ5IDE1OS44OTMgMTc0LjQ4NkMxNTkuMzg1IDE3NC42MjIgMTU4Ljg5NSAxNzQuNjkgMTU4LjQyNCAxNzQuNjlDMTU2Ljk4NyAxNzQuNjkgMTU1Ljg1MyAxNzQuMjc1IDE1NS4wMjMgMTczLjQ0NUMxNTQuMTkzIDE3Mi42MDIgMTUzLjc3OCAxNzEuNDU2IDE1My43NzggMTcwLjAwN0MxNTMuNzc4IDE2OS4wNzcgMTUzLjk1OCAxNjguMjU0IDE1NC4zMTcgMTY3LjUzNUMxNTQuNjg5IDE2Ni44MTYgMTU1LjIwMyAxNjYuMjU5IDE1NS44NiAxNjUuODYyQzE1Ni41MjkgMTY1LjQ2NiAxNTcuMjg1IDE2NS4yNjggMTU4LjEyNyAxNjUuMjY4QzE1OS4zNDEgMTY1LjI2OCAxNjAuMzAxIDE2NS42NTggMTYxLjAwOCAxNjYuNDM4QzE2MS43MTQgMTY3LjIxOSAxNjIuMDY3IDE2OC4yNzIgMTYyLjA2NyAxNjkuNTk4QzE2Mi4wNjcgMTcwLjA5MyAxNjEuODQ0IDE3MC4zNDEgMTYxLjM5OCAxNzAuMzQxSDE1NS42NTVDMTU1Ljc3OSAxNzIuMjYyIDE1Ni43MDIgMTczLjIyMiAxNTguNDI0IDE3My4yMjJDMTU4Ljg4MyAxNzMuMjIyIDE1OS4yNzkgMTczLjE2IDE1OS42MTQgMTczLjAzNkMxNTkuOTQ4IDE3Mi45MTIgMTYwLjMwMSAxNzIuNzUxIDE2MC42NzMgMTcyLjU1M0MxNjAuNzEgMTcyLjUyOCAxNjAuODA5IDE3Mi40NzkgMTYwLjk3MSAxNzIuNDA0QzE2MS4xNDQgMTcyLjMxNyAxNjEuMjg2IDE3Mi4yNzQgMTYxLjM5OCAxNzIuMjc0Wk0xNTguMTY0IDE2Ni42NDNDMTU3LjQ0NiAxNjYuNjQzIDE1Ni44NjkgMTY2Ljg3MiAxNTYuNDM2IDE2Ny4zM0MxNTYuMDAyIDE2Ny43ODkgMTU1Ljc0MiAxNjguNDMzIDE1NS42NTUgMTY5LjI2M0gxNjAuNDVDMTYwLjQxMyAxNjguNDIxIDE2MC4xOTYgMTY3Ljc3NyAxNTkuOCAxNjcuMzNDMTU5LjQxNiAxNjYuODcyIDE1OC44NyAxNjYuNjQzIDE1OC4xNjQgMTY2LjY0M1pNMTcxLjU1MSAxNjEuMzY1QzE3MS44MzYgMTYxLjM2NSAxNzIuMDY1IDE2MS40NDUgMTcyLjIzOSAxNjEuNjA2QzE3Mi40MTIgMTYxLjc2NyAxNzIuNDk5IDE2MS45ODQgMTcyLjQ5OSAxNjIuMjU3VjE3My43NDJDMTcyLjQ5OSAxNzQuMDI3IDE3Mi40MTIgMTc0LjI1IDE3Mi4yMzkgMTc0LjQxMUMxNzIuMDc3IDE3NC41NzIgMTcxLjg1NCAxNzQuNjUzIDE3MS41NjkgMTc0LjY1M0MxNzEuMjg1IDE3NC42NTMgMTcxLjA1NSAxNzQuNTcyIDE3MC44ODIgMTc0LjQxMUMxNzAuNzIxIDE3NC4yNSAxNzAuNjQgMTc0LjAyNyAxNzAuNjQgMTczLjc0MlYxNzIuOTk5QzE3MC4zNjggMTczLjU0NCAxNjkuOTcxIDE3My45NjUgMTY5LjQ1MSAxNzQuMjYzQzE2OC45MyAxNzQuNTQ4IDE2OC4zMyAxNzQuNjkgMTY3LjY0OCAxNzQuNjlDMTY2Ljg2NyAxNzQuNjkgMTY2LjE2NyAxNzQuNDkyIDE2NS41NDggMTc0LjA5NUMxNjQuOTQxIDE3My42OTkgMTY0LjQ2NCAxNzMuMTQxIDE2NC4xMTcgMTcyLjQyM0MxNjMuNzgyIDE3MS43MDQgMTYzLjYxNSAxNzAuODggMTYzLjYxNSAxNjkuOTUxQzE2My42MTUgMTY5LjAwOSAxNjMuNzgyIDE2OC4xODUgMTY0LjExNyAxNjcuNDc5QzE2NC40NjQgMTY2Ljc3MyAxNjQuOTQxIDE2Ni4yMjggMTY1LjU0OCAxNjUuODQ0QzE2Ni4xNTUgMTY1LjQ2IDE2Ni44NTUgMTY1LjI2OCAxNjcuNjQ4IDE2NS4yNjhDMTY4LjMzIDE2NS4yNjggMTY4LjkyNCAxNjUuNDE2IDE2OS40MzIgMTY1LjcxNEMxNjkuOTUzIDE2NS45OTkgMTcwLjM0OSAxNjYuNDA3IDE3MC42MjIgMTY2Ljk0VjE2Mi4yMkMxNzAuNjIyIDE2MS45NTkgMTcwLjcwMiAxNjEuNzU1IDE3MC44NjMgMTYxLjYwNkMxNzEuMDM3IDE2MS40NDUgMTcxLjI2NiAxNjEuMzY1IDE3MS41NTEgMTYxLjM2NVpNMTY4LjA5NCAxNzMuMjAzQzE2OC44OTkgMTczLjIwMyAxNjkuNTI1IDE3Mi45MjUgMTY5Ljk3MSAxNzIuMzY3QzE3MC40MTcgMTcxLjgwOSAxNzAuNjQgMTcxLjAxNyAxNzAuNjQgMTY5Ljk4OEMxNzAuNjQgMTY4Ljk2IDE3MC40MTcgMTY4LjE2NyAxNjkuOTcxIDE2Ny42MDlDMTY5LjUzOCAxNjcuMDUyIDE2OC45MTIgMTY2Ljc3MyAxNjguMDk0IDE2Ni43NzNDMTY3LjI3NiAxNjYuNzczIDE2Ni42MzggMTY3LjA1MiAxNjYuMTggMTY3LjYwOUMxNjUuNzM0IDE2OC4xNTQgMTY1LjUxMSAxNjguOTM1IDE2NS41MTEgMTY5Ljk1MUMxNjUuNTExIDE3MC45NjcgMTY1Ljc0IDE3MS43NjYgMTY2LjE5OCAxNzIuMzQ4QzE2Ni42NTcgMTcyLjkxOCAxNjcuMjg5IDE3My4yMDMgMTY4LjA5NCAxNzMuMjAzWk0xODcuMDQxIDE2NS4zMDVDMTg3LjMyNiAxNjUuMzA1IDE4Ny41NDkgMTY1LjM4NSAxODcuNzEgMTY1LjU0NkMxODcuODg0IDE2NS43MDcgMTg3Ljk3MSAxNjUuOTMgMTg3Ljk3MSAxNjYuMjE1VjE3My43NzlDMTg3Ljk3MSAxNzQuMDQgMTg3Ljg4NCAxNzQuMjUgMTg3LjcxIDE3NC40MTFDMTg3LjUzNyAxNzQuNTcyIDE4Ny4zMDggMTc0LjY1MyAxODcuMDIzIDE3NC42NTNDMTg2Ljc2MyAxNzQuNjUzIDE4Ni41NTIgMTc0LjU3OSAxODYuMzkxIDE3NC40M0MxODYuMjMgMTc0LjI2OSAxODYuMTQ5IDE3NC4wNTggMTg2LjE0OSAxNzMuNzk4VjE3My4wOTJDMTg1Ljg2NCAxNzMuNjEyIDE4NS40NjggMTc0LjAwOSAxODQuOTYgMTc0LjI4MUMxODQuNDY0IDE3NC41NTQgMTgzLjkwNyAxNzQuNjkgMTgzLjI4NyAxNzQuNjlDMTgxLjA4MiAxNzQuNjkgMTc5Ljk3OSAxNzMuNDc2IDE3OS45NzkgMTcxLjA0N1YxNjYuMjE1QzE3OS45NzkgMTY1LjkzIDE4MC4wNiAxNjUuNzA3IDE4MC4yMjEgMTY1LjU0NkMxODAuMzk0IDE2NS4zODUgMTgwLjYzIDE2NS4zMDUgMTgwLjkyNyAxNjUuMzA1QzE4MS4yMTIgMTY1LjMwNSAxODEuNDM1IDE2NS4zODUgMTgxLjU5NiAxNjUuNTQ2QzE4MS43NjkgMTY1LjcwNyAxODEuODU2IDE2NS45MyAxODEuODU2IDE2Ni4yMTVWMTcxLjAyOUMxODEuODU2IDE3MS43NiAxODIuMDA1IDE3Mi4yOTkgMTgyLjMwMiAxNzIuNjQ2QzE4Mi42IDE3Mi45OTMgMTgzLjA1OCAxNzMuMTY2IDE4My42NzcgMTczLjE2NkMxODQuNDA4IDE3My4xNjYgMTg0Ljk5MSAxNzIuOTMxIDE4NS40MjQgMTcyLjQ2QzE4NS44NzEgMTcxLjk4OSAxODYuMDk0IDE3MS4zNjMgMTg2LjA5NCAxNzAuNTgzVjE2Ni4yMTVDMTg2LjA5NCAxNjUuOTQzIDE4Ni4xOCAxNjUuNzI2IDE4Ni4zNTQgMTY1LjU2NUMxODYuNTI3IDE2NS4zOTEgMTg2Ljc1NiAxNjUuMzA1IDE4Ny4wNDEgMTY1LjMwNVpNMTkzLjc1NyAxNzQuNjlDMTkyLjQ5MyAxNzQuNjkgMTkxLjQ1OCAxNzQuNDMgMTkwLjY1MyAxNzMuOTFDMTkwLjQzIDE3My43NzMgMTkwLjI2OSAxNzMuNjMxIDE5MC4xNyAxNzMuNDgyQzE5MC4wODMgMTczLjMzMyAxOTAuMDQgMTczLjE2NiAxOTAuMDQgMTcyLjk4QzE5MC4wNCAxNzIuNzgyIDE5MC4wOTYgMTcyLjYxNSAxOTAuMjA3IDE3Mi40NzlDMTkwLjMxOSAxNzIuMzQyIDE5MC40NjEgMTcyLjI3NCAxOTAuNjM1IDE3Mi4yNzRDMTkwLjc5NiAxNzIuMjc0IDE5MS4wNSAxNzIuMzczIDE5MS4zOTYgMTcyLjU3MUMxOTEuNzY4IDE3Mi43NyAxOTIuMTI4IDE3Mi45MzEgMTkyLjQ3NCAxNzMuMDU1QzE5Mi44MzQgMTczLjE3OSAxOTMuMjggMTczLjI0MSAxOTMuODEzIDE3My4yNDFDMTk0LjQwNyAxNzMuMjQxIDE5NC44NzIgMTczLjEzNSAxOTUuMjA2IDE3Mi45MjVDMTk1LjU0MSAxNzIuNzE0IDE5NS43MDggMTcyLjQxNyAxOTUuNzA4IDE3Mi4wMzJDMTk1LjcwOCAxNzEuNzg1IDE5NS42NCAxNzEuNTg2IDE5NS41MDQgMTcxLjQzOEMxOTUuMzggMTcxLjI4OSAxOTUuMTU3IDE3MS4xNTkgMTk0LjgzNSAxNzEuMDQ3QzE5NC41MTMgMTcwLjkyNCAxOTQuMDM2IDE3MC43OTMgMTkzLjQwNCAxNzAuNjU3QzE5Mi4zMTMgMTcwLjQyMiAxOTEuNTI3IDE3MC4xMDYgMTkxLjA0MyAxNjkuNzA5QzE5MC41NzMgMTY5LjMwMSAxOTAuMzM3IDE2OC43NDkgMTkwLjMzNyAxNjguMDU1QzE5MC4zMzcgMTY3LjUyMyAxOTAuNDkyIDE2Ny4wNDYgMTkwLjgwMiAxNjYuNjI0QzE5MS4xMTIgMTY2LjE5MSAxOTEuNTM5IDE2NS44NTYgMTkyLjA4NCAxNjUuNjIxQzE5Mi42MjkgMTY1LjM4NSAxOTMuMjQ5IDE2NS4yNjggMTkzLjk0MyAxNjUuMjY4QzE5NC40MzggMTY1LjI2OCAxOTQuOTIxIDE2NS4zMzYgMTk1LjM5MiAxNjUuNDcyQzE5NS44NjMgMTY1LjU5NiAxOTYuMjc4IDE2NS43ODIgMTk2LjYzNyAxNjYuMDNDMTk3LjA0NiAxNjYuMzAyIDE5Ny4yNTEgMTY2LjYxOCAxOTcuMjUxIDE2Ni45NzdDMTk3LjI1MSAxNjcuMTc2IDE5Ny4xODkgMTY3LjM0MyAxOTcuMDY1IDE2Ny40NzlDMTk2Ljk1MyAxNjcuNjE1IDE5Ni44MTcgMTY3LjY4NCAxOTYuNjU2IDE2Ny42ODRDMTk2LjU0NSAxNjcuNjg0IDE5Ni40MzMgMTY3LjY1OSAxOTYuMzIyIDE2Ny42MDlDMTk2LjIxIDE2Ny41NiAxOTYuMDYxIDE2Ny40NzkgMTk1Ljg3NSAxNjcuMzY4QzE5NS41NDEgMTY3LjE2OSAxOTUuMjI1IDE2Ny4wMTUgMTk0LjkyOCAxNjYuOTAzQzE5NC42NDMgMTY2Ljc5MiAxOTQuMjgzIDE2Ni43MzYgMTkzLjg1IDE2Ni43MzZDMTkzLjMyOSAxNjYuNzM2IDE5Mi45MDggMTY2Ljg0NyAxOTIuNTg2IDE2Ny4wN0MxOTIuMjc2IDE2Ny4yOTMgMTkyLjEyMSAxNjcuNTk3IDE5Mi4xMjEgMTY3Ljk4MUMxOTIuMTIxIDE2OC4zMjggMTkyLjI2NCAxNjguNiAxOTIuNTQ5IDE2OC43OTlDMTkyLjg0NiAxNjguOTg1IDE5My4zOTcgMTY5LjE2NCAxOTQuMjAzIDE2OS4zMzhDMTk1LjAzMyAxNjkuNTExIDE5NS42ODMgMTY5LjcwOSAxOTYuMTU0IDE2OS45MzJDMTk2LjYyNSAxNzAuMTU1IDE5Ni45NiAxNzAuNDM0IDE5Ny4xNTggMTcwLjc2OUMxOTcuMzY4IDE3MS4wOTEgMTk3LjQ3NCAxNzEuNTA2IDE5Ny40NzQgMTcyLjAxNEMxOTcuNDc0IDE3Mi44MTkgMTk3LjEzMyAxNzMuNDcgMTk2LjQ1MiAxNzMuOTY1QzE5NS43ODMgMTc0LjQ0OSAxOTQuODg0IDE3NC42OSAxOTMuNzU3IDE3NC42OVpNMjA2LjY2MyAxNzIuMjc0QzIwNi44MzYgMTcyLjI3NCAyMDYuOTc5IDE3Mi4zNDIgMjA3LjA5IDE3Mi40NzlDMjA3LjIwMiAxNzIuNjE1IDIwNy4yNTcgMTcyLjc4OCAyMDcuMjU3IDE3Mi45OTlDMjA3LjI1NyAxNzMuMzU4IDIwNy4wMzQgMTczLjY2MiAyMDYuNTg4IDE3My45MUMyMDYuMTU1IDE3NC4xNTcgMjA1LjY3OCAxNzQuMzQ5IDIwNS4xNTcgMTc0LjQ4NkMyMDQuNjQ5IDE3NC42MjIgMjA0LjE2IDE3NC42OSAyMDMuNjg5IDE3NC42OUMyMDIuMjUyIDE3NC42OSAyMDEuMTE4IDE3NC4yNzUgMjAwLjI4OCAxNzMuNDQ1QzE5OS40NTggMTcyLjYwMiAxOTkuMDQzIDE3MS40NTYgMTk5LjA0MyAxNzAuMDA3QzE5OS4wNDMgMTY5LjA3NyAxOTkuMjIyIDE2OC4yNTQgMTk5LjU4MiAxNjcuNTM1QzE5OS45NTMgMTY2LjgxNiAyMDAuNDY4IDE2Ni4yNTkgMjAxLjEyNCAxNjUuODYyQzIwMS43OTMgMTY1LjQ2NiAyMDIuNTQ5IDE2NS4yNjggMjAzLjM5MiAxNjUuMjY4QzIwNC42MDYgMTY1LjI2OCAyMDUuNTY2IDE2NS42NTggMjA2LjI3MiAxNjYuNDM4QzIwNi45NzkgMTY3LjIxOSAyMDcuMzMyIDE2OC4yNzIgMjA3LjMzMiAxNjkuNTk4QzIwNy4zMzIgMTcwLjA5MyAyMDcuMTA5IDE3MC4zNDEgMjA2LjY2MyAxNzAuMzQxSDIwMC45MkMyMDEuMDQ0IDE3Mi4yNjIgMjAxLjk2NyAxNzMuMjIyIDIwMy42ODkgMTczLjIyMkMyMDQuMTQ3IDE3My4yMjIgMjA0LjU0NCAxNzMuMTYgMjA0Ljg3OCAxNzMuMDM2QzIwNS4yMTMgMTcyLjkxMiAyMDUuNTY2IDE3Mi43NTEgMjA1LjkzOCAxNzIuNTUzQzIwNS45NzUgMTcyLjUyOCAyMDYuMDc0IDE3Mi40NzkgMjA2LjIzNSAxNzIuNDA0QzIwNi40MDkgMTcyLjMxNyAyMDYuNTUxIDE3Mi4yNzQgMjA2LjY2MyAxNzIuMjc0Wk0yMDMuNDI5IDE2Ni42NDNDMjAyLjcxIDE2Ni42NDMgMjAyLjEzNCAxNjYuODcyIDIwMS43IDE2Ny4zM0MyMDEuMjY3IDE2Ny43ODkgMjAxLjAwNyAxNjguNDMzIDIwMC45MiAxNjkuMjYzSDIwNS43MTVDMjA1LjY3OCAxNjguNDIxIDIwNS40NjEgMTY3Ljc3NyAyMDUuMDY0IDE2Ny4zM0MyMDQuNjggMTY2Ljg3MiAyMDQuMTM1IDE2Ni42NDMgMjAzLjQyOSAxNjYuNjQzWk0yMTQuMTU4IDE2NS4zMDVDMjE0Ljc1MyAxNjUuMjY4IDIxNS4wNSAxNjUuNTIyIDIxNS4wNSAxNjYuMDY3QzIxNS4wNSAxNjYuMzM5IDIxNC45ODIgMTY2LjU0NCAyMTQuODQ2IDE2Ni42OEMyMTQuNzA5IDE2Ni44MTYgMjE0LjQ3NCAxNjYuODk3IDIxNC4xMzkgMTY2LjkyMkwyMTMuNTgyIDE2Ni45NzdDMjEyLjgwMSAxNjcuMDUyIDIxMi4yMTkgMTY3LjMyNCAyMTEuODM1IDE2Ny43OTVDMjExLjQ2MyAxNjguMjY2IDIxMS4yNzcgMTY4LjgzNiAyMTEuMjc3IDE2OS41MDVWMTczLjc2MUMyMTEuMjc3IDE3NC4wNTggMjExLjE5IDE3NC4yODEgMjExLjAxNyAxNzQuNDNDMjEwLjg0NCAxNzQuNTc5IDIxMC42MjEgMTc0LjY1MyAyMTAuMzQ4IDE3NC42NTNDMjEwLjA3NSAxNzQuNjUzIDIwOS44NDYgMTc0LjU3OSAyMDkuNjYgMTc0LjQzQzIwOS40ODcgMTc0LjI4MSAyMDkuNCAxNzQuMDU4IDIwOS40IDE3My43NjFWMTY2LjE5N0MyMDkuNCAxNjUuOTEyIDIwOS40ODcgMTY1LjY5NSAyMDkuNjYgMTY1LjU0NkMyMDkuODQ2IDE2NS4zODUgMjEwLjA3NSAxNjUuMzA1IDIxMC4zNDggMTY1LjMwNUMyMTAuNTk2IDE2NS4zMDUgMjEwLjggMTY1LjM4NSAyMTAuOTYxIDE2NS41NDZDMjExLjEzNSAxNjUuNjk1IDIxMS4yMjEgMTY1LjkwNiAyMTEuMjIxIDE2Ni4xNzhWMTY3LjA3QzIxMS40NjkgMTY2LjUyNSAyMTEuODI5IDE2Ni4xMSAyMTIuMjk5IDE2NS44MjVDMjEyLjc3IDE2NS41NCAyMTMuMzAzIDE2NS4zNzMgMjEzLjg5OCAxNjUuMzIzTDIxNC4xNTggMTY1LjMwNVoiIGZpbGw9IiMyQTMyM0MiLz4KPHBhdGggZD0iTTExMy41NDIgMTI1LjkzNEMxMTUuNyAxMjUuOTM0IDExNi43OCAxMjYuODM3IDExNi43OCAxMjguNjQzQzExNi43OCAxMzAuNDQ5IDExNS43IDEzMS4zNTIgMTEzLjU0MiAxMzEuMzUySDEwOS4zMTNWMTM3Ljg5NEMxMDkuMzEzIDEzOC45OTYgMTA5LjAwNCAxMzkuODU1IDEwOC4zODggMTQwLjQ3MUMxMDcuNzcxIDE0MS4wNDQgMTA2Ljk1NiAxNDEuMzMgMTA1Ljk0MyAxNDEuMzNDMTA0Ljk3MyAxNDEuMzMgMTA0LjE4IDE0MS4wNDQgMTAzLjU2NCAxNDAuNDcxQzEwMi45NDcgMTM5Ljg1NSAxMDIuNjM5IDEzOC45OTYgMTAyLjYzOSAxMzcuODk0VjEzMS4zNTJIODQuMDcwMUM4My4xMDA5IDEzMS4zNTIgODIuMzUyIDEzMS4wODggODEuODIzNCAxMzAuNTU5QzgxLjI5NDcgMTMwLjAzMSA4MS4wMzA0IDEyOS4zNDggODEuMDMwNCAxMjguNTExQzgxLjAzMDQgMTI3LjYzIDgxLjMxNjggMTI2Ljc3MSA4MS44ODk0IDEyNS45MzRMMTAyLjk2OSA5NS42MDMxQzEwMy42NzQgOTQuNTg5OCAxMDQuNjY1IDk0LjA4MzIgMTA1Ljk0MyA5NC4wODMyQzEwNi44NjggOTQuMDgzMiAxMDcuNjYxIDk0LjM5MTYgMTA4LjMyMSA5NS4wMDgzQzEwOC45ODIgOTUuNTgxIDEwOS4zMTMgOTYuNDE4IDEwOS4zMTMgOTcuNTE5NFYxMjUuOTM0SDExMy41NDJaTTg4LjM2NTMgMTI1LjkzNEgxMDIuNjM5VjEwNS4zMTdMODguMzY1MyAxMjUuOTM0Wk0xMzguMDMyIDE0MS41MjlDMTMyLjYxMyAxNDEuNTI5IDEyOC40NzIgMTM5LjUwMiAxMjUuNjA5IDEzNS40NDlDMTIyLjc4OSAxMzEuMzk2IDEyMS4zNzkgMTI1LjQ5MyAxMjEuMzc5IDExNy43NEMxMjEuMzc5IDEwOS45NDIgMTIyLjc4OSAxMDQuMDE3IDEyNS42MDkgOTkuOTY0M0MxMjguNDcyIDk1LjkxMTQgMTMyLjYxMyA5My44ODUgMTM4LjAzMiA5My44ODVDMTQzLjQ1IDkzLjg4NSAxNDcuNTY5IDk1LjkxMTQgMTUwLjM4OSA5OS45NjQzQzE1My4yNTIgMTAzLjk3MyAxNTQuNjg0IDEwOS44NzYgMTU0LjY4NCAxMTcuNjc0QzE1NC42ODQgMTI1LjQ3MSAxNTMuMjUyIDEzMS4zOTYgMTUwLjM4OSAxMzUuNDQ5QzE0Ny41NjkgMTM5LjUwMiAxNDMuNDUgMTQxLjUyOSAxMzguMDMyIDE0MS41MjlaTTEzOC4wMzIgMTM2LjA0NEMxNDEuNDI0IDEzNi4wNDQgMTQzLjkxMyAxMzQuNTY4IDE0NS40OTkgMTMxLjYxN0MxNDcuMDg1IDEyOC42NjUgMTQ3Ljg3OCAxMjQuMDE3IDE0Ny44NzggMTE3LjY3NEMxNDcuODc4IDExMS4zMyAxNDcuMDg1IDEwNi43MDQgMTQ1LjQ5OSAxMDMuNzk3QzE0My45MTMgMTAwLjg0NSAxNDEuNDI0IDk5LjM2OTYgMTM4LjAzMiA5OS4zNjk2QzEzNC42NCA5OS4zNjk2IDEzMi4xNSAxMDAuODQ1IDEzMC41NjUgMTAzLjc5N0MxMjguOTc5IDEwNi43MDQgMTI4LjE4NiAxMTEuMzMgMTI4LjE4NiAxMTcuNjc0QzEyOC4xODYgMTIzLjk3MyAxMjguOTc5IDEyOC42MjEgMTMwLjU2NSAxMzEuNjE3QzEzMi4xNSAxMzQuNTY4IDEzNC42NCAxMzYuMDQ0IDEzOC4wMzIgMTM2LjA0NFpNMTkwLjYwNSAxMzUuMzgzQzE5MS42NjMgMTM1LjM4MyAxOTIuNDU2IDEzNS42MjUgMTkyLjk4NCAxMzYuMTFDMTkzLjUxMyAxMzYuNTk1IDE5My43NzcgMTM3LjI3NyAxOTMuNzc3IDEzOC4xNTlDMTkzLjc3NyAxNDAuMDUzIDE5Mi43MiAxNDEgMTkwLjYwNSAxNDFIMTY4LjUzNUMxNjYuMzc2IDE0MSAxNjUuMjk3IDE0MC4wNTMgMTY1LjI5NyAxMzguMTU5QzE2NS4yOTcgMTM3LjI3NyAxNjUuNTYxIDEzNi41OTUgMTY2LjA5IDEzNi4xMUMxNjYuNjYyIDEzNS42MjUgMTY3LjQ3NyAxMzUuMzgzIDE2OC41MzUgMTM1LjM4M0gxNzYuMTM0VjEwMi40MDlMMTY5LjMyOCAxMDYuNzA0QzE2OC44ODcgMTA2Ljk2OSAxNjguNDQ3IDEwNy4xMDEgMTY4LjAwNiAxMDcuMTAxQzE2Ny4yNTcgMTA3LjEwMSAxNjYuNTk2IDEwNi43NzEgMTY2LjAyNCAxMDYuMTFDMTY1LjQ5NSAxMDUuNDQ5IDE2NS4yMzEgMTA0LjcgMTY1LjIzMSAxMDMuODYzQzE2NS4yMzEgMTAyLjg1IDE2NS42NzEgMTAyLjA1NyAxNjYuNTUyIDEwMS40ODRMMTc2LjcyOSA5NS4wMDgzQzE3Ny43NDIgOTQuMzkxNiAxNzguNzExIDk0LjA4MzIgMTc5LjYzNiA5NC4wODMyQzE4MC42MDUgOTQuMDgzMiAxODEuMzk4IDk0LjM5MTYgMTgyLjAxNSA5NS4wMDgzQzE4Mi42MzIgOTUuNjI1MSAxODIuOTQgOTYuNDYyMSAxODIuOTQgOTcuNTE5NFYxMzUuMzgzSDE5MC42MDVaIiBmaWxsPSIjRkRDMDAwIi8+Cjwvc3ZnPgo=", aze = "_unauthorized_1ah0w_1", sze = "_title_1ah0w_11", uze = "_subtitle_1ah0w_17", lze = "_image_1ah0w_22", xI = {
  unauthorized: aze,
  title: sze,
  subtitle: uze,
  image: lze
}, nue = ({
  primaryMessage: e = "Permission Denied",
  secondaryMessage: t = "Unfortunately you don't have permission to access this page. Please try logging in again or refresh the page."
}) => /* @__PURE__ */ pe.jsxs("div", { className: xI.unauthorized, children: [
  /* @__PURE__ */ pe.jsx(
    "img",
    {
      src: oze,
      className: xI.image,
      alt: "Permission Denied. Unauthorized User."
    }
  ),
  /* @__PURE__ */ pe.jsx("span", { className: xI.title, children: e }),
  /* @__PURE__ */ pe.jsx("span", { className: xI.subtitle, children: t })
] }), Zve = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjc1IiBoZWlnaHQ9IjI3NSIgdmlld0JveD0iMCAwIDI3NSAyNzUiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjEzNy41IiBjeT0iMTM3LjUiIHI9IjEyNy41IiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSIjRjlGOUY5IiBzdHJva2Utd2lkdGg9IjIwIi8+CjxwYXRoIGQ9Ik04MSAxNThIMTM4VjE3MEw4MSAxNzNWMTU4WiIgZmlsbD0iI0ZEQjIwMCIvPgo8cGF0aCBkPSJNNzggMTAzSDEyM0MxMzEuMjg0IDEwMyAxMzggMTA5LjcxNiAxMzggMTE4VjE2OUg3OFYxMDNaIiBmaWxsPSIjRkVEOTY2Ii8+CjxwYXRoIGQ9Ik0xMzggMTczQzE0MS44NjYgMTczIDE0NSAxNzEuMjA5IDE0NSAxNjlIMTMxQzEzMSAxNzEuMjA5IDEzNC4xMzQgMTczIDEzOCAxNzNaIiBmaWxsPSIjRkU4RDAwIi8+CjxwYXRoIGQ9Ik0xOTYgMTcyTDEzOCAxNjlMMTM4IDE2MUwxOTYgMTU4TDE5NiAxNzJaIiBmaWxsPSIjRkVEOTY2Ii8+CjxwYXRoIGQ9Ik0xMzggMTE4QzEzOCAxMDkuNzE2IDE0NC43MTYgMTAzIDE1MyAxMDNIMTk4VjE2OUgxMzhWMTE4WiIgZmlsbD0iI0ZEQzAwMCIvPgo8cGF0aCBkPSJNMTc3IDExNy40MUwxNzUuNTkgMTE2TDE3MCAxMjEuNTlMMTY0LjQxIDExNkwxNjMgMTE3LjQxTDE2OC41OSAxMjNMMTYzIDEyOC41OUwxNjQuNDEgMTMwTDE3MCAxMjQuNDFMMTc1LjU5IDEzMEwxNzcgMTI4LjU5TDE3MS40MSAxMjNMMTc3IDExNy40MVoiIGZpbGw9IiNGRUVDQjIiLz4KPHJlY3QgeD0iMTU3IiB5PSIxMzkiIHdpZHRoPSIyNSIgaGVpZ2h0PSIzIiBmaWxsPSIjRkVFQ0IyIi8+CjxyZWN0IHg9IjE1NyIgeT0iMTQ3IiB3aWR0aD0iMjUiIGhlaWdodD0iMyIgZmlsbD0iI0ZFRUNCMiIvPgo8cmVjdCB4PSIxNTciIHk9IjE1NSIgd2lkdGg9IjI1IiBoZWlnaHQ9IjMiIGZpbGw9IiNGRUVDQjIiLz4KPHBhdGggZD0iTTExNSAxMTcuNDFMMTEzLjU5IDExNkwxMDggMTIxLjU5TDEwMi40MSAxMTZMMTAxIDExNy40MUwxMDYuNTkgMTIzTDEwMSAxMjguNTlMMTAyLjQxIDEzMEwxMDggMTI0LjQxTDExMy41OSAxMzBMMTE1IDEyOC41OUwxMDkuNDEgMTIzTDExNSAxMTcuNDFaIiBmaWxsPSIjRkU4RDAwIi8+CjxyZWN0IHg9Ijk1IiB5PSIxMzkiIHdpZHRoPSIyNSIgaGVpZ2h0PSIzIiBmaWxsPSIjRkU4RDAwIi8+CjxyZWN0IHg9Ijk1IiB5PSIxNDciIHdpZHRoPSIyNSIgaGVpZ2h0PSIzIiBmaWxsPSIjRkU4RDAwIi8+CjxyZWN0IHg9Ijk1IiB5PSIxNTUiIHdpZHRoPSIyNSIgaGVpZ2h0PSIzIiBmaWxsPSIjRkU4RDAwIi8+Cjwvc3ZnPg==", cze = "_unableToDisplayContainer_17r67_1", fze = "_title_17r67_11", dze = "_subtitle_17r67_17", hze = "_image_17r67_24", wI = {
  unableToDisplayContainer: cze,
  title: fze,
  subtitle: dze,
  image: hze
}, rue = ({
  primaryMessage: e = "Oops, Page Failed To Display",
  secondaryMessage: t = "It seems to be that the page your are looking for has failed to load due to server issues."
}) => /* @__PURE__ */ pe.jsxs("div", { className: wI.unableToDisplayContainer, children: [
  /* @__PURE__ */ pe.jsx(
    "img",
    {
      src: Zve,
      className: wI.image,
      alt: "Server Error. Unable to Display."
    }
  ),
  /* @__PURE__ */ pe.jsx("span", { className: wI.title, children: e }),
  /* @__PURE__ */ pe.jsx("span", { className: wI.subtitle, children: t })
] }), pze = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iOTBweCIgaGVpZ2h0PSIxMjJweCIgdmlld0JveD0iMCAwIDkwIDEyMiIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBza2V0Y2h0b29sIDUxLjIgKDU3NTE5KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT44MzYwNDAyNi1BRkUxLTRENDUtQjNDMS0yOTU4Rjg0N0YwQzM8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIHNrZXRjaHRvb2wuPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IkZhY2UtTWF0Y2giIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJFcnJvci1Mb2FkaW5nLVBhZ2UiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01OTYuMDAwMDAwLCAtMTg5LjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0iZXJyb3ItbG9hZGluZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTk2LjAwMDAwMCwgMTg5LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9InBhcGVyLWNvcm5lciIgZmlsbD0iIzlFQ0ZFRiIgcG9pbnRzPSIxNy45NDk0MjI4IDE3IDE3Ljk0OTQyMjggMSAxLjk0OTQyMjggMTciPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02MSw1OS40NDcyNDEgTDY4LjQ3NDcxMTQsNTEuOTcyNTI5NiBMNjkuODg4OTI1LDUzLjM4Njc0MzEgTDYyLjQxNDIxMzYsNjAuODYxNDU0NSBMNjkuODg4OTI1LDY4LjMzNjE2NTkgTDY4LjQ3NDcxMTQsNjkuNzUwMzc5NSBMNjEsNjIuMjc1NjY4MSBMNTMuNTI1Mjg4Niw2OS43NTAzNzk1IEw1Mi4xMTEwNzUsNjguMzM2MTY1OSBMNTkuNTg1Nzg2NCw2MC44NjE0NTQ1IEw1Mi4xMTEwNzUsNTMuMzg2NzQzMSBMNTMuNTI1Mjg4Niw1MS45NzI1Mjk2IEw2MSw1OS40NDcyNDEgWiBNMjguMjcyNzI3Myw1OS40NDcyNDEgTDM1Ljc0NzQzODcsNTEuOTcyNTI5NiBMMzcuMTYxNjUyMiw1My4zODY3NDMxIEwyOS42ODY5NDA4LDYwLjg2MTQ1NDUgTDM3LjE2MTY1MjIsNjguMzM2MTY1OSBMMzUuNzQ3NDM4Nyw2OS43NTAzNzk1IEwyOC4yNzI3MjczLDYyLjI3NTY2ODEgTDIwLjc5ODAxNTksNjkuNzUwMzc5NSBMMTkuMzgzODAyMyw2OC4zMzYxNjU5IEwyNi44NTg1MTM3LDYwLjg2MTQ1NDUgTDE5LjM4MzgwMjMsNTMuMzg2NzQzMSBMMjAuNzk4MDE1OSw1MS45NzI1Mjk2IEwyOC4yNzI3MjczLDU5LjQ0NzI0MSBaIE0xNy4zNjM2MzY0LDEgTDE5LjM2MzYzNjQsMSBMMTkuMzYzNjM2NCwxOC4zNjM2MzY0IEwyLDE4LjM2MzYzNjQgTDIsMTYuMzYzNjM2NCBMMTcuMzYzNjM2NCwxNi4zNjM2MzY0IEwxNy4zNjM2MzY0LDEgWiBNMzEuODQyOTI1LDg4Ljk3OTgzNDEgTDMwLjQyODcxMTQsODcuNTY1NjIwNSBDMzQuMjQ4NDMxMyw4My43NDU5MDA2IDM5LjM0MjUzMTUsODEuNjc5MDkwOSA0NC42MzU4MTgyLDgxLjY3OTA5MDkgQzQ5LjkyNzM4MjMsODEuNjc5MDkwOSA1NS4wMjM4NjUsODMuNzQ2NTYwNSA1OC44NDI5MjUsODcuNTY1NjIwNSBMNTcuNDI4NzExNCw4OC45Nzk4MzQxIEM1My45ODg1MTE5LDg1LjUzOTYzNDUgNDkuNDAyMTE4OCw4My42NzkwOTA5IDQ0LjYzNTgxODIsODMuNjc5MDkwOSBDMzkuODY3ODMwOCw4My42NzkwOTA5IDM1LjI4MzgxMTYsODUuNTM4OTQ3NCAzMS44NDI5MjUsODguOTc5ODM0MSBaIE04OS4yNzI3MjczLDAgTDg5LjI3MjcyNzMsMTIyIEwwLDEyMiBMMCwxNi45NDk0MjI4IEwxNi45NDk0MjI4LDAgTDg5LjI3MjcyNzMsMCBaIE04Ny4yNzI3MjczLDIgTDE3Ljc3Nzg0OTksMiBMMiwxNy43Nzc4NDk5IEwyLDEyMCBMODcuMjcyNzI3MywxMjAgTDg3LjI3MjcyNzMsMiBaIiBpZD0iZXJyb3Itc3RhdGUtcGFwZXItb3V0bGluZSIgZmlsbD0iIzA2ODZEOCIgZmlsbC1ydWxlPSJub256ZXJvIj48L3BhdGg+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==", gze = "_container_1t28m_1", mze = "_image_1t28m_8", yze = "_title_1t28m_11", vze = "_subtitle_1t28m_17", _I = {
  container: gze,
  image: mze,
  title: yze,
  subtitle: vze
}, bze = ({
  title: e = "Page Not Found",
  subtitle: t = "The page you are looking for has been moved, deleted or doesn't exist."
}) => /* @__PURE__ */ pe.jsxs("div", { className: _I.container, children: [
  /* @__PURE__ */ pe.jsx("img", { src: pze, className: _I.image, alt: "Page Not Found." }),
  /* @__PURE__ */ pe.jsx("span", { className: _I.title, children: e }),
  /* @__PURE__ */ pe.jsx("span", { className: _I.subtitle, children: t })
] }), xze = "_DefaultErrorContainer_14bjq_1", wze = "_title_14bjq_11", _ze = "_subtitle_14bjq_17", Eze = "_image_14bjq_24", Sze = "_wrapper_14bjq_27", CM = {
  DefaultErrorContainer: xze,
  title: wze,
  subtitle: _ze,
  image: Eze,
  wrapper: Sze
}, Mze = ({
  componentsAvailable: e,
  primaryMessage: t = "Something Went Wrong",
  tryAgainMessage: n = "Please try again later.",
  noDataMessage: r = "No Analytics Found"
}) => /* @__PURE__ */ pe.jsxs("div", { className: CM.DefaultErrorContainer, children: [
  /* @__PURE__ */ pe.jsx("img", { src: Zve, className: CM.image, alt: "Error" }),
  e === 0 ? /* @__PURE__ */ pe.jsx("span", { className: CM.title, children: r }) : /* @__PURE__ */ pe.jsxs("div", { className: CM.wrapper, children: [
    /* @__PURE__ */ pe.jsx("span", { className: CM.title, children: t }),
    /* @__PURE__ */ pe.jsx("span", { className: CM.subtitle, children: n })
  ] })
] }), Tze = async (e = "") => {
  try {
    const t = await fetch(e, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    }), n = await t.json(), r = await t.status;
    if (r === 200)
      return { data: n, status: r };
    if (!t.ok)
      return n;
  } catch (t) {
    return console.log("ERROR: ", t), t;
  }
}, Cze = (e) => e.includes("?") ? "&" + e.replace(/[/\?]/g, "") : e, JV = {
  aiwareRoleIds: [""],
  aiwareUserId: "",
  email: "",
  firstName: "",
  lastName: "",
  loaded: {},
  organizationId: "",
  query_string: {
    referrer_app: "",
    sitename: "",
    random: ""
  },
  renders: [],
  route: [""]
}, Nze = [
  {
    componentName: "",
    content: {
      dimensions: [],
      metrics: [],
      settings: {
        dataExport: !1
      },
      title: {
        text: "",
        markdown: ""
      }
    },
    version: ""
  }
], Dze = {
  log: [],
  ui_setting: {
    ai_chat_enabled: !1,
    app_logo_url: ""
  }
}, Aze = {
  response: {
    inputConfig: [{}],
    suggestions: {
      global: [
        {
          label: "",
          suggestion_prompt: {
            messages: [],
            modal: "",
            options: {
              temperature: 0
            },
            prompt_id: 0,
            provider: ""
          },
          suggestion_type: ""
        }
      ]
    }
  },
  session: {
    data: {
      "": ""
    }
  }
}, Oze = {
  accessCode: "",
  aesGcmKey: "",
  createdAt: "",
  endPoint: ""
}, Rze = {
  fontFamily: "Nunito Sans, sans-serif",
  fontSize: "40px",
  fontWeight: 900,
  lineHeight: "110%",
  letterSpacing: "-0.5px",
  paddingTop: "0.5em",
  paddingBottom: "0.25em",
  margin: 0
}, wX = {
  fontFamily: "Nunito Sans, sans-serif",
  fontWeight: 700,
  fontSize: "32px",
  lineHeight: "110%",
  letterSpacing: 0,
  paddingTop: "0.5em",
  paddingBottom: "0.25em",
  margin: 0
}, Jve = {
  fontFamily: "Nunito Sans, sans-serif",
  fontWeight: 600,
  fontSize: "24px",
  lineHeight: "110%",
  letterSpacing: 0,
  paddingTop: "0.5em",
  paddingBottom: "0.25em",
  margin: 0
}, ZU = {
  fontFamily: "Nunito Sans, sans-serif",
  fontWeight: 700,
  fontSize: "16px",
  lineHeight: "140%",
  letterSpacing: 0,
  paddingTop: "0.25em",
  paddingBottom: 0,
  margin: 0
}, kj = {
  fontFamily: "Nunito Sans, sans-serif",
  fontWeight: 400,
  fontSize: "14px",
  lineHeight: "140%",
  letterSpacing: 0
}, kze = {
  fontFamily: "Nunito Sans, sans-serif",
  fontWeight: 600,
  fontSize: "12px",
  lineHeight: "110%",
  letterSpacing: 0,
  color: "#7D7D7D",
  borderBottom: "2px solid #eee",
  padding: "3px 10px 10px 0px",
  zIndex: "1",
  position: "sticky"
  // top: '8px',
}, $ze = {
  borderBottom: "1px solid #eee",
  padding: "3px 10px 3px 0px",
  lineHeight: "1.1",
  zIndex: "0",
  position: "sticky"
}, Pze = "09ee3a74-4339-47ba-9497-71fedffe5e77";
var $j = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
$j.exports;
(function(e, t) {
  (function() {
    var n, r = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", s = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", l = 500, f = "__lodash_placeholder__", h = 1, p = 2, g = 4, y = 1, b = 2, _ = 1, S = 2, C = 4, A = 8, O = 16, R = 32, j = 64, $ = 128, z = 256, W = 512, Y = 30, V = "...", ee = 800, K = 16, Q = 1, q = 2, te = 3, X = 1 / 0, Z = 9007199254740991, se = 17976931348623157e292, H = 0 / 0, ie = 4294967295, he = ie - 1, ye = ie >>> 1, _e = [
      ["ary", $],
      ["bind", _],
      ["bindKey", S],
      ["curry", A],
      ["curryRight", O],
      ["flip", W],
      ["partial", R],
      ["partialRight", j],
      ["rearg", z]
    ], Ne = "[object Arguments]", Oe = "[object Array]", ke = "[object AsyncFunction]", Me = "[object Boolean]", we = "[object Date]", Ye = "[object DOMException]", ze = "[object Error]", fe = "[object Function]", Qe = "[object GeneratorFunction]", $e = "[object Map]", pt = "[object Number]", _t = "[object Null]", Ot = "[object Object]", mn = "[object Promise]", jr = "[object Proxy]", tn = "[object RegExp]", Zt = "[object Set]", qn = "[object String]", fn = "[object Symbol]", gr = "[object Undefined]", Zn = "[object WeakMap]", xr = "[object WeakSet]", Un = "[object ArrayBuffer]", Qt = "[object DataView]", Ut = "[object Float32Array]", er = "[object Float64Array]", We = "[object Int8Array]", ht = "[object Int16Array]", Ft = "[object Int32Array]", _n = "[object Uint8Array]", Dn = "[object Uint8ClampedArray]", di = "[object Uint16Array]", bi = "[object Uint32Array]", ua = /\b__p \+= '';/g, Zr = /\b(__p \+=) '' \+/g, Wa = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Lr = /&(?:amp|lt|gt|quot|#39);/g, Ar = /[&<>"']/g, Ks = RegExp(Lr.source), ws = RegExp(Ar.source), Ql = /<%-([\s\S]+?)%>/g, Lc = /<%([\s\S]+?)%>/g, zc = /<%=([\s\S]+?)%>/g, Xl = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Fc = /^\w*$/, _s = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, as = /[\\^$.*+?()[\]{}|]/g, Es = RegExp(as.source), xa = /^\s+/, la = /\s/, Hi = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ss = /\{\n\/\* \[wrapped with (.+)\] \*/, xe = /,? & /, lt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, St = /[()=,{}\[\]\/\s]/, $t = /\\(\\)?/g, In = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, lr = /\w*$/, zn = /^[-+]0x[0-9a-f]+$/i, sn = /^0b[01]+$/i, No = /^\[object .+?Constructor\]$/, xi = /^0o[0-7]+$/i, wi = /^(?:0|[1-9]\d*)$/, nn = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Oi = /($^)/, lm = /['\n\r\u2028\u2029\\]/g, mr = "\\ud800-\\udfff", Vw = "\\u0300-\\u036f", Kl = "\\ufe20-\\ufe2f", cr = "\\u20d0-\\u20ff", Zl = Vw + Kl + cr, Uf = "\\u2700-\\u27bf", Np = "a-z\\xdf-\\xf6\\xf8-\\xff", qd = "\\xac\\xb1\\xd7\\xf7", Zs = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", vv = "\\u2000-\\u206f", Ss = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cm = "A-Z\\xc0-\\xd6\\xd8-\\xde", fm = "\\ufe0e\\ufe0f", bv = qd + Zs + vv + Ss, Gd = "['’]", Qd = "[" + mr + "]", sl = "[" + bv + "]", wa = "[" + Zl + "]", Yf = "\\d+", Xd = "[" + Uf + "]", Hf = "[" + Np + "]", Dp = "[^" + mr + bv + Yf + Uf + Np + cm + "]", Kd = "\\ud83c[\\udffb-\\udfff]", Vf = "(?:" + wa + "|" + Kd + ")", $b = "[^" + mr + "]", ul = "(?:\\ud83c[\\udde6-\\uddff]){2}", Or = "[\\ud800-\\udbff][\\udc00-\\udfff]", Jl = "[" + cm + "]", Zd = "\\u200d", Ap = "(?:" + Hf + "|" + Dp + ")", Rr = "(?:" + Jl + "|" + Dp + ")", Op = "(?:" + Gd + "(?:d|ll|m|re|s|t|ve))?", Rp = "(?:" + Gd + "(?:D|LL|M|RE|S|T|VE))?", jn = Vf + "?", Jd = "[" + fm + "]?", vo = "(?:" + Zd + "(?:" + [$b, ul, Or].join("|") + ")" + Jd + jn + ")*", Js = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Ms = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Wf = Jd + jn + vo, Do = "(?:" + [Xd, ul, Or].join("|") + ")" + Wf, ii = "(?:" + [$b + wa + "?", wa, ul, Or, Qd].join("|") + ")", Pb = RegExp(Gd, "g"), eu = RegExp(wa, "g"), Ko = RegExp(Kd + "(?=" + Kd + ")|" + ii + Wf, "g"), Bc = RegExp([
      Jl + "?" + Hf + "+" + Op + "(?=" + [sl, Jl, "$"].join("|") + ")",
      Rr + "+" + Rp + "(?=" + [sl, Jl + Ap, "$"].join("|") + ")",
      Jl + "?" + Ap + "+" + Op,
      Jl + "+" + Rp,
      Ms,
      Js,
      Yf,
      Do
    ].join("|"), "g"), Ib = RegExp("[" + Zd + mr + Zl + fm + "]"), qf = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, eh = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], jb = -1, wr = {};
    wr[Ut] = wr[er] = wr[We] = wr[ht] = wr[Ft] = wr[_n] = wr[Dn] = wr[di] = wr[bi] = !0, wr[Ne] = wr[Oe] = wr[Un] = wr[Me] = wr[Qt] = wr[we] = wr[ze] = wr[fe] = wr[$e] = wr[pt] = wr[Ot] = wr[tn] = wr[Zt] = wr[qn] = wr[Zn] = !1;
    var zr = {};
    zr[Ne] = zr[Oe] = zr[Un] = zr[Qt] = zr[Me] = zr[we] = zr[Ut] = zr[er] = zr[We] = zr[ht] = zr[Ft] = zr[$e] = zr[pt] = zr[Ot] = zr[tn] = zr[Zt] = zr[qn] = zr[fn] = zr[_n] = zr[Dn] = zr[di] = zr[bi] = !0, zr[ze] = zr[fe] = zr[Zn] = !1;
    var th = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, ll = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, dm = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, nh = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, rh = parseFloat, kp = parseInt, $p = typeof wA == "object" && wA && wA.Object === Object && wA, xv = typeof self == "object" && self && self.Object === Object && self, Ri = $p || xv || Function("return this")(), ne = t && !t.nodeType && t, be = ne && !0 && e && !e.nodeType && e, Be = be && be.exports === ne, qe = Be && $p.process, gt = function() {
      try {
        var Ae = be && be.require && be.require("util").types;
        return Ae || qe && qe.binding && qe.binding("util");
      } catch {
      }
    }(), gn = gt && gt.isArrayBuffer, Dt = gt && gt.isDate, dn = gt && gt.isMap, sr = gt && gt.isRegExp, Tr = gt && gt.isSet, _i = gt && gt.isTypedArray;
    function tr(Ae, Ke, Fe) {
      switch (Fe.length) {
        case 0:
          return Ae.call(Ke);
        case 1:
          return Ae.call(Ke, Fe[0]);
        case 2:
          return Ae.call(Ke, Fe[0], Fe[1]);
        case 3:
          return Ae.call(Ke, Fe[0], Fe[1], Fe[2]);
      }
      return Ae.apply(Ke, Fe);
    }
    function ki(Ae, Ke, Fe, It) {
      for (var Yn = -1, qr = Ae == null ? 0 : Ae.length; ++Yn < qr; ) {
        var Zo = Ae[Yn];
        Ke(It, Zo, Fe(Zo), Ae);
      }
      return It;
    }
    function yr(Ae, Ke) {
      for (var Fe = -1, It = Ae == null ? 0 : Ae.length; ++Fe < It && Ke(Ae[Fe], Fe, Ae) !== !1; )
        ;
      return Ae;
    }
    function _r(Ae, Ke) {
      for (var Fe = Ae == null ? 0 : Ae.length; Fe-- && Ke(Ae[Fe], Fe, Ae) !== !1; )
        ;
      return Ae;
    }
    function Uc(Ae, Ke) {
      for (var Fe = -1, It = Ae == null ? 0 : Ae.length; ++Fe < It; )
        if (!Ke(Ae[Fe], Fe, Ae))
          return !1;
      return !0;
    }
    function Eu(Ae, Ke) {
      for (var Fe = -1, It = Ae == null ? 0 : Ae.length, Yn = 0, qr = []; ++Fe < It; ) {
        var Zo = Ae[Fe];
        Ke(Zo, Fe, Ae) && (qr[Yn++] = Zo);
      }
      return qr;
    }
    function ih(Ae, Ke) {
      var Fe = Ae == null ? 0 : Ae.length;
      return !!Fe && Ip(Ae, Ke, 0) > -1;
    }
    function wv(Ae, Ke, Fe) {
      for (var It = -1, Yn = Ae == null ? 0 : Ae.length; ++It < Yn; )
        if (Fe(Ke, Ae[It]))
          return !0;
      return !1;
    }
    function kr(Ae, Ke) {
      for (var Fe = -1, It = Ae == null ? 0 : Ae.length, Yn = Array(It); ++Fe < It; )
        Yn[Fe] = Ke(Ae[Fe], Fe, Ae);
      return Yn;
    }
    function cl(Ae, Ke) {
      for (var Fe = -1, It = Ke.length, Yn = Ae.length; ++Fe < It; )
        Ae[Yn + Fe] = Ke[Fe];
      return Ae;
    }
    function Pp(Ae, Ke, Fe, It) {
      var Yn = -1, qr = Ae == null ? 0 : Ae.length;
      for (It && qr && (Fe = Ae[++Yn]); ++Yn < qr; )
        Fe = Ke(Fe, Ae[Yn], Yn, Ae);
      return Fe;
    }
    function Ww(Ae, Ke, Fe, It) {
      var Yn = Ae == null ? 0 : Ae.length;
      for (It && Yn && (Fe = Ae[--Yn]); Yn--; )
        Fe = Ke(Fe, Ae[Yn], Yn, Ae);
      return Fe;
    }
    function qw(Ae, Ke) {
      for (var Fe = -1, It = Ae == null ? 0 : Ae.length; ++Fe < It; )
        if (Ke(Ae[Fe], Fe, Ae))
          return !0;
      return !1;
    }
    var WN = Ev("length");
    function Gw(Ae) {
      return Ae.split("");
    }
    function Qw(Ae) {
      return Ae.match(lt) || [];
    }
    function Xw(Ae, Ke, Fe) {
      var It;
      return Fe(Ae, function(Yn, qr, Zo) {
        if (Ke(Yn, qr, Zo))
          return It = qr, !1;
      }), It;
    }
    function _v(Ae, Ke, Fe, It) {
      for (var Yn = Ae.length, qr = Fe + (It ? 1 : -1); It ? qr-- : ++qr < Yn; )
        if (Ke(Ae[qr], qr, Ae))
          return qr;
      return -1;
    }
    function Ip(Ae, Ke, Fe) {
      return Ke === Ke ? bm(Ae, Ke, Fe) : _v(Ae, Yc, Fe);
    }
    function Kw(Ae, Ke, Fe, It) {
      for (var Yn = Fe - 1, qr = Ae.length; ++Yn < qr; )
        if (It(Ae[Yn], Ke))
          return Yn;
      return -1;
    }
    function Yc(Ae) {
      return Ae !== Ae;
    }
    function b2(Ae, Ke) {
      var Fe = Ae == null ? 0 : Ae.length;
      return Fe ? pm(Ae, Ke) / Fe : H;
    }
    function Ev(Ae) {
      return function(Ke) {
        return Ke == null ? n : Ke[Ae];
      };
    }
    function hm(Ae) {
      return function(Ke) {
        return Ae == null ? n : Ae[Ke];
      };
    }
    function Lb(Ae, Ke, Fe, It, Yn) {
      return Yn(Ae, function(qr, Zo, oi) {
        Fe = It ? (It = !1, qr) : Ke(Fe, qr, Zo, oi);
      }), Fe;
    }
    function qN(Ae, Ke) {
      var Fe = Ae.length;
      for (Ae.sort(Ke); Fe--; )
        Ae[Fe] = Ae[Fe].value;
      return Ae;
    }
    function pm(Ae, Ke) {
      for (var Fe, It = -1, Yn = Ae.length; ++It < Yn; ) {
        var qr = Ke(Ae[It]);
        qr !== n && (Fe = Fe === n ? qr : Fe + qr);
      }
      return Fe;
    }
    function zb(Ae, Ke) {
      for (var Fe = -1, It = Array(Ae); ++Fe < Ae; )
        It[Fe] = Ke(Fe);
      return It;
    }
    function tu(Ae, Ke) {
      return kr(Ke, function(Fe) {
        return [Fe, Ae[Fe]];
      });
    }
    function Hc(Ae) {
      return Ae && Ae.slice(0, Ub(Ae) + 1).replace(xa, "");
    }
    function Wr(Ae) {
      return function(Ke) {
        return Ae(Ke);
      };
    }
    function Su(Ae, Ke) {
      return kr(Ke, function(Fe) {
        return Ae[Fe];
      });
    }
    function ec(Ae, Ke) {
      return Ae.has(Ke);
    }
    function Sv(Ae, Ke) {
      for (var Fe = -1, It = Ae.length; ++Fe < It && Ip(Ke, Ae[Fe], 0) > -1; )
        ;
      return Fe;
    }
    function Zw(Ae, Ke) {
      for (var Fe = Ae.length; Fe-- && Ip(Ke, Ae[Fe], 0) > -1; )
        ;
      return Fe;
    }
    function gm(Ae, Ke) {
      for (var Fe = Ae.length, It = 0; Fe--; )
        Ae[Fe] === Ke && ++It;
      return It;
    }
    var x2 = hm(th), w2 = hm(ll);
    function Fb(Ae) {
      return "\\" + nh[Ae];
    }
    function mm(Ae, Ke) {
      return Ae == null ? n : Ae[Ke];
    }
    function ym(Ae) {
      return Ib.test(Ae);
    }
    function GN(Ae) {
      return qf.test(Ae);
    }
    function _2(Ae) {
      for (var Ke, Fe = []; !(Ke = Ae.next()).done; )
        Fe.push(Ke.value);
      return Fe;
    }
    function Bb(Ae) {
      var Ke = -1, Fe = Array(Ae.size);
      return Ae.forEach(function(It, Yn) {
        Fe[++Ke] = [Yn, It];
      }), Fe;
    }
    function Jw(Ae, Ke) {
      return function(Fe) {
        return Ae(Ke(Fe));
      };
    }
    function fl(Ae, Ke) {
      for (var Fe = -1, It = Ae.length, Yn = 0, qr = []; ++Fe < It; ) {
        var Zo = Ae[Fe];
        (Zo === Ke || Zo === f) && (Ae[Fe] = f, qr[Yn++] = Fe);
      }
      return qr;
    }
    function Gf(Ae) {
      var Ke = -1, Fe = Array(Ae.size);
      return Ae.forEach(function(It) {
        Fe[++Ke] = It;
      }), Fe;
    }
    function vm(Ae) {
      var Ke = -1, Fe = Array(Ae.size);
      return Ae.forEach(function(It) {
        Fe[++Ke] = [It, It];
      }), Fe;
    }
    function bm(Ae, Ke, Fe) {
      for (var It = Fe - 1, Yn = Ae.length; ++It < Yn; )
        if (Ae[It] === Ke)
          return It;
      return -1;
    }
    function E2(Ae, Ke, Fe) {
      for (var It = Fe + 1; It--; )
        if (Ae[It] === Ke)
          return It;
      return It;
    }
    function oh(Ae) {
      return ym(Ae) ? M2(Ae) : WN(Ae);
    }
    function Mu(Ae) {
      return ym(Ae) ? T2(Ae) : Gw(Ae);
    }
    function Ub(Ae) {
      for (var Ke = Ae.length; Ke-- && la.test(Ae.charAt(Ke)); )
        ;
      return Ke;
    }
    var S2 = hm(dm);
    function M2(Ae) {
      for (var Ke = Ko.lastIndex = 0; Ko.test(Ae); )
        ++Ke;
      return Ke;
    }
    function T2(Ae) {
      return Ae.match(Ko) || [];
    }
    function QN(Ae) {
      return Ae.match(Bc) || [];
    }
    var XN = function Ae(Ke) {
      Ke = Ke == null ? Ri : xm.defaults(Ri.Object(), Ke, xm.pick(Ri, eh));
      var Fe = Ke.Array, It = Ke.Date, Yn = Ke.Error, qr = Ke.Function, Zo = Ke.Math, oi = Ke.Object, tc = Ke.RegExp, Yb = Ke.String, Tu = Ke.TypeError, nu = Fe.prototype, e_ = qr.prototype, Vc = oi.prototype, wm = Ke["__core-js_shared__"], Mv = e_.toString, Gr = Vc.hasOwnProperty, jp = 0, Hb = function() {
        var w = /[^.]+$/.exec(wm && wm.keys && wm.keys.IE_PROTO || "");
        return w ? "Symbol(src)_1." + w : "";
      }(), _m = Vc.toString, _a = Mv.call(oi), t_ = Ri._, C2 = tc(
        "^" + Mv.call(Gr).replace(as, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Tv = Be ? Ke.Buffer : n, Qf = Ke.Symbol, Cv = Ke.Uint8Array, n_ = Tv ? Tv.allocUnsafe : n, dl = Jw(oi.getPrototypeOf, oi), Em = oi.create, ah = Vc.propertyIsEnumerable, Vb = nu.splice, Sm = Qf ? Qf.isConcatSpreadable : n, Xf = Qf ? Qf.iterator : n, Lp = Qf ? Qf.toStringTag : n, Nv = function() {
        try {
          var w = ef(oi, "defineProperty");
          return w({}, "", {}), w;
        } catch {
        }
      }(), Wb = Ke.clearTimeout !== Ri.clearTimeout && Ke.clearTimeout, $i = It && It.now !== Ri.Date.now && It.now, sh = Ke.setTimeout !== Ri.setTimeout && Ke.setTimeout, hl = Zo.ceil, Kf = Zo.floor, qb = oi.getOwnPropertySymbols, Gb = Tv ? Tv.isBuffer : n, Mm = Ke.isFinite, Dv = nu.join, zp = Jw(oi.keys, oi), zo = Zo.max, Ea = Zo.min, KN = It.now, r_ = Ke.parseInt, Av = Zo.random, Qb = nu.reverse, Ov = ef(Ke, "DataView"), nc = ef(Ke, "Map"), Fp = ef(Ke, "Promise"), pl = ef(Ke, "Set"), Tm = ef(Ke, "WeakMap"), Bp = ef(oi, "create"), Cm = Tm && new Tm(), Nm = {}, uh = Ah(Ov), rc = Ah(nc), Rv = Ah(Fp), lh = Ah(pl), Wc = Ah(Tm), qc = Qf ? Qf.prototype : n, Cu = qc ? qc.valueOf : n, Xb = qc ? qc.toString : n;
      function ue(w) {
        if (Yo(w) && !ir(w) && !(w instanceof nr)) {
          if (w instanceof us)
            return w;
          if (Gr.call(w, "__wrapped__"))
            return w_(w);
        }
        return new us(w);
      }
      var ch = function() {
        function w() {
        }
        return function(M) {
          if (!Po(M))
            return {};
          if (Em)
            return Em(M);
          w.prototype = M;
          var P = new w();
          return w.prototype = n, P;
        };
      }();
      function Ts() {
      }
      function us(w, M) {
        this.__wrapped__ = w, this.__actions__ = [], this.__chain__ = !!M, this.__index__ = 0, this.__values__ = n;
      }
      ue.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Ql,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Lc,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: zc,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: ue
        }
      }, ue.prototype = Ts.prototype, ue.prototype.constructor = ue, us.prototype = ch(Ts.prototype), us.prototype.constructor = us;
      function nr(w) {
        this.__wrapped__ = w, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ie, this.__views__ = [];
      }
      function cn() {
        var w = new nr(this.__wrapped__);
        return w.__actions__ = da(this.__actions__), w.__dir__ = this.__dir__, w.__filtered__ = this.__filtered__, w.__iteratees__ = da(this.__iteratees__), w.__takeCount__ = this.__takeCount__, w.__views__ = da(this.__views__), w;
      }
      function fh() {
        if (this.__filtered__) {
          var w = new nr(this);
          w.__dir__ = -1, w.__filtered__ = !0;
        } else
          w = this.clone(), w.__dir__ *= -1;
        return w;
      }
      function no() {
        var w = this.__wrapped__.value(), M = this.__dir__, P = ir(w), U = M < 0, re = P ? w.length : 0, ce = Zv(0, re, this.__views__), ve = ce.start, Se = ce.end, Re = Se - ve, st = U ? Se : ve - 1, rt = this.__iteratees__, ct = rt.length, Nt = 0, Gt = Ea(Re, this.__takeCount__);
        if (!P || !U && re == Re && Gt == Re)
          return zv(w, this.__actions__);
        var Sn = [];
        e:
          for (; Re-- && Nt < Gt; ) {
            st += M;
            for (var ur = -1, Rn = w[st]; ++ur < ct; ) {
              var Sr = rt[ur], $r = Sr.iteratee, uu = Sr.type, wo = $r(Rn);
              if (uu == q)
                Rn = wo;
              else if (!wo) {
                if (uu == Q)
                  continue e;
                break e;
              }
            }
            Sn[Nt++] = Rn;
          }
        return Sn;
      }
      nr.prototype = ch(Ts.prototype), nr.prototype.constructor = nr;
      function Tn(w) {
        var M = -1, P = w == null ? 0 : w.length;
        for (this.clear(); ++M < P; ) {
          var U = w[M];
          this.set(U[0], U[1]);
        }
      }
      function Jr() {
        this.__data__ = Bp ? Bp(null) : {}, this.size = 0;
      }
      function ai(w) {
        var M = this.has(w) && delete this.__data__[w];
        return this.size -= M ? 1 : 0, M;
      }
      function Gc(w) {
        var M = this.__data__;
        if (Bp) {
          var P = M[w];
          return P === u ? n : P;
        }
        return Gr.call(M, w) ? M[w] : n;
      }
      function An(w) {
        var M = this.__data__;
        return Bp ? M[w] !== n : Gr.call(M, w);
      }
      function Ao(w, M) {
        var P = this.__data__;
        return this.size += this.has(w) ? 0 : 1, P[w] = Bp && M === n ? u : M, this;
      }
      Tn.prototype.clear = Jr, Tn.prototype.delete = ai, Tn.prototype.get = Gc, Tn.prototype.has = An, Tn.prototype.set = Ao;
      function Oo(w) {
        var M = -1, P = w == null ? 0 : w.length;
        for (this.clear(); ++M < P; ) {
          var U = w[M];
          this.set(U[0], U[1]);
        }
      }
      function gl() {
        this.__data__ = [], this.size = 0;
      }
      function ao(w) {
        var M = this.__data__, P = cs(M, w);
        if (P < 0)
          return !1;
        var U = M.length - 1;
        return P == U ? M.pop() : Vb.call(M, P, 1), --this.size, !0;
      }
      function ml(w) {
        var M = this.__data__, P = cs(M, w);
        return P < 0 ? n : M[P][1];
      }
      function dh(w) {
        return cs(this.__data__, w) > -1;
      }
      function kv(w, M) {
        var P = this.__data__, U = cs(P, w);
        return U < 0 ? (++this.size, P.push([w, M])) : P[U][1] = M, this;
      }
      Oo.prototype.clear = gl, Oo.prototype.delete = ao, Oo.prototype.get = ml, Oo.prototype.has = dh, Oo.prototype.set = kv;
      function yl(w) {
        var M = -1, P = w == null ? 0 : w.length;
        for (this.clear(); ++M < P; ) {
          var U = w[M];
          this.set(U[0], U[1]);
        }
      }
      function N2() {
        this.size = 0, this.__data__ = {
          hash: new Tn(),
          map: new (nc || Oo)(),
          string: new Tn()
        };
      }
      function Nu(w) {
        var M = h1(this, w).delete(w);
        return this.size -= M ? 1 : 0, M;
      }
      function Sa(w) {
        return h1(this, w).get(w);
      }
      function $v(w) {
        return h1(this, w).has(w);
      }
      function i_(w, M) {
        var P = h1(this, w), U = P.size;
        return P.set(w, M), this.size += P.size == U ? 0 : 1, this;
      }
      yl.prototype.clear = N2, yl.prototype.delete = Nu, yl.prototype.get = Sa, yl.prototype.has = $v, yl.prototype.set = i_;
      function Zf(w) {
        var M = -1, P = w == null ? 0 : w.length;
        for (this.__data__ = new yl(); ++M < P; )
          this.add(w[M]);
      }
      function ru(w) {
        return this.__data__.set(w, u), this;
      }
      function hh(w) {
        return this.__data__.has(w);
      }
      Zf.prototype.add = Zf.prototype.push = ru, Zf.prototype.has = hh;
      function so(w) {
        var M = this.__data__ = new Oo(w);
        this.size = M.size;
      }
      function Up() {
        this.__data__ = new Oo(), this.size = 0;
      }
      function Dm(w) {
        var M = this.__data__, P = M.delete(w);
        return this.size = M.size, P;
      }
      function iu(w) {
        return this.__data__.get(w);
      }
      function ls(w) {
        return this.__data__.has(w);
      }
      function vl(w, M) {
        var P = this.__data__;
        if (P instanceof Oo) {
          var U = P.__data__;
          if (!nc || U.length < i - 1)
            return U.push([w, M]), this.size = ++P.size, this;
          P = this.__data__ = new yl(U);
        }
        return P.set(w, M), this.size = P.size, this;
      }
      so.prototype.clear = Up, so.prototype.delete = Dm, so.prototype.get = iu, so.prototype.has = ls, so.prototype.set = vl;
      function Ma(w, M) {
        var P = ir(w), U = !P && s0(w), re = !P && !U && jh(w), ce = !P && !U && !re && ry(w), ve = P || U || re || ce, Se = ve ? zb(w.length, Yb) : [], Re = Se.length;
        for (var st in w)
          (M || Gr.call(w, st)) && !(ve && // Safari 9 has enumerable `arguments.length` in strict mode.
          (st == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          re && (st == "offset" || st == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ce && (st == "buffer" || st == "byteLength" || st == "byteOffset") || // Skip index properties.
          ku(st, Re))) && Se.push(st);
        return Se;
      }
      function Qc(w) {
        var M = w.length;
        return M ? w[au(0, M - 1)] : n;
      }
      function Du(w, M) {
        return Pu(da(w), Xc(M, 0, w.length));
      }
      function o_(w) {
        return Pu(da(w));
      }
      function Am(w, M, P) {
        (P !== n && !dd(w[M], P) || P === n && !(M in w)) && ic(w, M, P);
      }
      function Yp(w, M, P) {
        var U = w[M];
        (!(Gr.call(w, M) && dd(U, P)) || P === n && !(M in w)) && ic(w, M, P);
      }
      function cs(w, M) {
        for (var P = w.length; P--; )
          if (dd(w[P][0], M))
            return P;
        return -1;
      }
      function ou(w, M, P, U) {
        return Kc(w, function(re, ce, ve) {
          M(U, re, P(re), ve);
        }), U;
      }
      function Vi(w, M) {
        return w && qa(M, ms(M), w);
      }
      function bl(w, M) {
        return w && qa(M, Ml(M), w);
      }
      function ic(w, M, P) {
        M == "__proto__" && Nv ? Nv(w, M, {
          configurable: !0,
          enumerable: !0,
          value: P,
          writable: !0
        }) : w[M] = P;
      }
      function Kb(w, M) {
        for (var P = -1, U = M.length, re = Fe(U), ce = w == null; ++P < U; )
          re[P] = ce ? n : bD(w, M[P]);
        return re;
      }
      function Xc(w, M, P) {
        return w === w && (P !== n && (w = w <= P ? w : P), M !== n && (w = w >= M ? w : M)), w;
      }
      function Cs(w, M, P, U, re, ce) {
        var ve, Se = M & h, Re = M & p, st = M & g;
        if (P && (ve = re ? P(w, U, re, ce) : P(w)), ve !== n)
          return ve;
        if (!Po(w))
          return w;
        var rt = ir(w);
        if (rt) {
          if (ve = pa(w), !Se)
            return da(w, ve);
        } else {
          var ct = ho(w), Nt = ct == fe || ct == Qe;
          if (jh(w))
            return Bv(w, Se);
          if (ct == Ot || ct == Ne || Nt && !re) {
            if (ve = Re || Nt ? {} : Ym(w), !Se)
              return Re ? ZN(w, bl(ve, w)) : su(w, Vi(ve, w));
          } else {
            if (!zr[ct])
              return re ? w : {};
            ve = ds(w, ct, Se);
          }
        }
        ce || (ce = new so());
        var Gt = ce.get(w);
        if (Gt)
          return Gt;
        ce.set(w, ve), gD(w) ? w.forEach(function(Rn) {
          ve.add(Cs(Rn, M, P, Rn, w, ce));
        }) : pD(w) && w.forEach(function(Rn, Sr) {
          ve.set(Sr, Cs(Rn, M, P, Sr, w, ce));
        });
        var Sn = st ? Re ? ld : Bm : Re ? Ml : ms, ur = rt ? n : Sn(w);
        return yr(ur || w, function(Rn, Sr) {
          ur && (Sr = Rn, Rn = w[Sr]), Yp(ve, Sr, Cs(Rn, M, P, Sr, w, ce));
        }), ve;
      }
      function D2(w) {
        var M = ms(w);
        return function(P) {
          return Pv(P, w, M);
        };
      }
      function Pv(w, M, P) {
        var U = P.length;
        if (w == null)
          return !U;
        for (w = oi(w); U--; ) {
          var re = P[U], ce = M[re], ve = w[re];
          if (ve === n && !(re in w) || !ce(ve))
            return !1;
        }
        return !0;
      }
      function a_(w, M, P) {
        if (typeof w != "function")
          throw new Tu(a);
        return tf(function() {
          w.apply(n, P);
        }, M);
      }
      function Pi(w, M, P, U) {
        var re = -1, ce = ih, ve = !0, Se = w.length, Re = [], st = M.length;
        if (!Se)
          return Re;
        P && (M = kr(M, Wr(P))), U ? (ce = wv, ve = !1) : M.length >= i && (ce = ec, ve = !1, M = new Zf(M));
        e:
          for (; ++re < Se; ) {
            var rt = w[re], ct = P == null ? rt : P(rt);
            if (rt = U || rt !== 0 ? rt : 0, ve && ct === ct) {
              for (var Nt = st; Nt--; )
                if (M[Nt] === ct)
                  continue e;
              Re.push(rt);
            } else
              ce(M, ct, U) || Re.push(rt);
          }
        return Re;
      }
      var Kc = Wv(Ii), Iv = Wv(Ct, !0);
      function Au(w, M) {
        var P = !0;
        return Kc(w, function(U, re, ce) {
          return P = !!M(U, re, ce), P;
        }), P;
      }
      function Ou(w, M, P) {
        for (var U = -1, re = w.length; ++U < re; ) {
          var ce = w[U], ve = M(ce);
          if (ve != null && (Se === n ? ve === ve && !Cr(ve) : P(ve, Se)))
            var Se = ve, Re = ce;
        }
        return Re;
      }
      function Zb(w, M, P, U) {
        var re = w.length;
        for (P = Jn(P), P < 0 && (P = -P > re ? 0 : re + P), U = U === n || U > re ? re : Jn(U), U < 0 && (U += re), U = P > U ? 0 : l0(U); P < U; )
          w[P++] = M;
        return w;
      }
      function Jf(w, M) {
        var P = [];
        return Kc(w, function(U, re, ce) {
          M(U, re, ce) && P.push(U);
        }), P;
      }
      function ca(w, M, P, U, re) {
        var ce = -1, ve = w.length;
        for (P || (P = g_), re || (re = []); ++ce < ve; ) {
          var Se = w[ce];
          M > 0 && P(Se) ? M > 1 ? ca(Se, M - 1, P, U, re) : cl(re, Se) : U || (re[re.length] = Se);
        }
        return re;
      }
      var jv = Gp(), ed = Gp(!0);
      function Ii(w, M) {
        return w && jv(w, M, ms);
      }
      function Ct(w, M) {
        return w && ed(w, M, ms);
      }
      function uo(w, M) {
        return Eu(M, function(P) {
          return Lh(w[P]);
        });
      }
      function bo(w, M) {
        M = sc(M, w);
        for (var P = 0, U = M.length; w != null && P < U; )
          w = w[Ds(M[P++])];
        return P && P == U ? w : n;
      }
      function Jb(w, M, P) {
        var U = M(w);
        return ir(w) ? U : cl(U, P(w));
      }
      function fs(w) {
        return w == null ? w === n ? gr : _t : Lp && Lp in oi(w) ? p_(w) : g1(w);
      }
      function oc(w, M) {
        return w > M;
      }
      function ph(w, M) {
        return w != null && Gr.call(w, M);
      }
      function s_(w, M) {
        return w != null && M in oi(w);
      }
      function fa(w, M, P) {
        return w >= Ea(M, P) && w < zo(M, P);
      }
      function ac(w, M, P) {
        for (var U = P ? wv : ih, re = w[0].length, ce = w.length, ve = ce, Se = Fe(ce), Re = 1 / 0, st = []; ve--; ) {
          var rt = w[ve];
          ve && M && (rt = kr(rt, Wr(M))), Re = Ea(rt.length, Re), Se[ve] = !P && (M || re >= 120 && rt.length >= 120) ? new Zf(ve && rt) : n;
        }
        rt = w[0];
        var ct = -1, Nt = Se[0];
        e:
          for (; ++ct < re && st.length < Re; ) {
            var Gt = rt[ct], Sn = M ? M(Gt) : Gt;
            if (Gt = P || Gt !== 0 ? Gt : 0, !(Nt ? ec(Nt, Sn) : U(st, Sn, P))) {
              for (ve = ce; --ve; ) {
                var ur = Se[ve];
                if (!(ur ? ec(ur, Sn) : U(w[ve], Sn, P)))
                  continue e;
              }
              Nt && Nt.push(Sn), st.push(Gt);
            }
          }
        return st;
      }
      function gh(w, M, P, U) {
        return Ii(w, function(re, ce, ve) {
          M(U, P(re), ce, ve);
        }), U;
      }
      function mh(w, M, P) {
        M = sc(M, w), w = lc(w, M);
        var U = w == null ? w : w[Ds(ma(M))];
        return U == null ? n : tr(U, w, P);
      }
      function e1(w) {
        return Yo(w) && fs(w) == Ne;
      }
      function yh(w) {
        return Yo(w) && fs(w) == Un;
      }
      function Hp(w) {
        return Yo(w) && fs(w) == we;
      }
      function Om(w, M, P, U, re) {
        return w === M ? !0 : w == null || M == null || !Yo(w) && !Yo(M) ? w !== w && M !== M : u_(w, M, P, U, Om, re);
      }
      function u_(w, M, P, U, re, ce) {
        var ve = ir(w), Se = ir(M), Re = ve ? Oe : ho(w), st = Se ? Oe : ho(M);
        Re = Re == Ne ? Ot : Re, st = st == Ne ? Ot : st;
        var rt = Re == Ot, ct = st == Ot, Nt = Re == st;
        if (Nt && jh(w)) {
          if (!jh(M))
            return !1;
          ve = !0, rt = !1;
        }
        if (Nt && !rt)
          return ce || (ce = new so()), ve || ry(w) ? Xp(w, M, P, U, re, ce) : h_(w, M, Re, P, U, re, ce);
        if (!(P & y)) {
          var Gt = rt && Gr.call(w, "__wrapped__"), Sn = ct && Gr.call(M, "__wrapped__");
          if (Gt || Sn) {
            var ur = Gt ? w.value() : w, Rn = Sn ? M.value() : M;
            return ce || (ce = new so()), re(ur, Rn, P, U, ce);
          }
        }
        return Nt ? (ce || (ce = new so()), $2(w, M, P, U, re, ce)) : !1;
      }
      function t1(w) {
        return Yo(w) && ho(w) == $e;
      }
      function n1(w, M, P, U) {
        var re = P.length, ce = re, ve = !U;
        if (w == null)
          return !ce;
        for (w = oi(w); re--; ) {
          var Se = P[re];
          if (ve && Se[2] ? Se[1] !== w[Se[0]] : !(Se[0] in w))
            return !1;
        }
        for (; ++re < ce; ) {
          Se = P[re];
          var Re = Se[0], st = w[Re], rt = Se[1];
          if (ve && Se[2]) {
            if (st === n && !(Re in w))
              return !1;
          } else {
            var ct = new so();
            if (U)
              var Nt = U(st, rt, Re, w, M, ct);
            if (!(Nt === n ? Om(rt, st, y | b, U, ct) : Nt))
              return !1;
          }
        }
        return !0;
      }
      function l_(w) {
        if (!Po(w) || Jv(w))
          return !1;
        var M = Lh(w) ? C2 : No;
        return M.test(Ah(w));
      }
      function A2(w) {
        return Yo(w) && fs(w) == tn;
      }
      function r1(w) {
        return Yo(w) && ho(w) == Zt;
      }
      function Rm(w) {
        return Yo(w) && I_(w.length) && !!wr[fs(w)];
      }
      function Lv(w) {
        return typeof w == "function" ? w : w == null ? Tl : typeof w == "object" ? ir(w) ? xl(w[0], w[1]) : km(w) : V_(w);
      }
      function i1(w) {
        if (!Hm(w))
          return zp(w);
        var M = [];
        for (var P in oi(w))
          Gr.call(w, P) && P != "constructor" && M.push(P);
        return M;
      }
      function O2(w) {
        if (!Po(w))
          return I2(w);
        var M = Hm(w), P = [];
        for (var U in w)
          U == "constructor" && (M || !Gr.call(w, U)) || P.push(U);
        return P;
      }
      function vh(w, M) {
        return w < M;
      }
      function c_(w, M) {
        var P = -1, U = Ga(w) ? Fe(w.length) : [];
        return Kc(w, function(re, ce, ve) {
          U[++P] = M(re, ce, ve);
        }), U;
      }
      function km(w) {
        var M = Kv(w);
        return M.length == 1 && M[0][2] ? Wm(M[0][0], M[0][1]) : function(P) {
          return P === w || n1(P, w, M);
        };
      }
      function xl(w, M) {
        return p1(w) && Vm(M) ? Wm(Ds(w), M) : function(P) {
          var U = bD(P, w);
          return U === n && U === M ? I1(P, w) : Om(M, U, y | b);
        };
      }
      function bh(w, M, P, U, re) {
        w !== M && jv(M, function(ce, ve) {
          if (re || (re = new so()), Po(ce))
            $m(w, M, ve, P, bh, U, re);
          else {
            var Se = U ? U(Jo(w, ve), ce, ve + "", w, M, re) : n;
            Se === n && (Se = ce), Am(w, ve, Se);
          }
        }, Ml);
      }
      function $m(w, M, P, U, re, ce, ve) {
        var Se = Jo(w, P), Re = Jo(M, P), st = ve.get(Re);
        if (st) {
          Am(w, P, st);
          return;
        }
        var rt = ce ? ce(Se, Re, P + "", w, M, ve) : n, ct = rt === n;
        if (ct) {
          var Nt = ir(Re), Gt = !Nt && jh(Re), Sn = !Nt && !Gt && ry(Re);
          rt = Re, Nt || Gt || Sn ? ir(Se) ? rt = Se : Uo(Se) ? rt = da(Se) : Gt ? (ct = !1, rt = Bv(Re, !0)) : Sn ? (ct = !1, rt = Yv(Re, !0)) : rt = [] : u0(Re) || s0(Re) ? (rt = Se, s0(Se) ? rt = yD(Se) : (!Po(Se) || Lh(Se)) && (rt = Ym(Re))) : ct = !1;
        }
        ct && (ve.set(Re, rt), re(rt, Re, U, ce, ve), ve.delete(Re)), Am(w, P, rt);
      }
      function xh(w, M) {
        var P = w.length;
        if (P)
          return M += M < 0 ? P : 0, ku(M, P) ? w[M] : n;
      }
      function o1(w, M, P) {
        M.length ? M = kr(M, function(ce) {
          return ir(ce) ? function(ve) {
            return bo(ve, ce.length === 1 ? ce[0] : ce);
          } : ce;
        }) : M = [Tl];
        var U = -1;
        M = kr(M, Wr(un()));
        var re = c_(w, function(ce, ve, Se) {
          var Re = kr(M, function(st) {
            return st(ce);
          });
          return { criteria: Re, index: ++U, value: ce };
        });
        return qN(re, function(ce, ve) {
          return f_(ce, ve, P);
        });
      }
      function wh(w, M) {
        return hn(w, M, function(P, U) {
          return I1(w, U);
        });
      }
      function hn(w, M, P) {
        for (var U = -1, re = M.length, ce = {}; ++U < re; ) {
          var ve = M[U], Se = bo(w, ve);
          P(Se, ve) && Xe(ce, sc(ve, w), Se);
        }
        return ce;
      }
      function fr(w) {
        return function(M) {
          return bo(M, w);
        };
      }
      function pn(w, M, P, U) {
        var re = U ? Kw : Ip, ce = -1, ve = M.length, Se = w;
        for (w === M && (M = da(M)), P && (Se = kr(w, Wr(P))); ++ce < ve; )
          for (var Re = 0, st = M[ce], rt = P ? P(st) : st; (Re = re(Se, rt, Re, U)) > -1; )
            Se !== w && Vb.call(Se, Re, 1), Vb.call(w, Re, 1);
        return w;
      }
      function lo(w, M) {
        for (var P = w ? M.length : 0, U = P - 1; P--; ) {
          var re = M[P];
          if (P == U || re !== ce) {
            var ce = re;
            ku(re) ? Vb.call(w, re, 1) : rd(w, re);
          }
        }
        return w;
      }
      function au(w, M) {
        return w + Kf(Av() * (M - w + 1));
      }
      function a1(w, M, P, U) {
        for (var re = -1, ce = zo(hl((M - w) / (P || 1)), 0), ve = Fe(ce); ce--; )
          ve[U ? ce : ++re] = w, w += P;
        return ve;
      }
      function Pm(w, M) {
        var P = "";
        if (!w || M < 1 || M > Z)
          return P;
        do
          M % 2 && (P += w), M = Kf(M / 2), M && (w += w);
        while (M);
        return P;
      }
      function rr(w, M) {
        return cc(Zp(w, M, Tl), w + "");
      }
      function Vp(w) {
        return Qc(j1(w));
      }
      function ro(w, M) {
        var P = j1(w);
        return Pu(P, Xc(M, 0, P.length));
      }
      function Xe(w, M, P, U) {
        if (!Po(w))
          return w;
        M = sc(M, w);
        for (var re = -1, ce = M.length, ve = ce - 1, Se = w; Se != null && ++re < ce; ) {
          var Re = Ds(M[re]), st = P;
          if (Re === "__proto__" || Re === "constructor" || Re === "prototype")
            return w;
          if (re != ve) {
            var rt = Se[Re];
            st = U ? U(rt, Re, Se) : n, st === n && (st = Po(rt) ? rt : ku(M[re + 1]) ? [] : {});
          }
          Yp(Se, Re, st), Se = Se[Re];
        }
        return w;
      }
      var Er = Cm ? function(w, M) {
        return Cm.set(w, M), w;
      } : Tl, En = Nv ? function(w, M) {
        return Nv(w, "toString", {
          configurable: !0,
          enumerable: !1,
          value: AD(M),
          writable: !0
        });
      } : Tl;
      function Zc(w) {
        return Pu(j1(w));
      }
      function co(w, M, P) {
        var U = -1, re = w.length;
        M < 0 && (M = -M > re ? 0 : re + M), P = P > re ? re : P, P < 0 && (P += re), re = M > P ? 0 : P - M >>> 0, M >>>= 0;
        for (var ce = Fe(re); ++U < re; )
          ce[U] = w[U + M];
        return ce;
      }
      function Wp(w, M) {
        var P;
        return Kc(w, function(U, re, ce) {
          return P = M(U, re, ce), !P;
        }), !!P;
      }
      function Ei(w, M, P) {
        var U = 0, re = w == null ? U : w.length;
        if (typeof M == "number" && M === M && re <= ye) {
          for (; U < re; ) {
            var ce = U + re >>> 1, ve = w[ce];
            ve !== null && !Cr(ve) && (P ? ve <= M : ve < M) ? U = ce + 1 : re = ce;
          }
          return re;
        }
        return td(w, M, Tl, P);
      }
      function td(w, M, P, U) {
        var re = 0, ce = w == null ? 0 : w.length;
        if (ce === 0)
          return 0;
        M = P(M);
        for (var ve = M !== M, Se = M === null, Re = Cr(M), st = M === n; re < ce; ) {
          var rt = Kf((re + ce) / 2), ct = P(w[rt]), Nt = ct !== n, Gt = ct === null, Sn = ct === ct, ur = Cr(ct);
          if (ve)
            var Rn = U || Sn;
          else
            st ? Rn = Sn && (U || Nt) : Se ? Rn = Sn && Nt && (U || !Gt) : Re ? Rn = Sn && Nt && !Gt && (U || !ur) : Gt || ur ? Rn = !1 : Rn = U ? ct <= M : ct < M;
          Rn ? re = rt + 1 : ce = rt;
        }
        return Ea(ce, he);
      }
      function nd(w, M) {
        for (var P = -1, U = w.length, re = 0, ce = []; ++P < U; ) {
          var ve = w[P], Se = M ? M(ve) : ve;
          if (!P || !dd(Se, Re)) {
            var Re = Se;
            ce[re++] = ve === 0 ? 0 : ve;
          }
        }
        return ce;
      }
      function _h(w) {
        return typeof w == "number" ? w : Cr(w) ? H : +w;
      }
      function fo(w) {
        if (typeof w == "string")
          return w;
        if (ir(w))
          return kr(w, fo) + "";
        if (Cr(w))
          return Xb ? Xb.call(w) : "";
        var M = w + "";
        return M == "0" && 1 / w == -X ? "-0" : M;
      }
      function Fo(w, M, P) {
        var U = -1, re = ih, ce = w.length, ve = !0, Se = [], Re = Se;
        if (P)
          ve = !1, re = wv;
        else if (ce >= i) {
          var st = M ? null : ha(w);
          if (st)
            return Gf(st);
          ve = !1, re = ec, Re = new Zf();
        } else
          Re = M ? [] : Se;
        e:
          for (; ++U < ce; ) {
            var rt = w[U], ct = M ? M(rt) : rt;
            if (rt = P || rt !== 0 ? rt : 0, ve && ct === ct) {
              for (var Nt = Re.length; Nt--; )
                if (Re[Nt] === ct)
                  continue e;
              M && Re.push(ct), Se.push(rt);
            } else
              re(Re, ct, P) || (Re !== Se && Re.push(ct), Se.push(rt));
          }
        return Se;
      }
      function rd(w, M) {
        return M = sc(M, w), w = lc(w, M), w == null || delete w[Ds(ma(M))];
      }
      function Im(w, M, P, U) {
        return Xe(w, M, P(bo(w, M)), U);
      }
      function Eh(w, M, P, U) {
        for (var re = w.length, ce = U ? re : -1; (U ? ce-- : ++ce < re) && M(w[ce], ce, w); )
          ;
        return P ? co(w, U ? 0 : ce, U ? ce + 1 : re) : co(w, U ? ce + 1 : 0, U ? re : ce);
      }
      function zv(w, M) {
        var P = w;
        return P instanceof nr && (P = P.value()), Pp(M, function(U, re) {
          return re.func.apply(re.thisArg, cl([U], re.args));
        }, P);
      }
      function jm(w, M, P) {
        var U = w.length;
        if (U < 2)
          return U ? Fo(w[0]) : [];
        for (var re = -1, ce = Fe(U); ++re < U; )
          for (var ve = w[re], Se = -1; ++Se < U; )
            Se != re && (ce[re] = Pi(ce[re] || ve, w[Se], M, P));
        return Fo(ca(ce, 1), M, P);
      }
      function Fv(w, M, P) {
        for (var U = -1, re = w.length, ce = M.length, ve = {}; ++U < re; ) {
          var Se = U < ce ? M[U] : n;
          P(ve, w[U], Se);
        }
        return ve;
      }
      function Lm(w) {
        return Uo(w) ? w : [];
      }
      function zm(w) {
        return typeof w == "function" ? w : Tl;
      }
      function sc(w, M) {
        return ir(w) ? w : p1(w, M) ? [w] : b_(Si(w));
      }
      var s1 = rr;
      function uc(w, M, P) {
        var U = w.length;
        return P = P === n ? U : P, !M && P >= U ? w : co(w, M, P);
      }
      var Sh = Wb || function(w) {
        return Ri.clearTimeout(w);
      };
      function Bv(w, M) {
        if (M)
          return w.slice();
        var P = w.length, U = n_ ? n_(P) : new w.constructor(P);
        return w.copy(U), U;
      }
      function id(w) {
        var M = new w.constructor(w.byteLength);
        return new Cv(M).set(new Cv(w)), M;
      }
      function od(w, M) {
        var P = M ? id(w.buffer) : w.buffer;
        return new w.constructor(P, w.byteOffset, w.byteLength);
      }
      function u1(w) {
        var M = new w.constructor(w.source, lr.exec(w));
        return M.lastIndex = w.lastIndex, M;
      }
      function Uv(w) {
        return Cu ? oi(Cu.call(w)) : {};
      }
      function Yv(w, M) {
        var P = M ? id(w.buffer) : w.buffer;
        return new w.constructor(P, w.byteOffset, w.length);
      }
      function Hv(w, M) {
        if (w !== M) {
          var P = w !== n, U = w === null, re = w === w, ce = Cr(w), ve = M !== n, Se = M === null, Re = M === M, st = Cr(M);
          if (!Se && !st && !ce && w > M || ce && ve && Re && !Se && !st || U && ve && Re || !P && Re || !re)
            return 1;
          if (!U && !ce && !st && w < M || st && P && re && !U && !ce || Se && P && re || !ve && re || !Re)
            return -1;
        }
        return 0;
      }
      function f_(w, M, P) {
        for (var U = -1, re = w.criteria, ce = M.criteria, ve = re.length, Se = P.length; ++U < ve; ) {
          var Re = Hv(re[U], ce[U]);
          if (Re) {
            if (U >= Se)
              return Re;
            var st = P[U];
            return Re * (st == "desc" ? -1 : 1);
          }
        }
        return w.index - M.index;
      }
      function qp(w, M, P, U) {
        for (var re = -1, ce = w.length, ve = P.length, Se = -1, Re = M.length, st = zo(ce - ve, 0), rt = Fe(Re + st), ct = !U; ++Se < Re; )
          rt[Se] = M[Se];
        for (; ++re < ve; )
          (ct || re < ce) && (rt[P[re]] = w[re]);
        for (; st--; )
          rt[Se++] = w[re++];
        return rt;
      }
      function Vv(w, M, P, U) {
        for (var re = -1, ce = w.length, ve = -1, Se = P.length, Re = -1, st = M.length, rt = zo(ce - Se, 0), ct = Fe(rt + st), Nt = !U; ++re < rt; )
          ct[re] = w[re];
        for (var Gt = re; ++Re < st; )
          ct[Gt + Re] = M[Re];
        for (; ++ve < Se; )
          (Nt || re < ce) && (ct[Gt + P[ve]] = w[re++]);
        return ct;
      }
      function da(w, M) {
        var P = -1, U = w.length;
        for (M || (M = Fe(U)); ++P < U; )
          M[P] = w[P];
        return M;
      }
      function qa(w, M, P, U) {
        var re = !P;
        P || (P = {});
        for (var ce = -1, ve = M.length; ++ce < ve; ) {
          var Se = M[ce], Re = U ? U(P[Se], w[Se], Se, P, w) : n;
          Re === n && (Re = w[Se]), re ? ic(P, Se, Re) : Yp(P, Se, Re);
        }
        return P;
      }
      function su(w, M) {
        return qa(w, Ta(w), M);
      }
      function ZN(w, M) {
        return qa(w, Ca(w), M);
      }
      function si(w, M) {
        return function(P, U) {
          var re = ir(P) ? ki : ou, ce = M ? M() : {};
          return re(P, w, un(U, 2), ce);
        };
      }
      function ad(w) {
        return rr(function(M, P) {
          var U = -1, re = P.length, ce = re > 1 ? P[re - 1] : n, ve = re > 2 ? P[2] : n;
          for (ce = w.length > 3 && typeof ce == "function" ? (re--, ce) : n, ve && Fr(P[0], P[1], ve) && (ce = re < 3 ? n : ce, re = 1), M = oi(M); ++U < re; ) {
            var Se = P[U];
            Se && w(M, Se, U, ce);
          }
          return M;
        });
      }
      function Wv(w, M) {
        return function(P, U) {
          if (P == null)
            return P;
          if (!Ga(P))
            return w(P, U);
          for (var re = P.length, ce = M ? re : -1, ve = oi(P); (M ? ce-- : ++ce < re) && U(ve[ce], ce, ve) !== !1; )
            ;
          return P;
        };
      }
      function Gp(w) {
        return function(M, P, U) {
          for (var re = -1, ce = oi(M), ve = U(M), Se = ve.length; Se--; ) {
            var Re = ve[w ? Se : ++re];
            if (P(ce[Re], Re, ce) === !1)
              break;
          }
          return M;
        };
      }
      function qv(w, M, P) {
        var U = M & _, re = Gv(w);
        function ce() {
          var ve = this && this !== Ri && this instanceof ce ? re : w;
          return ve.apply(U ? P : this, arguments);
        }
        return ce;
      }
      function d_(w) {
        return function(M) {
          M = Si(M);
          var P = ym(M) ? Mu(M) : n, U = P ? P[0] : M.charAt(0), re = P ? uc(P, 1).join("") : M.slice(1);
          return U[w]() + re;
        };
      }
      function sd(w) {
        return function(M) {
          return Pp(DD(U_(M).replace(Pb, "")), w, "");
        };
      }
      function Gv(w) {
        return function() {
          var M = arguments;
          switch (M.length) {
            case 0:
              return new w();
            case 1:
              return new w(M[0]);
            case 2:
              return new w(M[0], M[1]);
            case 3:
              return new w(M[0], M[1], M[2]);
            case 4:
              return new w(M[0], M[1], M[2], M[3]);
            case 5:
              return new w(M[0], M[1], M[2], M[3], M[4]);
            case 6:
              return new w(M[0], M[1], M[2], M[3], M[4], M[5]);
            case 7:
              return new w(M[0], M[1], M[2], M[3], M[4], M[5], M[6]);
          }
          var P = ch(w.prototype), U = w.apply(P, M);
          return Po(U) ? U : P;
        };
      }
      function JN(w, M, P) {
        var U = Gv(w);
        function re() {
          for (var ce = arguments.length, ve = Fe(ce), Se = ce, Re = Nh(re); Se--; )
            ve[Se] = arguments[Se];
          var st = ce < 3 && ve[0] !== Re && ve[ce - 1] !== Re ? [] : fl(ve, Re);
          if (ce -= st.length, ce < P)
            return k2(
              w,
              M,
              Mh,
              re.placeholder,
              n,
              ve,
              st,
              n,
              n,
              P - ce
            );
          var rt = this && this !== Ri && this instanceof re ? U : w;
          return tr(rt, this, ve);
        }
        return re;
      }
      function l1(w) {
        return function(M, P, U) {
          var re = oi(M);
          if (!Ga(M)) {
            var ce = un(P, 3);
            M = ms(M), P = function(Se) {
              return ce(re[Se], Se, re);
            };
          }
          var ve = w(M, P, U);
          return ve > -1 ? re[ce ? M[ve] : ve] : n;
        };
      }
      function Qp(w) {
        return Jc(function(M) {
          var P = M.length, U = P, re = us.prototype.thru;
          for (w && M.reverse(); U--; ) {
            var ce = M[U];
            if (typeof ce != "function")
              throw new Tu(a);
            if (re && !ve && Um(ce) == "wrapper")
              var ve = new us([], !0);
          }
          for (U = ve ? U : P; ++U < P; ) {
            ce = M[U];
            var Se = Um(ce), Re = Se == "wrapper" ? Xv(ce) : n;
            Re && Dh(Re[0]) && Re[1] == ($ | A | R | z) && !Re[4].length && Re[9] == 1 ? ve = ve[Um(Re[0])].apply(ve, Re[3]) : ve = ce.length == 1 && Dh(ce) ? ve[Se]() : ve.thru(ce);
          }
          return function() {
            var st = arguments, rt = st[0];
            if (ve && st.length == 1 && ir(rt))
              return ve.plant(rt).value();
            for (var ct = 0, Nt = P ? M[ct].apply(this, st) : rt; ++ct < P; )
              Nt = M[ct].call(this, Nt);
            return Nt;
          };
        });
      }
      function Mh(w, M, P, U, re, ce, ve, Se, Re, st) {
        var rt = M & $, ct = M & _, Nt = M & S, Gt = M & (A | O), Sn = M & W, ur = Nt ? n : Gv(w);
        function Rn() {
          for (var Sr = arguments.length, $r = Fe(Sr), uu = Sr; uu--; )
            $r[uu] = arguments[uu];
          if (Gt)
            var wo = Nh(Rn), Lu = gm($r, wo);
          if (U && ($r = qp($r, U, re, Gt)), ce && ($r = Vv($r, ce, ve, Gt)), Sr -= Lu, Gt && Sr < st) {
            var Io = fl($r, wo);
            return k2(
              w,
              M,
              Mh,
              Rn.placeholder,
              P,
              $r,
              Io,
              Se,
              Re,
              st - Sr
            );
          }
          var Qa = ct ? P : this, lu = Nt ? Qa[w] : w;
          return Sr = $r.length, Se ? $r = po($r, Se) : Sn && Sr > 1 && $r.reverse(), rt && Re < Sr && ($r.length = Re), this && this !== Ri && this instanceof Rn && (lu = ur || Gv(lu)), lu.apply(Qa, $r);
        }
        return Rn;
      }
      function Qv(w, M) {
        return function(P, U) {
          return gh(P, w, M(U), {});
        };
      }
      function c1(w, M) {
        return function(P, U) {
          var re;
          if (P === n && U === n)
            return M;
          if (P !== n && (re = P), U !== n) {
            if (re === n)
              return U;
            typeof P == "string" || typeof U == "string" ? (P = fo(P), U = fo(U)) : (P = _h(P), U = _h(U)), re = w(P, U);
          }
          return re;
        };
      }
      function f1(w) {
        return Jc(function(M) {
          return M = kr(M, Wr(un())), rr(function(P) {
            var U = this;
            return w(M, function(re) {
              return tr(re, U, P);
            });
          });
        });
      }
      function Th(w, M) {
        M = M === n ? " " : fo(M);
        var P = M.length;
        if (P < 2)
          return P ? Pm(M, w) : M;
        var U = Pm(M, hl(w / oh(M)));
        return ym(M) ? uc(Mu(U), 0, w).join("") : U.slice(0, w);
      }
      function R2(w, M, P, U) {
        var re = M & _, ce = Gv(w);
        function ve() {
          for (var Se = -1, Re = arguments.length, st = -1, rt = U.length, ct = Fe(rt + Re), Nt = this && this !== Ri && this instanceof ve ? ce : w; ++st < rt; )
            ct[st] = U[st];
          for (; Re--; )
            ct[st++] = arguments[++Se];
          return tr(Nt, re ? P : this, ct);
        }
        return ve;
      }
      function d1(w) {
        return function(M, P, U) {
          return U && typeof U != "number" && Fr(M, P, U) && (P = U = n), M = ag(M), P === n ? (P = M, M = 0) : P = ag(P), U = U === n ? M < P ? 1 : -1 : ag(U), a1(M, P, U, w);
        };
      }
      function Fm(w) {
        return function(M, P) {
          return typeof M == "string" && typeof P == "string" || (M = of(M), P = of(P)), w(M, P);
        };
      }
      function k2(w, M, P, U, re, ce, ve, Se, Re, st) {
        var rt = M & A, ct = rt ? ve : n, Nt = rt ? n : ve, Gt = rt ? ce : n, Sn = rt ? n : ce;
        M |= rt ? R : j, M &= ~(rt ? j : R), M & C || (M &= ~(_ | S));
        var ur = [
          w,
          M,
          re,
          Gt,
          ct,
          Sn,
          Nt,
          Se,
          Re,
          st
        ], Rn = P.apply(n, ur);
        return Dh(w) && $u(Rn, ur), Rn.placeholder = U, _l(Rn, w, M);
      }
      function Ro(w) {
        var M = Zo[w];
        return function(P, U) {
          if (P = of(P), U = U == null ? 0 : Ea(Jn(U), 292), U && Mm(P)) {
            var re = (Si(P) + "e").split("e"), ce = M(re[0] + "e" + (+re[1] + U));
            return re = (Si(ce) + "e").split("e"), +(re[0] + "e" + (+re[1] - U));
          }
          return M(P);
        };
      }
      var ha = pl && 1 / Gf(new pl([, -0]))[1] == X ? function(w) {
        return new pl(w);
      } : $D;
      function ud(w) {
        return function(M) {
          var P = ho(M);
          return P == $e ? Bb(M) : P == Zt ? vm(M) : tu(M, w(M));
        };
      }
      function wl(w, M, P, U, re, ce, ve, Se) {
        var Re = M & S;
        if (!Re && typeof w != "function")
          throw new Tu(a);
        var st = U ? U.length : 0;
        if (st || (M &= ~(R | j), U = re = n), ve = ve === n ? ve : zo(Jn(ve), 0), Se = Se === n ? Se : Jn(Se), st -= re ? re.length : 0, M & j) {
          var rt = U, ct = re;
          U = re = n;
        }
        var Nt = Re ? n : Xv(w), Gt = [
          w,
          M,
          P,
          U,
          re,
          rt,
          ct,
          ce,
          ve,
          Se
        ];
        if (Nt && y_(Gt, Nt), w = Gt[0], M = Gt[1], P = Gt[2], U = Gt[3], re = Gt[4], Se = Gt[9] = Gt[9] === n ? Re ? 0 : w.length : zo(Gt[9] - st, 0), !Se && M & (A | O) && (M &= ~(A | O)), !M || M == _)
          var Sn = qv(w, M, P);
        else
          M == A || M == O ? Sn = JN(w, M, Se) : (M == R || M == (_ | R)) && !re.length ? Sn = R2(w, M, P, U) : Sn = Mh.apply(n, Gt);
        var ur = Nt ? Er : $u;
        return _l(ur(Sn, Gt), w, M);
      }
      function Ns(w, M, P, U) {
        return w === n || dd(w, Vc[P]) && !Gr.call(U, P) ? M : w;
      }
      function Ch(w, M, P, U, re, ce) {
        return Po(w) && Po(M) && (ce.set(M, w), bh(w, M, n, Ch, ce), ce.delete(M)), w;
      }
      function Gn(w) {
        return u0(w) ? n : w;
      }
      function Xp(w, M, P, U, re, ce) {
        var ve = P & y, Se = w.length, Re = M.length;
        if (Se != Re && !(ve && Re > Se))
          return !1;
        var st = ce.get(w), rt = ce.get(M);
        if (st && rt)
          return st == M && rt == w;
        var ct = -1, Nt = !0, Gt = P & b ? new Zf() : n;
        for (ce.set(w, M), ce.set(M, w); ++ct < Se; ) {
          var Sn = w[ct], ur = M[ct];
          if (U)
            var Rn = ve ? U(ur, Sn, ct, M, w, ce) : U(Sn, ur, ct, w, M, ce);
          if (Rn !== n) {
            if (Rn)
              continue;
            Nt = !1;
            break;
          }
          if (Gt) {
            if (!qw(M, function(Sr, $r) {
              if (!ec(Gt, $r) && (Sn === Sr || re(Sn, Sr, P, U, ce)))
                return Gt.push($r);
            })) {
              Nt = !1;
              break;
            }
          } else if (!(Sn === ur || re(Sn, ur, P, U, ce))) {
            Nt = !1;
            break;
          }
        }
        return ce.delete(w), ce.delete(M), Nt;
      }
      function h_(w, M, P, U, re, ce, ve) {
        switch (P) {
          case Qt:
            if (w.byteLength != M.byteLength || w.byteOffset != M.byteOffset)
              return !1;
            w = w.buffer, M = M.buffer;
          case Un:
            return !(w.byteLength != M.byteLength || !ce(new Cv(w), new Cv(M)));
          case Me:
          case we:
          case pt:
            return dd(+w, +M);
          case ze:
            return w.name == M.name && w.message == M.message;
          case tn:
          case qn:
            return w == M + "";
          case $e:
            var Se = Bb;
          case Zt:
            var Re = U & y;
            if (Se || (Se = Gf), w.size != M.size && !Re)
              return !1;
            var st = ve.get(w);
            if (st)
              return st == M;
            U |= b, ve.set(w, M);
            var rt = Xp(Se(w), Se(M), U, re, ce, ve);
            return ve.delete(w), rt;
          case fn:
            if (Cu)
              return Cu.call(w) == Cu.call(M);
        }
        return !1;
      }
      function $2(w, M, P, U, re, ce) {
        var ve = P & y, Se = Bm(w), Re = Se.length, st = Bm(M), rt = st.length;
        if (Re != rt && !ve)
          return !1;
        for (var ct = Re; ct--; ) {
          var Nt = Se[ct];
          if (!(ve ? Nt in M : Gr.call(M, Nt)))
            return !1;
        }
        var Gt = ce.get(w), Sn = ce.get(M);
        if (Gt && Sn)
          return Gt == M && Sn == w;
        var ur = !0;
        ce.set(w, M), ce.set(M, w);
        for (var Rn = ve; ++ct < Re; ) {
          Nt = Se[ct];
          var Sr = w[Nt], $r = M[Nt];
          if (U)
            var uu = ve ? U($r, Sr, Nt, M, w, ce) : U(Sr, $r, Nt, w, M, ce);
          if (!(uu === n ? Sr === $r || re(Sr, $r, P, U, ce) : uu)) {
            ur = !1;
            break;
          }
          Rn || (Rn = Nt == "constructor");
        }
        if (ur && !Rn) {
          var wo = w.constructor, Lu = M.constructor;
          wo != Lu && "constructor" in w && "constructor" in M && !(typeof wo == "function" && wo instanceof wo && typeof Lu == "function" && Lu instanceof Lu) && (ur = !1);
        }
        return ce.delete(w), ce.delete(M), ur;
      }
      function Jc(w) {
        return cc(Zp(w, n, t0), w + "");
      }
      function Bm(w) {
        return Jb(w, ms, Ta);
      }
      function ld(w) {
        return Jb(w, Ml, Ca);
      }
      var Xv = Cm ? function(w) {
        return Cm.get(w);
      } : $D;
      function Um(w) {
        for (var M = w.name + "", P = Nm[M], U = Gr.call(Nm, M) ? P.length : 0; U--; ) {
          var re = P[U], ce = re.func;
          if (ce == null || ce == w)
            return re.name;
        }
        return M;
      }
      function Nh(w) {
        var M = Gr.call(ue, "placeholder") ? ue : w;
        return M.placeholder;
      }
      function un() {
        var w = ue.iteratee || RD;
        return w = w === RD ? Lv : w, arguments.length ? w(arguments[0], arguments[1]) : w;
      }
      function h1(w, M) {
        var P = w.__data__;
        return Vt(M) ? P[typeof M == "string" ? "string" : "hash"] : P.map;
      }
      function Kv(w) {
        for (var M = ms(w), P = M.length; P--; ) {
          var U = M[P], re = w[U];
          M[P] = [U, re, Vm(re)];
        }
        return M;
      }
      function ef(w, M) {
        var P = mm(w, M);
        return l_(P) ? P : n;
      }
      function p_(w) {
        var M = Gr.call(w, Lp), P = w[Lp];
        try {
          w[Lp] = n;
          var U = !0;
        } catch {
        }
        var re = _m.call(w);
        return U && (M ? w[Lp] = P : delete w[Lp]), re;
      }
      var Ta = qb ? function(w) {
        return w == null ? [] : (w = oi(w), Eu(qb(w), function(M) {
          return ah.call(w, M);
        }));
      } : ID, Ca = qb ? function(w) {
        for (var M = []; w; )
          cl(M, Ta(w)), w = dl(w);
        return M;
      } : ID, ho = fs;
      (Ov && ho(new Ov(new ArrayBuffer(1))) != Qt || nc && ho(new nc()) != $e || Fp && ho(Fp.resolve()) != mn || pl && ho(new pl()) != Zt || Tm && ho(new Tm()) != Zn) && (ho = function(w) {
        var M = fs(w), P = M == Ot ? w.constructor : n, U = P ? Ah(P) : "";
        if (U)
          switch (U) {
            case uh:
              return Qt;
            case rc:
              return $e;
            case Rv:
              return mn;
            case lh:
              return Zt;
            case Wc:
              return Zn;
          }
        return M;
      });
      function Zv(w, M, P) {
        for (var U = -1, re = P.length; ++U < re; ) {
          var ce = P[U], ve = ce.size;
          switch (ce.type) {
            case "drop":
              w += ve;
              break;
            case "dropRight":
              M -= ve;
              break;
            case "take":
              M = Ea(M, w + ve);
              break;
            case "takeRight":
              w = zo(w, M - ve);
              break;
          }
        }
        return { start: w, end: M };
      }
      function Kp(w) {
        var M = w.match(ss);
        return M ? M[1].split(xe) : [];
      }
      function Ru(w, M, P) {
        M = sc(M, w);
        for (var U = -1, re = M.length, ce = !1; ++U < re; ) {
          var ve = Ds(M[U]);
          if (!(ce = w != null && P(w, ve)))
            break;
          w = w[ve];
        }
        return ce || ++U != re ? ce : (re = w == null ? 0 : w.length, !!re && I_(re) && ku(ve, re) && (ir(w) || s0(w)));
      }
      function pa(w) {
        var M = w.length, P = new w.constructor(M);
        return M && typeof w[0] == "string" && Gr.call(w, "index") && (P.index = w.index, P.input = w.input), P;
      }
      function Ym(w) {
        return typeof w.constructor == "function" && !Hm(w) ? ch(dl(w)) : {};
      }
      function ds(w, M, P) {
        var U = w.constructor;
        switch (M) {
          case Un:
            return id(w);
          case Me:
          case we:
            return new U(+w);
          case Qt:
            return od(w, P);
          case Ut:
          case er:
          case We:
          case ht:
          case Ft:
          case _n:
          case Dn:
          case di:
          case bi:
            return Yv(w, P);
          case $e:
            return new U();
          case pt:
          case qn:
            return new U(w);
          case tn:
            return u1(w);
          case Zt:
            return new U();
          case fn:
            return Uv(w);
        }
      }
      function eD(w, M) {
        var P = M.length;
        if (!P)
          return w;
        var U = P - 1;
        return M[U] = (P > 1 ? "& " : "") + M[U], M = M.join(P > 2 ? ", " : " "), w.replace(Hi, `{
/* [wrapped with ` + M + `] */
`);
      }
      function g_(w) {
        return ir(w) || s0(w) || !!(Sm && w && w[Sm]);
      }
      function ku(w, M) {
        var P = typeof w;
        return M = M ?? Z, !!M && (P == "number" || P != "symbol" && wi.test(w)) && w > -1 && w % 1 == 0 && w < M;
      }
      function Fr(w, M, P) {
        if (!Po(P))
          return !1;
        var U = typeof M;
        return (U == "number" ? Ga(P) && ku(M, P.length) : U == "string" && M in P) ? dd(P[M], w) : !1;
      }
      function p1(w, M) {
        if (ir(w))
          return !1;
        var P = typeof w;
        return P == "number" || P == "symbol" || P == "boolean" || w == null || Cr(w) ? !0 : Fc.test(w) || !Xl.test(w) || M != null && w in oi(M);
      }
      function Vt(w) {
        var M = typeof w;
        return M == "string" || M == "number" || M == "symbol" || M == "boolean" ? w !== "__proto__" : w === null;
      }
      function Dh(w) {
        var M = Um(w), P = ue[M];
        if (typeof P != "function" || !(M in nr.prototype))
          return !1;
        if (w === P)
          return !0;
        var U = Xv(P);
        return !!U && w === U[0];
      }
      function Jv(w) {
        return !!Hb && Hb in w;
      }
      var P2 = wm ? Lh : jD;
      function Hm(w) {
        var M = w && w.constructor, P = typeof M == "function" && M.prototype || Vc;
        return w === P;
      }
      function Vm(w) {
        return w === w && !Po(w);
      }
      function Wm(w, M) {
        return function(P) {
          return P == null ? !1 : P[w] === M && (M !== n || w in oi(P));
        };
      }
      function m_(w) {
        var M = Te(w, function(U) {
          return P.size === l && P.clear(), U;
        }), P = M.cache;
        return M;
      }
      function y_(w, M) {
        var P = w[1], U = M[1], re = P | U, ce = re < (_ | S | $), ve = U == $ && P == A || U == $ && P == z && w[7].length <= M[8] || U == ($ | z) && M[7].length <= M[8] && P == A;
        if (!(ce || ve))
          return w;
        U & _ && (w[2] = M[2], re |= P & _ ? 0 : C);
        var Se = M[3];
        if (Se) {
          var Re = w[3];
          w[3] = Re ? qp(Re, Se, M[4]) : Se, w[4] = Re ? fl(w[3], f) : M[4];
        }
        return Se = M[5], Se && (Re = w[5], w[5] = Re ? Vv(Re, Se, M[6]) : Se, w[6] = Re ? fl(w[5], f) : M[6]), Se = M[7], Se && (w[7] = Se), U & $ && (w[8] = w[8] == null ? M[8] : Ea(w[8], M[8])), w[9] == null && (w[9] = M[9]), w[0] = M[0], w[1] = re, w;
      }
      function I2(w) {
        var M = [];
        if (w != null)
          for (var P in oi(w))
            M.push(P);
        return M;
      }
      function g1(w) {
        return _m.call(w);
      }
      function Zp(w, M, P) {
        return M = zo(M === n ? w.length - 1 : M, 0), function() {
          for (var U = arguments, re = -1, ce = zo(U.length - M, 0), ve = Fe(ce); ++re < ce; )
            ve[re] = U[M + re];
          re = -1;
          for (var Se = Fe(M + 1); ++re < M; )
            Se[re] = U[re];
          return Se[M] = P(ve), tr(w, this, Se);
        };
      }
      function lc(w, M) {
        return M.length < 2 ? w : bo(w, co(M, 0, -1));
      }
      function po(w, M) {
        for (var P = w.length, U = Ea(M.length, P), re = da(w); U--; ) {
          var ce = M[U];
          w[U] = ku(ce, P) ? re[ce] : n;
        }
        return w;
      }
      function Jo(w, M) {
        if (!(M === "constructor" && typeof w[M] == "function") && M != "__proto__")
          return w[M];
      }
      var $u = v_(Er), tf = sh || function(w, M) {
        return Ri.setTimeout(w, M);
      }, cc = v_(En);
      function _l(w, M, P) {
        var U = M + "";
        return cc(w, eD(U, x_(Kp(U), P)));
      }
      function v_(w) {
        var M = 0, P = 0;
        return function() {
          var U = KN(), re = K - (U - P);
          if (P = U, re > 0) {
            if (++M >= ee)
              return arguments[0];
          } else
            M = 0;
          return w.apply(n, arguments);
        };
      }
      function Pu(w, M) {
        var P = -1, U = w.length, re = U - 1;
        for (M = M === n ? U : M; ++P < M; ) {
          var ce = au(P, re), ve = w[ce];
          w[ce] = w[P], w[P] = ve;
        }
        return w.length = M, w;
      }
      var b_ = m_(function(w) {
        var M = [];
        return w.charCodeAt(0) === 46 && M.push(""), w.replace(_s, function(P, U, re, ce) {
          M.push(re ? ce.replace($t, "$1") : U || P);
        }), M;
      });
      function Ds(w) {
        if (typeof w == "string" || Cr(w))
          return w;
        var M = w + "";
        return M == "0" && 1 / w == -X ? "-0" : M;
      }
      function Ah(w) {
        if (w != null) {
          try {
            return Mv.call(w);
          } catch {
          }
          try {
            return w + "";
          } catch {
          }
        }
        return "";
      }
      function x_(w, M) {
        return yr(_e, function(P) {
          var U = "_." + P[0];
          M & P[1] && !ih(w, U) && w.push(U);
        }), w.sort();
      }
      function w_(w) {
        if (w instanceof nr)
          return w.clone();
        var M = new us(w.__wrapped__, w.__chain__);
        return M.__actions__ = da(w.__actions__), M.__index__ = w.__index__, M.__values__ = w.__values__, M;
      }
      function m1(w, M, P) {
        (P ? Fr(w, M, P) : M === n) ? M = 1 : M = zo(Jn(M), 0);
        var U = w == null ? 0 : w.length;
        if (!U || M < 1)
          return [];
        for (var re = 0, ce = 0, ve = Fe(hl(U / M)); re < U; )
          ve[ce++] = co(w, re, re += M);
        return ve;
      }
      function e0(w) {
        for (var M = -1, P = w == null ? 0 : w.length, U = 0, re = []; ++M < P; ) {
          var ce = w[M];
          ce && (re[U++] = ce);
        }
        return re;
      }
      function __() {
        var w = arguments.length;
        if (!w)
          return [];
        for (var M = Fe(w - 1), P = arguments[0], U = w; U--; )
          M[U - 1] = arguments[U];
        return cl(ir(P) ? da(P) : [P], ca(M, 1));
      }
      var hs = rr(function(w, M) {
        return Uo(w) ? Pi(w, ca(M, 1, Uo, !0)) : [];
      }), vr = rr(function(w, M) {
        var P = ma(M);
        return Uo(P) && (P = n), Uo(w) ? Pi(w, ca(M, 1, Uo, !0), un(P, 2)) : [];
      }), xo = rr(function(w, M) {
        var P = ma(M);
        return Uo(P) && (P = n), Uo(w) ? Pi(w, ca(M, 1, Uo, !0), n, P) : [];
      });
      function ko(w, M, P) {
        var U = w == null ? 0 : w.length;
        return U ? (M = P || M === n ? 1 : Jn(M), co(w, M < 0 ? 0 : M, U)) : [];
      }
      function Na(w, M, P) {
        var U = w == null ? 0 : w.length;
        return U ? (M = P || M === n ? 1 : Jn(M), M = U - M, co(w, 0, M < 0 ? 0 : M)) : [];
      }
      function Iu(w, M) {
        return w && w.length ? Eh(w, un(M, 3), !0, !0) : [];
      }
      function qm(w, M) {
        return w && w.length ? Eh(w, un(M, 3), !0) : [];
      }
      function ga(w, M, P, U) {
        var re = w == null ? 0 : w.length;
        return re ? (P && typeof P != "number" && Fr(w, M, P) && (P = 0, U = re), Zb(w, M, P, U)) : [];
      }
      function Gm(w, M, P) {
        var U = w == null ? 0 : w.length;
        if (!U)
          return -1;
        var re = P == null ? 0 : Jn(P);
        return re < 0 && (re = zo(U + re, 0)), _v(w, un(M, 3), re);
      }
      function nf(w, M, P) {
        var U = w == null ? 0 : w.length;
        if (!U)
          return -1;
        var re = U - 1;
        return P !== n && (re = Jn(P), re = P < 0 ? zo(U + re, 0) : Ea(re, U - 1)), _v(w, un(M, 3), re, !0);
      }
      function t0(w) {
        var M = w == null ? 0 : w.length;
        return M ? ca(w, 1) : [];
      }
      function Qm(w) {
        var M = w == null ? 0 : w.length;
        return M ? ca(w, X) : [];
      }
      function Jp(w, M) {
        var P = w == null ? 0 : w.length;
        return P ? (M = M === n ? 1 : Jn(M), ca(w, M)) : [];
      }
      function As(w) {
        for (var M = -1, P = w == null ? 0 : w.length, U = {}; ++M < P; ) {
          var re = w[M];
          U[re[0]] = re[1];
        }
        return U;
      }
      function y1(w) {
        return w && w.length ? w[0] : n;
      }
      function Xm(w, M, P) {
        var U = w == null ? 0 : w.length;
        if (!U)
          return -1;
        var re = P == null ? 0 : Jn(P);
        return re < 0 && (re = zo(U + re, 0)), Ip(w, M, re);
      }
      function cd(w) {
        var M = w == null ? 0 : w.length;
        return M ? co(w, 0, -1) : [];
      }
      var v1 = rr(function(w) {
        var M = kr(w, Lm);
        return M.length && M[0] === w[0] ? ac(M) : [];
      }), eg = rr(function(w) {
        var M = ma(w), P = kr(w, Lm);
        return M === ma(P) ? M = n : P.pop(), P.length && P[0] === w[0] ? ac(P, un(M, 2)) : [];
      }), rf = rr(function(w) {
        var M = ma(w), P = kr(w, Lm);
        return M = typeof M == "function" ? M : n, M && P.pop(), P.length && P[0] === w[0] ? ac(P, n, M) : [];
      });
      function Oh(w, M) {
        return w == null ? "" : Dv.call(w, M);
      }
      function ma(w) {
        var M = w == null ? 0 : w.length;
        return M ? w[M - 1] : n;
      }
      function b1(w, M, P) {
        var U = w == null ? 0 : w.length;
        if (!U)
          return -1;
        var re = U;
        return P !== n && (re = Jn(P), re = re < 0 ? zo(U + re, 0) : Ea(re, U - 1)), M === M ? E2(w, M, re) : _v(w, Yc, re, !0);
      }
      function Km(w, M) {
        return w && w.length ? xh(w, Jn(M)) : n;
      }
      var x1 = rr(Rh);
      function Rh(w, M) {
        return w && w.length && M && M.length ? pn(w, M) : w;
      }
      function tg(w, M, P) {
        return w && w.length && M && M.length ? pn(w, M, un(P, 2)) : w;
      }
      function ps(w, M, P) {
        return w && w.length && M && M.length ? pn(w, M, n, P) : w;
      }
      var ea = Jc(function(w, M) {
        var P = w == null ? 0 : w.length, U = Kb(w, M);
        return lo(w, kr(M, function(re) {
          return ku(re, P) ? +re : re;
        }).sort(Hv)), U;
      });
      function gs(w, M) {
        var P = [];
        if (!(w && w.length))
          return P;
        var U = -1, re = [], ce = w.length;
        for (M = un(M, 3); ++U < ce; ) {
          var ve = w[U];
          M(ve, U, w) && (P.push(ve), re.push(U));
        }
        return lo(w, re), P;
      }
      function Da(w) {
        return w == null ? w : Qb.call(w);
      }
      function Zm(w, M, P) {
        var U = w == null ? 0 : w.length;
        return U ? (P && typeof P != "number" && Fr(w, M, P) ? (M = 0, P = U) : (M = M == null ? 0 : Jn(M), P = P === n ? U : Jn(P)), co(w, M, P)) : [];
      }
      function E_(w, M) {
        return Ei(w, M);
      }
      function n0(w, M, P) {
        return td(w, M, un(P, 2));
      }
      function S_(w, M) {
        var P = w == null ? 0 : w.length;
        if (P) {
          var U = Ei(w, M);
          if (U < P && dd(w[U], M))
            return U;
        }
        return -1;
      }
      function El(w, M) {
        return Ei(w, M, !0);
      }
      function j2(w, M, P) {
        return td(w, M, un(P, 2), !0);
      }
      function Jm(w, M) {
        var P = w == null ? 0 : w.length;
        if (P) {
          var U = Ei(w, M, !0) - 1;
          if (dd(w[U], M))
            return U;
        }
        return -1;
      }
      function kh(w) {
        return w && w.length ? nd(w) : [];
      }
      function M_(w, M) {
        return w && w.length ? nd(w, un(M, 2)) : [];
      }
      function ng(w) {
        var M = w == null ? 0 : w.length;
        return M ? co(w, 1, M) : [];
      }
      function L2(w, M, P) {
        return w && w.length ? (M = P || M === n ? 1 : Jn(M), co(w, 0, M < 0 ? 0 : M)) : [];
      }
      function w1(w, M, P) {
        var U = w == null ? 0 : w.length;
        return U ? (M = P || M === n ? 1 : Jn(M), M = U - M, co(w, M < 0 ? 0 : M, U)) : [];
      }
      function T_(w, M) {
        return w && w.length ? Eh(w, un(M, 3), !1, !0) : [];
      }
      function _1(w, M) {
        return w && w.length ? Eh(w, un(M, 3)) : [];
      }
      var tD = rr(function(w) {
        return Fo(ca(w, 1, Uo, !0));
      }), nD = rr(function(w) {
        var M = ma(w);
        return Uo(M) && (M = n), Fo(ca(w, 1, Uo, !0), un(M, 2));
      }), z2 = rr(function(w) {
        var M = ma(w);
        return M = typeof M == "function" ? M : n, Fo(ca(w, 1, Uo, !0), n, M);
      });
      function C_(w) {
        return w && w.length ? Fo(w) : [];
      }
      function rg(w, M) {
        return w && w.length ? Fo(w, un(M, 2)) : [];
      }
      function rD(w, M) {
        return M = typeof M == "function" ? M : n, w && w.length ? Fo(w, n, M) : [];
      }
      function $h(w) {
        if (!(w && w.length))
          return [];
        var M = 0;
        return w = Eu(w, function(P) {
          if (Uo(P))
            return M = zo(P.length, M), !0;
        }), zb(M, function(P) {
          return kr(w, Ev(P));
        });
      }
      function N_(w, M) {
        if (!(w && w.length))
          return [];
        var P = $h(w);
        return M == null ? P : kr(P, function(U) {
          return tr(M, n, U);
        });
      }
      var $o = rr(function(w, M) {
        return Uo(w) ? Pi(w, M) : [];
      }), iD = rr(function(w) {
        return jm(Eu(w, Uo));
      }), E1 = rr(function(w) {
        var M = ma(w);
        return Uo(M) && (M = n), jm(Eu(w, Uo), un(M, 2));
      }), oD = rr(function(w) {
        var M = ma(w);
        return M = typeof M == "function" ? M : n, jm(Eu(w, Uo), n, M);
      }), aD = rr($h);
      function F2(w, M) {
        return Fv(w || [], M || [], Yp);
      }
      function D_(w, M) {
        return Fv(w || [], M || [], Xe);
      }
      var sD = rr(function(w) {
        var M = w.length, P = M > 1 ? w[M - 1] : n;
        return P = typeof P == "function" ? (w.pop(), P) : n, N_(w, P);
      });
      function ju(w) {
        var M = ue(w);
        return M.__chain__ = !0, M;
      }
      function A_(w, M) {
        return M(w), w;
      }
      function S1(w, M) {
        return M(w);
      }
      var Ph = Jc(function(w) {
        var M = w.length, P = M ? w[0] : 0, U = this.__wrapped__, re = function(ce) {
          return Kb(ce, w);
        };
        return M > 1 || this.__actions__.length || !(U instanceof nr) || !ku(P) ? this.thru(re) : (U = U.slice(P, +P + (M ? 1 : 0)), U.__actions__.push({
          func: S1,
          args: [re],
          thisArg: n
        }), new us(U, this.__chain__).thru(function(ce) {
          return M && !ce.length && ce.push(n), ce;
        }));
      });
      function M1() {
        return ju(this);
      }
      function ig() {
        return new us(this.value(), this.__chain__);
      }
      function r0() {
        this.__values__ === n && (this.__values__ = $1(this.value()));
        var w = this.__index__ >= this.__values__.length, M = w ? n : this.__values__[this.__index__++];
        return { done: w, value: M };
      }
      function i0() {
        return this;
      }
      function og(w) {
        for (var M, P = this; P instanceof Ts; ) {
          var U = w_(P);
          U.__index__ = 0, U.__values__ = n, M ? re.__wrapped__ = U : M = U;
          var re = U;
          P = P.__wrapped__;
        }
        return re.__wrapped__ = w, M;
      }
      function uD() {
        var w = this.__wrapped__;
        if (w instanceof nr) {
          var M = w;
          return this.__actions__.length && (M = new nr(this)), M = M.reverse(), M.__actions__.push({
            func: S1,
            args: [Da],
            thisArg: n
          }), new us(M, this.__chain__);
        }
        return this.thru(Da);
      }
      function T1() {
        return zv(this.__wrapped__, this.__actions__);
      }
      var B2 = si(function(w, M, P) {
        Gr.call(w, P) ? ++w[P] : ic(w, P, 1);
      });
      function O_(w, M, P) {
        var U = ir(w) ? Uc : Au;
        return P && Fr(w, M, P) && (M = n), U(w, un(M, 3));
      }
      function U2(w, M) {
        var P = ir(w) ? Eu : Jf;
        return P(w, un(M, 3));
      }
      var o0 = l1(Gm), C1 = l1(nf);
      function Y2(w, M) {
        return ca(A1(w, M), 1);
      }
      function R_(w, M) {
        return ca(A1(w, M), X);
      }
      function H2(w, M, P) {
        return P = P === n ? 1 : Jn(P), ca(A1(w, M), P);
      }
      function N1(w, M) {
        var P = ir(w) ? yr : Kc;
        return P(w, un(M, 3));
      }
      function a0(w, M) {
        var P = ir(w) ? _r : Iv;
        return P(w, un(M, 3));
      }
      var fd = si(function(w, M, P) {
        Gr.call(w, P) ? w[P].push(M) : ic(w, P, [M]);
      });
      function k_(w, M, P, U) {
        w = Ga(w) ? w : j1(w), P = P && !U ? Jn(P) : 0;
        var re = w.length;
        return P < 0 && (P = zo(re + P, 0)), G2(w) ? P <= re && w.indexOf(M, P) > -1 : !!re && Ip(w, M, P) > -1;
      }
      var D1 = rr(function(w, M, P) {
        var U = -1, re = typeof M == "function", ce = Ga(w) ? Fe(w.length) : [];
        return Kc(w, function(ve) {
          ce[++U] = re ? tr(M, ve, P) : mh(ve, M, P);
        }), ce;
      }), V2 = si(function(w, M, P) {
        ic(w, P, M);
      });
      function A1(w, M) {
        var P = ir(w) ? kr : c_;
        return P(w, un(M, 3));
      }
      function O1(w, M, P, U) {
        return w == null ? [] : (ir(M) || (M = M == null ? [] : [M]), P = U ? n : P, ir(P) || (P = P == null ? [] : [P]), o1(w, M, P));
      }
      var lD = si(function(w, M, P) {
        w[P ? 0 : 1].push(M);
      }, function() {
        return [[], []];
      });
      function ey(w, M, P) {
        var U = ir(w) ? Pp : Lb, re = arguments.length < 3;
        return U(w, un(M, 4), P, re, Kc);
      }
      function cD(w, M, P) {
        var U = ir(w) ? Ww : Lb, re = arguments.length < 3;
        return U(w, un(M, 4), P, re, Iv);
      }
      function R1(w, M) {
        var P = ir(w) ? Eu : Jf;
        return P(w, Ie(un(M, 3)));
      }
      function m(w) {
        var M = ir(w) ? Qc : Vp;
        return M(w);
      }
      function v(w, M, P) {
        (P ? Fr(w, M, P) : M === n) ? M = 1 : M = Jn(M);
        var U = ir(w) ? Du : ro;
        return U(w, M);
      }
      function T(w) {
        var M = ir(w) ? o_ : Zc;
        return M(w);
      }
      function k(w) {
        if (w == null)
          return 0;
        if (Ga(w))
          return G2(w) ? oh(w) : w.length;
        var M = ho(w);
        return M == $e || M == Zt ? w.size : i1(w).length;
      }
      function L(w, M, P) {
        var U = ir(w) ? qw : Wp;
        return P && Fr(w, M, P) && (M = n), U(w, un(M, 3));
      }
      var B = rr(function(w, M) {
        if (w == null)
          return [];
        var P = M.length;
        return P > 1 && Fr(w, M[0], M[1]) ? M = [] : P > 2 && Fr(M[0], M[1], M[2]) && (M = [M[0]]), o1(w, ca(M, 1), []);
      }), oe = $i || function() {
        return Ri.Date.now();
      };
      function me(w, M) {
        if (typeof M != "function")
          throw new Tu(a);
        return w = Jn(w), function() {
          if (--w < 1)
            return M.apply(this, arguments);
        };
      }
      function Ee(w, M, P) {
        return M = P ? n : M, M = w && M == null ? w.length : M, wl(w, $, n, n, n, n, M);
      }
      function He(w, M) {
        var P;
        if (typeof M != "function")
          throw new Tu(a);
        return w = Jn(w), function() {
          return --w > 0 && (P = M.apply(this, arguments)), w <= 1 && (M = n), P;
        };
      }
      var ft = rr(function(w, M, P) {
        var U = _;
        if (P.length) {
          var re = fl(P, Nh(ft));
          U |= R;
        }
        return wl(w, U, M, P, re);
      }), mt = rr(function(w, M, P) {
        var U = _ | S;
        if (P.length) {
          var re = fl(P, Nh(mt));
          U |= R;
        }
        return wl(M, U, w, P, re);
      });
      function dt(w, M, P) {
        M = P ? n : M;
        var U = wl(w, A, n, n, n, n, n, M);
        return U.placeholder = dt.placeholder, U;
      }
      function jt(w, M, P) {
        M = P ? n : M;
        var U = wl(w, O, n, n, n, n, n, M);
        return U.placeholder = jt.placeholder, U;
      }
      function qt(w, M, P) {
        var U, re, ce, ve, Se, Re, st = 0, rt = !1, ct = !1, Nt = !0;
        if (typeof w != "function")
          throw new Tu(a);
        M = of(M) || 0, Po(P) && (rt = !!P.leading, ct = "maxWait" in P, ce = ct ? zo(of(P.maxWait) || 0, M) : ce, Nt = "trailing" in P ? !!P.trailing : Nt);
        function Gt(Io) {
          var Qa = U, lu = re;
          return U = re = n, st = Io, ve = w.apply(lu, Qa), ve;
        }
        function Sn(Io) {
          return st = Io, Se = tf(Sr, M), rt ? Gt(Io) : ve;
        }
        function ur(Io) {
          var Qa = Io - Re, lu = Io - st, Os = M - Qa;
          return ct ? Ea(Os, ce - lu) : Os;
        }
        function Rn(Io) {
          var Qa = Io - Re, lu = Io - st;
          return Re === n || Qa >= M || Qa < 0 || ct && lu >= ce;
        }
        function Sr() {
          var Io = oe();
          if (Rn(Io))
            return $r(Io);
          Se = tf(Sr, ur(Io));
        }
        function $r(Io) {
          return Se = n, Nt && U ? Gt(Io) : (U = re = n, ve);
        }
        function uu() {
          Se !== n && Sh(Se), st = 0, U = Re = re = Se = n;
        }
        function wo() {
          return Se === n ? ve : $r(oe());
        }
        function Lu() {
          var Io = oe(), Qa = Rn(Io);
          if (U = arguments, re = this, Re = Io, Qa) {
            if (Se === n)
              return Sn(Re);
            if (ct)
              return Sh(Se), Se = tf(Sr, M), Gt(Re);
          }
          return Se === n && (Se = tf(Sr, M)), ve;
        }
        return Lu.cancel = uu, Lu.flush = wo, Lu;
      }
      var Xt = rr(function(w, M) {
        return a_(w, 1, M);
      }), Bo = rr(function(w, M, P) {
        return a_(w, of(M) || 0, P);
      });
      function Pe(w) {
        return wl(w, W);
      }
      function Te(w, M) {
        if (typeof w != "function" || M != null && typeof M != "function")
          throw new Tu(a);
        var P = function() {
          var U = arguments, re = M ? M.apply(this, U) : U[0], ce = P.cache;
          if (ce.has(re))
            return ce.get(re);
          var ve = w.apply(this, U);
          return P.cache = ce.set(re, ve) || ce, ve;
        };
        return P.cache = new (Te.Cache || yl)(), P;
      }
      Te.Cache = yl;
      function Ie(w) {
        if (typeof w != "function")
          throw new Tu(a);
        return function() {
          var M = arguments;
          switch (M.length) {
            case 0:
              return !w.call(this);
            case 1:
              return !w.call(this, M[0]);
            case 2:
              return !w.call(this, M[0], M[1]);
            case 3:
              return !w.call(this, M[0], M[1], M[2]);
          }
          return !w.apply(this, M);
        };
      }
      function wt(w) {
        return He(2, w);
      }
      var Jt = s1(function(w, M) {
        M = M.length == 1 && ir(M[0]) ? kr(M[0], Wr(un())) : kr(ca(M, 1), Wr(un()));
        var P = M.length;
        return rr(function(U) {
          for (var re = -1, ce = Ea(U.length, P); ++re < ce; )
            U[re] = M[re].call(this, U[re]);
          return tr(w, this, U);
        });
      }), Wt = rr(function(w, M) {
        var P = fl(M, Nh(Wt));
        return wl(w, R, n, M, P);
      }), rn = rr(function(w, M) {
        var P = fl(M, Nh(rn));
        return wl(w, j, n, M, P);
      }), On = Jc(function(w, M) {
        return wl(w, z, n, n, n, M);
      });
      function Aa(w, M) {
        if (typeof w != "function")
          throw new Tu(a);
        return M = M === n ? M : Jn(M), rr(w, M);
      }
      function Br(w, M) {
        if (typeof w != "function")
          throw new Tu(a);
        return M = M == null ? 0 : zo(Jn(M), 0), rr(function(P) {
          var U = P[M], re = uc(P, 0, M);
          return U && cl(re, U), tr(w, this, re);
        });
      }
      function Ih(w, M, P) {
        var U = !0, re = !0;
        if (typeof w != "function")
          throw new Tu(a);
        return Po(P) && (U = "leading" in P ? !!P.leading : U, re = "trailing" in P ? !!P.trailing : re), qt(w, M, {
          leading: U,
          maxWait: M,
          trailing: re
        });
      }
      function fD(w) {
        return Ee(w, 1);
      }
      function l9(w, M) {
        return Wt(zm(M), w);
      }
      function j4() {
        if (!arguments.length)
          return [];
        var w = arguments[0];
        return ir(w) ? w : [w];
      }
      function L4(w) {
        return Cs(w, g);
      }
      function c9(w, M) {
        return M = typeof M == "function" ? M : n, Cs(w, g, M);
      }
      function f9(w) {
        return Cs(w, h | g);
      }
      function z4(w, M) {
        return M = typeof M == "function" ? M : n, Cs(w, h | g, M);
      }
      function dD(w, M) {
        return M == null || Pv(w, M, ms(M));
      }
      function dd(w, M) {
        return w === M || w !== w && M !== M;
      }
      var d9 = Fm(oc), h9 = Fm(function(w, M) {
        return w >= M;
      }), s0 = e1(function() {
        return arguments;
      }()) ? e1 : function(w) {
        return Yo(w) && Gr.call(w, "callee") && !ah.call(w, "callee");
      }, ir = Fe.isArray, p9 = gn ? Wr(gn) : yh;
      function Ga(w) {
        return w != null && I_(w.length) && !Lh(w);
      }
      function Uo(w) {
        return Yo(w) && Ga(w);
      }
      function $_(w) {
        return w === !0 || w === !1 || Yo(w) && fs(w) == Me;
      }
      var jh = Gb || jD, g9 = Dt ? Wr(Dt) : Hp;
      function m9(w) {
        return Yo(w) && w.nodeType === 1 && !u0(w);
      }
      function F4(w) {
        if (w == null)
          return !0;
        if (Ga(w) && (ir(w) || typeof w == "string" || typeof w.splice == "function" || jh(w) || ry(w) || s0(w)))
          return !w.length;
        var M = ho(w);
        if (M == $e || M == Zt)
          return !w.size;
        if (Hm(w))
          return !i1(w).length;
        for (var P in w)
          if (Gr.call(w, P))
            return !1;
        return !0;
      }
      function y9(w, M) {
        return Om(w, M);
      }
      function W2(w, M, P) {
        P = typeof P == "function" ? P : n;
        var U = P ? P(w, M) : n;
        return U === n ? Om(w, M, n, P) : !!U;
      }
      function ty(w) {
        if (!Yo(w))
          return !1;
        var M = fs(w);
        return M == ze || M == Ye || typeof w.message == "string" && typeof w.name == "string" && !u0(w);
      }
      function hD(w) {
        return typeof w == "number" && Mm(w);
      }
      function Lh(w) {
        if (!Po(w))
          return !1;
        var M = fs(w);
        return M == fe || M == Qe || M == ke || M == jr;
      }
      function P_(w) {
        return typeof w == "number" && w == Jn(w);
      }
      function I_(w) {
        return typeof w == "number" && w > -1 && w % 1 == 0 && w <= Z;
      }
      function Po(w) {
        var M = typeof w;
        return w != null && (M == "object" || M == "function");
      }
      function Yo(w) {
        return w != null && typeof w == "object";
      }
      var pD = dn ? Wr(dn) : t1;
      function B4(w, M) {
        return w === M || n1(w, M, Kv(M));
      }
      function U4(w, M, P) {
        return P = typeof P == "function" ? P : n, n1(w, M, Kv(M), P);
      }
      function ny(w) {
        return k1(w) && w != +w;
      }
      function v9(w) {
        if (P2(w))
          throw new Yn(o);
        return l_(w);
      }
      function b9(w) {
        return w === null;
      }
      function x9(w) {
        return w == null;
      }
      function k1(w) {
        return typeof w == "number" || Yo(w) && fs(w) == pt;
      }
      function u0(w) {
        if (!Yo(w) || fs(w) != Ot)
          return !1;
        var M = dl(w);
        if (M === null)
          return !0;
        var P = Gr.call(M, "constructor") && M.constructor;
        return typeof P == "function" && P instanceof P && Mv.call(P) == _a;
      }
      var q2 = sr ? Wr(sr) : A2;
      function w9(w) {
        return P_(w) && w >= -Z && w <= Z;
      }
      var gD = Tr ? Wr(Tr) : r1;
      function G2(w) {
        return typeof w == "string" || !ir(w) && Yo(w) && fs(w) == qn;
      }
      function Cr(w) {
        return typeof w == "symbol" || Yo(w) && fs(w) == fn;
      }
      var ry = _i ? Wr(_i) : Rm;
      function Q2(w) {
        return w === n;
      }
      function j_(w) {
        return Yo(w) && ho(w) == Zn;
      }
      function Y4(w) {
        return Yo(w) && fs(w) == xr;
      }
      var H4 = Fm(vh), mD = Fm(function(w, M) {
        return w <= M;
      });
      function $1(w) {
        if (!w)
          return [];
        if (Ga(w))
          return G2(w) ? Mu(w) : da(w);
        if (Xf && w[Xf])
          return _2(w[Xf]());
        var M = ho(w), P = M == $e ? Bb : M == Zt ? Gf : j1;
        return P(w);
      }
      function ag(w) {
        if (!w)
          return w === 0 ? w : 0;
        if (w = of(w), w === X || w === -X) {
          var M = w < 0 ? -1 : 1;
          return M * se;
        }
        return w === w ? w : 0;
      }
      function Jn(w) {
        var M = ag(w), P = M % 1;
        return M === M ? P ? M - P : M : 0;
      }
      function l0(w) {
        return w ? Xc(Jn(w), 0, ie) : 0;
      }
      function of(w) {
        if (typeof w == "number")
          return w;
        if (Cr(w))
          return H;
        if (Po(w)) {
          var M = typeof w.valueOf == "function" ? w.valueOf() : w;
          w = Po(M) ? M + "" : M;
        }
        if (typeof w != "string")
          return w === 0 ? w : +w;
        w = Hc(w);
        var P = sn.test(w);
        return P || xi.test(w) ? kp(w.slice(2), P ? 2 : 8) : zn.test(w) ? H : +w;
      }
      function yD(w) {
        return qa(w, Ml(w));
      }
      function _9(w) {
        return w ? Xc(Jn(w), -Z, Z) : w === 0 ? w : 0;
      }
      function Si(w) {
        return w == null ? "" : fo(w);
      }
      var Sl = ad(function(w, M) {
        if (Hm(M) || Ga(M)) {
          qa(M, ms(M), w);
          return;
        }
        for (var P in M)
          Gr.call(M, P) && Yp(w, P, M[P]);
      }), P1 = ad(function(w, M) {
        qa(M, Ml(M), w);
      }), c0 = ad(function(w, M, P, U) {
        qa(M, Ml(M), w, U);
      }), iy = ad(function(w, M, P, U) {
        qa(M, ms(M), w, U);
      }), V4 = Jc(Kb);
      function f0(w, M) {
        var P = ch(w);
        return M == null ? P : Vi(P, M);
      }
      var d0 = rr(function(w, M) {
        w = oi(w);
        var P = -1, U = M.length, re = U > 2 ? M[2] : n;
        for (re && Fr(M[0], M[1], re) && (U = 1); ++P < U; )
          for (var ce = M[P], ve = Ml(ce), Se = -1, Re = ve.length; ++Se < Re; ) {
            var st = ve[Se], rt = w[st];
            (rt === n || dd(rt, Vc[st]) && !Gr.call(w, st)) && (w[st] = ce[st]);
          }
        return w;
      }), X2 = rr(function(w) {
        return w.push(n, Ch), tr(X4, n, w);
      });
      function vD(w, M) {
        return Xw(w, un(M, 3), Ii);
      }
      function K2(w, M) {
        return Xw(w, un(M, 3), Ct);
      }
      function L_(w, M) {
        return w == null ? w : jv(w, un(M, 3), Ml);
      }
      function W4(w, M) {
        return w == null ? w : ed(w, un(M, 3), Ml);
      }
      function Z2(w, M) {
        return w && Ii(w, un(M, 3));
      }
      function q4(w, M) {
        return w && Ct(w, un(M, 3));
      }
      function G4(w) {
        return w == null ? [] : uo(w, ms(w));
      }
      function E9(w) {
        return w == null ? [] : uo(w, Ml(w));
      }
      function bD(w, M, P) {
        var U = w == null ? n : bo(w, M);
        return U === n ? P : U;
      }
      function J2(w, M) {
        return w != null && Ru(w, M, ph);
      }
      function I1(w, M) {
        return w != null && Ru(w, M, s_);
      }
      var Q4 = Qv(function(w, M, P) {
        M != null && typeof M.toString != "function" && (M = _m.call(M)), w[M] = P;
      }, AD(Tl)), S9 = Qv(function(w, M, P) {
        M != null && typeof M.toString != "function" && (M = _m.call(M)), Gr.call(w, M) ? w[M].push(P) : w[M] = [P];
      }, un), eM = rr(mh);
      function ms(w) {
        return Ga(w) ? Ma(w) : i1(w);
      }
      function Ml(w) {
        return Ga(w) ? Ma(w, !0) : O2(w);
      }
      function M9(w, M) {
        var P = {};
        return M = un(M, 3), Ii(w, function(U, re, ce) {
          ic(P, M(U, re, ce), U);
        }), P;
      }
      function T9(w, M) {
        var P = {};
        return M = un(M, 3), Ii(w, function(U, re, ce) {
          ic(P, re, M(U, re, ce));
        }), P;
      }
      var C9 = ad(function(w, M, P) {
        bh(w, M, P);
      }), X4 = ad(function(w, M, P, U) {
        bh(w, M, P, U);
      }), N9 = Jc(function(w, M) {
        var P = {};
        if (w == null)
          return P;
        var U = !1;
        M = kr(M, function(ce) {
          return ce = sc(ce, w), U || (U = ce.length > 1), ce;
        }), qa(w, ld(w), P), U && (P = Cs(P, h | p | g, Gn));
        for (var re = M.length; re--; )
          rd(P, M[re]);
        return P;
      });
      function D9(w, M) {
        return K4(w, Ie(un(M)));
      }
      var A9 = Jc(function(w, M) {
        return w == null ? {} : wh(w, M);
      });
      function K4(w, M) {
        if (w == null)
          return {};
        var P = kr(ld(w), function(U) {
          return [U];
        });
        return M = un(M), hn(w, P, function(U, re) {
          return M(U, re[0]);
        });
      }
      function xD(w, M, P) {
        M = sc(M, w);
        var U = -1, re = M.length;
        for (re || (re = 1, w = n); ++U < re; ) {
          var ce = w == null ? n : w[Ds(M[U])];
          ce === n && (U = re, ce = P), w = Lh(ce) ? ce.call(w) : ce;
        }
        return w;
      }
      function wD(w, M, P) {
        return w == null ? w : Xe(w, M, P);
      }
      function _D(w, M, P, U) {
        return U = typeof U == "function" ? U : n, w == null ? w : Xe(w, M, P, U);
      }
      var tM = ud(ms), Z4 = ud(Ml);
      function z_(w, M, P) {
        var U = ir(w), re = U || jh(w) || ry(w);
        if (M = un(M, 4), P == null) {
          var ce = w && w.constructor;
          re ? P = U ? new ce() : [] : Po(w) ? P = Lh(ce) ? ch(dl(w)) : {} : P = {};
        }
        return (re ? yr : Ii)(w, function(ve, Se, Re) {
          return M(P, ve, Se, Re);
        }), P;
      }
      function F_(w, M) {
        return w == null ? !0 : rd(w, M);
      }
      function O9(w, M, P) {
        return w == null ? w : Im(w, M, zm(P));
      }
      function J4(w, M, P, U) {
        return U = typeof U == "function" ? U : n, w == null ? w : Im(w, M, zm(P), U);
      }
      function j1(w) {
        return w == null ? [] : Su(w, ms(w));
      }
      function R9(w) {
        return w == null ? [] : Su(w, Ml(w));
      }
      function eP(w, M, P) {
        return P === n && (P = M, M = n), P !== n && (P = of(P), P = P === P ? P : 0), M !== n && (M = of(M), M = M === M ? M : 0), Xc(of(w), M, P);
      }
      function k9(w, M, P) {
        return M = ag(M), P === n ? (P = M, M = 0) : P = ag(P), w = of(w), fa(w, M, P);
      }
      function $9(w, M, P) {
        if (P && typeof P != "boolean" && Fr(w, M, P) && (M = P = n), P === n && (typeof M == "boolean" ? (P = M, M = n) : typeof w == "boolean" && (P = w, w = n)), w === n && M === n ? (w = 0, M = 1) : (w = ag(w), M === n ? (M = w, w = 0) : M = ag(M)), w > M) {
          var U = w;
          w = M, M = U;
        }
        if (P || w % 1 || M % 1) {
          var re = Av();
          return Ea(w + re * (M - w + rh("1e-" + ((re + "").length - 1))), M);
        }
        return au(w, M);
      }
      var tP = sd(function(w, M, P) {
        return M = M.toLowerCase(), w + (P ? B_(M) : M);
      });
      function B_(w) {
        return ND(Si(w).toLowerCase());
      }
      function U_(w) {
        return w = Si(w), w && w.replace(nn, x2).replace(eu, "");
      }
      function nM(w, M, P) {
        w = Si(w), M = fo(M);
        var U = w.length;
        P = P === n ? U : Xc(Jn(P), 0, U);
        var re = P;
        return P -= M.length, P >= 0 && w.slice(P, re) == M;
      }
      function Y_(w) {
        return w = Si(w), w && ws.test(w) ? w.replace(Ar, w2) : w;
      }
      function H_(w) {
        return w = Si(w), w && Es.test(w) ? w.replace(as, "\\$&") : w;
      }
      var P9 = sd(function(w, M, P) {
        return w + (P ? "-" : "") + M.toLowerCase();
      }), ED = sd(function(w, M, P) {
        return w + (P ? " " : "") + M.toLowerCase();
      }), SD = d_("toLowerCase");
      function I9(w, M, P) {
        w = Si(w), M = Jn(M);
        var U = M ? oh(w) : 0;
        if (!M || U >= M)
          return w;
        var re = (M - U) / 2;
        return Th(Kf(re), P) + w + Th(hl(re), P);
      }
      function j9(w, M, P) {
        w = Si(w), M = Jn(M);
        var U = M ? oh(w) : 0;
        return M && U < M ? w + Th(M - U, P) : w;
      }
      function Yie(w, M, P) {
        w = Si(w), M = Jn(M);
        var U = M ? oh(w) : 0;
        return M && U < M ? Th(M - U, P) + w : w;
      }
      function L9(w, M, P) {
        return P || M == null ? M = 0 : M && (M = +M), r_(Si(w).replace(xa, ""), M || 0);
      }
      function z9(w, M, P) {
        return (P ? Fr(w, M, P) : M === n) ? M = 1 : M = Jn(M), Pm(Si(w), M);
      }
      function F9() {
        var w = arguments, M = Si(w[0]);
        return w.length < 3 ? M : M.replace(w[1], w[2]);
      }
      var B9 = sd(function(w, M, P) {
        return w + (P ? "_" : "") + M.toLowerCase();
      });
      function U9(w, M, P) {
        return P && typeof P != "number" && Fr(w, M, P) && (M = P = n), P = P === n ? ie : P >>> 0, P ? (w = Si(w), w && (typeof M == "string" || M != null && !q2(M)) && (M = fo(M), !M && ym(w)) ? uc(Mu(w), 0, P) : w.split(M, P)) : [];
      }
      var Y9 = sd(function(w, M, P) {
        return w + (P ? " " : "") + ND(M);
      });
      function MD(w, M, P) {
        return w = Si(w), P = P == null ? 0 : Xc(Jn(P), 0, w.length), M = fo(M), w.slice(P, P + M.length) == M;
      }
      function H9(w, M, P) {
        var U = ue.templateSettings;
        P && Fr(w, M, P) && (M = n), w = Si(w), M = c0({}, M, U, Ns);
        var re = c0({}, M.imports, U.imports, Ns), ce = ms(re), ve = Su(re, ce), Se, Re, st = 0, rt = M.interpolate || Oi, ct = "__p += '", Nt = tc(
          (M.escape || Oi).source + "|" + rt.source + "|" + (rt === zc ? In : Oi).source + "|" + (M.evaluate || Oi).source + "|$",
          "g"
        ), Gt = "//# sourceURL=" + (Gr.call(M, "sourceURL") ? (M.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++jb + "]") + `
`;
        w.replace(Nt, function(Rn, Sr, $r, uu, wo, Lu) {
          return $r || ($r = uu), ct += w.slice(st, Lu).replace(lm, Fb), Sr && (Se = !0, ct += `' +
__e(` + Sr + `) +
'`), wo && (Re = !0, ct += `';
` + wo + `;
__p += '`), $r && (ct += `' +
((__t = (` + $r + `)) == null ? '' : __t) +
'`), st = Lu + Rn.length, Rn;
        }), ct += `';
`;
        var Sn = Gr.call(M, "variable") && M.variable;
        if (!Sn)
          ct = `with (obj) {
` + ct + `
}
`;
        else if (St.test(Sn))
          throw new Yn(s);
        ct = (Re ? ct.replace(ua, "") : ct).replace(Zr, "$1").replace(Wa, "$1;"), ct = "function(" + (Sn || "obj") + `) {
` + (Sn ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Se ? ", __e = _.escape" : "") + (Re ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ct + `return __p
}`;
        var ur = rP(function() {
          return qr(ce, Gt + "return " + ct).apply(n, ve);
        });
        if (ur.source = ct, ty(ur))
          throw ur;
        return ur;
      }
      function V9(w) {
        return Si(w).toLowerCase();
      }
      function TD(w) {
        return Si(w).toUpperCase();
      }
      function W9(w, M, P) {
        if (w = Si(w), w && (P || M === n))
          return Hc(w);
        if (!w || !(M = fo(M)))
          return w;
        var U = Mu(w), re = Mu(M), ce = Sv(U, re), ve = Zw(U, re) + 1;
        return uc(U, ce, ve).join("");
      }
      function CD(w, M, P) {
        if (w = Si(w), w && (P || M === n))
          return w.slice(0, Ub(w) + 1);
        if (!w || !(M = fo(M)))
          return w;
        var U = Mu(w), re = Zw(U, Mu(M)) + 1;
        return uc(U, 0, re).join("");
      }
      function nP(w, M, P) {
        if (w = Si(w), w && (P || M === n))
          return w.replace(xa, "");
        if (!w || !(M = fo(M)))
          return w;
        var U = Mu(w), re = Sv(U, Mu(M));
        return uc(U, re).join("");
      }
      function q9(w, M) {
        var P = Y, U = V;
        if (Po(M)) {
          var re = "separator" in M ? M.separator : re;
          P = "length" in M ? Jn(M.length) : P, U = "omission" in M ? fo(M.omission) : U;
        }
        w = Si(w);
        var ce = w.length;
        if (ym(w)) {
          var ve = Mu(w);
          ce = ve.length;
        }
        if (P >= ce)
          return w;
        var Se = P - oh(U);
        if (Se < 1)
          return U;
        var Re = ve ? uc(ve, 0, Se).join("") : w.slice(0, Se);
        if (re === n)
          return Re + U;
        if (ve && (Se += Re.length - Se), q2(re)) {
          if (w.slice(Se).search(re)) {
            var st, rt = Re;
            for (re.global || (re = tc(re.source, Si(lr.exec(re)) + "g")), re.lastIndex = 0; st = re.exec(rt); )
              var ct = st.index;
            Re = Re.slice(0, ct === n ? Se : ct);
          }
        } else if (w.indexOf(fo(re), Se) != Se) {
          var Nt = Re.lastIndexOf(re);
          Nt > -1 && (Re = Re.slice(0, Nt));
        }
        return Re + U;
      }
      function G9(w) {
        return w = Si(w), w && Ks.test(w) ? w.replace(Lr, S2) : w;
      }
      var Q9 = sd(function(w, M, P) {
        return w + (P ? " " : "") + M.toUpperCase();
      }), ND = d_("toUpperCase");
      function DD(w, M, P) {
        return w = Si(w), M = P ? n : M, M === n ? GN(w) ? QN(w) : Qw(w) : w.match(M) || [];
      }
      var rP = rr(function(w, M) {
        try {
          return tr(w, n, M);
        } catch (P) {
          return ty(P) ? P : new Yn(P);
        }
      }), X9 = Jc(function(w, M) {
        return yr(M, function(P) {
          P = Ds(P), ic(w, P, ft(w[P], w));
        }), w;
      });
      function K9(w) {
        var M = w == null ? 0 : w.length, P = un();
        return w = M ? kr(w, function(U) {
          if (typeof U[1] != "function")
            throw new Tu(a);
          return [P(U[0]), U[1]];
        }) : [], rr(function(U) {
          for (var re = -1; ++re < M; ) {
            var ce = w[re];
            if (tr(ce[0], this, U))
              return tr(ce[1], this, U);
          }
        });
      }
      function Z9(w) {
        return D2(Cs(w, h));
      }
      function AD(w) {
        return function() {
          return w;
        };
      }
      function J9(w, M) {
        return w == null || w !== w ? M : w;
      }
      var e7 = Qp(), OD = Qp(!0);
      function Tl(w) {
        return w;
      }
      function RD(w) {
        return Lv(typeof w == "function" ? w : Cs(w, h));
      }
      function t7(w) {
        return km(Cs(w, h));
      }
      function n7(w, M) {
        return xl(w, Cs(M, h));
      }
      var r7 = rr(function(w, M) {
        return function(P) {
          return mh(P, w, M);
        };
      }), i7 = rr(function(w, M) {
        return function(P) {
          return mh(w, P, M);
        };
      });
      function kD(w, M, P) {
        var U = ms(M), re = uo(M, U);
        P == null && !(Po(M) && (re.length || !U.length)) && (P = M, M = w, w = this, re = uo(M, ms(M)));
        var ce = !(Po(P) && "chain" in P) || !!P.chain, ve = Lh(w);
        return yr(re, function(Se) {
          var Re = M[Se];
          w[Se] = Re, ve && (w.prototype[Se] = function() {
            var st = this.__chain__;
            if (ce || st) {
              var rt = w(this.__wrapped__), ct = rt.__actions__ = da(this.__actions__);
              return ct.push({ func: Re, args: arguments, thisArg: w }), rt.__chain__ = st, rt;
            }
            return Re.apply(w, cl([this.value()], arguments));
          });
        }), w;
      }
      function o7() {
        return Ri._ === this && (Ri._ = t_), this;
      }
      function $D() {
      }
      function iP(w) {
        return w = Jn(w), rr(function(M) {
          return xh(M, w);
        });
      }
      var PD = f1(kr), a7 = f1(Uc), s7 = f1(qw);
      function V_(w) {
        return p1(w) ? Ev(Ds(w)) : fr(w);
      }
      function W_(w) {
        return function(M) {
          return w == null ? n : bo(w, M);
        };
      }
      var u7 = d1(), l7 = d1(!0);
      function ID() {
        return [];
      }
      function jD() {
        return !1;
      }
      function c7() {
        return {};
      }
      function f7() {
        return "";
      }
      function d7() {
        return !0;
      }
      function oP(w, M) {
        if (w = Jn(w), w < 1 || w > Z)
          return [];
        var P = ie, U = Ea(w, ie);
        M = un(M), w -= ie;
        for (var re = zb(U, M); ++P < w; )
          M(P);
        return re;
      }
      function h7(w) {
        return ir(w) ? kr(w, Ds) : Cr(w) ? [w] : da(b_(Si(w)));
      }
      function p7(w) {
        var M = ++jp;
        return Si(w) + M;
      }
      var g7 = c1(function(w, M) {
        return w + M;
      }, 0), m7 = Ro("ceil"), y7 = c1(function(w, M) {
        return w / M;
      }, 1), v7 = Ro("floor");
      function b7(w) {
        return w && w.length ? Ou(w, Tl, oc) : n;
      }
      function x7(w, M) {
        return w && w.length ? Ou(w, un(M, 2), oc) : n;
      }
      function w7(w) {
        return b2(w, Tl);
      }
      function _7(w, M) {
        return b2(w, un(M, 2));
      }
      function E7(w) {
        return w && w.length ? Ou(w, Tl, vh) : n;
      }
      function S7(w, M) {
        return w && w.length ? Ou(w, un(M, 2), vh) : n;
      }
      var M7 = c1(function(w, M) {
        return w * M;
      }, 1), T7 = Ro("round"), C7 = c1(function(w, M) {
        return w - M;
      }, 0);
      function N7(w) {
        return w && w.length ? pm(w, Tl) : 0;
      }
      function L1(w, M) {
        return w && w.length ? pm(w, un(M, 2)) : 0;
      }
      return ue.after = me, ue.ary = Ee, ue.assign = Sl, ue.assignIn = P1, ue.assignInWith = c0, ue.assignWith = iy, ue.at = V4, ue.before = He, ue.bind = ft, ue.bindAll = X9, ue.bindKey = mt, ue.castArray = j4, ue.chain = ju, ue.chunk = m1, ue.compact = e0, ue.concat = __, ue.cond = K9, ue.conforms = Z9, ue.constant = AD, ue.countBy = B2, ue.create = f0, ue.curry = dt, ue.curryRight = jt, ue.debounce = qt, ue.defaults = d0, ue.defaultsDeep = X2, ue.defer = Xt, ue.delay = Bo, ue.difference = hs, ue.differenceBy = vr, ue.differenceWith = xo, ue.drop = ko, ue.dropRight = Na, ue.dropRightWhile = Iu, ue.dropWhile = qm, ue.fill = ga, ue.filter = U2, ue.flatMap = Y2, ue.flatMapDeep = R_, ue.flatMapDepth = H2, ue.flatten = t0, ue.flattenDeep = Qm, ue.flattenDepth = Jp, ue.flip = Pe, ue.flow = e7, ue.flowRight = OD, ue.fromPairs = As, ue.functions = G4, ue.functionsIn = E9, ue.groupBy = fd, ue.initial = cd, ue.intersection = v1, ue.intersectionBy = eg, ue.intersectionWith = rf, ue.invert = Q4, ue.invertBy = S9, ue.invokeMap = D1, ue.iteratee = RD, ue.keyBy = V2, ue.keys = ms, ue.keysIn = Ml, ue.map = A1, ue.mapKeys = M9, ue.mapValues = T9, ue.matches = t7, ue.matchesProperty = n7, ue.memoize = Te, ue.merge = C9, ue.mergeWith = X4, ue.method = r7, ue.methodOf = i7, ue.mixin = kD, ue.negate = Ie, ue.nthArg = iP, ue.omit = N9, ue.omitBy = D9, ue.once = wt, ue.orderBy = O1, ue.over = PD, ue.overArgs = Jt, ue.overEvery = a7, ue.overSome = s7, ue.partial = Wt, ue.partialRight = rn, ue.partition = lD, ue.pick = A9, ue.pickBy = K4, ue.property = V_, ue.propertyOf = W_, ue.pull = x1, ue.pullAll = Rh, ue.pullAllBy = tg, ue.pullAllWith = ps, ue.pullAt = ea, ue.range = u7, ue.rangeRight = l7, ue.rearg = On, ue.reject = R1, ue.remove = gs, ue.rest = Aa, ue.reverse = Da, ue.sampleSize = v, ue.set = wD, ue.setWith = _D, ue.shuffle = T, ue.slice = Zm, ue.sortBy = B, ue.sortedUniq = kh, ue.sortedUniqBy = M_, ue.split = U9, ue.spread = Br, ue.tail = ng, ue.take = L2, ue.takeRight = w1, ue.takeRightWhile = T_, ue.takeWhile = _1, ue.tap = A_, ue.throttle = Ih, ue.thru = S1, ue.toArray = $1, ue.toPairs = tM, ue.toPairsIn = Z4, ue.toPath = h7, ue.toPlainObject = yD, ue.transform = z_, ue.unary = fD, ue.union = tD, ue.unionBy = nD, ue.unionWith = z2, ue.uniq = C_, ue.uniqBy = rg, ue.uniqWith = rD, ue.unset = F_, ue.unzip = $h, ue.unzipWith = N_, ue.update = O9, ue.updateWith = J4, ue.values = j1, ue.valuesIn = R9, ue.without = $o, ue.words = DD, ue.wrap = l9, ue.xor = iD, ue.xorBy = E1, ue.xorWith = oD, ue.zip = aD, ue.zipObject = F2, ue.zipObjectDeep = D_, ue.zipWith = sD, ue.entries = tM, ue.entriesIn = Z4, ue.extend = P1, ue.extendWith = c0, kD(ue, ue), ue.add = g7, ue.attempt = rP, ue.camelCase = tP, ue.capitalize = B_, ue.ceil = m7, ue.clamp = eP, ue.clone = L4, ue.cloneDeep = f9, ue.cloneDeepWith = z4, ue.cloneWith = c9, ue.conformsTo = dD, ue.deburr = U_, ue.defaultTo = J9, ue.divide = y7, ue.endsWith = nM, ue.eq = dd, ue.escape = Y_, ue.escapeRegExp = H_, ue.every = O_, ue.find = o0, ue.findIndex = Gm, ue.findKey = vD, ue.findLast = C1, ue.findLastIndex = nf, ue.findLastKey = K2, ue.floor = v7, ue.forEach = N1, ue.forEachRight = a0, ue.forIn = L_, ue.forInRight = W4, ue.forOwn = Z2, ue.forOwnRight = q4, ue.get = bD, ue.gt = d9, ue.gte = h9, ue.has = J2, ue.hasIn = I1, ue.head = y1, ue.identity = Tl, ue.includes = k_, ue.indexOf = Xm, ue.inRange = k9, ue.invoke = eM, ue.isArguments = s0, ue.isArray = ir, ue.isArrayBuffer = p9, ue.isArrayLike = Ga, ue.isArrayLikeObject = Uo, ue.isBoolean = $_, ue.isBuffer = jh, ue.isDate = g9, ue.isElement = m9, ue.isEmpty = F4, ue.isEqual = y9, ue.isEqualWith = W2, ue.isError = ty, ue.isFinite = hD, ue.isFunction = Lh, ue.isInteger = P_, ue.isLength = I_, ue.isMap = pD, ue.isMatch = B4, ue.isMatchWith = U4, ue.isNaN = ny, ue.isNative = v9, ue.isNil = x9, ue.isNull = b9, ue.isNumber = k1, ue.isObject = Po, ue.isObjectLike = Yo, ue.isPlainObject = u0, ue.isRegExp = q2, ue.isSafeInteger = w9, ue.isSet = gD, ue.isString = G2, ue.isSymbol = Cr, ue.isTypedArray = ry, ue.isUndefined = Q2, ue.isWeakMap = j_, ue.isWeakSet = Y4, ue.join = Oh, ue.kebabCase = P9, ue.last = ma, ue.lastIndexOf = b1, ue.lowerCase = ED, ue.lowerFirst = SD, ue.lt = H4, ue.lte = mD, ue.max = b7, ue.maxBy = x7, ue.mean = w7, ue.meanBy = _7, ue.min = E7, ue.minBy = S7, ue.stubArray = ID, ue.stubFalse = jD, ue.stubObject = c7, ue.stubString = f7, ue.stubTrue = d7, ue.multiply = M7, ue.nth = Km, ue.noConflict = o7, ue.noop = $D, ue.now = oe, ue.pad = I9, ue.padEnd = j9, ue.padStart = Yie, ue.parseInt = L9, ue.random = $9, ue.reduce = ey, ue.reduceRight = cD, ue.repeat = z9, ue.replace = F9, ue.result = xD, ue.round = T7, ue.runInContext = Ae, ue.sample = m, ue.size = k, ue.snakeCase = B9, ue.some = L, ue.sortedIndex = E_, ue.sortedIndexBy = n0, ue.sortedIndexOf = S_, ue.sortedLastIndex = El, ue.sortedLastIndexBy = j2, ue.sortedLastIndexOf = Jm, ue.startCase = Y9, ue.startsWith = MD, ue.subtract = C7, ue.sum = N7, ue.sumBy = L1, ue.template = H9, ue.times = oP, ue.toFinite = ag, ue.toInteger = Jn, ue.toLength = l0, ue.toLower = V9, ue.toNumber = of, ue.toSafeInteger = _9, ue.toString = Si, ue.toUpper = TD, ue.trim = W9, ue.trimEnd = CD, ue.trimStart = nP, ue.truncate = q9, ue.unescape = G9, ue.uniqueId = p7, ue.upperCase = Q9, ue.upperFirst = ND, ue.each = N1, ue.eachRight = a0, ue.first = y1, kD(ue, function() {
        var w = {};
        return Ii(ue, function(M, P) {
          Gr.call(ue.prototype, P) || (w[P] = M);
        }), w;
      }(), { chain: !1 }), ue.VERSION = r, yr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(w) {
        ue[w].placeholder = ue;
      }), yr(["drop", "take"], function(w, M) {
        nr.prototype[w] = function(P) {
          P = P === n ? 1 : zo(Jn(P), 0);
          var U = this.__filtered__ && !M ? new nr(this) : this.clone();
          return U.__filtered__ ? U.__takeCount__ = Ea(P, U.__takeCount__) : U.__views__.push({
            size: Ea(P, ie),
            type: w + (U.__dir__ < 0 ? "Right" : "")
          }), U;
        }, nr.prototype[w + "Right"] = function(P) {
          return this.reverse()[w](P).reverse();
        };
      }), yr(["filter", "map", "takeWhile"], function(w, M) {
        var P = M + 1, U = P == Q || P == te;
        nr.prototype[w] = function(re) {
          var ce = this.clone();
          return ce.__iteratees__.push({
            iteratee: un(re, 3),
            type: P
          }), ce.__filtered__ = ce.__filtered__ || U, ce;
        };
      }), yr(["head", "last"], function(w, M) {
        var P = "take" + (M ? "Right" : "");
        nr.prototype[w] = function() {
          return this[P](1).value()[0];
        };
      }), yr(["initial", "tail"], function(w, M) {
        var P = "drop" + (M ? "" : "Right");
        nr.prototype[w] = function() {
          return this.__filtered__ ? new nr(this) : this[P](1);
        };
      }), nr.prototype.compact = function() {
        return this.filter(Tl);
      }, nr.prototype.find = function(w) {
        return this.filter(w).head();
      }, nr.prototype.findLast = function(w) {
        return this.reverse().find(w);
      }, nr.prototype.invokeMap = rr(function(w, M) {
        return typeof w == "function" ? new nr(this) : this.map(function(P) {
          return mh(P, w, M);
        });
      }), nr.prototype.reject = function(w) {
        return this.filter(Ie(un(w)));
      }, nr.prototype.slice = function(w, M) {
        w = Jn(w);
        var P = this;
        return P.__filtered__ && (w > 0 || M < 0) ? new nr(P) : (w < 0 ? P = P.takeRight(-w) : w && (P = P.drop(w)), M !== n && (M = Jn(M), P = M < 0 ? P.dropRight(-M) : P.take(M - w)), P);
      }, nr.prototype.takeRightWhile = function(w) {
        return this.reverse().takeWhile(w).reverse();
      }, nr.prototype.toArray = function() {
        return this.take(ie);
      }, Ii(nr.prototype, function(w, M) {
        var P = /^(?:filter|find|map|reject)|While$/.test(M), U = /^(?:head|last)$/.test(M), re = ue[U ? "take" + (M == "last" ? "Right" : "") : M], ce = U || /^find/.test(M);
        re && (ue.prototype[M] = function() {
          var ve = this.__wrapped__, Se = U ? [1] : arguments, Re = ve instanceof nr, st = Se[0], rt = Re || ir(ve), ct = function(Sr) {
            var $r = re.apply(ue, cl([Sr], Se));
            return U && Nt ? $r[0] : $r;
          };
          rt && P && typeof st == "function" && st.length != 1 && (Re = rt = !1);
          var Nt = this.__chain__, Gt = !!this.__actions__.length, Sn = ce && !Nt, ur = Re && !Gt;
          if (!ce && rt) {
            ve = ur ? ve : new nr(this);
            var Rn = w.apply(ve, Se);
            return Rn.__actions__.push({ func: S1, args: [ct], thisArg: n }), new us(Rn, Nt);
          }
          return Sn && ur ? w.apply(this, Se) : (Rn = this.thru(ct), Sn ? U ? Rn.value()[0] : Rn.value() : Rn);
        });
      }), yr(["pop", "push", "shift", "sort", "splice", "unshift"], function(w) {
        var M = nu[w], P = /^(?:push|sort|unshift)$/.test(w) ? "tap" : "thru", U = /^(?:pop|shift)$/.test(w);
        ue.prototype[w] = function() {
          var re = arguments;
          if (U && !this.__chain__) {
            var ce = this.value();
            return M.apply(ir(ce) ? ce : [], re);
          }
          return this[P](function(ve) {
            return M.apply(ir(ve) ? ve : [], re);
          });
        };
      }), Ii(nr.prototype, function(w, M) {
        var P = ue[M];
        if (P) {
          var U = P.name + "";
          Gr.call(Nm, U) || (Nm[U] = []), Nm[U].push({ name: M, func: P });
        }
      }), Nm[Mh(n, S).name] = [{
        name: "wrapper",
        func: n
      }], nr.prototype.clone = cn, nr.prototype.reverse = fh, nr.prototype.value = no, ue.prototype.at = Ph, ue.prototype.chain = M1, ue.prototype.commit = ig, ue.prototype.next = r0, ue.prototype.plant = og, ue.prototype.reverse = uD, ue.prototype.toJSON = ue.prototype.valueOf = ue.prototype.value = T1, ue.prototype.first = ue.prototype.head, Xf && (ue.prototype[Xf] = i0), ue;
    }, xm = XN();
    be ? ((be.exports = xm)._ = xm, ne._ = xm) : Ri._ = xm;
  }).call(wA);
})($j, $j.exports);
var ar = $j.exports;
const $x = "-", e0e = "Data Not Available", iue = "left", Ize = "max", oue = "SITENAME", _X = "number", jze = "dimensions", Lze = "metrics", zze = "bar", EI = "asc", Fze = "desc", Bze = "rgba(1, 107, 255, 0.08)", Uze = 10, Yze = [10, 15, 20], Hze = {
  black: "#000",
  white: "#fff"
}, XR = Hze, Vze = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, NM = Vze, Wze = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, DM = Wze, qze = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, AM = qze, Gze = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, OM = Gze, Qze = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, RM = Qze, Xze = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, MA = Xze, Kze = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Zze = Kze;
function KS(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...r) {
    return e(...r) || t(...r);
  };
}
function ge() {
  return ge = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ge.apply(this, arguments);
}
function NE(e) {
  return e !== null && typeof e == "object" && e.constructor === Object;
}
function t0e(e) {
  if (!NE(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = t0e(e[n]);
  }), t;
}
function ip(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? ge({}, e) : e;
  return NE(e) && NE(t) && Object.keys(t).forEach((i) => {
    i !== "__proto__" && (NE(t[i]) && i in e && NE(e[i]) ? r[i] = ip(e[i], t[i], n) : n.clone ? r[i] = NE(t[i]) ? t0e(t[i]) : t[i] : r[i] = t[i]);
  }), r;
}
var eW = { exports: {} }, SI = { exports: {} }, Gi = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aue;
function Jze() {
  if (aue)
    return Gi;
  aue = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, f = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, b = e ? Symbol.for("react.block") : 60121, _ = e ? Symbol.for("react.fundamental") : 60117, S = e ? Symbol.for("react.responder") : 60118, C = e ? Symbol.for("react.scope") : 60119;
  function A(R) {
    if (typeof R == "object" && R !== null) {
      var j = R.$$typeof;
      switch (j) {
        case t:
          switch (R = R.type, R) {
            case u:
            case l:
            case r:
            case o:
            case i:
            case h:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case s:
                case f:
                case y:
                case g:
                case a:
                  return R;
                default:
                  return j;
              }
          }
        case n:
          return j;
      }
    }
  }
  function O(R) {
    return A(R) === l;
  }
  return Gi.AsyncMode = u, Gi.ConcurrentMode = l, Gi.ContextConsumer = s, Gi.ContextProvider = a, Gi.Element = t, Gi.ForwardRef = f, Gi.Fragment = r, Gi.Lazy = y, Gi.Memo = g, Gi.Portal = n, Gi.Profiler = o, Gi.StrictMode = i, Gi.Suspense = h, Gi.isAsyncMode = function(R) {
    return O(R) || A(R) === u;
  }, Gi.isConcurrentMode = O, Gi.isContextConsumer = function(R) {
    return A(R) === s;
  }, Gi.isContextProvider = function(R) {
    return A(R) === a;
  }, Gi.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, Gi.isForwardRef = function(R) {
    return A(R) === f;
  }, Gi.isFragment = function(R) {
    return A(R) === r;
  }, Gi.isLazy = function(R) {
    return A(R) === y;
  }, Gi.isMemo = function(R) {
    return A(R) === g;
  }, Gi.isPortal = function(R) {
    return A(R) === n;
  }, Gi.isProfiler = function(R) {
    return A(R) === o;
  }, Gi.isStrictMode = function(R) {
    return A(R) === i;
  }, Gi.isSuspense = function(R) {
    return A(R) === h;
  }, Gi.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === l || R === o || R === i || R === h || R === p || typeof R == "object" && R !== null && (R.$$typeof === y || R.$$typeof === g || R.$$typeof === a || R.$$typeof === s || R.$$typeof === f || R.$$typeof === _ || R.$$typeof === S || R.$$typeof === C || R.$$typeof === b);
  }, Gi.typeOf = A, Gi;
}
var Qi = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sue;
function eFe() {
  return sue || (sue = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, f = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, b = e ? Symbol.for("react.block") : 60121, _ = e ? Symbol.for("react.fundamental") : 60117, S = e ? Symbol.for("react.responder") : 60118, C = e ? Symbol.for("react.scope") : 60119;
    function A(fe) {
      return typeof fe == "string" || typeof fe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      fe === r || fe === l || fe === o || fe === i || fe === h || fe === p || typeof fe == "object" && fe !== null && (fe.$$typeof === y || fe.$$typeof === g || fe.$$typeof === a || fe.$$typeof === s || fe.$$typeof === f || fe.$$typeof === _ || fe.$$typeof === S || fe.$$typeof === C || fe.$$typeof === b);
    }
    function O(fe) {
      if (typeof fe == "object" && fe !== null) {
        var Qe = fe.$$typeof;
        switch (Qe) {
          case t:
            var $e = fe.type;
            switch ($e) {
              case u:
              case l:
              case r:
              case o:
              case i:
              case h:
                return $e;
              default:
                var pt = $e && $e.$$typeof;
                switch (pt) {
                  case s:
                  case f:
                  case y:
                  case g:
                  case a:
                    return pt;
                  default:
                    return Qe;
                }
            }
          case n:
            return Qe;
        }
      }
    }
    var R = u, j = l, $ = s, z = a, W = t, Y = f, V = r, ee = y, K = g, Q = n, q = o, te = i, X = h, Z = !1;
    function se(fe) {
      return Z || (Z = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), H(fe) || O(fe) === u;
    }
    function H(fe) {
      return O(fe) === l;
    }
    function ie(fe) {
      return O(fe) === s;
    }
    function he(fe) {
      return O(fe) === a;
    }
    function ye(fe) {
      return typeof fe == "object" && fe !== null && fe.$$typeof === t;
    }
    function _e(fe) {
      return O(fe) === f;
    }
    function Ne(fe) {
      return O(fe) === r;
    }
    function Oe(fe) {
      return O(fe) === y;
    }
    function ke(fe) {
      return O(fe) === g;
    }
    function Me(fe) {
      return O(fe) === n;
    }
    function we(fe) {
      return O(fe) === o;
    }
    function Ye(fe) {
      return O(fe) === i;
    }
    function ze(fe) {
      return O(fe) === h;
    }
    Qi.AsyncMode = R, Qi.ConcurrentMode = j, Qi.ContextConsumer = $, Qi.ContextProvider = z, Qi.Element = W, Qi.ForwardRef = Y, Qi.Fragment = V, Qi.Lazy = ee, Qi.Memo = K, Qi.Portal = Q, Qi.Profiler = q, Qi.StrictMode = te, Qi.Suspense = X, Qi.isAsyncMode = se, Qi.isConcurrentMode = H, Qi.isContextConsumer = ie, Qi.isContextProvider = he, Qi.isElement = ye, Qi.isForwardRef = _e, Qi.isFragment = Ne, Qi.isLazy = Oe, Qi.isMemo = ke, Qi.isPortal = Me, Qi.isProfiler = we, Qi.isStrictMode = Ye, Qi.isSuspense = ze, Qi.isValidElementType = A, Qi.typeOf = O;
  }()), Qi;
}
var uue;
function n0e() {
  return uue || (uue = 1, process.env.NODE_ENV === "production" ? SI.exports = Jze() : SI.exports = eFe()), SI.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var JU, lue;
function tFe() {
  if (lue)
    return JU;
  lue = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var u = Object.getOwnPropertyNames(a).map(function(f) {
        return a[f];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(f) {
        l[f] = f;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return JU = i() ? Object.assign : function(o, a) {
    for (var s, u = r(o), l, f = 1; f < arguments.length; f++) {
      s = Object(arguments[f]);
      for (var h in s)
        t.call(s, h) && (u[h] = s[h]);
      if (e) {
        l = e(s);
        for (var p = 0; p < l.length; p++)
          n.call(s, l[p]) && (u[l[p]] = s[l[p]]);
      }
    }
    return u;
  }, JU;
}
var eY, cue;
function EX() {
  if (cue)
    return eY;
  cue = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return eY = e, eY;
}
var tY, fue;
function r0e() {
  return fue || (fue = 1, tY = Function.call.bind(Object.prototype.hasOwnProperty)), tY;
}
var nY, due;
function nFe() {
  if (due)
    return nY;
  due = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = EX(), n = {}, r = r0e();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, u, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var f in o)
        if (r(o, f)) {
          var h;
          try {
            if (typeof o[f] != "function") {
              var p = Error(
                (u || "React class") + ": " + s + " type `" + f + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[f] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            h = o[f](a, f, u, s, null, t);
          } catch (y) {
            h = y;
          }
          if (h && !(h instanceof Error) && e(
            (u || "React class") + ": type specification of " + s + " `" + f + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof h + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), h instanceof Error && !(h.message in n)) {
            n[h.message] = !0;
            var g = l ? l() : "";
            e(
              "Failed " + s + " type: " + h.message + (g ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, nY = i, nY;
}
var rY, hue;
function rFe() {
  if (hue)
    return rY;
  hue = 1;
  var e = n0e(), t = tFe(), n = EX(), r = r0e(), i = nFe(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var u = "Warning: " + s;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return rY = function(s, u) {
    var l = typeof Symbol == "function" && Symbol.iterator, f = "@@iterator";
    function h(H) {
      var ie = H && (l && H[l] || H[f]);
      if (typeof ie == "function")
        return ie;
    }
    var p = "<<anonymous>>", g = {
      array: S("array"),
      bigint: S("bigint"),
      bool: S("boolean"),
      func: S("function"),
      number: S("number"),
      object: S("object"),
      string: S("string"),
      symbol: S("symbol"),
      any: C(),
      arrayOf: A,
      element: O(),
      elementType: R(),
      instanceOf: j,
      node: Y(),
      objectOf: z,
      oneOf: $,
      oneOfType: W,
      shape: ee,
      exact: K
    };
    function y(H, ie) {
      return H === ie ? H !== 0 || 1 / H === 1 / ie : H !== H && ie !== ie;
    }
    function b(H, ie) {
      this.message = H, this.data = ie && typeof ie == "object" ? ie : {}, this.stack = "";
    }
    b.prototype = Error.prototype;
    function _(H) {
      if (process.env.NODE_ENV !== "production")
        var ie = {}, he = 0;
      function ye(Ne, Oe, ke, Me, we, Ye, ze) {
        if (Me = Me || p, Ye = Ye || ke, ze !== n) {
          if (u) {
            var fe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw fe.name = "Invariant Violation", fe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Qe = Me + ":" + ke;
            !ie[Qe] && // Avoid spamming the console because they are often not actionable except for lib authors
            he < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + Ye + "` prop on `" + Me + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), ie[Qe] = !0, he++);
          }
        }
        return Oe[ke] == null ? Ne ? Oe[ke] === null ? new b("The " + we + " `" + Ye + "` is marked as required " + ("in `" + Me + "`, but its value is `null`.")) : new b("The " + we + " `" + Ye + "` is marked as required in " + ("`" + Me + "`, but its value is `undefined`.")) : null : H(Oe, ke, Me, we, Ye);
      }
      var _e = ye.bind(null, !1);
      return _e.isRequired = ye.bind(null, !0), _e;
    }
    function S(H) {
      function ie(he, ye, _e, Ne, Oe, ke) {
        var Me = he[ye], we = te(Me);
        if (we !== H) {
          var Ye = X(Me);
          return new b(
            "Invalid " + Ne + " `" + Oe + "` of type " + ("`" + Ye + "` supplied to `" + _e + "`, expected ") + ("`" + H + "`."),
            { expectedType: H }
          );
        }
        return null;
      }
      return _(ie);
    }
    function C() {
      return _(a);
    }
    function A(H) {
      function ie(he, ye, _e, Ne, Oe) {
        if (typeof H != "function")
          return new b("Property `" + Oe + "` of component `" + _e + "` has invalid PropType notation inside arrayOf.");
        var ke = he[ye];
        if (!Array.isArray(ke)) {
          var Me = te(ke);
          return new b("Invalid " + Ne + " `" + Oe + "` of type " + ("`" + Me + "` supplied to `" + _e + "`, expected an array."));
        }
        for (var we = 0; we < ke.length; we++) {
          var Ye = H(ke, we, _e, Ne, Oe + "[" + we + "]", n);
          if (Ye instanceof Error)
            return Ye;
        }
        return null;
      }
      return _(ie);
    }
    function O() {
      function H(ie, he, ye, _e, Ne) {
        var Oe = ie[he];
        if (!s(Oe)) {
          var ke = te(Oe);
          return new b("Invalid " + _e + " `" + Ne + "` of type " + ("`" + ke + "` supplied to `" + ye + "`, expected a single ReactElement."));
        }
        return null;
      }
      return _(H);
    }
    function R() {
      function H(ie, he, ye, _e, Ne) {
        var Oe = ie[he];
        if (!e.isValidElementType(Oe)) {
          var ke = te(Oe);
          return new b("Invalid " + _e + " `" + Ne + "` of type " + ("`" + ke + "` supplied to `" + ye + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return _(H);
    }
    function j(H) {
      function ie(he, ye, _e, Ne, Oe) {
        if (!(he[ye] instanceof H)) {
          var ke = H.name || p, Me = se(he[ye]);
          return new b("Invalid " + Ne + " `" + Oe + "` of type " + ("`" + Me + "` supplied to `" + _e + "`, expected ") + ("instance of `" + ke + "`."));
        }
        return null;
      }
      return _(ie);
    }
    function $(H) {
      if (!Array.isArray(H))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function ie(he, ye, _e, Ne, Oe) {
        for (var ke = he[ye], Me = 0; Me < H.length; Me++)
          if (y(ke, H[Me]))
            return null;
        var we = JSON.stringify(H, function(ze, fe) {
          var Qe = X(fe);
          return Qe === "symbol" ? String(fe) : fe;
        });
        return new b("Invalid " + Ne + " `" + Oe + "` of value `" + String(ke) + "` " + ("supplied to `" + _e + "`, expected one of " + we + "."));
      }
      return _(ie);
    }
    function z(H) {
      function ie(he, ye, _e, Ne, Oe) {
        if (typeof H != "function")
          return new b("Property `" + Oe + "` of component `" + _e + "` has invalid PropType notation inside objectOf.");
        var ke = he[ye], Me = te(ke);
        if (Me !== "object")
          return new b("Invalid " + Ne + " `" + Oe + "` of type " + ("`" + Me + "` supplied to `" + _e + "`, expected an object."));
        for (var we in ke)
          if (r(ke, we)) {
            var Ye = H(ke, we, _e, Ne, Oe + "." + we, n);
            if (Ye instanceof Error)
              return Ye;
          }
        return null;
      }
      return _(ie);
    }
    function W(H) {
      if (!Array.isArray(H))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var ie = 0; ie < H.length; ie++) {
        var he = H[ie];
        if (typeof he != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Z(he) + " at index " + ie + "."
          ), a;
      }
      function ye(_e, Ne, Oe, ke, Me) {
        for (var we = [], Ye = 0; Ye < H.length; Ye++) {
          var ze = H[Ye], fe = ze(_e, Ne, Oe, ke, Me, n);
          if (fe == null)
            return null;
          fe.data && r(fe.data, "expectedType") && we.push(fe.data.expectedType);
        }
        var Qe = we.length > 0 ? ", expected one of type [" + we.join(", ") + "]" : "";
        return new b("Invalid " + ke + " `" + Me + "` supplied to " + ("`" + Oe + "`" + Qe + "."));
      }
      return _(ye);
    }
    function Y() {
      function H(ie, he, ye, _e, Ne) {
        return Q(ie[he]) ? null : new b("Invalid " + _e + " `" + Ne + "` supplied to " + ("`" + ye + "`, expected a ReactNode."));
      }
      return _(H);
    }
    function V(H, ie, he, ye, _e) {
      return new b(
        (H || "React class") + ": " + ie + " type `" + he + "." + ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + _e + "`."
      );
    }
    function ee(H) {
      function ie(he, ye, _e, Ne, Oe) {
        var ke = he[ye], Me = te(ke);
        if (Me !== "object")
          return new b("Invalid " + Ne + " `" + Oe + "` of type `" + Me + "` " + ("supplied to `" + _e + "`, expected `object`."));
        for (var we in H) {
          var Ye = H[we];
          if (typeof Ye != "function")
            return V(_e, Ne, Oe, we, X(Ye));
          var ze = Ye(ke, we, _e, Ne, Oe + "." + we, n);
          if (ze)
            return ze;
        }
        return null;
      }
      return _(ie);
    }
    function K(H) {
      function ie(he, ye, _e, Ne, Oe) {
        var ke = he[ye], Me = te(ke);
        if (Me !== "object")
          return new b("Invalid " + Ne + " `" + Oe + "` of type `" + Me + "` " + ("supplied to `" + _e + "`, expected `object`."));
        var we = t({}, he[ye], H);
        for (var Ye in we) {
          var ze = H[Ye];
          if (r(H, Ye) && typeof ze != "function")
            return V(_e, Ne, Oe, Ye, X(ze));
          if (!ze)
            return new b(
              "Invalid " + Ne + " `" + Oe + "` key `" + Ye + "` supplied to `" + _e + "`.\nBad object: " + JSON.stringify(he[ye], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(H), null, "  ")
            );
          var fe = ze(ke, Ye, _e, Ne, Oe + "." + Ye, n);
          if (fe)
            return fe;
        }
        return null;
      }
      return _(ie);
    }
    function Q(H) {
      switch (typeof H) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !H;
        case "object":
          if (Array.isArray(H))
            return H.every(Q);
          if (H === null || s(H))
            return !0;
          var ie = h(H);
          if (ie) {
            var he = ie.call(H), ye;
            if (ie !== H.entries) {
              for (; !(ye = he.next()).done; )
                if (!Q(ye.value))
                  return !1;
            } else
              for (; !(ye = he.next()).done; ) {
                var _e = ye.value;
                if (_e && !Q(_e[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(H, ie) {
      return H === "symbol" ? !0 : ie ? ie["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && ie instanceof Symbol : !1;
    }
    function te(H) {
      var ie = typeof H;
      return Array.isArray(H) ? "array" : H instanceof RegExp ? "object" : q(ie, H) ? "symbol" : ie;
    }
    function X(H) {
      if (typeof H > "u" || H === null)
        return "" + H;
      var ie = te(H);
      if (ie === "object") {
        if (H instanceof Date)
          return "date";
        if (H instanceof RegExp)
          return "regexp";
      }
      return ie;
    }
    function Z(H) {
      var ie = X(H);
      switch (ie) {
        case "array":
        case "object":
          return "an " + ie;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + ie;
        default:
          return ie;
      }
    }
    function se(H) {
      return !H.constructor || !H.constructor.name ? p : H.constructor.name;
    }
    return g.checkPropTypes = i, g.resetWarningCache = i.resetWarningCache, g.PropTypes = g, g;
  }, rY;
}
var iY, pue;
function iFe() {
  if (pue)
    return iY;
  pue = 1;
  var e = EX();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, iY = function() {
    function r(a, s, u, l, f, h) {
      if (h !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, iY;
}
if (process.env.NODE_ENV !== "production") {
  var oFe = n0e(), aFe = !0;
  eW.exports = rFe()(oFe.isElement, aFe);
} else
  eW.exports = iFe()();
var sFe = eW.exports;
const N = /* @__PURE__ */ KC(sFe);
function uFe(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function i0e(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  const u = o.type;
  return typeof u == "function" && !uFe(u) && (s = "Did you accidentally use a plain function component for an element instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const o0e = KS(N.element, i0e);
o0e.isRequired = KS(N.element.isRequired, i0e);
const Nz = o0e;
function lFe(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function cFe(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  return typeof o == "function" && !lFe(o) && (s = "Did you accidentally provide a plain function component instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element type that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const Dz = KS(N.elementType, cFe);
function Hx(e) {
  let t = "https://mui.com/production-error/?code=" + e;
  for (let n = 1; n < arguments.length; n += 1)
    t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified MUI error #" + e + "; visit " + t + " for the full message.";
}
var tW = { exports: {} }, Xi = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gue;
function fFe() {
  if (gue)
    return Xi;
  gue = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), y;
  y = Symbol.for("react.module.reference");
  function b(_) {
    if (typeof _ == "object" && _ !== null) {
      var S = _.$$typeof;
      switch (S) {
        case e:
          switch (_ = _.type, _) {
            case n:
            case i:
            case r:
            case l:
            case f:
              return _;
            default:
              switch (_ = _ && _.$$typeof, _) {
                case s:
                case a:
                case u:
                case p:
                case h:
                case o:
                  return _;
                default:
                  return S;
              }
          }
        case t:
          return S;
      }
    }
  }
  return Xi.ContextConsumer = a, Xi.ContextProvider = o, Xi.Element = e, Xi.ForwardRef = u, Xi.Fragment = n, Xi.Lazy = p, Xi.Memo = h, Xi.Portal = t, Xi.Profiler = i, Xi.StrictMode = r, Xi.Suspense = l, Xi.SuspenseList = f, Xi.isAsyncMode = function() {
    return !1;
  }, Xi.isConcurrentMode = function() {
    return !1;
  }, Xi.isContextConsumer = function(_) {
    return b(_) === a;
  }, Xi.isContextProvider = function(_) {
    return b(_) === o;
  }, Xi.isElement = function(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === e;
  }, Xi.isForwardRef = function(_) {
    return b(_) === u;
  }, Xi.isFragment = function(_) {
    return b(_) === n;
  }, Xi.isLazy = function(_) {
    return b(_) === p;
  }, Xi.isMemo = function(_) {
    return b(_) === h;
  }, Xi.isPortal = function(_) {
    return b(_) === t;
  }, Xi.isProfiler = function(_) {
    return b(_) === i;
  }, Xi.isStrictMode = function(_) {
    return b(_) === r;
  }, Xi.isSuspense = function(_) {
    return b(_) === l;
  }, Xi.isSuspenseList = function(_) {
    return b(_) === f;
  }, Xi.isValidElementType = function(_) {
    return typeof _ == "string" || typeof _ == "function" || _ === n || _ === i || _ === r || _ === l || _ === f || _ === g || typeof _ == "object" && _ !== null && (_.$$typeof === p || _.$$typeof === h || _.$$typeof === o || _.$$typeof === a || _.$$typeof === u || _.$$typeof === y || _.getModuleId !== void 0);
  }, Xi.typeOf = b, Xi;
}
var Ki = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mue;
function dFe() {
  return mue || (mue = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), y = !1, b = !1, _ = !1, S = !1, C = !1, A;
    A = Symbol.for("react.module.reference");
    function O($e) {
      return !!(typeof $e == "string" || typeof $e == "function" || $e === n || $e === i || C || $e === r || $e === l || $e === f || S || $e === g || y || b || _ || typeof $e == "object" && $e !== null && ($e.$$typeof === p || $e.$$typeof === h || $e.$$typeof === o || $e.$$typeof === a || $e.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      $e.$$typeof === A || $e.getModuleId !== void 0));
    }
    function R($e) {
      if (typeof $e == "object" && $e !== null) {
        var pt = $e.$$typeof;
        switch (pt) {
          case e:
            var _t = $e.type;
            switch (_t) {
              case n:
              case i:
              case r:
              case l:
              case f:
                return _t;
              default:
                var Ot = _t && _t.$$typeof;
                switch (Ot) {
                  case s:
                  case a:
                  case u:
                  case p:
                  case h:
                  case o:
                    return Ot;
                  default:
                    return pt;
                }
            }
          case t:
            return pt;
        }
      }
    }
    var j = a, $ = o, z = e, W = u, Y = n, V = p, ee = h, K = t, Q = i, q = r, te = l, X = f, Z = !1, se = !1;
    function H($e) {
      return Z || (Z = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function ie($e) {
      return se || (se = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function he($e) {
      return R($e) === a;
    }
    function ye($e) {
      return R($e) === o;
    }
    function _e($e) {
      return typeof $e == "object" && $e !== null && $e.$$typeof === e;
    }
    function Ne($e) {
      return R($e) === u;
    }
    function Oe($e) {
      return R($e) === n;
    }
    function ke($e) {
      return R($e) === p;
    }
    function Me($e) {
      return R($e) === h;
    }
    function we($e) {
      return R($e) === t;
    }
    function Ye($e) {
      return R($e) === i;
    }
    function ze($e) {
      return R($e) === r;
    }
    function fe($e) {
      return R($e) === l;
    }
    function Qe($e) {
      return R($e) === f;
    }
    Ki.ContextConsumer = j, Ki.ContextProvider = $, Ki.Element = z, Ki.ForwardRef = W, Ki.Fragment = Y, Ki.Lazy = V, Ki.Memo = ee, Ki.Portal = K, Ki.Profiler = Q, Ki.StrictMode = q, Ki.Suspense = te, Ki.SuspenseList = X, Ki.isAsyncMode = H, Ki.isConcurrentMode = ie, Ki.isContextConsumer = he, Ki.isContextProvider = ye, Ki.isElement = _e, Ki.isForwardRef = Ne, Ki.isFragment = Oe, Ki.isLazy = ke, Ki.isMemo = Me, Ki.isPortal = we, Ki.isProfiler = Ye, Ki.isStrictMode = ze, Ki.isSuspense = fe, Ki.isSuspenseList = Qe, Ki.isValidElementType = O, Ki.typeOf = R;
  }()), Ki;
}
process.env.NODE_ENV === "production" ? tW.exports = fFe() : tW.exports = dFe();
var dS = tW.exports;
const hFe = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function pFe(e) {
  const t = `${e}`.match(hFe);
  return t && t[1] || "";
}
function a0e(e, t = "") {
  return e.displayName || e.name || pFe(e) || t;
}
function yue(e, t, n) {
  const r = a0e(t);
  return e.displayName || (r !== "" ? `${n}(${r})` : n);
}
function gFe(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return a0e(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case dS.ForwardRef:
          return yue(e, e.render, "ForwardRef");
        case dS.Memo:
          return yue(e, e.type, "memo");
        default:
          return;
      }
  }
}
function YT(e, t, n, r, i) {
  if (process.env.NODE_ENV === "production")
    return null;
  const o = e[t], a = i || t;
  return o == null ? null : o && o.nodeType !== 1 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an HTMLElement.`) : null;
}
const mFe = N.oneOfType([N.func, N.object]), mb = mFe;
function Xn(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : Hx(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function yFe(...e) {
  return e.reduce((t, n) => n == null ? t : function(...i) {
    t.apply(this, i), n.apply(this, i);
  }, () => {
  });
}
function s0e(e, t = 166) {
  let n;
  function r(...i) {
    const o = () => {
      e.apply(this, i);
    };
    clearTimeout(n), n = setTimeout(o, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function vFe(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : (n, r, i, o, a) => {
    const s = i || "<<anonymous>>", u = a || r;
    return typeof n[r] < "u" ? new Error(`The ${o} \`${u}\` of \`${s}\` is deprecated. ${t}`) : null;
  };
}
function bFe(e, t) {
  return /* @__PURE__ */ ae.isValidElement(e) && t.indexOf(e.type.muiName) !== -1;
}
function hS(e) {
  return e && e.ownerDocument || document;
}
function nW(e) {
  return hS(e).defaultView || window;
}
function u0e(e, t) {
  if (process.env.NODE_ENV === "production")
    return () => null;
  const n = t ? ge({}, t.propTypes) : null;
  return (i) => (o, a, s, u, l, ...f) => {
    const h = l || a, p = n == null ? void 0 : n[h];
    if (p) {
      const g = p(o, a, s, u, l, ...f);
      if (g)
        return g;
    }
    return typeof o[a] < "u" && !o[i] ? new Error(`The prop \`${h}\` of \`${e}\` can only be used together with the \`${i}\` prop.`) : null;
  };
}
function l0e(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
const xFe = typeof window < "u" ? ae.useLayoutEffect : ae.useEffect, p$ = xFe;
let vue = 0;
function wFe(e) {
  const [t, n] = ae.useState(e), r = e || t;
  return ae.useEffect(() => {
    t == null && (vue += 1, n(`mui-${vue}`));
  }, [t]), r;
}
const bue = KV["useId".toString()];
function Pj(e) {
  if (bue !== void 0) {
    const t = bue();
    return e ?? t;
  }
  return wFe(e);
}
function _Fe(e, t, n, r, i) {
  if (process.env.NODE_ENV === "production")
    return null;
  const o = i || t;
  return typeof e[t] < "u" ? new Error(`The prop \`${o}\` is not supported. Please remove it.`) : null;
}
function Ij({
  controlled: e,
  default: t,
  name: n,
  state: r = "value"
}) {
  const {
    current: i
  } = ae.useRef(e !== void 0), [o, a] = ae.useState(t), s = i ? e : o;
  if (process.env.NODE_ENV !== "production") {
    ae.useEffect(() => {
      i !== (e !== void 0) && console.error([`MUI: A component is changing the ${i ? "" : "un"}controlled ${r} state of ${n} to be ${i ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${n} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [r, n, e]);
    const {
      current: l
    } = ae.useRef(t);
    ae.useEffect(() => {
      !i && l !== t && console.error([`MUI: A component is changing the default ${r} state of an uncontrolled ${n} after being initialized. To suppress this warning opt to use a controlled ${n}.`].join(`
`));
    }, [JSON.stringify(t)]);
  }
  const u = ae.useCallback((l) => {
    i || a(l);
  }, []);
  return [s, u];
}
function uT(e) {
  const t = ae.useRef(e);
  return p$(() => {
    t.current = e;
  }), ae.useCallback((...n) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, t.current)(...n)
  ), []);
}
function jd(...e) {
  return ae.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      l0e(n, t);
    });
  }, e);
}
let Az = !0, rW = !1, xue;
const EFe = {
  text: !0,
  search: !0,
  url: !0,
  tel: !0,
  email: !0,
  password: !0,
  number: !0,
  date: !0,
  month: !0,
  week: !0,
  time: !0,
  datetime: !0,
  "datetime-local": !0
};
function SFe(e) {
  const {
    type: t,
    tagName: n
  } = e;
  return !!(n === "INPUT" && EFe[t] && !e.readOnly || n === "TEXTAREA" && !e.readOnly || e.isContentEditable);
}
function MFe(e) {
  e.metaKey || e.altKey || e.ctrlKey || (Az = !0);
}
function oY() {
  Az = !1;
}
function TFe() {
  this.visibilityState === "hidden" && rW && (Az = !0);
}
function CFe(e) {
  e.addEventListener("keydown", MFe, !0), e.addEventListener("mousedown", oY, !0), e.addEventListener("pointerdown", oY, !0), e.addEventListener("touchstart", oY, !0), e.addEventListener("visibilitychange", TFe, !0);
}
function NFe(e) {
  const {
    target: t
  } = e;
  try {
    return t.matches(":focus-visible");
  } catch {
  }
  return Az || SFe(t);
}
function Oz() {
  const e = ae.useCallback((i) => {
    i != null && CFe(i.ownerDocument);
  }, []), t = ae.useRef(!1);
  function n() {
    return t.current ? (rW = !0, window.clearTimeout(xue), xue = window.setTimeout(() => {
      rW = !1;
    }, 100), t.current = !1, !0) : !1;
  }
  function r(i) {
    return NFe(i) ? (t.current = !0, !0) : !1;
  }
  return {
    isFocusVisibleRef: t,
    onFocus: r,
    onBlur: n,
    ref: e
  };
}
function DFe(e) {
  const t = e.documentElement.clientWidth;
  return Math.abs(window.innerWidth - t);
}
function AFe(e) {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : Number.isFinite(e) ? e !== Math.floor(e) ? "float" : "number" : "Infinity";
    case "object":
      return e === null ? "null" : e.constructor.name;
    default:
      return t;
  }
}
function OFe(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
const RFe = Number.isInteger || OFe;
function c0e(e, t, n, r) {
  const i = e[t];
  if (i == null || !RFe(i)) {
    const o = AFe(i);
    return new RangeError(`Invalid ${r} \`${t}\` of type \`${o}\` supplied to \`${n}\`, expected \`integer\`.`);
  }
  return null;
}
function f0e(e, t, ...n) {
  return e[t] === void 0 ? null : c0e(e, t, ...n);
}
function iW() {
  return null;
}
f0e.isRequired = c0e;
iW.isRequired = iW;
const sR = process.env.NODE_ENV === "production" ? iW : f0e;
function SX(e, t) {
  const n = ge({}, t);
  return Object.keys(e).forEach((r) => {
    if (r.toString().match(/^(components|slots)$/))
      n[r] = ge({}, e[r], n[r]);
    else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
      const i = e[r] || {}, o = t[r];
      n[r] = {}, !o || !Object.keys(o) ? n[r] = i : !i || !Object.keys(i) ? n[r] = o : (n[r] = ge({}, o), Object.keys(i).forEach((a) => {
        n[r][a] = SX(i[a], o[a]);
      }));
    } else
      n[r] === void 0 && (n[r] = e[r]);
  }), n;
}
const wue = (e) => e, kFe = () => {
  let e = wue;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = wue;
    }
  };
}, $Fe = kFe(), d0e = $Fe, PFe = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  readOnly: "readOnly",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function gi(e, t, n = "Mui") {
  const r = PFe[t];
  return r ? `${n}-${r}` : `${d0e.generate(e)}-${t}`;
}
function fi(e, t, n = "Mui") {
  const r = {};
  return t.forEach((i) => {
    r[i] = gi(e, i, n);
  }), r;
}
const g$ = "$$material";
function ln(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function h0e(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var IFe = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, jFe = /* @__PURE__ */ h0e(
  function(e) {
    return IFe.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function LFe(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function zFe(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var FFe = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? process.env.NODE_ENV === "production" : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(zFe(this));
    var i = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var o = r.charCodeAt(0) === 64 && r.charCodeAt(1) === 105;
      o && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + r + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !o;
    }
    if (this.isSpeedy) {
      var a = LFe(i);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch (s) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(r) && console.error('There was a problem inserting the following rule: "' + r + '"', s);
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      return r.parentNode && r.parentNode.removeChild(r);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, e;
}(), kl = "-ms-", jj = "-moz-", ji = "-webkit-", MX = "comm", TX = "rule", CX = "decl", BFe = "@import", p0e = "@keyframes", UFe = "@layer", YFe = Math.abs, Rz = String.fromCharCode, HFe = Object.assign;
function VFe(e, t) {
  return Xu(e, 0) ^ 45 ? (((t << 2 ^ Xu(e, 0)) << 2 ^ Xu(e, 1)) << 2 ^ Xu(e, 2)) << 2 ^ Xu(e, 3) : 0;
}
function g0e(e) {
  return e.trim();
}
function WFe(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Li(e, t, n) {
  return e.replace(t, n);
}
function oW(e, t) {
  return e.indexOf(t);
}
function Xu(e, t) {
  return e.charCodeAt(t) | 0;
}
function KR(e, t, n) {
  return e.slice(t, n);
}
function _y(e) {
  return e.length;
}
function NX(e) {
  return e.length;
}
function MI(e, t) {
  return t.push(e), e;
}
function qFe(e, t) {
  return e.map(t).join("");
}
var kz = 1, HT = 1, m0e = 0, Tf = 0, vs = 0, ZC = "";
function $z(e, t, n, r, i, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: kz, column: HT, length: a, return: "" };
}
function TA(e, t) {
  return HFe($z("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function GFe() {
  return vs;
}
function QFe() {
  return vs = Tf > 0 ? Xu(ZC, --Tf) : 0, HT--, vs === 10 && (HT = 1, kz--), vs;
}
function Ad() {
  return vs = Tf < m0e ? Xu(ZC, Tf++) : 0, HT++, vs === 10 && (HT = 1, kz++), vs;
}
function Py() {
  return Xu(ZC, Tf);
}
function q3() {
  return Tf;
}
function m$(e, t) {
  return KR(ZC, e, t);
}
function ZR(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function y0e(e) {
  return kz = HT = 1, m0e = _y(ZC = e), Tf = 0, [];
}
function v0e(e) {
  return ZC = "", e;
}
function G3(e) {
  return g0e(m$(Tf - 1, aW(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function XFe(e) {
  for (; (vs = Py()) && vs < 33; )
    Ad();
  return ZR(e) > 2 || ZR(vs) > 3 ? "" : " ";
}
function KFe(e, t) {
  for (; --t && Ad() && !(vs < 48 || vs > 102 || vs > 57 && vs < 65 || vs > 70 && vs < 97); )
    ;
  return m$(e, q3() + (t < 6 && Py() == 32 && Ad() == 32));
}
function aW(e) {
  for (; Ad(); )
    switch (vs) {
      case e:
        return Tf;
      case 34:
      case 39:
        e !== 34 && e !== 39 && aW(vs);
        break;
      case 40:
        e === 41 && aW(e);
        break;
      case 92:
        Ad();
        break;
    }
  return Tf;
}
function ZFe(e, t) {
  for (; Ad() && e + vs !== 47 + 10; )
    if (e + vs === 42 + 42 && Py() === 47)
      break;
  return "/*" + m$(t, Tf - 1) + "*" + Rz(e === 47 ? e : Ad());
}
function JFe(e) {
  for (; !ZR(Py()); )
    Ad();
  return m$(e, Tf);
}
function e6e(e) {
  return v0e(Q3("", null, null, null, [""], e = y0e(e), 0, [0], e));
}
function Q3(e, t, n, r, i, o, a, s, u) {
  for (var l = 0, f = 0, h = a, p = 0, g = 0, y = 0, b = 1, _ = 1, S = 1, C = 0, A = "", O = i, R = o, j = r, $ = A; _; )
    switch (y = C, C = Ad()) {
      case 40:
        if (y != 108 && Xu($, h - 1) == 58) {
          oW($ += Li(G3(C), "&", "&\f"), "&\f") != -1 && (S = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        $ += G3(C);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        $ += XFe(y);
        break;
      case 92:
        $ += KFe(q3() - 1, 7);
        continue;
      case 47:
        switch (Py()) {
          case 42:
          case 47:
            MI(t6e(ZFe(Ad(), q3()), t, n), u);
            break;
          default:
            $ += "/";
        }
        break;
      case 123 * b:
        s[l++] = _y($) * S;
      case 125 * b:
      case 59:
      case 0:
        switch (C) {
          case 0:
          case 125:
            _ = 0;
          case 59 + f:
            S == -1 && ($ = Li($, /\f/g, "")), g > 0 && _y($) - h && MI(g > 32 ? Eue($ + ";", r, n, h - 1) : Eue(Li($, " ", "") + ";", r, n, h - 2), u);
            break;
          case 59:
            $ += ";";
          default:
            if (MI(j = _ue($, t, n, l, f, i, s, A, O = [], R = [], h), o), C === 123)
              if (f === 0)
                Q3($, t, j, j, O, o, h, s, R);
              else
                switch (p === 99 && Xu($, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Q3(e, j, j, r && MI(_ue(e, j, j, 0, 0, i, s, A, i, O = [], h), R), i, R, h, s, r ? O : R);
                    break;
                  default:
                    Q3($, j, j, j, [""], R, 0, s, R);
                }
        }
        l = f = g = 0, b = S = 1, A = $ = "", h = a;
        break;
      case 58:
        h = 1 + _y($), g = y;
      default:
        if (b < 1) {
          if (C == 123)
            --b;
          else if (C == 125 && b++ == 0 && QFe() == 125)
            continue;
        }
        switch ($ += Rz(C), C * b) {
          case 38:
            S = f > 0 ? 1 : ($ += "\f", -1);
            break;
          case 44:
            s[l++] = (_y($) - 1) * S, S = 1;
            break;
          case 64:
            Py() === 45 && ($ += G3(Ad())), p = Py(), f = h = _y(A = $ += JFe(q3())), C++;
            break;
          case 45:
            y === 45 && _y($) == 2 && (b = 0);
        }
    }
  return o;
}
function _ue(e, t, n, r, i, o, a, s, u, l, f) {
  for (var h = i - 1, p = i === 0 ? o : [""], g = NX(p), y = 0, b = 0, _ = 0; y < r; ++y)
    for (var S = 0, C = KR(e, h + 1, h = YFe(b = a[y])), A = e; S < g; ++S)
      (A = g0e(b > 0 ? p[S] + " " + C : Li(C, /&\f/g, p[S]))) && (u[_++] = A);
  return $z(e, t, n, i === 0 ? TX : s, u, l, f);
}
function t6e(e, t, n) {
  return $z(e, t, n, MX, Rz(GFe()), KR(e, 2, -2), 0);
}
function Eue(e, t, n, r) {
  return $z(e, t, n, CX, KR(e, 0, r), KR(e, r + 1, -1), r);
}
function ET(e, t) {
  for (var n = "", r = NX(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function n6e(e, t, n, r) {
  switch (e.type) {
    case UFe:
      if (e.children.length)
        break;
    case BFe:
    case CX:
      return e.return = e.return || e.value;
    case MX:
      return "";
    case p0e:
      return e.return = e.value + "{" + ET(e.children, r) + "}";
    case TX:
      e.value = e.props.join(",");
  }
  return _y(n = ET(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function r6e(e) {
  var t = NX(e);
  return function(n, r, i, o) {
    for (var a = "", s = 0; s < t; s++)
      a += e[s](n, r, i, o) || "";
    return a;
  };
}
function i6e(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
var o6e = function(t, n, r) {
  for (var i = 0, o = 0; i = o, o = Py(), i === 38 && o === 12 && (n[r] = 1), !ZR(o); )
    Ad();
  return m$(t, Tf);
}, a6e = function(t, n) {
  var r = -1, i = 44;
  do
    switch (ZR(i)) {
      case 0:
        i === 38 && Py() === 12 && (n[r] = 1), t[r] += o6e(Tf - 1, n, r);
        break;
      case 2:
        t[r] += G3(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Py() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += Rz(i);
    }
  while (i = Ad());
  return t;
}, s6e = function(t, n) {
  return v0e(a6e(y0e(t), n));
}, Sue = /* @__PURE__ */ new WeakMap(), u6e = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r)
        return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Sue.get(r)) && !i) {
      Sue.set(t, !0);
      for (var o = [], a = s6e(n, o), s = r.props, u = 0, l = 0; u < a.length; u++)
        for (var f = 0; f < s.length; f++, l++)
          t.props[l] = o[u] ? a[u].replace(/&\f/g, s[f]) : s[f] + " " + a[u];
    }
  }
}, l6e = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
}, c6e = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", f6e = function(t) {
  return t.type === "comm" && t.children.indexOf(c6e) > -1;
}, d6e = function(t) {
  return function(n, r, i) {
    if (!(n.type !== "rule" || t.compat)) {
      var o = n.value.match(/(:first|:nth|:nth-last)-child/g);
      if (o) {
        for (var a = !!n.parent, s = a ? n.parent.children : (
          // global rule at the root level
          i
        ), u = s.length - 1; u >= 0; u--) {
          var l = s[u];
          if (l.line < n.line)
            break;
          if (l.column < n.column) {
            if (f6e(l))
              return;
            break;
          }
        }
        o.forEach(function(f) {
          console.error('The pseudo class "' + f + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + f.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, b0e = function(t) {
  return t.type.charCodeAt(1) === 105 && t.type.charCodeAt(0) === 64;
}, h6e = function(t, n) {
  for (var r = t - 1; r >= 0; r--)
    if (!b0e(n[r]))
      return !0;
  return !1;
}, Mue = function(t) {
  t.type = "", t.value = "", t.return = "", t.children = "", t.props = "";
}, p6e = function(t, n, r) {
  b0e(t) && (t.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), Mue(t)) : h6e(n, r) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), Mue(t)));
};
function x0e(e, t) {
  switch (VFe(e, t)) {
    case 5103:
      return ji + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ji + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ji + e + jj + e + kl + e + e;
    case 6828:
    case 4268:
      return ji + e + kl + e + e;
    case 6165:
      return ji + e + kl + "flex-" + e + e;
    case 5187:
      return ji + e + Li(e, /(\w+).+(:[^]+)/, ji + "box-$1$2" + kl + "flex-$1$2") + e;
    case 5443:
      return ji + e + kl + "flex-item-" + Li(e, /flex-|-self/, "") + e;
    case 4675:
      return ji + e + kl + "flex-line-pack" + Li(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return ji + e + kl + Li(e, "shrink", "negative") + e;
    case 5292:
      return ji + e + kl + Li(e, "basis", "preferred-size") + e;
    case 6060:
      return ji + "box-" + Li(e, "-grow", "") + ji + e + kl + Li(e, "grow", "positive") + e;
    case 4554:
      return ji + Li(e, /([^-])(transform)/g, "$1" + ji + "$2") + e;
    case 6187:
      return Li(Li(Li(e, /(zoom-|grab)/, ji + "$1"), /(image-set)/, ji + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return Li(e, /(image-set\([^]*)/, ji + "$1$`$1");
    case 4968:
      return Li(Li(e, /(.+:)(flex-)?(.*)/, ji + "box-pack:$3" + kl + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ji + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Li(e, /(.+)-inline(.+)/, ji + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (_y(e) - 1 - t > 6)
        switch (Xu(e, t + 1)) {
          case 109:
            if (Xu(e, t + 4) !== 45)
              break;
          case 102:
            return Li(e, /(.+:)(.+)-([^]+)/, "$1" + ji + "$2-$3$1" + jj + (Xu(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~oW(e, "stretch") ? x0e(Li(e, "stretch", "fill-available"), t) + e : e;
        }
      break;
    case 4949:
      if (Xu(e, t + 1) !== 115)
        break;
    case 6444:
      switch (Xu(e, _y(e) - 3 - (~oW(e, "!important") && 10))) {
        case 107:
          return Li(e, ":", ":" + ji) + e;
        case 101:
          return Li(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ji + (Xu(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ji + "$2$3$1" + kl + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (Xu(e, t + 11)) {
        case 114:
          return ji + e + kl + Li(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return ji + e + kl + Li(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return ji + e + kl + Li(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ji + e + kl + e + e;
  }
  return e;
}
var g6e = function(t, n, r, i) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case CX:
        t.return = x0e(t.value, t.length);
        break;
      case p0e:
        return ET([TA(t, {
          value: Li(t.value, "@", "@" + ji)
        })], i);
      case TX:
        if (t.length)
          return qFe(t.props, function(o) {
            switch (WFe(o, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return ET([TA(t, {
                  props: [Li(o, /:(read-\w+)/, ":" + jj + "$1")]
                })], i);
              case "::placeholder":
                return ET([TA(t, {
                  props: [Li(o, /:(plac\w+)/, ":" + ji + "input-$1")]
                }), TA(t, {
                  props: [Li(o, /:(plac\w+)/, ":" + jj + "$1")]
                }), TA(t, {
                  props: [Li(o, /:(plac\w+)/, kl + "input-$1")]
                })], i);
            }
            return "";
          });
    }
}, m6e = [g6e], y6e = function(t) {
  var n = t.key;
  if (process.env.NODE_ENV !== "production" && !n)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(b) {
      var _ = b.getAttribute("data-emotion");
      _.indexOf(" ") !== -1 && (document.head.appendChild(b), b.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || m6e;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(n))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + n + '" was passed');
  var o = {}, a, s = [];
  a = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(b) {
      for (var _ = b.getAttribute("data-emotion").split(" "), S = 1; S < _.length; S++)
        o[_[S]] = !0;
      s.push(b);
    }
  );
  var u, l = [u6e, l6e];
  process.env.NODE_ENV !== "production" && l.push(d6e({
    get compat() {
      return y.compat;
    }
  }), p6e);
  {
    var f, h = [n6e, process.env.NODE_ENV !== "production" ? function(b) {
      b.root || (b.return ? f.insert(b.return) : b.value && b.type !== MX && f.insert(b.value + "{}"));
    } : i6e(function(b) {
      f.insert(b);
    })], p = r6e(l.concat(i, h)), g = function(_) {
      return ET(e6e(_), p);
    };
    u = function(_, S, C, A) {
      f = C, process.env.NODE_ENV !== "production" && S.map !== void 0 && (f = {
        insert: function(R) {
          C.insert(R + S.map);
        }
      }), g(_ ? _ + "{" + S.styles + "}" : S.styles), A && (y.inserted[S.name] = !0);
    };
  }
  var y = {
    key: n,
    sheet: new FFe({
      key: n,
      container: a,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return y.sheet.hydrate(s), y;
}, sW = { exports: {} }, Zi = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tue;
function v6e() {
  if (Tue)
    return Zi;
  Tue = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, f = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, b = e ? Symbol.for("react.block") : 60121, _ = e ? Symbol.for("react.fundamental") : 60117, S = e ? Symbol.for("react.responder") : 60118, C = e ? Symbol.for("react.scope") : 60119;
  function A(R) {
    if (typeof R == "object" && R !== null) {
      var j = R.$$typeof;
      switch (j) {
        case t:
          switch (R = R.type, R) {
            case u:
            case l:
            case r:
            case o:
            case i:
            case h:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case s:
                case f:
                case y:
                case g:
                case a:
                  return R;
                default:
                  return j;
              }
          }
        case n:
          return j;
      }
    }
  }
  function O(R) {
    return A(R) === l;
  }
  return Zi.AsyncMode = u, Zi.ConcurrentMode = l, Zi.ContextConsumer = s, Zi.ContextProvider = a, Zi.Element = t, Zi.ForwardRef = f, Zi.Fragment = r, Zi.Lazy = y, Zi.Memo = g, Zi.Portal = n, Zi.Profiler = o, Zi.StrictMode = i, Zi.Suspense = h, Zi.isAsyncMode = function(R) {
    return O(R) || A(R) === u;
  }, Zi.isConcurrentMode = O, Zi.isContextConsumer = function(R) {
    return A(R) === s;
  }, Zi.isContextProvider = function(R) {
    return A(R) === a;
  }, Zi.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, Zi.isForwardRef = function(R) {
    return A(R) === f;
  }, Zi.isFragment = function(R) {
    return A(R) === r;
  }, Zi.isLazy = function(R) {
    return A(R) === y;
  }, Zi.isMemo = function(R) {
    return A(R) === g;
  }, Zi.isPortal = function(R) {
    return A(R) === n;
  }, Zi.isProfiler = function(R) {
    return A(R) === o;
  }, Zi.isStrictMode = function(R) {
    return A(R) === i;
  }, Zi.isSuspense = function(R) {
    return A(R) === h;
  }, Zi.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === l || R === o || R === i || R === h || R === p || typeof R == "object" && R !== null && (R.$$typeof === y || R.$$typeof === g || R.$$typeof === a || R.$$typeof === s || R.$$typeof === f || R.$$typeof === _ || R.$$typeof === S || R.$$typeof === C || R.$$typeof === b);
  }, Zi.typeOf = A, Zi;
}
var Ji = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cue;
function b6e() {
  return Cue || (Cue = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, f = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, b = e ? Symbol.for("react.block") : 60121, _ = e ? Symbol.for("react.fundamental") : 60117, S = e ? Symbol.for("react.responder") : 60118, C = e ? Symbol.for("react.scope") : 60119;
    function A(fe) {
      return typeof fe == "string" || typeof fe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      fe === r || fe === l || fe === o || fe === i || fe === h || fe === p || typeof fe == "object" && fe !== null && (fe.$$typeof === y || fe.$$typeof === g || fe.$$typeof === a || fe.$$typeof === s || fe.$$typeof === f || fe.$$typeof === _ || fe.$$typeof === S || fe.$$typeof === C || fe.$$typeof === b);
    }
    function O(fe) {
      if (typeof fe == "object" && fe !== null) {
        var Qe = fe.$$typeof;
        switch (Qe) {
          case t:
            var $e = fe.type;
            switch ($e) {
              case u:
              case l:
              case r:
              case o:
              case i:
              case h:
                return $e;
              default:
                var pt = $e && $e.$$typeof;
                switch (pt) {
                  case s:
                  case f:
                  case y:
                  case g:
                  case a:
                    return pt;
                  default:
                    return Qe;
                }
            }
          case n:
            return Qe;
        }
      }
    }
    var R = u, j = l, $ = s, z = a, W = t, Y = f, V = r, ee = y, K = g, Q = n, q = o, te = i, X = h, Z = !1;
    function se(fe) {
      return Z || (Z = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), H(fe) || O(fe) === u;
    }
    function H(fe) {
      return O(fe) === l;
    }
    function ie(fe) {
      return O(fe) === s;
    }
    function he(fe) {
      return O(fe) === a;
    }
    function ye(fe) {
      return typeof fe == "object" && fe !== null && fe.$$typeof === t;
    }
    function _e(fe) {
      return O(fe) === f;
    }
    function Ne(fe) {
      return O(fe) === r;
    }
    function Oe(fe) {
      return O(fe) === y;
    }
    function ke(fe) {
      return O(fe) === g;
    }
    function Me(fe) {
      return O(fe) === n;
    }
    function we(fe) {
      return O(fe) === o;
    }
    function Ye(fe) {
      return O(fe) === i;
    }
    function ze(fe) {
      return O(fe) === h;
    }
    Ji.AsyncMode = R, Ji.ConcurrentMode = j, Ji.ContextConsumer = $, Ji.ContextProvider = z, Ji.Element = W, Ji.ForwardRef = Y, Ji.Fragment = V, Ji.Lazy = ee, Ji.Memo = K, Ji.Portal = Q, Ji.Profiler = q, Ji.StrictMode = te, Ji.Suspense = X, Ji.isAsyncMode = se, Ji.isConcurrentMode = H, Ji.isContextConsumer = ie, Ji.isContextProvider = he, Ji.isElement = ye, Ji.isForwardRef = _e, Ji.isFragment = Ne, Ji.isLazy = Oe, Ji.isMemo = ke, Ji.isPortal = Me, Ji.isProfiler = we, Ji.isStrictMode = Ye, Ji.isSuspense = ze, Ji.isValidElementType = A, Ji.typeOf = O;
  }()), Ji;
}
process.env.NODE_ENV === "production" ? sW.exports = v6e() : sW.exports = b6e();
var x6e = sW.exports, w0e = x6e, w6e = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, _6e = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, _0e = {};
_0e[w0e.ForwardRef] = w6e;
_0e[w0e.Memo] = _6e;
var E6e = !0;
function DX(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : r += i + " ";
  }), r;
}
var Pz = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  E6e === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, Iz = function(t, n, r) {
  Pz(t, n, r);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + i : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function S6e(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var M6e = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Nue = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, T6e = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", C6e = /[A-Z]|^ms/g, E0e = /_EMO_([^_]+?)_([^]*?)_EMO_/g, AX = function(t) {
  return t.charCodeAt(1) === 45;
}, Due = function(t) {
  return t != null && typeof t != "boolean";
}, aY = /* @__PURE__ */ h0e(function(e) {
  return AX(e) ? e : e.replace(C6e, "-$&").toLowerCase();
}), Lj = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(E0e, function(r, i, o) {
          return Mg = {
            name: i,
            styles: o,
            next: Mg
          }, i;
        });
  }
  return M6e[t] !== 1 && !AX(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
if (process.env.NODE_ENV !== "production") {
  var N6e = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, D6e = ["normal", "none", "initial", "inherit", "unset"], A6e = Lj, O6e = /^-ms-/, R6e = /-(.)/g, Aue = {};
  Lj = function(t, n) {
    if (t === "content" && (typeof n != "string" || D6e.indexOf(n) === -1 && !N6e.test(n) && (n.charAt(0) !== n.charAt(n.length - 1) || n.charAt(0) !== '"' && n.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + n + "\"'`");
    var r = A6e(t, n);
    return r !== "" && !AX(t) && t.indexOf("-") !== -1 && Aue[t] === void 0 && (Aue[t] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + t.replace(O6e, "ms-").replace(R6e, function(i, o) {
      return o.toUpperCase();
    }) + "?")), r;
  };
}
var S0e = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function JR(e, t, n) {
  if (n == null)
    return "";
  if (n.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && n.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(S0e);
    return n;
  }
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      if (n.anim === 1)
        return Mg = {
          name: n.name,
          styles: n.styles,
          next: Mg
        }, n.name;
      if (n.styles !== void 0) {
        var r = n.next;
        if (r !== void 0)
          for (; r !== void 0; )
            Mg = {
              name: r.name,
              styles: r.styles,
              next: Mg
            }, r = r.next;
        var i = n.styles + ";";
        return process.env.NODE_ENV !== "production" && n.map !== void 0 && (i += n.map), i;
      }
      return k6e(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var o = Mg, a = n(e);
        return Mg = o, JR(e, t, a);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var s = [], u = n.replace(E0e, function(f, h, p) {
          var g = "animation" + s.length;
          return s.push("const " + g + " = keyframes`" + p.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + g + "}";
        });
        s.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(s, ["`" + u + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + u + "`"));
      }
      break;
  }
  if (t == null)
    return n;
  var l = t[n];
  return l !== void 0 ? l : n;
}
function k6e(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += JR(e, t, n[i]) + ";";
  else
    for (var o in n) {
      var a = n[o];
      if (typeof a != "object")
        t != null && t[a] !== void 0 ? r += o + "{" + t[a] + "}" : Due(a) && (r += aY(o) + ":" + Lj(o, a) + ";");
      else {
        if (o === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(S0e);
        if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
          for (var s = 0; s < a.length; s++)
            Due(a[s]) && (r += aY(o) + ":" + Lj(o, a[s]) + ";");
        else {
          var u = JR(e, t, a);
          switch (o) {
            case "animation":
            case "animationName": {
              r += aY(o) + ":" + u + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && o === "undefined" && console.error(T6e), r += o + "{" + u + "}";
          }
        }
      }
    }
  return r;
}
var Oue = /label:\s*([^\s;\n{]+)\s*(;|$)/g, M0e;
process.env.NODE_ENV !== "production" && (M0e = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var Mg, VT = function(t, n, r) {
  if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
    return t[0];
  var i = !0, o = "";
  Mg = void 0;
  var a = t[0];
  a == null || a.raw === void 0 ? (i = !1, o += JR(r, n, a)) : (process.env.NODE_ENV !== "production" && a[0] === void 0 && console.error(Nue), o += a[0]);
  for (var s = 1; s < t.length; s++)
    o += JR(r, n, t[s]), i && (process.env.NODE_ENV !== "production" && a[s] === void 0 && console.error(Nue), o += a[s]);
  var u;
  process.env.NODE_ENV !== "production" && (o = o.replace(M0e, function(p) {
    return u = p, "";
  })), Oue.lastIndex = 0;
  for (var l = "", f; (f = Oue.exec(o)) !== null; )
    l += "-" + // $FlowFixMe we know it's not null
    f[1];
  var h = S6e(o) + l;
  return process.env.NODE_ENV !== "production" ? {
    name: h,
    styles: o,
    map: u,
    next: Mg,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: h,
    styles: o,
    next: Mg
  };
}, $6e = function(t) {
  return t();
}, T0e = KV["useInsertionEffect"] ? KV["useInsertionEffect"] : !1, OX = T0e || $6e, Rue = T0e || ae.useLayoutEffect, P6e = {}.hasOwnProperty, RX = /* @__PURE__ */ ae.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ y6e({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (RX.displayName = "EmotionCacheContext");
RX.Provider;
var jz = function(t) {
  return /* @__PURE__ */ ae.forwardRef(function(n, r) {
    var i = ae.useContext(RX);
    return t(n, i, r);
  });
}, JC = /* @__PURE__ */ ae.createContext({});
process.env.NODE_ENV !== "production" && (JC.displayName = "EmotionThemeContext");
var kue = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", $ue = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", I6e = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Pz(n, r, i), OX(function() {
    return Iz(n, r, i);
  }), null;
}, j6e = /* @__PURE__ */ jz(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var i = e[kue], o = [r], a = "";
  typeof e.className == "string" ? a = DX(t.registered, o, e.className) : e.className != null && (a = e.className + " ");
  var s = VT(o, void 0, ae.useContext(JC));
  if (process.env.NODE_ENV !== "production" && s.name.indexOf("-") === -1) {
    var u = e[$ue];
    u && (s = VT([s, "label:" + u + ";"]));
  }
  a += t.key + "-" + s.name;
  var l = {};
  for (var f in e)
    P6e.call(e, f) && f !== "css" && f !== kue && (process.env.NODE_ENV === "production" || f !== $ue) && (l[f] = e[f]);
  return l.ref = n, l.className = a, /* @__PURE__ */ ae.createElement(ae.Fragment, null, /* @__PURE__ */ ae.createElement(I6e, {
    cache: t,
    serialized: s,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ ae.createElement(i, l));
});
process.env.NODE_ENV !== "production" && (j6e.displayName = "EmotionCssPropInternal");
var L6e = {
  name: "@emotion/react",
  version: "11.11.1",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      import: "./dist/emotion-react.cjs.mjs",
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        import: "./macro.d.mts",
        default: "./macro.d.ts"
      },
      default: "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            import: "./macro.d.mts",
            default: "./macro.d.ts"
          },
          default: "./macro.js"
        }
      }
    }
  }
}, Pue = !1, C0e = /* @__PURE__ */ jz(function(e, t) {
  process.env.NODE_ENV !== "production" && !Pue && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (e.className || e.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), Pue = !0);
  var n = e.styles, r = VT([n], void 0, ae.useContext(JC)), i = ae.useRef();
  return Rue(function() {
    var o = t.key + "-global", a = new t.sheet.constructor({
      key: o,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), s = !1, u = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
    return t.sheet.tags.length && (a.before = t.sheet.tags[0]), u !== null && (s = !0, u.setAttribute("data-emotion", o), a.hydrate([u])), i.current = [a, s], function() {
      a.flush();
    };
  }, [t]), Rue(function() {
    var o = i.current, a = o[0], s = o[1];
    if (s) {
      o[1] = !1;
      return;
    }
    if (r.next !== void 0 && Iz(t, r.next, !0), a.tags.length) {
      var u = a.tags[a.tags.length - 1].nextElementSibling;
      a.before = u, a.flush();
    }
    t.insert("", r, a, !1);
  }, [t, r.name]), null;
});
process.env.NODE_ENV !== "production" && (C0e.displayName = "EmotionGlobal");
function z6e() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return VT(t);
}
var kX = function() {
  var t = z6e.apply(void 0, arguments), n = "animation-" + t.name;
  return {
    name: n,
    styles: "@keyframes " + n + "{" + t.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, F6e = function e(t) {
  for (var n = t.length, r = 0, i = ""; r < n; r++) {
    var o = t[r];
    if (o != null) {
      var a = void 0;
      switch (typeof o) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(o))
            a = e(o);
          else {
            process.env.NODE_ENV !== "production" && o.styles !== void 0 && o.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), a = "";
            for (var s in o)
              o[s] && s && (a && (a += " "), a += s);
          }
          break;
        }
        default:
          a = o;
      }
      a && (i && (i += " "), i += a);
    }
  }
  return i;
};
function B6e(e, t, n) {
  var r = [], i = DX(e, r, n);
  return r.length < 2 ? n : i + t(r);
}
var U6e = function(t) {
  var n = t.cache, r = t.serializedArr;
  return OX(function() {
    for (var i = 0; i < r.length; i++)
      Iz(n, r[i], !1);
  }), null;
}, Y6e = /* @__PURE__ */ jz(function(e, t) {
  var n = !1, r = [], i = function() {
    if (n && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var l = arguments.length, f = new Array(l), h = 0; h < l; h++)
      f[h] = arguments[h];
    var p = VT(f, t.registered);
    return r.push(p), Pz(t, p, !1), t.key + "-" + p.name;
  }, o = function() {
    if (n && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var l = arguments.length, f = new Array(l), h = 0; h < l; h++)
      f[h] = arguments[h];
    return B6e(t.registered, i, F6e(f));
  }, a = {
    css: i,
    cx: o,
    theme: ae.useContext(JC)
  }, s = e.children(a);
  return n = !0, /* @__PURE__ */ ae.createElement(ae.Fragment, null, /* @__PURE__ */ ae.createElement(U6e, {
    cache: t,
    serializedArr: r
  }), s);
});
process.env.NODE_ENV !== "production" && (Y6e.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var Iue = !0, H6e = typeof jest < "u" || typeof vi < "u";
  if (Iue && !H6e) {
    var jue = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : Iue ? window : global
    ), Lue = "__EMOTION_REACT_" + L6e.version.split(".")[0] + "__";
    jue[Lue] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), jue[Lue] = !0;
  }
}
var V6e = jFe, W6e = function(t) {
  return t !== "theme";
}, zue = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? V6e : W6e;
}, Fue = function(t, n, r) {
  var i;
  if (n) {
    var o = n.shouldForwardProp;
    i = t.__emotion_forwardProp && o ? function(a) {
      return t.__emotion_forwardProp(a) && o(a);
    } : o;
  }
  return typeof i != "function" && r && (i = t.__emotion_forwardProp), i;
}, Bue = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, q6e = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Pz(n, r, i), OX(function() {
    return Iz(n, r, i);
  }), null;
}, G6e = function e(t, n) {
  if (process.env.NODE_ENV !== "production" && t === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var r = t.__emotion_real === t, i = r && t.__emotion_base || t, o, a;
  n !== void 0 && (o = n.label, a = n.target);
  var s = Fue(t, n, r), u = s || zue(i), l = !u("as");
  return function() {
    var f = arguments, h = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (o !== void 0 && h.push("label:" + o + ";"), f[0] == null || f[0].raw === void 0)
      h.push.apply(h, f);
    else {
      process.env.NODE_ENV !== "production" && f[0][0] === void 0 && console.error(Bue), h.push(f[0][0]);
      for (var p = f.length, g = 1; g < p; g++)
        process.env.NODE_ENV !== "production" && f[0][g] === void 0 && console.error(Bue), h.push(f[g], f[0][g]);
    }
    var y = jz(function(b, _, S) {
      var C = l && b.as || i, A = "", O = [], R = b;
      if (b.theme == null) {
        R = {};
        for (var j in b)
          R[j] = b[j];
        R.theme = ae.useContext(JC);
      }
      typeof b.className == "string" ? A = DX(_.registered, O, b.className) : b.className != null && (A = b.className + " ");
      var $ = VT(h.concat(O), _.registered, R);
      A += _.key + "-" + $.name, a !== void 0 && (A += " " + a);
      var z = l && s === void 0 ? zue(C) : u, W = {};
      for (var Y in b)
        l && Y === "as" || // $FlowFixMe
        z(Y) && (W[Y] = b[Y]);
      return W.className = A, W.ref = S, /* @__PURE__ */ ae.createElement(ae.Fragment, null, /* @__PURE__ */ ae.createElement(q6e, {
        cache: _,
        serialized: $,
        isStringTag: typeof C == "string"
      }), /* @__PURE__ */ ae.createElement(C, W));
    });
    return y.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", y.defaultProps = t.defaultProps, y.__emotion_real = y, y.__emotion_base = i, y.__emotion_styles = h, y.__emotion_forwardProp = s, Object.defineProperty(y, "toString", {
      value: function() {
        return a === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + a;
      }
    }), y.withComponent = function(b, _) {
      return e(b, ge({}, n, _, {
        shouldForwardProp: Fue(y, _, !0)
      })).apply(void 0, h);
    }, y;
  };
}, Q6e = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], uW = G6e.bind();
Q6e.forEach(function(e) {
  uW[e] = uW(e);
});
function X6e(e) {
  return e == null || Object.keys(e).length === 0;
}
function N0e(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (i) => t(X6e(i) ? n : i) : t;
  return /* @__PURE__ */ pe.jsx(C0e, {
    styles: r
  });
}
process.env.NODE_ENV !== "production" && (N0e.propTypes = {
  defaultTheme: N.object,
  styles: N.oneOfType([N.array, N.string, N.object, N.func])
});
/**
 * @mui/styled-engine v5.13.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function D0e(e, t) {
  const n = uW(e, t);
  return process.env.NODE_ENV !== "production" ? (...r) => {
    const i = typeof e == "string" ? `"${e}"` : "component";
    return r.length === 0 ? console.error([`MUI: Seems like you called \`styled(${i})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : r.some((o) => o === void 0) && console.error(`MUI: the styled(${i})(...args) API requires all its args to be defined.`), n(...r);
  } : n;
}
const K6e = (e, t) => {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}, Z6e = ["values", "unit", "step"], J6e = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ge({}, n, {
    [r.key]: r.val
  }), {});
};
function e8e(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5
  } = e, i = ln(e, Z6e), o = J6e(t), a = Object.keys(o);
  function s(p) {
    return `@media (min-width:${typeof t[p] == "number" ? t[p] : p}${n})`;
  }
  function u(p) {
    return `@media (max-width:${(typeof t[p] == "number" ? t[p] : p) - r / 100}${n})`;
  }
  function l(p, g) {
    const y = a.indexOf(g);
    return `@media (min-width:${typeof t[p] == "number" ? t[p] : p}${n}) and (max-width:${(y !== -1 && typeof t[a[y]] == "number" ? t[a[y]] : g) - r / 100}${n})`;
  }
  function f(p) {
    return a.indexOf(p) + 1 < a.length ? l(p, a[a.indexOf(p) + 1]) : s(p);
  }
  function h(p) {
    const g = a.indexOf(p);
    return g === 0 ? s(a[1]) : g === a.length - 1 ? u(a[g]) : l(p, a[a.indexOf(p) + 1]).replace("@media", "@media not all and");
  }
  return ge({
    keys: a,
    values: o,
    up: s,
    down: u,
    between: l,
    only: f,
    not: h,
    unit: n
  }, i);
}
const t8e = {
  borderRadius: 4
}, n8e = t8e, r8e = process.env.NODE_ENV !== "production" ? N.oneOfType([N.number, N.string, N.object, N.array]) : {}, ww = r8e;
function uR(e, t) {
  return t ? ip(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const $X = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, Uue = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${$X[e]}px)`
};
function up(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const o = r.breakpoints || Uue;
    return t.reduce((a, s, u) => (a[o.up(o.keys[u])] = n(t[u]), a), {});
  }
  if (typeof t == "object") {
    const o = r.breakpoints || Uue;
    return Object.keys(t).reduce((a, s) => {
      if (Object.keys(o.values || $X).indexOf(s) !== -1) {
        const u = o.up(s);
        a[u] = n(t[s], s);
      } else {
        const u = s;
        a[u] = t[u];
      }
      return a;
    }, {});
  }
  return n(t);
}
function i8e(e = {}) {
  var t;
  return ((t = e.keys) == null ? void 0 : t.reduce((r, i) => {
    const o = e.up(i);
    return r[o] = {}, r;
  }, {})) || {};
}
function o8e(e, t) {
  return e.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, t);
}
function a8e(e, t) {
  if (typeof e != "object")
    return {};
  const n = {}, r = Object.keys(t);
  return Array.isArray(e) ? r.forEach((i, o) => {
    o < e.length && (n[i] = !0);
  }) : r.forEach((i) => {
    e[i] != null && (n[i] = !0);
  }), n;
}
function Lz({
  values: e,
  breakpoints: t,
  base: n
}) {
  const r = n || a8e(e, t), i = Object.keys(r);
  if (i.length === 0)
    return e;
  let o;
  return i.reduce((a, s, u) => (Array.isArray(e) ? (a[s] = e[u] != null ? e[u] : e[o], o = u) : typeof e == "object" ? (a[s] = e[s] != null ? e[s] : e[o], o = s) : a[s] = e, a), {});
}
function WT(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((i, o) => i && i[o] ? i[o] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, e);
}
function zj(e, t, n, r = n) {
  let i;
  return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = WT(e, n) || r, t && (i = t(i, r, e)), i;
}
function to(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: i
  } = e, o = (a) => {
    if (a[t] == null)
      return null;
    const s = a[t], u = a.theme, l = WT(u, r) || {};
    return up(a, s, (h) => {
      let p = zj(l, i, h);
      return h === p && typeof h == "string" && (p = zj(l, i, `${t}${h === "default" ? "" : Xn(h)}`, h)), n === !1 ? p : {
        [n]: p
      };
    });
  };
  return o.propTypes = process.env.NODE_ENV !== "production" ? {
    [t]: ww
  } : {}, o.filterProps = [t], o;
}
function s8e(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const u8e = {
  m: "margin",
  p: "padding"
}, l8e = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, Yue = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, c8e = s8e((e) => {
  if (e.length > 2)
    if (Yue[e])
      e = Yue[e];
    else
      return [e];
  const [t, n] = e.split(""), r = u8e[t], i = l8e[n] || "";
  return Array.isArray(i) ? i.map((o) => r + o) : [r + i];
}), zz = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Fz = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], f8e = [...zz, ...Fz];
function y$(e, t, n, r) {
  var i;
  const o = (i = WT(e, t, !1)) != null ? i : n;
  return typeof o == "number" ? (a) => typeof a == "string" ? a : (process.env.NODE_ENV !== "production" && typeof a != "number" && console.error(`MUI: Expected ${r} argument to be a number or a string, got ${a}.`), o * a) : Array.isArray(o) ? (a) => typeof a == "string" ? a : (process.env.NODE_ENV !== "production" && (Number.isInteger(a) ? a > o.length - 1 && console.error([`MUI: The value provided (${a}) overflows.`, `The supported values are: ${JSON.stringify(o)}.`, `${a} > ${o.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${t}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${t}\` as a number.`].join(`
`))), o[a]) : typeof o == "function" ? o : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${t}\` value (${o}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function A0e(e) {
  return y$(e, "spacing", 8, "spacing");
}
function v$(e, t) {
  if (typeof t == "string" || t == null)
    return t;
  const n = Math.abs(t), r = e(n);
  return t >= 0 ? r : typeof r == "number" ? -r : `-${r}`;
}
function d8e(e, t) {
  return (n) => e.reduce((r, i) => (r[i] = v$(t, n), r), {});
}
function h8e(e, t, n, r) {
  if (t.indexOf(n) === -1)
    return null;
  const i = c8e(n), o = d8e(i, r), a = e[n];
  return up(e, a, o);
}
function O0e(e, t) {
  const n = A0e(e.theme);
  return Object.keys(e).map((r) => h8e(e, t, r, n)).reduce(uR, {});
}
function Ra(e) {
  return O0e(e, zz);
}
Ra.propTypes = process.env.NODE_ENV !== "production" ? zz.reduce((e, t) => (e[t] = ww, e), {}) : {};
Ra.filterProps = zz;
function ka(e) {
  return O0e(e, Fz);
}
ka.propTypes = process.env.NODE_ENV !== "production" ? Fz.reduce((e, t) => (e[t] = ww, e), {}) : {};
ka.filterProps = Fz;
process.env.NODE_ENV !== "production" && f8e.reduce((e, t) => (e[t] = ww, e), {});
function p8e(e = 8) {
  if (e.mui)
    return e;
  const t = A0e({
    spacing: e
  }), n = (...r) => (process.env.NODE_ENV !== "production" && (r.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${r.length}`)), (r.length === 0 ? [1] : r).map((o) => {
    const a = t(o);
    return typeof a == "number" ? `${a}px` : a;
  }).join(" "));
  return n.mui = !0, n;
}
function Bz(...e) {
  const t = e.reduce((r, i) => (i.filterProps.forEach((o) => {
    r[o] = i;
  }), r), {}), n = (r) => Object.keys(r).reduce((i, o) => t[o] ? uR(i, t[o](r)) : i, {});
  return n.propTypes = process.env.NODE_ENV !== "production" ? e.reduce((r, i) => Object.assign(r, i.propTypes), {}) : {}, n.filterProps = e.reduce((r, i) => r.concat(i.filterProps), []), n;
}
function My(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
const g8e = to({
  prop: "border",
  themeKey: "borders",
  transform: My
}), m8e = to({
  prop: "borderTop",
  themeKey: "borders",
  transform: My
}), y8e = to({
  prop: "borderRight",
  themeKey: "borders",
  transform: My
}), v8e = to({
  prop: "borderBottom",
  themeKey: "borders",
  transform: My
}), b8e = to({
  prop: "borderLeft",
  themeKey: "borders",
  transform: My
}), x8e = to({
  prop: "borderColor",
  themeKey: "palette"
}), w8e = to({
  prop: "borderTopColor",
  themeKey: "palette"
}), _8e = to({
  prop: "borderRightColor",
  themeKey: "palette"
}), E8e = to({
  prop: "borderBottomColor",
  themeKey: "palette"
}), S8e = to({
  prop: "borderLeftColor",
  themeKey: "palette"
}), Uz = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = y$(e.theme, "shape.borderRadius", 4, "borderRadius"), n = (r) => ({
      borderRadius: v$(t, r)
    });
    return up(e, e.borderRadius, n);
  }
  return null;
};
Uz.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: ww
} : {};
Uz.filterProps = ["borderRadius"];
Bz(g8e, m8e, y8e, v8e, b8e, x8e, w8e, _8e, E8e, S8e, Uz);
const Yz = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = y$(e.theme, "spacing", 8, "gap"), n = (r) => ({
      gap: v$(t, r)
    });
    return up(e, e.gap, n);
  }
  return null;
};
Yz.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: ww
} : {};
Yz.filterProps = ["gap"];
const Hz = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = y$(e.theme, "spacing", 8, "columnGap"), n = (r) => ({
      columnGap: v$(t, r)
    });
    return up(e, e.columnGap, n);
  }
  return null;
};
Hz.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: ww
} : {};
Hz.filterProps = ["columnGap"];
const Vz = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = y$(e.theme, "spacing", 8, "rowGap"), n = (r) => ({
      rowGap: v$(t, r)
    });
    return up(e, e.rowGap, n);
  }
  return null;
};
Vz.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: ww
} : {};
Vz.filterProps = ["rowGap"];
const M8e = to({
  prop: "gridColumn"
}), T8e = to({
  prop: "gridRow"
}), C8e = to({
  prop: "gridAutoFlow"
}), N8e = to({
  prop: "gridAutoColumns"
}), D8e = to({
  prop: "gridAutoRows"
}), A8e = to({
  prop: "gridTemplateColumns"
}), O8e = to({
  prop: "gridTemplateRows"
}), R8e = to({
  prop: "gridTemplateAreas"
}), k8e = to({
  prop: "gridArea"
});
Bz(Yz, Hz, Vz, M8e, T8e, C8e, N8e, D8e, A8e, O8e, R8e, k8e);
function ST(e, t) {
  return t === "grey" ? t : e;
}
const $8e = to({
  prop: "color",
  themeKey: "palette",
  transform: ST
}), P8e = to({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: ST
}), I8e = to({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: ST
});
Bz($8e, P8e, I8e);
function Ed(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const j8e = to({
  prop: "width",
  transform: Ed
}), PX = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      var r;
      return {
        maxWidth: ((r = e.theme) == null || (r = r.breakpoints) == null || (r = r.values) == null ? void 0 : r[n]) || $X[n] || Ed(n)
      };
    };
    return up(e, e.maxWidth, t);
  }
  return null;
};
PX.filterProps = ["maxWidth"];
const L8e = to({
  prop: "minWidth",
  transform: Ed
}), z8e = to({
  prop: "height",
  transform: Ed
}), F8e = to({
  prop: "maxHeight",
  transform: Ed
}), B8e = to({
  prop: "minHeight",
  transform: Ed
});
to({
  prop: "size",
  cssProperty: "width",
  transform: Ed
});
to({
  prop: "size",
  cssProperty: "height",
  transform: Ed
});
const U8e = to({
  prop: "boxSizing"
});
Bz(j8e, PX, L8e, z8e, F8e, B8e, U8e);
const Y8e = {
  // borders
  border: {
    themeKey: "borders",
    transform: My
  },
  borderTop: {
    themeKey: "borders",
    transform: My
  },
  borderRight: {
    themeKey: "borders",
    transform: My
  },
  borderBottom: {
    themeKey: "borders",
    transform: My
  },
  borderLeft: {
    themeKey: "borders",
    transform: My
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Uz
  },
  // palette
  color: {
    themeKey: "palette",
    transform: ST
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: ST
  },
  backgroundColor: {
    themeKey: "palette",
    transform: ST
  },
  // spacing
  p: {
    style: ka
  },
  pt: {
    style: ka
  },
  pr: {
    style: ka
  },
  pb: {
    style: ka
  },
  pl: {
    style: ka
  },
  px: {
    style: ka
  },
  py: {
    style: ka
  },
  padding: {
    style: ka
  },
  paddingTop: {
    style: ka
  },
  paddingRight: {
    style: ka
  },
  paddingBottom: {
    style: ka
  },
  paddingLeft: {
    style: ka
  },
  paddingX: {
    style: ka
  },
  paddingY: {
    style: ka
  },
  paddingInline: {
    style: ka
  },
  paddingInlineStart: {
    style: ka
  },
  paddingInlineEnd: {
    style: ka
  },
  paddingBlock: {
    style: ka
  },
  paddingBlockStart: {
    style: ka
  },
  paddingBlockEnd: {
    style: ka
  },
  m: {
    style: Ra
  },
  mt: {
    style: Ra
  },
  mr: {
    style: Ra
  },
  mb: {
    style: Ra
  },
  ml: {
    style: Ra
  },
  mx: {
    style: Ra
  },
  my: {
    style: Ra
  },
  margin: {
    style: Ra
  },
  marginTop: {
    style: Ra
  },
  marginRight: {
    style: Ra
  },
  marginBottom: {
    style: Ra
  },
  marginLeft: {
    style: Ra
  },
  marginX: {
    style: Ra
  },
  marginY: {
    style: Ra
  },
  marginInline: {
    style: Ra
  },
  marginInlineStart: {
    style: Ra
  },
  marginInlineEnd: {
    style: Ra
  },
  marginBlock: {
    style: Ra
  },
  marginBlockStart: {
    style: Ra
  },
  marginBlockEnd: {
    style: Ra
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Yz
  },
  rowGap: {
    style: Vz
  },
  columnGap: {
    style: Hz
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Ed
  },
  maxWidth: {
    style: PX
  },
  minWidth: {
    transform: Ed
  },
  height: {
    transform: Ed
  },
  maxHeight: {
    transform: Ed
  },
  minHeight: {
    transform: Ed
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
}, Wz = Y8e;
function H8e(...e) {
  const t = e.reduce((r, i) => r.concat(Object.keys(i)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function V8e(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function W8e() {
  function e(n, r, i, o) {
    const a = {
      [n]: r,
      theme: i
    }, s = o[n];
    if (!s)
      return {
        [n]: r
      };
    const {
      cssProperty: u = n,
      themeKey: l,
      transform: f,
      style: h
    } = s;
    if (r == null)
      return null;
    if (l === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const p = WT(i, l) || {};
    return h ? h(a) : up(a, r, (y) => {
      let b = zj(p, f, y);
      return y === b && typeof y == "string" && (b = zj(p, f, `${n}${y === "default" ? "" : Xn(y)}`, y)), u === !1 ? b : {
        [u]: b
      };
    });
  }
  function t(n) {
    var r;
    const {
      sx: i,
      theme: o = {}
    } = n || {};
    if (!i)
      return null;
    const a = (r = o.unstable_sxConfig) != null ? r : Wz;
    function s(u) {
      let l = u;
      if (typeof u == "function")
        l = u(o);
      else if (typeof u != "object")
        return u;
      if (!l)
        return null;
      const f = i8e(o.breakpoints), h = Object.keys(f);
      let p = f;
      return Object.keys(l).forEach((g) => {
        const y = V8e(l[g], o);
        if (y != null)
          if (typeof y == "object")
            if (a[g])
              p = uR(p, e(g, y, o, a));
            else {
              const b = up({
                theme: o
              }, y, (_) => ({
                [g]: _
              }));
              H8e(b, y) ? p[g] = t({
                sx: y,
                theme: o
              }) : p = uR(p, b);
            }
          else
            p = uR(p, e(g, y, o, a));
      }), o8e(h, p);
    }
    return Array.isArray(i) ? i.map(s) : s(i);
  }
  return t;
}
const R0e = W8e();
R0e.filterProps = ["sx"];
const qz = R0e, q8e = ["breakpoints", "palette", "spacing", "shape"];
function IX(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: i,
    shape: o = {}
  } = e, a = ln(e, q8e), s = e8e(n), u = p8e(i);
  let l = ip({
    breakpoints: s,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: ge({
      mode: "light"
    }, r),
    spacing: u,
    shape: ge({}, n8e, o)
  }, a);
  return l = t.reduce((f, h) => ip(f, h), l), l.unstable_sxConfig = ge({}, Wz, a == null ? void 0 : a.unstable_sxConfig), l.unstable_sx = function(h) {
    return qz({
      sx: h,
      theme: this
    });
  }, l;
}
function G8e(e) {
  return Object.keys(e).length === 0;
}
function k0e(e = null) {
  const t = ae.useContext(JC);
  return !t || G8e(t) ? e : t;
}
const Q8e = IX();
function Gz(e = Q8e) {
  return k0e(e);
}
function $0e({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = Gz(n), i = typeof e == "function" ? e(t && r[t] || r) : e;
  return /* @__PURE__ */ pe.jsx(N0e, {
    styles: i
  });
}
process.env.NODE_ENV !== "production" && ($0e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  defaultTheme: N.object,
  /**
   * @ignore
   */
  styles: N.oneOfType([N.array, N.func, N.number, N.object, N.string, N.bool]),
  /**
   * @ignore
   */
  themeId: N.string
});
const X8e = ["sx"], K8e = (e) => {
  var t, n;
  const r = {
    systemProps: {},
    otherProps: {}
  }, i = (t = e == null || (n = e.theme) == null ? void 0 : n.unstable_sxConfig) != null ? t : Wz;
  return Object.keys(e).forEach((o) => {
    i[o] ? r.systemProps[o] = e[o] : r.otherProps[o] = e[o];
  }), r;
};
function jX(e) {
  const {
    sx: t
  } = e, n = ln(e, X8e), {
    systemProps: r,
    otherProps: i
  } = K8e(n);
  let o;
  return Array.isArray(t) ? o = [r, ...t] : typeof t == "function" ? o = (...a) => {
    const s = t(...a);
    return NE(s) ? ge({}, r, s) : r;
  } : o = ge({}, r, t), ge({}, i, {
    sx: o
  });
}
function P0e(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = P0e(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function kn() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = P0e(e)) && (r && (r += " "), r += t);
  return r;
}
const Z8e = ["className", "component"];
function J8e(e = {}) {
  const {
    themeId: t,
    defaultTheme: n,
    defaultClassName: r = "MuiBox-root",
    generateClassName: i
  } = e, o = D0e("div", {
    shouldForwardProp: (s) => s !== "theme" && s !== "sx" && s !== "as"
  })(qz);
  return /* @__PURE__ */ ae.forwardRef(function(u, l) {
    const f = Gz(n), h = jX(u), {
      className: p,
      component: g = "div"
    } = h, y = ln(h, Z8e);
    return /* @__PURE__ */ pe.jsx(o, ge({
      as: g,
      ref: l,
      className: kn(p, i ? i(r) : r),
      theme: t && f[t] || f
    }, y));
  });
}
const e9e = ["variant"];
function Hue(e) {
  return e.length === 0;
}
function I0e(e) {
  const {
    variant: t
  } = e, n = ln(e, e9e);
  let r = t || "";
  return Object.keys(n).sort().forEach((i) => {
    i === "color" ? r += Hue(r) ? e[i] : Xn(e[i]) : r += `${Hue(r) ? i : Xn(i)}${Xn(e[i].toString())}`;
  }), r;
}
const t9e = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function n9e(e) {
  return Object.keys(e).length === 0;
}
function r9e(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
const i9e = (e, t) => t.components && t.components[e] && t.components[e].styleOverrides ? t.components[e].styleOverrides : null, o9e = (e, t) => {
  let n = [];
  t && t.components && t.components[e] && t.components[e].variants && (n = t.components[e].variants);
  const r = {};
  return n.forEach((i) => {
    const o = I0e(i.props);
    r[o] = i.style;
  }), r;
}, a9e = (e, t, n, r) => {
  var i;
  const {
    ownerState: o = {}
  } = e, a = [], s = n == null || (i = n.components) == null || (i = i[r]) == null ? void 0 : i.variants;
  return s && s.forEach((u) => {
    let l = !0;
    Object.keys(u.props).forEach((f) => {
      o[f] !== u.props[f] && e[f] !== u.props[f] && (l = !1);
    }), l && a.push(t[I0e(u.props)]);
  }), a;
};
function lR(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const s9e = IX(), Vue = (e) => e && e.charAt(0).toLowerCase() + e.slice(1);
function CA({
  defaultTheme: e,
  theme: t,
  themeId: n
}) {
  return n9e(t) ? e : t[n] || t;
}
function u9e(e) {
  return e ? (t, n) => n[e] : null;
}
function l9e(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = s9e,
    rootShouldForwardProp: r = lR,
    slotShouldForwardProp: i = lR
  } = e, o = (a) => qz(ge({}, a, {
    theme: CA(ge({}, a, {
      defaultTheme: n,
      themeId: t
    }))
  }));
  return o.__mui_systemSx = !0, (a, s = {}) => {
    K6e(a, (O) => O.filter((R) => !(R != null && R.__mui_systemSx)));
    const {
      name: u,
      slot: l,
      skipVariantsResolver: f,
      skipSx: h,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: p = u9e(Vue(l))
    } = s, g = ln(s, t9e), y = f !== void 0 ? f : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      l && l !== "Root" && l !== "root" || !1
    ), b = h || !1;
    let _;
    process.env.NODE_ENV !== "production" && u && (_ = `${u}-${Vue(l || "Root")}`);
    let S = lR;
    l === "Root" || l === "root" ? S = r : l ? S = i : r9e(a) && (S = void 0);
    const C = D0e(a, ge({
      shouldForwardProp: S,
      label: _
    }, g)), A = (O, ...R) => {
      const j = R ? R.map((Y) => typeof Y == "function" && Y.__emotion_real !== Y ? (V) => Y(ge({}, V, {
        theme: CA(ge({}, V, {
          defaultTheme: n,
          themeId: t
        }))
      })) : Y) : [];
      let $ = O;
      u && p && j.push((Y) => {
        const V = CA(ge({}, Y, {
          defaultTheme: n,
          themeId: t
        })), ee = i9e(u, V);
        if (ee) {
          const K = {};
          return Object.entries(ee).forEach(([Q, q]) => {
            K[Q] = typeof q == "function" ? q(ge({}, Y, {
              theme: V
            })) : q;
          }), p(Y, K);
        }
        return null;
      }), u && !y && j.push((Y) => {
        const V = CA(ge({}, Y, {
          defaultTheme: n,
          themeId: t
        }));
        return a9e(Y, o9e(u, V), V, u);
      }), b || j.push(o);
      const z = j.length - R.length;
      if (Array.isArray(O) && z > 0) {
        const Y = new Array(z).fill("");
        $ = [...O, ...Y], $.raw = [...O.raw, ...Y];
      } else
        typeof O == "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        O.__emotion_real !== O && ($ = (Y) => O(ge({}, Y, {
          theme: CA(ge({}, Y, {
            defaultTheme: n,
            themeId: t
          }))
        })));
      const W = C($, ...j);
      if (process.env.NODE_ENV !== "production") {
        let Y;
        u && (Y = `${u}${Xn(l || "")}`), Y === void 0 && (Y = `Styled(${gFe(a)})`), W.displayName = Y;
      }
      return a.muiName && (W.muiName = a.muiName), W;
    };
    return C.withConfig && (A.withConfig = C.withConfig), A;
  };
}
function c9e(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : SX(t.components[n].defaultProps, r);
}
function f9e({
  props: e,
  name: t,
  defaultTheme: n,
  themeId: r
}) {
  let i = Gz(n);
  return r && (i = i[r] || i), c9e({
    theme: i,
    name: t,
    props: e
  });
}
function LX(e, t = 0, n = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > n) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${n}].`), Math.min(Math.max(t, e), n);
}
function d9e(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function pS(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return pS(d9e(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n) === -1)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${e}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : Hx(9, e));
  let r = e.substring(t + 1, e.length - 1), i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${i}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : Hx(10, i));
  } else
    r = r.split(",");
  return r = r.map((o) => parseFloat(o)), {
    type: n,
    values: r,
    colorSpace: i
  };
}
function Qz(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.indexOf("rgb") !== -1 ? r = r.map((i, o) => o < 3 ? parseInt(i, 10) : i) : t.indexOf("hsl") !== -1 && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.indexOf("color") !== -1 ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function h9e(e) {
  e = pS(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, o = r * Math.min(i, 1 - i), a = (l, f = (l + n / 30) % 12) => i - o * Math.max(Math.min(f - 3, 9 - f, 1), -1);
  let s = "rgb";
  const u = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
  return e.type === "hsla" && (s += "a", u.push(t[3])), Qz({
    type: s,
    values: u
  });
}
function Wue(e) {
  e = pS(e);
  let t = e.type === "hsl" || e.type === "hsla" ? pS(h9e(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function que(e, t) {
  const n = Wue(e), r = Wue(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function bs(e, t) {
  return e = pS(e), t = LX(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, Qz(e);
}
function Fj(e, t) {
  if (e = pS(e), t = LX(t), e.type.indexOf("hsl") !== -1)
    e.values[2] *= 1 - t;
  else if (e.type.indexOf("rgb") !== -1 || e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return Qz(e);
}
function j0e(e, t) {
  if (e = pS(e), t = LX(t), e.type.indexOf("hsl") !== -1)
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.indexOf("rgb") !== -1)
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return Qz(e);
}
function p9e(e, t) {
  return ge({
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    }
  }, t);
}
const g9e = ["mode", "contrastThreshold", "tonalOffset"], Gue = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: XR.white,
    default: XR.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
}, sY = {
  text: {
    primary: XR.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: XR.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function Que(e, t, n, r) {
  const i = r.light || r, o = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = j0e(e.main, i) : t === "dark" && (e.dark = Fj(e.main, o)));
}
function m9e(e = "light") {
  return e === "dark" ? {
    main: AM[200],
    light: AM[50],
    dark: AM[400]
  } : {
    main: AM[700],
    light: AM[400],
    dark: AM[800]
  };
}
function y9e(e = "light") {
  return e === "dark" ? {
    main: DM[200],
    light: DM[50],
    dark: DM[400]
  } : {
    main: DM[500],
    light: DM[300],
    dark: DM[700]
  };
}
function v9e(e = "light") {
  return e === "dark" ? {
    main: NM[500],
    light: NM[300],
    dark: NM[700]
  } : {
    main: NM[700],
    light: NM[400],
    dark: NM[800]
  };
}
function b9e(e = "light") {
  return e === "dark" ? {
    main: OM[400],
    light: OM[300],
    dark: OM[700]
  } : {
    main: OM[700],
    light: OM[500],
    dark: OM[900]
  };
}
function x9e(e = "light") {
  return e === "dark" ? {
    main: RM[400],
    light: RM[300],
    dark: RM[700]
  } : {
    main: RM[800],
    light: RM[500],
    dark: RM[900]
  };
}
function w9e(e = "light") {
  return e === "dark" ? {
    main: MA[400],
    light: MA[300],
    dark: MA[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: MA[500],
    dark: MA[900]
  };
}
function _9e(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2
  } = e, i = ln(e, g9e), o = e.primary || m9e(t), a = e.secondary || y9e(t), s = e.error || v9e(t), u = e.info || b9e(t), l = e.success || x9e(t), f = e.warning || w9e(t);
  function h(b) {
    const _ = que(b, sY.text.primary) >= n ? sY.text.primary : Gue.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const S = que(b, _);
      S < 3 && console.error([`MUI: The contrast ratio of ${S}:1 for ${_} on ${b}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return _;
  }
  const p = ({
    color: b,
    name: _,
    mainShade: S = 500,
    lightShade: C = 300,
    darkShade: A = 700
  }) => {
    if (b = ge({}, b), !b.main && b[S] && (b.main = b[S]), !b.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${_ ? ` (${_})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${S}\` property.` : Hx(11, _ ? ` (${_})` : "", S));
    if (typeof b.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${_ ? ` (${_})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(b.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : Hx(12, _ ? ` (${_})` : "", JSON.stringify(b.main)));
    return Que(b, "light", C, r), Que(b, "dark", A, r), b.contrastText || (b.contrastText = h(b.main)), b;
  }, g = {
    dark: sY,
    light: Gue
  };
  return process.env.NODE_ENV !== "production" && (g[t] || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), ip(ge({
    // A collection of common colors.
    common: ge({}, XR),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: p({
      color: o,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: p({
      color: a,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: p({
      color: s,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: p({
      color: f,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: p({
      color: u,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: p({
      color: l,
      name: "success"
    }),
    // The grey colors.
    grey: Zze,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: h,
    // Generate a rich color object.
    augmentColor: p,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r
  }, g[t]), i);
}
const E9e = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function S9e(e) {
  return Math.round(e * 1e5) / 1e5;
}
const Xue = {
  textTransform: "uppercase"
}, Kue = '"Roboto", "Helvetica", "Arial", sans-serif';
function M9e(e, t) {
  const n = typeof t == "function" ? t(e) : t, {
    fontFamily: r = Kue,
    // The default font size of the Material Specification.
    fontSize: i = 14,
    // px
    fontWeightLight: o = 300,
    fontWeightRegular: a = 400,
    fontWeightMedium: s = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: l = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: h
  } = n, p = ln(n, E9e);
  process.env.NODE_ENV !== "production" && (typeof i != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof l != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const g = i / 14, y = h || ((S) => `${S / l * g}rem`), b = (S, C, A, O, R) => ge({
    fontFamily: r,
    fontWeight: S,
    fontSize: y(C),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: A
  }, r === Kue ? {
    letterSpacing: `${S9e(O / C)}em`
  } : {}, R, f), _ = {
    h1: b(o, 96, 1.167, -1.5),
    h2: b(o, 60, 1.2, -0.5),
    h3: b(a, 48, 1.167, 0),
    h4: b(a, 34, 1.235, 0.25),
    h5: b(a, 24, 1.334, 0),
    h6: b(s, 20, 1.6, 0.15),
    subtitle1: b(a, 16, 1.75, 0.15),
    subtitle2: b(s, 14, 1.57, 0.1),
    body1: b(a, 16, 1.5, 0.15),
    body2: b(a, 14, 1.43, 0.15),
    button: b(s, 14, 1.75, 0.4, Xue),
    caption: b(a, 12, 1.66, 0.4),
    overline: b(a, 12, 2.66, 1, Xue),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return ip(ge({
    htmlFontSize: l,
    pxToRem: y,
    fontFamily: r,
    fontSize: i,
    fontWeightLight: o,
    fontWeightRegular: a,
    fontWeightMedium: s,
    fontWeightBold: u
  }, _), p, {
    clone: !1
    // No need to clone deep
  });
}
const T9e = 0.2, C9e = 0.14, N9e = 0.12;
function ta(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${T9e})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${C9e})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${N9e})`].join(",");
}
const D9e = ["none", ta(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), ta(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), ta(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), ta(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), ta(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), ta(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), ta(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), ta(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), ta(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), ta(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), ta(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), ta(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), ta(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), ta(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), ta(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), ta(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), ta(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), ta(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), ta(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), ta(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), ta(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), ta(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), ta(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), ta(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], A9e = D9e, O9e = ["duration", "easing", "delay"], R9e = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, k9e = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function Zue(e) {
  return `${Math.round(e)}ms`;
}
function $9e(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.round((4 + 15 * t ** 0.25 + t / 5) * 10);
}
function P9e(e) {
  const t = ge({}, R9e, e.easing), n = ge({}, k9e, e.duration);
  return ge({
    getAutoHeightDuration: $9e,
    create: (i = ["all"], o = {}) => {
      const {
        duration: a = n.standard,
        easing: s = t.easeInOut,
        delay: u = 0
      } = o, l = ln(o, O9e);
      if (process.env.NODE_ENV !== "production") {
        const f = (p) => typeof p == "string", h = (p) => !isNaN(parseFloat(p));
        !f(i) && !Array.isArray(i) && console.error('MUI: Argument "props" must be a string or Array.'), !h(a) && !f(a) && console.error(`MUI: Argument "duration" must be a number or a string but found ${a}.`), f(s) || console.error('MUI: Argument "easing" must be a string.'), !h(u) && !f(u) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof o != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(l).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(l).join(",")}].`);
      }
      return (Array.isArray(i) ? i : [i]).map((f) => `${f} ${typeof a == "string" ? a : Zue(a)} ${s} ${typeof u == "string" ? u : Zue(u)}`).join(",");
    }
  }, e, {
    easing: t,
    duration: n
  });
}
const I9e = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
}, j9e = I9e, L9e = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function L0e(e = {}, ...t) {
  const {
    mixins: n = {},
    palette: r = {},
    transitions: i = {},
    typography: o = {}
  } = e, a = ln(e, L9e);
  if (e.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : Hx(18));
  const s = _9e(r), u = IX(e);
  let l = ip(u, {
    mixins: p9e(u.breakpoints, n),
    palette: s,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: A9e.slice(),
    typography: M9e(s, o),
    transitions: P9e(i),
    zIndex: ge({}, j9e)
  });
  if (l = ip(l, a), l = t.reduce((f, h) => ip(f, h), l), process.env.NODE_ENV !== "production") {
    const f = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], h = (p, g) => {
      let y;
      for (y in p) {
        const b = p[y];
        if (f.indexOf(y) !== -1 && Object.keys(b).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const _ = gi("", y);
            console.error([`MUI: The \`${g}\` component increases the CSS specificity of the \`${y}\` internal state.`, "You can not override it like this: ", JSON.stringify(p, null, 2), "", `Instead, you need to use the '&.${_}' syntax:`, JSON.stringify({
              root: {
                [`&.${_}`]: b
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          p[y] = {};
        }
      }
    };
    Object.keys(l.components).forEach((p) => {
      const g = l.components[p].styleOverrides;
      g && p.indexOf("Mui") === 0 && h(g, p);
    });
  }
  return l.unstable_sxConfig = ge({}, Wz, a == null ? void 0 : a.unstable_sxConfig), l.unstable_sx = function(h) {
    return qz({
      sx: h,
      theme: this
    });
  }, l;
}
const z9e = L0e(), Xz = z9e;
function _w() {
  const e = Gz(Xz);
  return process.env.NODE_ENV !== "production" && ae.useDebugValue(e), e[g$] || e;
}
function mi({
  props: e,
  name: t
}) {
  return f9e({
    props: e,
    name: t,
    defaultTheme: Xz,
    themeId: g$
  });
}
const yb = (e) => lR(e) && e !== "classes", F9e = lR, B9e = l9e({
  themeId: g$,
  defaultTheme: Xz,
  rootShouldForwardProp: yb
}), zt = B9e, U9e = (e) => {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, (t / 100).toFixed(2);
}, Jue = U9e;
function zX(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...r) {
    return e(...r) || t(...r);
  };
}
function Y9e(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function z0e(e, t, n, r, i) {
  const o = e[t], a = i || t;
  if (o == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let s;
  const u = o.type;
  return typeof u == "function" && !Y9e(u) && (s = "Did you accidentally use a plain function component for an element instead?"), s !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element that can hold a ref. ${s} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const F0e = zX(N.element, z0e);
F0e.isRequired = zX(N.element.isRequired, z0e);
const B0e = F0e, H9e = "exact-prop: ​";
function U0e(e) {
  return process.env.NODE_ENV === "production" ? e : ge({}, e, {
    [H9e]: (t) => {
      const n = Object.keys(t).filter((r) => !e.hasOwnProperty(r));
      return n.length > 0 ? new Error(`The following props are not supported: ${n.map((r) => `\`${r}\``).join(", ")}. Please remove them.`) : null;
    }
  });
}
function Bj(e, t, n, r, i) {
  if (process.env.NODE_ENV === "production")
    return null;
  const o = e[t], a = i || t;
  return o == null ? null : o && o.nodeType !== 1 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an HTMLElement.`) : null;
}
const V9e = N.oneOfType([N.func, N.object]), W9e = V9e;
function ele(...e) {
  return e.reduce((t, n) => n == null ? t : function(...i) {
    t.apply(this, i), n.apply(this, i);
  }, () => {
  });
}
function q9e(e, t = 166) {
  let n;
  function r(...i) {
    const o = () => {
      e.apply(this, i);
    };
    clearTimeout(n), n = setTimeout(o, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function Iy(e) {
  return e && e.ownerDocument || document;
}
function ek(e) {
  return Iy(e).defaultView || window;
}
function lW(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
const G9e = typeof window < "u" ? ae.useLayoutEffect : ae.useEffect, qT = G9e;
function tle(e) {
  const t = ae.useRef(e);
  return qT(() => {
    t.current = e;
  }), ae.useCallback((...n) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, t.current)(...n)
  ), []);
}
function gS(...e) {
  return ae.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      lW(n, t);
    });
  }, e);
}
function Q9e(e) {
  const t = e.documentElement.clientWidth;
  return Math.abs(window.innerWidth - t);
}
function yi(e, t, n = void 0) {
  const r = {};
  return Object.keys(e).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (i) => {
      r[i] = e[i].reduce((o, a) => {
        if (a) {
          const s = t(a);
          s !== "" && o.push(s), n && n[a] && o.push(n[a]);
        }
        return o;
      }, []).join(" ");
    }
  ), r;
}
const nle = (e) => e, X9e = () => {
  let e = nle;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = nle;
    }
  };
}, K9e = X9e(), Y0e = K9e, Z9e = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  readOnly: "readOnly",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function FX(e, t, n = "Mui") {
  const r = Z9e[t];
  return r ? `${n}-${r}` : `${Y0e.generate(e)}-${t}`;
}
function H0e(e, t, n = "Mui") {
  const r = {};
  return t.forEach((i) => {
    r[i] = FX(e, i, n);
  }), r;
}
function J9e(e) {
  return gi("MuiSvgIcon", e);
}
fi("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const e7e = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], t7e = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, i = {
    root: ["root", t !== "inherit" && `color${Xn(t)}`, `fontSize${Xn(n)}`]
  };
  return yi(i, J9e, r);
}, n7e = zt("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${Xn(n.color)}`], t[`fontSize${Xn(n.fontSize)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n, r, i, o, a, s, u, l, f, h, p, g, y;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // e.g. heroicons uses fill="none" and stroke="currentColor"
    fill: t.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (n = e.transitions) == null || (r = n.create) == null ? void 0 : r.call(n, "fill", {
      duration: (i = e.transitions) == null || (i = i.duration) == null ? void 0 : i.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((o = e.typography) == null || (a = o.pxToRem) == null ? void 0 : a.call(o, 20)) || "1.25rem",
      medium: ((s = e.typography) == null || (u = s.pxToRem) == null ? void 0 : u.call(s, 24)) || "1.5rem",
      large: ((l = e.typography) == null || (f = l.pxToRem) == null ? void 0 : f.call(l, 35)) || "2.1875rem"
    }[t.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (h = (p = (e.vars || e).palette) == null || (p = p[t.color]) == null ? void 0 : p.main) != null ? h : {
      action: (g = (e.vars || e).palette) == null || (g = g.action) == null ? void 0 : g.active,
      disabled: (y = (e.vars || e).palette) == null || (y = y.action) == null ? void 0 : y.disabled,
      inherit: void 0
    }[t.color]
  };
}), BX = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: i,
    className: o,
    color: a = "inherit",
    component: s = "svg",
    fontSize: u = "medium",
    htmlColor: l,
    inheritViewBox: f = !1,
    titleAccess: h,
    viewBox: p = "0 0 24 24"
  } = r, g = ln(r, e7e), y = /* @__PURE__ */ ae.isValidElement(i) && i.type === "svg", b = ge({}, r, {
    color: a,
    component: s,
    fontSize: u,
    instanceFontSize: t.fontSize,
    inheritViewBox: f,
    viewBox: p,
    hasSvgAsChild: y
  }), _ = {};
  f || (_.viewBox = p);
  const S = t7e(b);
  return /* @__PURE__ */ pe.jsxs(n7e, ge({
    as: s,
    className: kn(S.root, o),
    focusable: "false",
    color: l,
    "aria-hidden": h ? void 0 : !0,
    role: h ? "img" : void 0,
    ref: n
  }, _, g, y && i.props, {
    ownerState: b,
    children: [y ? i.props.children : i, h ? /* @__PURE__ */ pe.jsx("title", {
      children: h
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" && (BX.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Node passed into the SVG element.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: N.oneOfType([N.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), N.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: N.oneOfType([N.oneOf(["inherit", "large", "medium", "small"]), N.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: N.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: N.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: N.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: N.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: N.string
});
BX.muiName = "SvgIcon";
const rle = BX;
function ZS(e, t) {
  function n(r, i) {
    return /* @__PURE__ */ pe.jsx(rle, ge({
      "data-testid": `${t}Icon`,
      ref: i
    }, r, {
      children: e
    }));
  }
  return process.env.NODE_ENV !== "production" && (n.displayName = `${t}Icon`), n.muiName = rle.muiName, /* @__PURE__ */ ae.memo(/* @__PURE__ */ ae.forwardRef(n));
}
const r7e = {
  configure: (e) => {
    process.env.NODE_ENV !== "production" && console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.", "", "You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead", "", "The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401", "", "The updated documentation: https://mui.com/guides/classname-generator/"].join(`
`)), Y0e.configure(e);
  }
}, i7e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize: Xn,
  createChainedFunction: yFe,
  createSvgIcon: ZS,
  debounce: s0e,
  deprecatedPropType: vFe,
  isMuiElement: bFe,
  ownerDocument: hS,
  ownerWindow: nW,
  requirePropFactory: u0e,
  setRef: l0e,
  unstable_ClassNameGenerator: r7e,
  unstable_useEnhancedEffect: p$,
  unstable_useId: Pj,
  unsupportedProp: _Fe,
  useControlled: Ij,
  useEventCallback: uT,
  useForkRef: jd,
  useIsFocusVisible: Oz
}, Symbol.toStringTag, { value: "Module" }));
function cW(e, t) {
  return cW = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, cW(e, t);
}
function V0e(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, cW(e, t);
}
const ile = {
  disabled: !1
};
var o7e = process.env.NODE_ENV !== "production" ? N.oneOfType([N.number, N.shape({
  enter: N.number,
  exit: N.number,
  appear: N.number
}).isRequired]) : null;
process.env.NODE_ENV !== "production" && N.oneOfType([N.string, N.shape({
  enter: N.string,
  exit: N.string,
  active: N.string
}), N.shape({
  enter: N.string,
  enterDone: N.string,
  enterActive: N.string,
  exit: N.string,
  exitDone: N.string,
  exitActive: N.string
})]);
const Uj = Oy.createContext(null);
var a7e = function(t) {
  return t.scrollTop;
}, EO = "unmounted", wE = "exited", _E = "entering", nT = "entered", fW = "exiting", vb = /* @__PURE__ */ function(e) {
  V0e(t, e);
  function t(r, i) {
    var o;
    o = e.call(this, r, i) || this;
    var a = i, s = a && !a.isMounting ? r.enter : r.appear, u;
    return o.appearStatus = null, r.in ? s ? (u = wE, o.appearStatus = _E) : u = nT : r.unmountOnExit || r.mountOnEnter ? u = EO : u = wE, o.state = {
      status: u
    }, o.nextCallback = null, o;
  }
  t.getDerivedStateFromProps = function(i, o) {
    var a = i.in;
    return a && o.status === EO ? {
      status: wE
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(i) {
    var o = null;
    if (i !== this.props) {
      var a = this.state.status;
      this.props.in ? a !== _E && a !== nT && (o = _E) : (a === _E || a === nT) && (o = fW);
    }
    this.updateStatus(!1, o);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var i = this.props.timeout, o, a, s;
    return o = a = s = i, i != null && typeof i != "number" && (o = i.exit, a = i.enter, s = i.appear !== void 0 ? i.appear : a), {
      exit: o,
      enter: a,
      appear: s
    };
  }, n.updateStatus = function(i, o) {
    if (i === void 0 && (i = !1), o !== null)
      if (this.cancelNextCallback(), o === _E) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var a = this.props.nodeRef ? this.props.nodeRef.current : vI.findDOMNode(this);
          a && a7e(a);
        }
        this.performEnter(i);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === wE && this.setState({
        status: EO
      });
  }, n.performEnter = function(i) {
    var o = this, a = this.props.enter, s = this.context ? this.context.isMounting : i, u = this.props.nodeRef ? [s] : [vI.findDOMNode(this), s], l = u[0], f = u[1], h = this.getTimeouts(), p = s ? h.appear : h.enter;
    if (!i && !a || ile.disabled) {
      this.safeSetState({
        status: nT
      }, function() {
        o.props.onEntered(l);
      });
      return;
    }
    this.props.onEnter(l, f), this.safeSetState({
      status: _E
    }, function() {
      o.props.onEntering(l, f), o.onTransitionEnd(p, function() {
        o.safeSetState({
          status: nT
        }, function() {
          o.props.onEntered(l, f);
        });
      });
    });
  }, n.performExit = function() {
    var i = this, o = this.props.exit, a = this.getTimeouts(), s = this.props.nodeRef ? void 0 : vI.findDOMNode(this);
    if (!o || ile.disabled) {
      this.safeSetState({
        status: wE
      }, function() {
        i.props.onExited(s);
      });
      return;
    }
    this.props.onExit(s), this.safeSetState({
      status: fW
    }, function() {
      i.props.onExiting(s), i.onTransitionEnd(a.exit, function() {
        i.safeSetState({
          status: wE
        }, function() {
          i.props.onExited(s);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(i, o) {
    o = this.setNextCallback(o), this.setState(i, o);
  }, n.setNextCallback = function(i) {
    var o = this, a = !0;
    return this.nextCallback = function(s) {
      a && (a = !1, o.nextCallback = null, i(s));
    }, this.nextCallback.cancel = function() {
      a = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(i, o) {
    this.setNextCallback(o);
    var a = this.props.nodeRef ? this.props.nodeRef.current : vI.findDOMNode(this), s = i == null && !this.props.addEndListener;
    if (!a || s) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var u = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], l = u[0], f = u[1];
      this.props.addEndListener(l, f);
    }
    i != null && setTimeout(this.nextCallback, i);
  }, n.render = function() {
    var i = this.state.status;
    if (i === EO)
      return null;
    var o = this.props, a = o.children;
    o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
    var s = ln(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ Oy.createElement(Uj.Provider, {
        value: null
      }, typeof a == "function" ? a(i, s) : Oy.cloneElement(Oy.Children.only(a), s))
    );
  }, t;
}(Oy.Component);
vb.contextType = Uj;
vb.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: N.shape({
    current: typeof Element > "u" ? N.any : function(e, t, n, r, i, o) {
      var a = e[t];
      return N.instanceOf(a && "ownerDocument" in a ? a.ownerDocument.defaultView.Element : Element)(e, t, n, r, i, o);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: N.oneOfType([N.func.isRequired, N.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: N.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: N.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: N.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: N.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: N.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: N.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function(t) {
    var n = o7e;
    t.addEndListener || (n = n.isRequired);
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      i[o - 1] = arguments[o];
    return n.apply(void 0, [t].concat(i));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: N.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: N.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: N.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: N.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: N.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: N.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: N.func
} : {};
function kM() {
}
vb.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: kM,
  onEntering: kM,
  onEntered: kM,
  onExit: kM,
  onExiting: kM,
  onExited: kM
};
vb.UNMOUNTED = EO;
vb.EXITED = wE;
vb.ENTERING = _E;
vb.ENTERED = nT;
vb.EXITING = fW;
const W0e = vb;
function s7e(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function UX(e, t) {
  var n = function(o) {
    return t && ae.isValidElement(o) ? t(o) : o;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && ae.Children.map(e, function(i) {
    return i;
  }).forEach(function(i) {
    r[i.key] = n(i);
  }), r;
}
function u7e(e, t) {
  e = e || {}, t = t || {};
  function n(f) {
    return f in t ? t[f] : e[f];
  }
  var r = /* @__PURE__ */ Object.create(null), i = [];
  for (var o in e)
    o in t ? i.length && (r[o] = i, i = []) : i.push(o);
  var a, s = {};
  for (var u in t) {
    if (r[u])
      for (a = 0; a < r[u].length; a++) {
        var l = r[u][a];
        s[r[u][a]] = n(l);
      }
    s[u] = n(u);
  }
  for (a = 0; a < i.length; a++)
    s[i[a]] = n(i[a]);
  return s;
}
function FE(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function l7e(e, t) {
  return UX(e.children, function(n) {
    return ae.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: FE(n, "appear", e),
      enter: FE(n, "enter", e),
      exit: FE(n, "exit", e)
    });
  });
}
function c7e(e, t, n) {
  var r = UX(e.children), i = u7e(t, r);
  return Object.keys(i).forEach(function(o) {
    var a = i[o];
    if (ae.isValidElement(a)) {
      var s = o in t, u = o in r, l = t[o], f = ae.isValidElement(l) && !l.props.in;
      u && (!s || f) ? i[o] = ae.cloneElement(a, {
        onExited: n.bind(null, a),
        in: !0,
        exit: FE(a, "exit", e),
        enter: FE(a, "enter", e)
      }) : !u && s && !f ? i[o] = ae.cloneElement(a, {
        in: !1
      }) : u && s && ae.isValidElement(l) && (i[o] = ae.cloneElement(a, {
        onExited: n.bind(null, a),
        in: l.props.in,
        exit: FE(a, "exit", e),
        enter: FE(a, "enter", e)
      }));
    }
  }), i;
}
var f7e = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, d7e = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, YX = /* @__PURE__ */ function(e) {
  V0e(t, e);
  function t(r, i) {
    var o;
    o = e.call(this, r, i) || this;
    var a = o.handleExited.bind(s7e(o));
    return o.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: a,
      firstRender: !0
    }, o;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(i, o) {
    var a = o.children, s = o.handleExited, u = o.firstRender;
    return {
      children: u ? l7e(i, s) : c7e(i, a, s),
      firstRender: !1
    };
  }, n.handleExited = function(i, o) {
    var a = UX(this.props.children);
    i.key in a || (i.props.onExited && i.props.onExited(o), this.mounted && this.setState(function(s) {
      var u = ge({}, s.children);
      return delete u[i.key], {
        children: u
      };
    }));
  }, n.render = function() {
    var i = this.props, o = i.component, a = i.childFactory, s = ln(i, ["component", "childFactory"]), u = this.state.contextValue, l = f7e(this.state.children).map(a);
    return delete s.appear, delete s.enter, delete s.exit, o === null ? /* @__PURE__ */ Oy.createElement(Uj.Provider, {
      value: u
    }, l) : /* @__PURE__ */ Oy.createElement(Uj.Provider, {
      value: u
    }, /* @__PURE__ */ Oy.createElement(o, s, l));
  }, t;
}(Oy.Component);
YX.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: N.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: N.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: N.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: N.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: N.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: N.func
} : {};
YX.defaultProps = d7e;
const h7e = YX, q0e = (e) => e.scrollTop;
function Yj(e, t) {
  var n, r;
  const {
    timeout: i,
    easing: o,
    style: a = {}
  } = e;
  return {
    duration: (n = a.transitionDuration) != null ? n : typeof i == "number" ? i : i[t.mode] || 0,
    easing: (r = a.transitionTimingFunction) != null ? r : typeof o == "object" ? o[t.mode] : o,
    delay: a.transitionDelay
  };
}
function p7e(e) {
  return gi("MuiPaper", e);
}
fi("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const g7e = ["className", "component", "elevation", "square", "variant"], m7e = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: i
  } = e, o = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return yi(o, p7e, i);
}, y7e = zt("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n;
  return ge({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow")
  }, !t.square && {
    borderRadius: e.shape.borderRadius
  }, t.variant === "outlined" && {
    border: `1px solid ${(e.vars || e).palette.divider}`
  }, t.variant === "elevation" && ge({
    boxShadow: (e.vars || e).shadows[t.elevation]
  }, !e.vars && e.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${bs("#fff", Jue(t.elevation))}, ${bs("#fff", Jue(t.elevation))})`
  }, e.vars && {
    backgroundImage: (n = e.vars.overlays) == null ? void 0 : n[t.elevation]
  }));
}), G0e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiPaper"
  }), {
    className: i,
    component: o = "div",
    elevation: a = 1,
    square: s = !1,
    variant: u = "elevation"
  } = r, l = ln(r, g7e), f = ge({}, r, {
    component: o,
    elevation: a,
    square: s,
    variant: u
  }), h = m7e(f);
  return process.env.NODE_ENV !== "production" && _w().shadows[a] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${a}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${a}]\` is defined.`].join(`
`)), /* @__PURE__ */ pe.jsx(y7e, ge({
    as: o,
    ownerState: f,
    className: kn(h.root, i),
    ref: n
  }, l));
});
process.env.NODE_ENV !== "production" && (G0e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: KS(sR, (e) => {
    const {
      elevation: t,
      variant: n
    } = e;
    return t > 0 && n === "outlined" ? new Error(`MUI: Combining \`elevation={${t}}\` with \`variant="${n}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: N.oneOfType([N.oneOf(["elevation", "outlined"]), N.string])
});
const v7e = G0e;
function Q0e(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: i,
    rippleY: o,
    rippleSize: a,
    in: s,
    onExited: u,
    timeout: l
  } = e, [f, h] = ae.useState(!1), p = kn(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), g = {
    width: a,
    height: a,
    top: -(a / 2) + o,
    left: -(a / 2) + i
  }, y = kn(n.child, f && n.childLeaving, r && n.childPulsate);
  return !s && !f && h(!0), ae.useEffect(() => {
    if (!s && u != null) {
      const b = setTimeout(u, l);
      return () => {
        clearTimeout(b);
      };
    }
  }, [u, s, l]), /* @__PURE__ */ pe.jsx("span", {
    className: p,
    style: g,
    children: /* @__PURE__ */ pe.jsx("span", {
      className: y
    })
  });
}
process.env.NODE_ENV !== "production" && (Q0e.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: N.object.isRequired,
  className: N.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: N.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: N.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: N.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: N.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: N.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: N.number,
  /**
   * exit delay
   */
  timeout: N.number.isRequired
});
const b7e = fi("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Xh = b7e, x7e = ["center", "classes", "className"];
let Kz = (e) => e, ole, ale, sle, ule;
const dW = 550, w7e = 80, _7e = kX(ole || (ole = Kz`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), E7e = kX(ale || (ale = Kz`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), S7e = kX(sle || (sle = Kz`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), M7e = zt("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), T7e = zt(Q0e, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(ule || (ule = Kz`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), Xh.rippleVisible, _7e, dW, ({
  theme: e
}) => e.transitions.easing.easeInOut, Xh.ripplePulsate, ({
  theme: e
}) => e.transitions.duration.shorter, Xh.child, Xh.childLeaving, E7e, dW, ({
  theme: e
}) => e.transitions.easing.easeInOut, Xh.childPulsate, S7e, ({
  theme: e
}) => e.transitions.easing.easeInOut), X0e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: i = !1,
    classes: o = {},
    className: a
  } = r, s = ln(r, x7e), [u, l] = ae.useState([]), f = ae.useRef(0), h = ae.useRef(null);
  ae.useEffect(() => {
    h.current && (h.current(), h.current = null);
  }, [u]);
  const p = ae.useRef(!1), g = ae.useRef(0), y = ae.useRef(null), b = ae.useRef(null);
  ae.useEffect(() => () => {
    g.current && clearTimeout(g.current);
  }, []);
  const _ = ae.useCallback((O) => {
    const {
      pulsate: R,
      rippleX: j,
      rippleY: $,
      rippleSize: z,
      cb: W
    } = O;
    l((Y) => [...Y, /* @__PURE__ */ pe.jsx(T7e, {
      classes: {
        ripple: kn(o.ripple, Xh.ripple),
        rippleVisible: kn(o.rippleVisible, Xh.rippleVisible),
        ripplePulsate: kn(o.ripplePulsate, Xh.ripplePulsate),
        child: kn(o.child, Xh.child),
        childLeaving: kn(o.childLeaving, Xh.childLeaving),
        childPulsate: kn(o.childPulsate, Xh.childPulsate)
      },
      timeout: dW,
      pulsate: R,
      rippleX: j,
      rippleY: $,
      rippleSize: z
    }, f.current)]), f.current += 1, h.current = W;
  }, [o]), S = ae.useCallback((O = {}, R = {}, j = () => {
  }) => {
    const {
      pulsate: $ = !1,
      center: z = i || R.pulsate,
      fakeElement: W = !1
      // For test purposes
    } = R;
    if ((O == null ? void 0 : O.type) === "mousedown" && p.current) {
      p.current = !1;
      return;
    }
    (O == null ? void 0 : O.type) === "touchstart" && (p.current = !0);
    const Y = W ? null : b.current, V = Y ? Y.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let ee, K, Q;
    if (z || O === void 0 || O.clientX === 0 && O.clientY === 0 || !O.clientX && !O.touches)
      ee = Math.round(V.width / 2), K = Math.round(V.height / 2);
    else {
      const {
        clientX: q,
        clientY: te
      } = O.touches && O.touches.length > 0 ? O.touches[0] : O;
      ee = Math.round(q - V.left), K = Math.round(te - V.top);
    }
    if (z)
      Q = Math.sqrt((2 * V.width ** 2 + V.height ** 2) / 3), Q % 2 === 0 && (Q += 1);
    else {
      const q = Math.max(Math.abs((Y ? Y.clientWidth : 0) - ee), ee) * 2 + 2, te = Math.max(Math.abs((Y ? Y.clientHeight : 0) - K), K) * 2 + 2;
      Q = Math.sqrt(q ** 2 + te ** 2);
    }
    O != null && O.touches ? y.current === null && (y.current = () => {
      _({
        pulsate: $,
        rippleX: ee,
        rippleY: K,
        rippleSize: Q,
        cb: j
      });
    }, g.current = setTimeout(() => {
      y.current && (y.current(), y.current = null);
    }, w7e)) : _({
      pulsate: $,
      rippleX: ee,
      rippleY: K,
      rippleSize: Q,
      cb: j
    });
  }, [i, _]), C = ae.useCallback(() => {
    S({}, {
      pulsate: !0
    });
  }, [S]), A = ae.useCallback((O, R) => {
    if (clearTimeout(g.current), (O == null ? void 0 : O.type) === "touchend" && y.current) {
      y.current(), y.current = null, g.current = setTimeout(() => {
        A(O, R);
      });
      return;
    }
    y.current = null, l((j) => j.length > 0 ? j.slice(1) : j), h.current = R;
  }, []);
  return ae.useImperativeHandle(n, () => ({
    pulsate: C,
    start: S,
    stop: A
  }), [C, S, A]), /* @__PURE__ */ pe.jsx(M7e, ge({
    className: kn(Xh.root, o.root, a),
    ref: b
  }, s, {
    children: /* @__PURE__ */ pe.jsx(h7e, {
      component: null,
      exit: !0,
      children: u
    })
  }));
});
process.env.NODE_ENV !== "production" && (X0e.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: N.bool,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string
});
const C7e = X0e;
function N7e(e) {
  return gi("MuiButtonBase", e);
}
const D7e = fi("MuiButtonBase", ["root", "disabled", "focusVisible"]), A7e = D7e, O7e = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], R7e = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: i
  } = e, a = yi({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, N7e, i);
  return n && r && (a.root += ` ${r}`), a;
}, k7e = zt("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${A7e.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), K0e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: i,
    centerRipple: o = !1,
    children: a,
    className: s,
    component: u = "button",
    disabled: l = !1,
    disableRipple: f = !1,
    disableTouchRipple: h = !1,
    focusRipple: p = !1,
    LinkComponent: g = "a",
    onBlur: y,
    onClick: b,
    onContextMenu: _,
    onDragLeave: S,
    onFocus: C,
    onFocusVisible: A,
    onKeyDown: O,
    onKeyUp: R,
    onMouseDown: j,
    onMouseLeave: $,
    onMouseUp: z,
    onTouchEnd: W,
    onTouchMove: Y,
    onTouchStart: V,
    tabIndex: ee = 0,
    TouchRippleProps: K,
    touchRippleRef: Q,
    type: q
  } = r, te = ln(r, O7e), X = ae.useRef(null), Z = ae.useRef(null), se = jd(Z, Q), {
    isFocusVisibleRef: H,
    onFocus: ie,
    onBlur: he,
    ref: ye
  } = Oz(), [_e, Ne] = ae.useState(!1);
  l && _e && Ne(!1), ae.useImperativeHandle(i, () => ({
    focusVisible: () => {
      Ne(!0), X.current.focus();
    }
  }), []);
  const [Oe, ke] = ae.useState(!1);
  ae.useEffect(() => {
    ke(!0);
  }, []);
  const Me = Oe && !f && !l;
  ae.useEffect(() => {
    _e && p && !f && Oe && Z.current.pulsate();
  }, [f, p, _e, Oe]);
  function we(Ut, er, We = h) {
    return uT((ht) => (er && er(ht), !We && Z.current && Z.current[Ut](ht), !0));
  }
  const Ye = we("start", j), ze = we("stop", _), fe = we("stop", S), Qe = we("stop", z), $e = we("stop", (Ut) => {
    _e && Ut.preventDefault(), $ && $(Ut);
  }), pt = we("start", V), _t = we("stop", W), Ot = we("stop", Y), mn = we("stop", (Ut) => {
    he(Ut), H.current === !1 && Ne(!1), y && y(Ut);
  }, !1), jr = uT((Ut) => {
    X.current || (X.current = Ut.currentTarget), ie(Ut), H.current === !0 && (Ne(!0), A && A(Ut)), C && C(Ut);
  }), tn = () => {
    const Ut = X.current;
    return u && u !== "button" && !(Ut.tagName === "A" && Ut.href);
  }, Zt = ae.useRef(!1), qn = uT((Ut) => {
    p && !Zt.current && _e && Z.current && Ut.key === " " && (Zt.current = !0, Z.current.stop(Ut, () => {
      Z.current.start(Ut);
    })), Ut.target === Ut.currentTarget && tn() && Ut.key === " " && Ut.preventDefault(), O && O(Ut), Ut.target === Ut.currentTarget && tn() && Ut.key === "Enter" && !l && (Ut.preventDefault(), b && b(Ut));
  }), fn = uT((Ut) => {
    p && Ut.key === " " && Z.current && _e && !Ut.defaultPrevented && (Zt.current = !1, Z.current.stop(Ut, () => {
      Z.current.pulsate(Ut);
    })), R && R(Ut), b && Ut.target === Ut.currentTarget && tn() && Ut.key === " " && !Ut.defaultPrevented && b(Ut);
  });
  let gr = u;
  gr === "button" && (te.href || te.to) && (gr = g);
  const Zn = {};
  gr === "button" ? (Zn.type = q === void 0 ? "button" : q, Zn.disabled = l) : (!te.href && !te.to && (Zn.role = "button"), l && (Zn["aria-disabled"] = l));
  const xr = jd(n, ye, X);
  process.env.NODE_ENV !== "production" && ae.useEffect(() => {
    Me && !Z.current && console.error(["MUI: The `component` prop provided to ButtonBase is invalid.", "Please make sure the children prop is rendered in this custom component."].join(`
`));
  }, [Me]);
  const Un = ge({}, r, {
    centerRipple: o,
    component: u,
    disabled: l,
    disableRipple: f,
    disableTouchRipple: h,
    focusRipple: p,
    tabIndex: ee,
    focusVisible: _e
  }), Qt = R7e(Un);
  return /* @__PURE__ */ pe.jsxs(k7e, ge({
    as: gr,
    className: kn(Qt.root, s),
    ownerState: Un,
    onBlur: mn,
    onClick: b,
    onContextMenu: ze,
    onFocus: jr,
    onKeyDown: qn,
    onKeyUp: fn,
    onMouseDown: Ye,
    onMouseLeave: $e,
    onMouseUp: Qe,
    onDragLeave: fe,
    onTouchEnd: _t,
    onTouchMove: Ot,
    onTouchStart: pt,
    ref: xr,
    tabIndex: l ? -1 : ee,
    type: q
  }, Zn, te, {
    children: [a, Me ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ pe.jsx(C7e, ge({
        ref: se,
        center: o
      }, K))
    ) : null]
  }));
});
process.env.NODE_ENV !== "production" && (K0e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: mb,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: N.bool,
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: Dz,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: N.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: N.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: N.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: N.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: N.string,
  /**
   * @ignore
   */
  href: N.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: N.elementType,
  /**
   * @ignore
   */
  onBlur: N.func,
  /**
   * @ignore
   */
  onClick: N.func,
  /**
   * @ignore
   */
  onContextMenu: N.func,
  /**
   * @ignore
   */
  onDragLeave: N.func,
  /**
   * @ignore
   */
  onFocus: N.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: N.func,
  /**
   * @ignore
   */
  onKeyDown: N.func,
  /**
   * @ignore
   */
  onKeyUp: N.func,
  /**
   * @ignore
   */
  onMouseDown: N.func,
  /**
   * @ignore
   */
  onMouseLeave: N.func,
  /**
   * @ignore
   */
  onMouseUp: N.func,
  /**
   * @ignore
   */
  onTouchEnd: N.func,
  /**
   * @ignore
   */
  onTouchMove: N.func,
  /**
   * @ignore
   */
  onTouchStart: N.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * @default 0
   */
  tabIndex: N.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: N.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: N.oneOfType([N.func, N.shape({
    current: N.shape({
      pulsate: N.func.isRequired,
      start: N.func.isRequired,
      stop: N.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: N.oneOfType([N.oneOf(["button", "reset", "submit"]), N.string])
});
const Zz = K0e;
function $7e(e) {
  return gi("MuiIconButton", e);
}
const P7e = fi("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), I7e = P7e, j7e = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"], L7e = (e) => {
  const {
    classes: t,
    disabled: n,
    color: r,
    edge: i,
    size: o
  } = e, a = {
    root: ["root", n && "disabled", r !== "default" && `color${Xn(r)}`, i && `edge${Xn(i)}`, `size${Xn(o)}`]
  };
  return yi(a, $7e, t);
}, z7e = zt(Zz, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "default" && t[`color${Xn(n.color)}`], n.edge && t[`edge${Xn(n.edge)}`], t[`size${Xn(n.size)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  })
}, !t.disableRipple && {
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : bs(e.palette.action.active, e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, t.edge === "start" && {
  marginLeft: t.size === "small" ? -3 : -12
}, t.edge === "end" && {
  marginRight: t.size === "small" ? -3 : -12
}), ({
  theme: e,
  ownerState: t
}) => {
  var n;
  const r = (n = (e.vars || e).palette) == null ? void 0 : n[t.color];
  return ge({}, t.color === "inherit" && {
    color: "inherit"
  }, t.color !== "inherit" && t.color !== "default" && ge({
    color: r == null ? void 0 : r.main
  }, !t.disableRipple && {
    "&:hover": ge({}, r && {
      backgroundColor: e.vars ? `rgba(${r.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : bs(r.main, e.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), t.size === "small" && {
    padding: 5,
    fontSize: e.typography.pxToRem(18)
  }, t.size === "large" && {
    padding: 12,
    fontSize: e.typography.pxToRem(28)
  }, {
    [`&.${I7e.disabled}`]: {
      backgroundColor: "transparent",
      color: (e.vars || e).palette.action.disabled
    }
  });
}), Z0e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiIconButton"
  }), {
    edge: i = !1,
    children: o,
    className: a,
    color: s = "default",
    disabled: u = !1,
    disableFocusRipple: l = !1,
    size: f = "medium"
  } = r, h = ln(r, j7e), p = ge({}, r, {
    edge: i,
    color: s,
    disabled: u,
    disableFocusRipple: l,
    size: f
  }), g = L7e(p);
  return /* @__PURE__ */ pe.jsx(z7e, ge({
    className: kn(g.root, a),
    centerRipple: !0,
    focusRipple: !l,
    disabled: u,
    ref: n,
    ownerState: p
  }, h, {
    children: o
  }));
});
process.env.NODE_ENV !== "production" && (Z0e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The icon to display.
   */
  children: KS(N.node, (e) => ae.Children.toArray(e.children).some((n) => /* @__PURE__ */ ae.isValidElement(n) && n.props.onClick) ? new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join(`
`)) : null),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'default'
   */
  color: N.oneOfType([N.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), N.string]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: N.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: N.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: N.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: N.oneOf(["end", "start", !1]),
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: N.oneOfType([N.oneOf(["small", "medium", "large"]), N.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const TI = Z0e;
function F7e(e) {
  return gi("MuiTypography", e);
}
fi("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const B7e = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"], U7e = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: r,
    paragraph: i,
    variant: o,
    classes: a
  } = e, s = {
    root: ["root", o, e.align !== "inherit" && `align${Xn(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
  };
  return yi(s, F7e, a);
}, Y7e = zt("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${Xn(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  margin: 0
}, t.variant === "inherit" && {
  // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
  font: "inherit"
}, t.variant !== "inherit" && e.typography[t.variant], t.align !== "inherit" && {
  textAlign: t.align
}, t.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, t.gutterBottom && {
  marginBottom: "0.35em"
}, t.paragraph && {
  marginBottom: 16
})), lle = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, H7e = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
}, V7e = (e) => H7e[e] || e, J0e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTypography"
  }), i = V7e(r.color), o = jX(ge({}, r, {
    color: i
  })), {
    align: a = "inherit",
    className: s,
    component: u,
    gutterBottom: l = !1,
    noWrap: f = !1,
    paragraph: h = !1,
    variant: p = "body1",
    variantMapping: g = lle
  } = o, y = ln(o, B7e), b = ge({}, o, {
    align: a,
    color: i,
    className: s,
    component: u,
    gutterBottom: l,
    noWrap: f,
    paragraph: h,
    variant: p,
    variantMapping: g
  }), _ = u || (h ? "p" : g[p] || lle[p]) || "span", S = U7e(b);
  return /* @__PURE__ */ pe.jsx(Y7e, ge({
    as: _,
    ref: n,
    ownerState: b,
    className: kn(S.root, s)
  }, y));
});
process.env.NODE_ENV !== "production" && (J0e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: N.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: N.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: N.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   */
  paragraph: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: N.oneOfType([N.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), N.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: N.object
});
const ebe = J0e;
function GT(e) {
  return typeof e == "string";
}
function SO(e, t, n) {
  return e === void 0 || GT(e) ? t : ge({}, t, {
    ownerState: ge({}, t.ownerState, n)
  });
}
const W7e = {
  disableDefaultClasses: !1
}, q7e = /* @__PURE__ */ ae.createContext(W7e);
function tbe(e) {
  const {
    disableDefaultClasses: t
  } = ae.useContext(q7e);
  return (n) => t ? "" : e(n);
}
function nbe(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function hW(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function rbe(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = rbe(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function cle() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = rbe(e)) && (r && (r += " "), r += t);
  return r;
}
function fle(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function G7e(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: o
  } = e;
  if (!t) {
    const g = cle(i == null ? void 0 : i.className, r == null ? void 0 : r.className, o, n == null ? void 0 : n.className), y = ge({}, n == null ? void 0 : n.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style), b = ge({}, n, i, r);
    return g.length > 0 && (b.className = g), Object.keys(y).length > 0 && (b.style = y), {
      props: b,
      internalRef: void 0
    };
  }
  const a = nbe(ge({}, i, r)), s = fle(r), u = fle(i), l = t(a), f = cle(l == null ? void 0 : l.className, n == null ? void 0 : n.className, o, i == null ? void 0 : i.className, r == null ? void 0 : r.className), h = ge({}, l == null ? void 0 : l.style, n == null ? void 0 : n.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style), p = ge({}, l, n, u, s);
  return f.length > 0 && (p.className = f), Object.keys(h).length > 0 && (p.style = h), {
    props: p,
    internalRef: l.ref
  };
}
const Q7e = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function mS(e) {
  var t;
  const {
    elementType: n,
    externalSlotProps: r,
    ownerState: i,
    skipResolvingSlotProps: o = !1
  } = e, a = ln(e, Q7e), s = o ? {} : hW(r, i), {
    props: u,
    internalRef: l
  } = G7e(ge({}, a, {
    externalSlotProps: s
  })), f = gS(l, s == null ? void 0 : s.ref, (t = e.additionalProps) == null ? void 0 : t.ref);
  return SO(n, ge({}, u, {
    ref: f
  }), i);
}
const X7e = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function K7e(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function Z7e(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function J7e(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || Z7e(e));
}
function eBe(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(X7e)).forEach((r, i) => {
    const o = K7e(r);
    o === -1 || !J7e(r) || (o === 0 ? t.push(r) : n.push({
      documentOrder: i,
      tabIndex: o,
      node: r
    }));
  }), n.sort((r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map((r) => r.node).concat(t);
}
function tBe() {
  return !0;
}
function Hj(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: i = !1,
    getTabbable: o = eBe,
    isEnabled: a = tBe,
    open: s
  } = e, u = ae.useRef(!1), l = ae.useRef(null), f = ae.useRef(null), h = ae.useRef(null), p = ae.useRef(null), g = ae.useRef(!1), y = ae.useRef(null), b = gS(t.ref, y), _ = ae.useRef(null);
  ae.useEffect(() => {
    !s || !y.current || (g.current = !n);
  }, [n, s]), ae.useEffect(() => {
    if (!s || !y.current)
      return;
    const A = Iy(y.current);
    return y.current.contains(A.activeElement) || (y.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), y.current.setAttribute("tabIndex", "-1")), g.current && y.current.focus()), () => {
      i || (h.current && h.current.focus && (u.current = !0, h.current.focus()), h.current = null);
    };
  }, [s]), ae.useEffect(() => {
    if (!s || !y.current)
      return;
    const A = Iy(y.current), O = ($) => {
      const {
        current: z
      } = y;
      if (z !== null) {
        if (!A.hasFocus() || r || !a() || u.current) {
          u.current = !1;
          return;
        }
        if (!z.contains(A.activeElement)) {
          if ($ && p.current !== $.target || A.activeElement !== p.current)
            p.current = null;
          else if (p.current !== null)
            return;
          if (!g.current)
            return;
          let V = [];
          if ((A.activeElement === l.current || A.activeElement === f.current) && (V = o(y.current)), V.length > 0) {
            var W, Y;
            const ee = !!((W = _.current) != null && W.shiftKey && ((Y = _.current) == null ? void 0 : Y.key) === "Tab"), K = V[0], Q = V[V.length - 1];
            typeof K != "string" && typeof Q != "string" && (ee ? Q.focus() : K.focus());
          } else
            z.focus();
        }
      }
    }, R = ($) => {
      _.current = $, !(r || !a() || $.key !== "Tab") && A.activeElement === y.current && $.shiftKey && (u.current = !0, f.current && f.current.focus());
    };
    A.addEventListener("focusin", O), A.addEventListener("keydown", R, !0);
    const j = setInterval(() => {
      A.activeElement && A.activeElement.tagName === "BODY" && O(null);
    }, 50);
    return () => {
      clearInterval(j), A.removeEventListener("focusin", O), A.removeEventListener("keydown", R, !0);
    };
  }, [n, r, i, a, s, o]);
  const S = (A) => {
    h.current === null && (h.current = A.relatedTarget), g.current = !0, p.current = A.target;
    const O = t.props.onFocus;
    O && O(A);
  }, C = (A) => {
    h.current === null && (h.current = A.relatedTarget), g.current = !0;
  };
  return /* @__PURE__ */ pe.jsxs(ae.Fragment, {
    children: [/* @__PURE__ */ pe.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: C,
      ref: l,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ ae.cloneElement(t, {
      ref: b,
      onFocus: S
    }), /* @__PURE__ */ pe.jsx("div", {
      tabIndex: s ? 0 : -1,
      onFocus: C,
      ref: f,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (Hj.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: B0e,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: N.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: N.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: N.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: N.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: N.func,
  /**
   * If `true`, focus is locked.
   */
  open: N.bool.isRequired
});
process.env.NODE_ENV !== "production" && (Hj["propTypes"] = U0e(Hj.propTypes));
var wf = "top", lp = "bottom", cp = "right", _f = "left", HX = "auto", b$ = [wf, lp, cp, _f], QT = "start", tk = "end", nBe = "clippingParents", ibe = "viewport", NA = "popper", rBe = "reference", dle = /* @__PURE__ */ b$.reduce(function(e, t) {
  return e.concat([t + "-" + QT, t + "-" + tk]);
}, []), obe = /* @__PURE__ */ [].concat(b$, [HX]).reduce(function(e, t) {
  return e.concat([t, t + "-" + QT, t + "-" + tk]);
}, []), iBe = "beforeRead", oBe = "read", aBe = "afterRead", sBe = "beforeMain", uBe = "main", lBe = "afterMain", cBe = "beforeWrite", fBe = "write", dBe = "afterWrite", hBe = [iBe, oBe, aBe, sBe, uBe, lBe, cBe, fBe, dBe];
function Vy(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Ld(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function yS(e) {
  var t = Ld(e).Element;
  return e instanceof t || e instanceof Element;
}
function op(e) {
  var t = Ld(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function VX(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Ld(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function pBe(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, o = t.elements[n];
    !op(o) || !Vy(o) || (Object.assign(o.style, r), Object.keys(i).forEach(function(a) {
      var s = i[a];
      s === !1 ? o.removeAttribute(a) : o.setAttribute(a, s === !0 ? "" : s);
    }));
  });
}
function gBe(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], o = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), s = a.reduce(function(u, l) {
        return u[l] = "", u;
      }, {});
      !op(i) || !Vy(i) || (Object.assign(i.style, s), Object.keys(o).forEach(function(u) {
        i.removeAttribute(u);
      }));
    });
  };
}
const mBe = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: pBe,
  effect: gBe,
  requires: ["computeStyles"]
};
function jy(e) {
  return e.split("-")[0];
}
var GE = Math.max, Vj = Math.min, XT = Math.round;
function pW() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function abe() {
  return !/^((?!chrome|android).)*safari/i.test(pW());
}
function KT(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, o = 1;
  t && op(e) && (i = e.offsetWidth > 0 && XT(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && XT(r.height) / e.offsetHeight || 1);
  var a = yS(e) ? Ld(e) : window, s = a.visualViewport, u = !abe() && n, l = (r.left + (u && s ? s.offsetLeft : 0)) / i, f = (r.top + (u && s ? s.offsetTop : 0)) / o, h = r.width / i, p = r.height / o;
  return {
    width: h,
    height: p,
    top: f,
    right: l + h,
    bottom: f + p,
    left: l,
    x: l,
    y: f
  };
}
function WX(e) {
  var t = KT(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function sbe(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && VX(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function ob(e) {
  return Ld(e).getComputedStyle(e);
}
function yBe(e) {
  return ["table", "td", "th"].indexOf(Vy(e)) >= 0;
}
function Ew(e) {
  return ((yS(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function Jz(e) {
  return Vy(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (VX(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Ew(e)
  );
}
function hle(e) {
  return !op(e) || // https://github.com/popperjs/popper-core/issues/837
  ob(e).position === "fixed" ? null : e.offsetParent;
}
function vBe(e) {
  var t = /firefox/i.test(pW()), n = /Trident/i.test(pW());
  if (n && op(e)) {
    var r = ob(e);
    if (r.position === "fixed")
      return null;
  }
  var i = Jz(e);
  for (VX(i) && (i = i.host); op(i) && ["html", "body"].indexOf(Vy(i)) < 0; ) {
    var o = ob(i);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function x$(e) {
  for (var t = Ld(e), n = hle(e); n && yBe(n) && ob(n).position === "static"; )
    n = hle(n);
  return n && (Vy(n) === "html" || Vy(n) === "body" && ob(n).position === "static") ? t : n || vBe(e) || t;
}
function qX(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function cR(e, t, n) {
  return GE(e, Vj(t, n));
}
function bBe(e, t, n) {
  var r = cR(e, t, n);
  return r > n ? n : r;
}
function ube() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function lbe(e) {
  return Object.assign({}, ube(), e);
}
function cbe(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var xBe = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, lbe(typeof t != "number" ? t : cbe(t, b$));
};
function wBe(e) {
  var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, s = jy(n.placement), u = qX(s), l = [_f, cp].indexOf(s) >= 0, f = l ? "height" : "width";
  if (!(!o || !a)) {
    var h = xBe(i.padding, n), p = WX(o), g = u === "y" ? wf : _f, y = u === "y" ? lp : cp, b = n.rects.reference[f] + n.rects.reference[u] - a[u] - n.rects.popper[f], _ = a[u] - n.rects.reference[u], S = x$(o), C = S ? u === "y" ? S.clientHeight || 0 : S.clientWidth || 0 : 0, A = b / 2 - _ / 2, O = h[g], R = C - p[f] - h[y], j = C / 2 - p[f] / 2 + A, $ = cR(O, j, R), z = u;
    n.modifiersData[r] = (t = {}, t[z] = $, t.centerOffset = $ - j, t);
  }
}
function _Be(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || sbe(t.elements.popper, i) && (t.elements.arrow = i));
}
const EBe = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: wBe,
  effect: _Be,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function ZT(e) {
  return e.split("-")[1];
}
var SBe = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function MBe(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: XT(n * i) / i || 0,
    y: XT(r * i) / i || 0
  };
}
function ple(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, a = e.offsets, s = e.position, u = e.gpuAcceleration, l = e.adaptive, f = e.roundOffsets, h = e.isFixed, p = a.x, g = p === void 0 ? 0 : p, y = a.y, b = y === void 0 ? 0 : y, _ = typeof f == "function" ? f({
    x: g,
    y: b
  }) : {
    x: g,
    y: b
  };
  g = _.x, b = _.y;
  var S = a.hasOwnProperty("x"), C = a.hasOwnProperty("y"), A = _f, O = wf, R = window;
  if (l) {
    var j = x$(n), $ = "clientHeight", z = "clientWidth";
    if (j === Ld(n) && (j = Ew(n), ob(j).position !== "static" && s === "absolute" && ($ = "scrollHeight", z = "scrollWidth")), j = j, i === wf || (i === _f || i === cp) && o === tk) {
      O = lp;
      var W = h && j === R && R.visualViewport ? R.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        j[$]
      );
      b -= W - r.height, b *= u ? 1 : -1;
    }
    if (i === _f || (i === wf || i === lp) && o === tk) {
      A = cp;
      var Y = h && j === R && R.visualViewport ? R.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        j[z]
      );
      g -= Y - r.width, g *= u ? 1 : -1;
    }
  }
  var V = Object.assign({
    position: s
  }, l && SBe), ee = f === !0 ? MBe({
    x: g,
    y: b
  }, Ld(n)) : {
    x: g,
    y: b
  };
  if (g = ee.x, b = ee.y, u) {
    var K;
    return Object.assign({}, V, (K = {}, K[O] = C ? "0" : "", K[A] = S ? "0" : "", K.transform = (R.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", K));
  }
  return Object.assign({}, V, (t = {}, t[O] = C ? b + "px" : "", t[A] = S ? g + "px" : "", t.transform = "", t));
}
function TBe(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, o = n.adaptive, a = o === void 0 ? !0 : o, s = n.roundOffsets, u = s === void 0 ? !0 : s, l = {
    placement: jy(t.placement),
    variation: ZT(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, ple(Object.assign({}, l, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: a,
    roundOffsets: u
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, ple(Object.assign({}, l, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const CBe = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: TBe,
  data: {}
};
var CI = {
  passive: !0
};
function NBe(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = i === void 0 ? !0 : i, a = r.resize, s = a === void 0 ? !0 : a, u = Ld(t.elements.popper), l = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && l.forEach(function(f) {
    f.addEventListener("scroll", n.update, CI);
  }), s && u.addEventListener("resize", n.update, CI), function() {
    o && l.forEach(function(f) {
      f.removeEventListener("scroll", n.update, CI);
    }), s && u.removeEventListener("resize", n.update, CI);
  };
}
const DBe = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: NBe,
  data: {}
};
var ABe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function X3(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return ABe[t];
  });
}
var OBe = {
  start: "end",
  end: "start"
};
function gle(e) {
  return e.replace(/start|end/g, function(t) {
    return OBe[t];
  });
}
function GX(e) {
  var t = Ld(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function QX(e) {
  return KT(Ew(e)).left + GX(e).scrollLeft;
}
function RBe(e, t) {
  var n = Ld(e), r = Ew(e), i = n.visualViewport, o = r.clientWidth, a = r.clientHeight, s = 0, u = 0;
  if (i) {
    o = i.width, a = i.height;
    var l = abe();
    (l || !l && t === "fixed") && (s = i.offsetLeft, u = i.offsetTop);
  }
  return {
    width: o,
    height: a,
    x: s + QX(e),
    y: u
  };
}
function kBe(e) {
  var t, n = Ew(e), r = GX(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, o = GE(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = GE(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + QX(e), u = -r.scrollTop;
  return ob(i || n).direction === "rtl" && (s += GE(n.clientWidth, i ? i.clientWidth : 0) - o), {
    width: o,
    height: a,
    x: s,
    y: u
  };
}
function XX(e) {
  var t = ob(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function fbe(e) {
  return ["html", "body", "#document"].indexOf(Vy(e)) >= 0 ? e.ownerDocument.body : op(e) && XX(e) ? e : fbe(Jz(e));
}
function fR(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = fbe(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Ld(r), a = i ? [o].concat(o.visualViewport || [], XX(r) ? r : []) : r, s = t.concat(a);
  return i ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(fR(Jz(a)))
  );
}
function gW(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function $Be(e, t) {
  var n = KT(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function mle(e, t, n) {
  return t === ibe ? gW(RBe(e, n)) : yS(t) ? $Be(t, n) : gW(kBe(Ew(e)));
}
function PBe(e) {
  var t = fR(Jz(e)), n = ["absolute", "fixed"].indexOf(ob(e).position) >= 0, r = n && op(e) ? x$(e) : e;
  return yS(r) ? t.filter(function(i) {
    return yS(i) && sbe(i, r) && Vy(i) !== "body";
  }) : [];
}
function IBe(e, t, n, r) {
  var i = t === "clippingParents" ? PBe(e) : [].concat(t), o = [].concat(i, [n]), a = o[0], s = o.reduce(function(u, l) {
    var f = mle(e, l, r);
    return u.top = GE(f.top, u.top), u.right = Vj(f.right, u.right), u.bottom = Vj(f.bottom, u.bottom), u.left = GE(f.left, u.left), u;
  }, mle(e, a, r));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function dbe(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? jy(r) : null, o = r ? ZT(r) : null, a = t.x + t.width / 2 - n.width / 2, s = t.y + t.height / 2 - n.height / 2, u;
  switch (i) {
    case wf:
      u = {
        x: a,
        y: t.y - n.height
      };
      break;
    case lp:
      u = {
        x: a,
        y: t.y + t.height
      };
      break;
    case cp:
      u = {
        x: t.x + t.width,
        y: s
      };
      break;
    case _f:
      u = {
        x: t.x - n.width,
        y: s
      };
      break;
    default:
      u = {
        x: t.x,
        y: t.y
      };
  }
  var l = i ? qX(i) : null;
  if (l != null) {
    var f = l === "y" ? "height" : "width";
    switch (o) {
      case QT:
        u[l] = u[l] - (t[f] / 2 - n[f] / 2);
        break;
      case tk:
        u[l] = u[l] + (t[f] / 2 - n[f] / 2);
        break;
    }
  }
  return u;
}
function nk(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, o = n.strategy, a = o === void 0 ? e.strategy : o, s = n.boundary, u = s === void 0 ? nBe : s, l = n.rootBoundary, f = l === void 0 ? ibe : l, h = n.elementContext, p = h === void 0 ? NA : h, g = n.altBoundary, y = g === void 0 ? !1 : g, b = n.padding, _ = b === void 0 ? 0 : b, S = lbe(typeof _ != "number" ? _ : cbe(_, b$)), C = p === NA ? rBe : NA, A = e.rects.popper, O = e.elements[y ? C : p], R = IBe(yS(O) ? O : O.contextElement || Ew(e.elements.popper), u, f, a), j = KT(e.elements.reference), $ = dbe({
    reference: j,
    element: A,
    strategy: "absolute",
    placement: i
  }), z = gW(Object.assign({}, A, $)), W = p === NA ? z : j, Y = {
    top: R.top - W.top + S.top,
    bottom: W.bottom - R.bottom + S.bottom,
    left: R.left - W.left + S.left,
    right: W.right - R.right + S.right
  }, V = e.modifiersData.offset;
  if (p === NA && V) {
    var ee = V[i];
    Object.keys(Y).forEach(function(K) {
      var Q = [cp, lp].indexOf(K) >= 0 ? 1 : -1, q = [wf, lp].indexOf(K) >= 0 ? "y" : "x";
      Y[K] += ee[q] * Q;
    });
  }
  return Y;
}
function jBe(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, a = n.padding, s = n.flipVariations, u = n.allowedAutoPlacements, l = u === void 0 ? obe : u, f = ZT(r), h = f ? s ? dle : dle.filter(function(y) {
    return ZT(y) === f;
  }) : b$, p = h.filter(function(y) {
    return l.indexOf(y) >= 0;
  });
  p.length === 0 && (p = h);
  var g = p.reduce(function(y, b) {
    return y[b] = nk(e, {
      placement: b,
      boundary: i,
      rootBoundary: o,
      padding: a
    })[jy(b)], y;
  }, {});
  return Object.keys(g).sort(function(y, b) {
    return g[y] - g[b];
  });
}
function LBe(e) {
  if (jy(e) === HX)
    return [];
  var t = X3(e);
  return [gle(e), t, gle(t)];
}
function zBe(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !0 : a, u = n.fallbackPlacements, l = n.padding, f = n.boundary, h = n.rootBoundary, p = n.altBoundary, g = n.flipVariations, y = g === void 0 ? !0 : g, b = n.allowedAutoPlacements, _ = t.options.placement, S = jy(_), C = S === _, A = u || (C || !y ? [X3(_)] : LBe(_)), O = [_].concat(A).reduce(function(_e, Ne) {
      return _e.concat(jy(Ne) === HX ? jBe(t, {
        placement: Ne,
        boundary: f,
        rootBoundary: h,
        padding: l,
        flipVariations: y,
        allowedAutoPlacements: b
      }) : Ne);
    }, []), R = t.rects.reference, j = t.rects.popper, $ = /* @__PURE__ */ new Map(), z = !0, W = O[0], Y = 0; Y < O.length; Y++) {
      var V = O[Y], ee = jy(V), K = ZT(V) === QT, Q = [wf, lp].indexOf(ee) >= 0, q = Q ? "width" : "height", te = nk(t, {
        placement: V,
        boundary: f,
        rootBoundary: h,
        altBoundary: p,
        padding: l
      }), X = Q ? K ? cp : _f : K ? lp : wf;
      R[q] > j[q] && (X = X3(X));
      var Z = X3(X), se = [];
      if (o && se.push(te[ee] <= 0), s && se.push(te[X] <= 0, te[Z] <= 0), se.every(function(_e) {
        return _e;
      })) {
        W = V, z = !1;
        break;
      }
      $.set(V, se);
    }
    if (z)
      for (var H = y ? 3 : 1, ie = function(Ne) {
        var Oe = O.find(function(ke) {
          var Me = $.get(ke);
          if (Me)
            return Me.slice(0, Ne).every(function(we) {
              return we;
            });
        });
        if (Oe)
          return W = Oe, "break";
      }, he = H; he > 0; he--) {
        var ye = ie(he);
        if (ye === "break")
          break;
      }
    t.placement !== W && (t.modifiersData[r]._skip = !0, t.placement = W, t.reset = !0);
  }
}
const FBe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: zBe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function yle(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function vle(e) {
  return [wf, cp, lp, _f].some(function(t) {
    return e[t] >= 0;
  });
}
function BBe(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, a = nk(t, {
    elementContext: "reference"
  }), s = nk(t, {
    altBoundary: !0
  }), u = yle(a, r), l = yle(s, i, o), f = vle(u), h = vle(l);
  t.modifiersData[n] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: l,
    isReferenceHidden: f,
    hasPopperEscaped: h
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": f,
    "data-popper-escaped": h
  });
}
const UBe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: BBe
};
function YBe(e, t, n) {
  var r = jy(e), i = [_f, wf].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, a = o[0], s = o[1];
  return a = a || 0, s = (s || 0) * i, [_f, cp].indexOf(r) >= 0 ? {
    x: s,
    y: a
  } : {
    x: a,
    y: s
  };
}
function HBe(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, o = i === void 0 ? [0, 0] : i, a = obe.reduce(function(f, h) {
    return f[h] = YBe(h, t.rects, o), f;
  }, {}), s = a[t.placement], u = s.x, l = s.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += l), t.modifiersData[r] = a;
}
const VBe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: HBe
};
function WBe(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = dbe({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const qBe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: WBe,
  data: {}
};
function GBe(e) {
  return e === "x" ? "y" : "x";
}
function QBe(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = i === void 0 ? !0 : i, a = n.altAxis, s = a === void 0 ? !1 : a, u = n.boundary, l = n.rootBoundary, f = n.altBoundary, h = n.padding, p = n.tether, g = p === void 0 ? !0 : p, y = n.tetherOffset, b = y === void 0 ? 0 : y, _ = nk(t, {
    boundary: u,
    rootBoundary: l,
    padding: h,
    altBoundary: f
  }), S = jy(t.placement), C = ZT(t.placement), A = !C, O = qX(S), R = GBe(O), j = t.modifiersData.popperOffsets, $ = t.rects.reference, z = t.rects.popper, W = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, Y = typeof W == "number" ? {
    mainAxis: W,
    altAxis: W
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, W), V = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ee = {
    x: 0,
    y: 0
  };
  if (j) {
    if (o) {
      var K, Q = O === "y" ? wf : _f, q = O === "y" ? lp : cp, te = O === "y" ? "height" : "width", X = j[O], Z = X + _[Q], se = X - _[q], H = g ? -z[te] / 2 : 0, ie = C === QT ? $[te] : z[te], he = C === QT ? -z[te] : -$[te], ye = t.elements.arrow, _e = g && ye ? WX(ye) : {
        width: 0,
        height: 0
      }, Ne = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : ube(), Oe = Ne[Q], ke = Ne[q], Me = cR(0, $[te], _e[te]), we = A ? $[te] / 2 - H - Me - Oe - Y.mainAxis : ie - Me - Oe - Y.mainAxis, Ye = A ? -$[te] / 2 + H + Me + ke + Y.mainAxis : he + Me + ke + Y.mainAxis, ze = t.elements.arrow && x$(t.elements.arrow), fe = ze ? O === "y" ? ze.clientTop || 0 : ze.clientLeft || 0 : 0, Qe = (K = V == null ? void 0 : V[O]) != null ? K : 0, $e = X + we - Qe - fe, pt = X + Ye - Qe, _t = cR(g ? Vj(Z, $e) : Z, X, g ? GE(se, pt) : se);
      j[O] = _t, ee[O] = _t - X;
    }
    if (s) {
      var Ot, mn = O === "x" ? wf : _f, jr = O === "x" ? lp : cp, tn = j[R], Zt = R === "y" ? "height" : "width", qn = tn + _[mn], fn = tn - _[jr], gr = [wf, _f].indexOf(S) !== -1, Zn = (Ot = V == null ? void 0 : V[R]) != null ? Ot : 0, xr = gr ? qn : tn - $[Zt] - z[Zt] - Zn + Y.altAxis, Un = gr ? tn + $[Zt] + z[Zt] - Zn - Y.altAxis : fn, Qt = g && gr ? bBe(xr, tn, Un) : cR(g ? xr : qn, tn, g ? Un : fn);
      j[R] = Qt, ee[R] = Qt - tn;
    }
    t.modifiersData[r] = ee;
  }
}
const XBe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: QBe,
  requiresIfExists: ["offset"]
};
function KBe(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function ZBe(e) {
  return e === Ld(e) || !op(e) ? GX(e) : KBe(e);
}
function JBe(e) {
  var t = e.getBoundingClientRect(), n = XT(t.width) / e.offsetWidth || 1, r = XT(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function eUe(e, t, n) {
  n === void 0 && (n = !1);
  var r = op(t), i = op(t) && JBe(t), o = Ew(t), a = KT(e, i, n), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((Vy(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  XX(o)) && (s = ZBe(t)), op(t) ? (u = KT(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : o && (u.x = QX(o))), {
    x: a.left + s.scrollLeft - u.x,
    y: a.top + s.scrollTop - u.y,
    width: a.width,
    height: a.height
  };
}
function tUe(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function i(o) {
    n.add(o.name);
    var a = [].concat(o.requires || [], o.requiresIfExists || []);
    a.forEach(function(s) {
      if (!n.has(s)) {
        var u = t.get(s);
        u && i(u);
      }
    }), r.push(o);
  }
  return e.forEach(function(o) {
    n.has(o.name) || i(o);
  }), r;
}
function nUe(e) {
  var t = tUe(e);
  return hBe.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function rUe(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function iUe(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var ble = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function xle() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function oUe(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, o = i === void 0 ? ble : i;
  return function(s, u, l) {
    l === void 0 && (l = o);
    var f = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, ble, o),
      modifiersData: {},
      elements: {
        reference: s,
        popper: u
      },
      attributes: {},
      styles: {}
    }, h = [], p = !1, g = {
      state: f,
      setOptions: function(S) {
        var C = typeof S == "function" ? S(f.options) : S;
        b(), f.options = Object.assign({}, o, f.options, C), f.scrollParents = {
          reference: yS(s) ? fR(s) : s.contextElement ? fR(s.contextElement) : [],
          popper: fR(u)
        };
        var A = nUe(iUe([].concat(r, f.options.modifiers)));
        return f.orderedModifiers = A.filter(function(O) {
          return O.enabled;
        }), y(), g.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!p) {
          var S = f.elements, C = S.reference, A = S.popper;
          if (xle(C, A)) {
            f.rects = {
              reference: eUe(C, x$(A), f.options.strategy === "fixed"),
              popper: WX(A)
            }, f.reset = !1, f.placement = f.options.placement, f.orderedModifiers.forEach(function(Y) {
              return f.modifiersData[Y.name] = Object.assign({}, Y.data);
            });
            for (var O = 0; O < f.orderedModifiers.length; O++) {
              if (f.reset === !0) {
                f.reset = !1, O = -1;
                continue;
              }
              var R = f.orderedModifiers[O], j = R.fn, $ = R.options, z = $ === void 0 ? {} : $, W = R.name;
              typeof j == "function" && (f = j({
                state: f,
                options: z,
                name: W,
                instance: g
              }) || f);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: rUe(function() {
        return new Promise(function(_) {
          g.forceUpdate(), _(f);
        });
      }),
      destroy: function() {
        b(), p = !0;
      }
    };
    if (!xle(s, u))
      return g;
    g.setOptions(l).then(function(_) {
      !p && l.onFirstUpdate && l.onFirstUpdate(_);
    });
    function y() {
      f.orderedModifiers.forEach(function(_) {
        var S = _.name, C = _.options, A = C === void 0 ? {} : C, O = _.effect;
        if (typeof O == "function") {
          var R = O({
            state: f,
            name: S,
            instance: g,
            options: A
          }), j = function() {
          };
          h.push(R || j);
        }
      });
    }
    function b() {
      h.forEach(function(_) {
        return _();
      }), h = [];
    }
    return g;
  };
}
var aUe = [DBe, qBe, CBe, mBe, VBe, FBe, XBe, EBe, UBe], sUe = /* @__PURE__ */ oUe({
  defaultModifiers: aUe
});
function uUe(e) {
  return typeof e == "function" ? e() : e;
}
const rk = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    children: r,
    container: i,
    disablePortal: o = !1
  } = t, [a, s] = ae.useState(null), u = gS(/* @__PURE__ */ ae.isValidElement(r) ? r.ref : null, n);
  if (qT(() => {
    o || s(uUe(i) || document.body);
  }, [i, o]), qT(() => {
    if (a && !o)
      return lW(n, a), () => {
        lW(n, null);
      };
  }, [n, a, o]), o) {
    if (/* @__PURE__ */ ae.isValidElement(r)) {
      const l = {
        ref: u
      };
      return /* @__PURE__ */ ae.cloneElement(r, l);
    }
    return /* @__PURE__ */ pe.jsx(ae.Fragment, {
      children: r
    });
  }
  return /* @__PURE__ */ pe.jsx(ae.Fragment, {
    children: a && /* @__PURE__ */ Cz.createPortal(r, a)
  });
});
process.env.NODE_ENV !== "production" && (rk.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The children to render into the `container`.
   */
  children: N.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: N.oneOfType([Bj, N.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: N.bool
});
process.env.NODE_ENV !== "production" && (rk["propTypes"] = U0e(rk.propTypes));
function lUe(e) {
  return FX("MuiPopper", e);
}
H0e("MuiPopper", ["root"]);
const cUe = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], fUe = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function dUe(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function Wj(e) {
  return typeof e == "function" ? e() : e;
}
function eF(e) {
  return e.nodeType !== void 0;
}
function hUe(e) {
  return !eF(e);
}
const pUe = () => yi({
  root: ["root"]
}, tbe(lUe)), gUe = {}, mUe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r;
  const {
    anchorEl: i,
    children: o,
    direction: a,
    disablePortal: s,
    modifiers: u,
    open: l,
    placement: f,
    popperOptions: h,
    popperRef: p,
    slotProps: g = {},
    slots: y = {},
    TransitionProps: b
    // @ts-ignore internal logic
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
  } = t, _ = ln(t, cUe), S = ae.useRef(null), C = gS(S, n), A = ae.useRef(null), O = gS(A, p), R = ae.useRef(O);
  qT(() => {
    R.current = O;
  }, [O]), ae.useImperativeHandle(p, () => A.current, []);
  const j = dUe(f, a), [$, z] = ae.useState(j), [W, Y] = ae.useState(Wj(i));
  ae.useEffect(() => {
    A.current && A.current.forceUpdate();
  }), ae.useEffect(() => {
    i && Y(Wj(i));
  }, [i]), qT(() => {
    if (!W || !l)
      return;
    const q = (Z) => {
      z(Z.placement);
    };
    if (process.env.NODE_ENV !== "production" && W && eF(W) && W.nodeType === 1) {
      const Z = W.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && Z.top === 0 && Z.left === 0 && Z.right === 0 && Z.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    let te = [{
      name: "preventOverflow",
      options: {
        altBoundary: s
      }
    }, {
      name: "flip",
      options: {
        altBoundary: s
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: Z
      }) => {
        q(Z);
      }
    }];
    u != null && (te = te.concat(u)), h && h.modifiers != null && (te = te.concat(h.modifiers));
    const X = sUe(W, S.current, ge({
      placement: j
    }, h, {
      modifiers: te
    }));
    return R.current(X), () => {
      X.destroy(), R.current(null);
    };
  }, [W, s, u, l, h, j]);
  const V = {
    placement: $
  };
  b !== null && (V.TransitionProps = b);
  const ee = pUe(), K = (r = y.root) != null ? r : "div", Q = mS({
    elementType: K,
    externalSlotProps: g.root,
    externalForwardedProps: _,
    additionalProps: {
      role: "tooltip",
      ref: C
    },
    ownerState: t,
    className: ee.root
  });
  return /* @__PURE__ */ pe.jsx(K, ge({}, Q, {
    children: typeof o == "function" ? o(V) : o
  }));
}), hbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    container: o,
    direction: a = "ltr",
    disablePortal: s = !1,
    keepMounted: u = !1,
    modifiers: l,
    open: f,
    placement: h = "bottom",
    popperOptions: p = gUe,
    popperRef: g,
    style: y,
    transition: b = !1,
    slotProps: _ = {},
    slots: S = {}
  } = t, C = ln(t, fUe), [A, O] = ae.useState(!0), R = () => {
    O(!1);
  }, j = () => {
    O(!0);
  };
  if (!u && !f && (!b || A))
    return null;
  let $;
  if (o)
    $ = o;
  else if (r) {
    const Y = Wj(r);
    $ = Y && eF(Y) ? Iy(Y).body : Iy(null).body;
  }
  const z = !f && u && (!b || A) ? "none" : void 0, W = b ? {
    in: f,
    onEnter: R,
    onExited: j
  } : void 0;
  return /* @__PURE__ */ pe.jsx(rk, {
    disablePortal: s,
    container: $,
    children: /* @__PURE__ */ pe.jsx(mUe, ge({
      anchorEl: r,
      direction: a,
      disablePortal: s,
      modifiers: l,
      ref: n,
      open: b ? !A : f,
      placement: h,
      popperOptions: p,
      popperRef: g,
      slotProps: _,
      slots: S
    }, C, {
      style: ge({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: z
      }, y),
      TransitionProps: W,
      children: i
    }))
  });
});
process.env.NODE_ENV !== "production" && (hbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: zX(N.oneOfType([Bj, N.object, N.func]), (e) => {
    if (e.open) {
      const t = Wj(e.anchorEl);
      if (t && eF(t) && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!t || typeof t.getBoundingClientRect != "function" || hUe(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: N.oneOfType([N.node, N.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: N.oneOfType([Bj, N.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: N.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: N.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: N.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: N.arrayOf(N.shape({
    data: N.object,
    effect: N.func,
    enabled: N.bool,
    fn: N.func,
    name: N.any,
    options: N.object,
    phase: N.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: N.arrayOf(N.string),
    requiresIfExists: N.arrayOf(N.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: N.shape({
    modifiers: N.array,
    onFirstUpdate: N.func,
    placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: N.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: W9e,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: N.shape({
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: N.shape({
    root: N.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: N.bool
});
function yUe(e) {
  const t = Iy(e);
  return t.body === e ? ek(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function dR(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function wle(e) {
  return parseInt(ek(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function vUe(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(e.tagName) !== -1, r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || r;
}
function _le(e, t, n, r, i) {
  const o = [t, n, ...r];
  [].forEach.call(e.children, (a) => {
    const s = o.indexOf(a) === -1, u = !vUe(a);
    s && u && dR(a, i);
  });
}
function uY(e, t) {
  let n = -1;
  return e.some((r, i) => t(r) ? (n = i, !0) : !1), n;
}
function bUe(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if (yUe(r)) {
      const a = Q9e(Iy(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${wle(r) + a}px`;
      const s = Iy(r).querySelectorAll(".mui-fixed");
      [].forEach.call(s, (u) => {
        n.push({
          value: u.style.paddingRight,
          property: "padding-right",
          el: u
        }), u.style.paddingRight = `${wle(u) + a}px`;
      });
    }
    let o;
    if (r.parentNode instanceof DocumentFragment)
      o = Iy(r).body;
    else {
      const a = r.parentElement, s = ek(r);
      o = (a == null ? void 0 : a.nodeName) === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : r;
    }
    n.push({
      value: o.style.overflow,
      property: "overflow",
      el: o
    }, {
      value: o.style.overflowX,
      property: "overflow-x",
      el: o
    }, {
      value: o.style.overflowY,
      property: "overflow-y",
      el: o
    }), o.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: o,
      el: a,
      property: s
    }) => {
      o ? a.style.setProperty(s, o) : a.style.removeProperty(s);
    });
  };
}
function xUe(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class wUe {
  constructor() {
    this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && dR(t.modalRef, !1);
    const i = xUe(n);
    _le(n, t.mount, t.modalRef, i, !0);
    const o = uY(this.containers, (a) => a.container === n);
    return o !== -1 ? (this.containers[o].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: i
    }), r);
  }
  mount(t, n) {
    const r = uY(this.containers, (o) => o.modals.indexOf(t) !== -1), i = this.containers[r];
    i.restore || (i.restore = bUe(i, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const i = uY(this.containers, (a) => a.modals.indexOf(t) !== -1), o = this.containers[i];
    if (o.modals.splice(o.modals.indexOf(t), 1), this.modals.splice(r, 1), o.modals.length === 0)
      o.restore && o.restore(), t.modalRef && dR(t.modalRef, n), _le(o.container, t.mount, t.modalRef, o.hiddenSiblings, !1), this.containers.splice(i, 1);
    else {
      const a = o.modals[o.modals.length - 1];
      a.modalRef && dR(a.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
function _Ue(e) {
  return typeof e == "function" ? e() : e;
}
function EUe(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const SUe = new wUe();
function MUe(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager: i = SUe,
    closeAfterTransition: o = !1,
    onTransitionEnter: a,
    onTransitionExited: s,
    children: u,
    onClose: l,
    open: f,
    rootRef: h
  } = e, p = ae.useRef({}), g = ae.useRef(null), y = ae.useRef(null), b = gS(y, h), [_, S] = ae.useState(!f), C = EUe(u);
  let A = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (A = !1);
  const O = () => Iy(g.current), R = () => (p.current.modalRef = y.current, p.current.mount = g.current, p.current), j = () => {
    i.mount(R(), {
      disableScrollLock: r
    }), y.current && (y.current.scrollTop = 0);
  }, $ = tle(() => {
    const te = _Ue(t) || O().body;
    i.add(R(), te), y.current && j();
  }), z = ae.useCallback(() => i.isTopModal(R()), [i]), W = tle((te) => {
    g.current = te, te && (f && z() ? j() : y.current && dR(y.current, A));
  }), Y = ae.useCallback(() => {
    i.remove(R(), A);
  }, [A, i]);
  ae.useEffect(() => () => {
    Y();
  }, [Y]), ae.useEffect(() => {
    f ? $() : (!C || !o) && Y();
  }, [f, Y, C, o, $]);
  const V = (te) => (X) => {
    var Z;
    (Z = te.onKeyDown) == null || Z.call(te, X), !(X.key !== "Escape" || !z()) && (n || (X.stopPropagation(), l && l(X, "escapeKeyDown")));
  }, ee = (te) => (X) => {
    var Z;
    (Z = te.onClick) == null || Z.call(te, X), X.target === X.currentTarget && l && l(X, "backdropClick");
  };
  return {
    getRootProps: (te = {}) => {
      const X = nbe(e);
      delete X.onTransitionEnter, delete X.onTransitionExited;
      const Z = ge({}, X, te);
      return ge({
        role: "presentation"
      }, Z, {
        onKeyDown: V(Z),
        ref: b
      });
    },
    getBackdropProps: (te = {}) => {
      const X = te;
      return ge({
        "aria-hidden": !0
      }, X, {
        onClick: ee(X),
        open: f
      });
    },
    getTransitionProps: () => {
      const te = () => {
        S(!1), a && a();
      }, X = () => {
        S(!0), s && s(), o && Y();
      };
      return {
        onEnter: ele(te, u.props.onEnter),
        onExited: ele(X, u.props.onExited)
      };
    },
    rootRef: b,
    portalRef: W,
    isTopModal: z,
    exited: _,
    hasTransition: C
  };
}
function TUe(e) {
  return FX("MuiModal", e);
}
H0e("MuiModal", ["root", "hidden", "backdrop"]);
const CUe = ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"], NUe = (e) => {
  const {
    open: t,
    exited: n
  } = e;
  return yi({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, tbe(TUe));
}, pbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r;
  const {
    children: i,
    closeAfterTransition: o = !1,
    container: a,
    disableAutoFocus: s = !1,
    disableEnforceFocus: u = !1,
    disableEscapeKeyDown: l = !1,
    disablePortal: f = !1,
    disableRestoreFocus: h = !1,
    disableScrollLock: p = !1,
    hideBackdrop: g = !1,
    keepMounted: y = !1,
    onBackdropClick: b,
    open: _,
    slotProps: S = {},
    slots: C = {}
  } = t, A = ln(t, CUe), O = ge({}, t, {
    closeAfterTransition: o,
    disableAutoFocus: s,
    disableEnforceFocus: u,
    disableEscapeKeyDown: l,
    disablePortal: f,
    disableRestoreFocus: h,
    disableScrollLock: p,
    hideBackdrop: g,
    keepMounted: y
  }), {
    getRootProps: R,
    getBackdropProps: j,
    getTransitionProps: $,
    portalRef: z,
    isTopModal: W,
    exited: Y,
    hasTransition: V
  } = MUe(ge({}, O, {
    rootRef: n
  })), ee = ge({}, O, {
    exited: Y,
    hasTransition: V
  }), K = NUe(ee), Q = {};
  if (i.props.tabIndex === void 0 && (Q.tabIndex = "-1"), V) {
    const {
      onEnter: se,
      onExited: H
    } = $();
    Q.onEnter = se, Q.onExited = H;
  }
  const q = (r = C.root) != null ? r : "div", te = mS({
    elementType: q,
    externalSlotProps: S.root,
    externalForwardedProps: A,
    getSlotProps: R,
    className: K.root,
    ownerState: ee
  }), X = C.backdrop, Z = mS({
    elementType: X,
    externalSlotProps: S.backdrop,
    getSlotProps: (se) => j(ge({}, se, {
      onClick: (H) => {
        b && b(H), se != null && se.onClick && se.onClick(H);
      }
    })),
    className: K.backdrop,
    ownerState: ee
  });
  return !y && !_ && (!V || Y) ? null : /* @__PURE__ */ pe.jsx(rk, {
    ref: z,
    container: a,
    disablePortal: f,
    children: /* @__PURE__ */ pe.jsxs(q, ge({}, te, {
      children: [!g && X ? /* @__PURE__ */ pe.jsx(X, ge({}, Z)) : null, /* @__PURE__ */ pe.jsx(Hj, {
        disableEnforceFocus: u,
        disableAutoFocus: s,
        disableRestoreFocus: h,
        isEnabled: W,
        open: _,
        children: /* @__PURE__ */ ae.cloneElement(i, Q)
      })]
    }))
  });
});
process.env.NODE_ENV !== "production" && (pbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: B0e.isRequired,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: N.bool,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: N.oneOfType([Bj, N.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: N.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: N.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: N.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: N.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: N.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: N.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: N.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: N.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: N.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: N.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: N.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: N.func,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: N.shape({
    backdrop: N.oneOfType([N.func, N.object]),
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: N.shape({
    backdrop: N.elementType,
    root: N.elementType
  })
});
const DUe = ["onChange", "maxRows", "minRows", "style", "value"];
function NI(e) {
  return parseInt(e, 10) || 0;
}
const AUe = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function Ele(e) {
  return e == null || Object.keys(e).length === 0 || e.outerHeightStyle === 0 && !e.overflow;
}
const gbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    onChange: r,
    maxRows: i,
    minRows: o = 1,
    style: a,
    value: s
  } = t, u = ln(t, DUe), {
    current: l
  } = ae.useRef(s != null), f = ae.useRef(null), h = gS(n, f), p = ae.useRef(null), g = ae.useRef(0), [y, b] = ae.useState({
    outerHeightStyle: 0
  }), _ = ae.useCallback(() => {
    const R = f.current, $ = ek(R).getComputedStyle(R);
    if ($.width === "0px")
      return {
        outerHeightStyle: 0
      };
    const z = p.current;
    z.style.width = $.width, z.value = R.value || t.placeholder || "x", z.value.slice(-1) === `
` && (z.value += " ");
    const W = $.boxSizing, Y = NI($.paddingBottom) + NI($.paddingTop), V = NI($.borderBottomWidth) + NI($.borderTopWidth), ee = z.scrollHeight;
    z.value = "x";
    const K = z.scrollHeight;
    let Q = ee;
    o && (Q = Math.max(Number(o) * K, Q)), i && (Q = Math.min(Number(i) * K, Q)), Q = Math.max(Q, K);
    const q = Q + (W === "border-box" ? Y + V : 0), te = Math.abs(Q - ee) <= 1;
    return {
      outerHeightStyle: q,
      overflow: te
    };
  }, [i, o, t.placeholder]), S = (R, j) => {
    const {
      outerHeightStyle: $,
      overflow: z
    } = j;
    return g.current < 20 && ($ > 0 && Math.abs((R.outerHeightStyle || 0) - $) > 1 || R.overflow !== z) ? (g.current += 1, {
      overflow: z,
      outerHeightStyle: $
    }) : (process.env.NODE_ENV !== "production" && g.current === 20 && console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join(`
`)), R);
  }, C = ae.useCallback(() => {
    const R = _();
    Ele(R) || b((j) => S(j, R));
  }, [_]), A = () => {
    const R = _();
    Ele(R) || Cz.flushSync(() => {
      b((j) => S(j, R));
    });
  };
  ae.useEffect(() => {
    const R = q9e(() => {
      g.current = 0, f.current && A();
    });
    let j;
    const $ = f.current, z = ek($);
    return z.addEventListener("resize", R), typeof ResizeObserver < "u" && (j = new ResizeObserver(R), j.observe($)), () => {
      R.clear(), z.removeEventListener("resize", R), j && j.disconnect();
    };
  }), qT(() => {
    C();
  }), ae.useEffect(() => {
    g.current = 0;
  }, [s]);
  const O = (R) => {
    g.current = 0, l || C(), r && r(R);
  };
  return /* @__PURE__ */ pe.jsxs(ae.Fragment, {
    children: [/* @__PURE__ */ pe.jsx("textarea", ge({
      value: s,
      onChange: O,
      ref: h,
      rows: o,
      style: ge({
        height: y.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: y.overflow ? "hidden" : void 0
      }, a)
    }, u)), /* @__PURE__ */ pe.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: p,
      tabIndex: -1,
      style: ge({}, AUe.shadow, a, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (gbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  className: N.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: N.oneOfType([N.number, N.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: N.oneOfType([N.number, N.string]),
  /**
   * @ignore
   */
  onChange: N.func,
  /**
   * @ignore
   */
  placeholder: N.string,
  /**
   * @ignore
   */
  style: N.object,
  /**
   * @ignore
   */
  value: N.oneOfType([N.arrayOf(N.string), N.number, N.string])
});
const OUe = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"], RUe = zt(hbe, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), mbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r;
  const i = k0e(), o = mi({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: a,
    component: s,
    components: u,
    componentsProps: l,
    container: f,
    disablePortal: h,
    keepMounted: p,
    modifiers: g,
    open: y,
    placement: b,
    popperOptions: _,
    popperRef: S,
    transition: C,
    slots: A,
    slotProps: O
  } = o, R = ln(o, OUe), j = (r = A == null ? void 0 : A.root) != null ? r : u == null ? void 0 : u.Root, $ = ge({
    anchorEl: a,
    container: f,
    disablePortal: h,
    keepMounted: p,
    modifiers: g,
    open: y,
    placement: b,
    popperOptions: _,
    popperRef: S,
    transition: C
  }, R);
  return /* @__PURE__ */ pe.jsx(RUe, ge({
    as: s,
    direction: i == null ? void 0 : i.direction,
    slots: {
      root: j
    },
    slotProps: O ?? l
  }, $, {
    ref: n
  }));
});
process.env.NODE_ENV !== "production" && (mbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: N.oneOfType([YT, N.object, N.func]),
  /**
   * Popper render function or node.
   */
  children: N.oneOfType([N.node, N.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: N.shape({
    Root: N.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  componentsProps: N.shape({
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: N.oneOfType([YT, N.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: N.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: N.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: N.arrayOf(N.shape({
    data: N.object,
    effect: N.func,
    enabled: N.bool,
    fn: N.func,
    name: N.any,
    options: N.object,
    phase: N.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: N.arrayOf(N.string),
    requiresIfExists: N.arrayOf(N.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: N.shape({
    modifiers: N.array,
    onFirstUpdate: N.func,
    placement: N.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: N.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: mb,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: N.shape({
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: N.shape({
    root: N.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: N.bool
});
const ybe = mbe;
function KX({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, i) => (r[i] = e[i], n && typeof e[i] > "u" && (r[i] = n[i]), r), {});
}
const vbe = /* @__PURE__ */ ae.createContext(void 0);
process.env.NODE_ENV !== "production" && (vbe.displayName = "FormControlContext");
const bbe = vbe;
function ZX() {
  return ae.useContext(bbe);
}
function xbe(e) {
  return /* @__PURE__ */ pe.jsx($0e, ge({}, e, {
    defaultTheme: Xz,
    themeId: g$
  }));
}
process.env.NODE_ENV !== "production" && (xbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The styles you want to apply globally.
   */
  styles: N.oneOfType([N.array, N.func, N.number, N.object, N.string, N.bool])
});
function Sle(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function wbe(e, t = !1) {
  return e && (Sle(e.value) && e.value !== "" || t && Sle(e.defaultValue) && e.defaultValue !== "");
}
function kUe(e) {
  return gi("MuiInputBase", e);
}
const $Ue = fi("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]), JT = $Ue, PUe = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"], tF = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${Xn(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, nF = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, IUe = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: i,
    endAdornment: o,
    focused: a,
    formControl: s,
    fullWidth: u,
    hiddenLabel: l,
    multiline: f,
    readOnly: h,
    size: p,
    startAdornment: g,
    type: y
  } = e, b = {
    root: ["root", `color${Xn(n)}`, r && "disabled", i && "error", u && "fullWidth", a && "focused", s && "formControl", p === "small" && "sizeSmall", f && "multiline", g && "adornedStart", o && "adornedEnd", l && "hiddenLabel", h && "readOnly"],
    input: ["input", r && "disabled", y === "search" && "inputTypeSearch", f && "inputMultiline", p === "small" && "inputSizeSmall", l && "inputHiddenLabel", g && "inputAdornedStart", o && "inputAdornedEnd", h && "readOnly"]
  };
  return yi(b, kUe, t);
}, rF = zt("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: tF
})(({
  theme: e,
  ownerState: t
}) => ge({}, e.typography.body1, {
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${JT.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  }
}, t.multiline && ge({
  padding: "4px 0 5px"
}, t.size === "small" && {
  paddingTop: 1
}), t.fullWidth && {
  width: "100%"
})), iF = zt("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: nF
})(({
  theme: e,
  ownerState: t
}) => {
  const n = e.palette.mode === "light", r = ge({
    color: "currentColor"
  }, e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: n ? 0.42 : 0.5
  }, {
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }), i = {
    opacity: "0 !important"
  }, o = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: n ? 0.42 : 0.5
  };
  return ge({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": r,
    "&::-moz-placeholder": r,
    // Firefox 19+
    "&:-ms-input-placeholder": r,
    // IE11
    "&::-ms-input-placeholder": r,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${JT.formControl} &`]: {
      "&::-webkit-input-placeholder": i,
      "&::-moz-placeholder": i,
      // Firefox 19+
      "&:-ms-input-placeholder": i,
      // IE11
      "&::-ms-input-placeholder": i,
      // Edge
      "&:focus::-webkit-input-placeholder": o,
      "&:focus::-moz-placeholder": o,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": o,
      // IE11
      "&:focus::-ms-input-placeholder": o
      // Edge
    },
    [`&.${JT.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, t.size === "small" && {
    paddingTop: 1
  }, t.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, t.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
}), jUe = /* @__PURE__ */ pe.jsx(xbe, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
}), _be = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r;
  const i = mi({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": o,
    autoComplete: a,
    autoFocus: s,
    className: u,
    components: l = {},
    componentsProps: f = {},
    defaultValue: h,
    disabled: p,
    disableInjectingGlobalStyles: g,
    endAdornment: y,
    fullWidth: b = !1,
    id: _,
    inputComponent: S = "input",
    inputProps: C = {},
    inputRef: A,
    maxRows: O,
    minRows: R,
    multiline: j = !1,
    name: $,
    onBlur: z,
    onChange: W,
    onClick: Y,
    onFocus: V,
    onKeyDown: ee,
    onKeyUp: K,
    placeholder: Q,
    readOnly: q,
    renderSuffix: te,
    rows: X,
    slotProps: Z = {},
    slots: se = {},
    startAdornment: H,
    type: ie = "text",
    value: he
  } = i, ye = ln(i, PUe), _e = C.value != null ? C.value : he, {
    current: Ne
  } = ae.useRef(_e != null), Oe = ae.useRef(), ke = ae.useCallback((Qt) => {
    process.env.NODE_ENV !== "production" && Qt && Qt.nodeName !== "INPUT" && !Qt.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), Me = jd(Oe, A, C.ref, ke), [we, Ye] = ae.useState(!1), ze = ZX();
  process.env.NODE_ENV !== "production" && ae.useEffect(() => {
    if (ze)
      return ze.registerEffect();
  }, [ze]);
  const fe = KX({
    props: i,
    muiFormControl: ze,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fe.focused = ze ? ze.focused : we, ae.useEffect(() => {
    !ze && p && we && (Ye(!1), z && z());
  }, [ze, p, we, z]);
  const Qe = ze && ze.onFilled, $e = ze && ze.onEmpty, pt = ae.useCallback((Qt) => {
    wbe(Qt) ? Qe && Qe() : $e && $e();
  }, [Qe, $e]);
  p$(() => {
    Ne && pt({
      value: _e
    });
  }, [_e, pt, Ne]);
  const _t = (Qt) => {
    if (fe.disabled) {
      Qt.stopPropagation();
      return;
    }
    V && V(Qt), C.onFocus && C.onFocus(Qt), ze && ze.onFocus ? ze.onFocus(Qt) : Ye(!0);
  }, Ot = (Qt) => {
    z && z(Qt), C.onBlur && C.onBlur(Qt), ze && ze.onBlur ? ze.onBlur(Qt) : Ye(!1);
  }, mn = (Qt, ...Ut) => {
    if (!Ne) {
      const er = Qt.target || Oe.current;
      if (er == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : Hx(1));
      pt({
        value: er.value
      });
    }
    C.onChange && C.onChange(Qt, ...Ut), W && W(Qt, ...Ut);
  };
  ae.useEffect(() => {
    pt(Oe.current);
  }, []);
  const jr = (Qt) => {
    Oe.current && Qt.currentTarget === Qt.target && Oe.current.focus(), Y && !fe.disabled && Y(Qt);
  };
  let tn = S, Zt = C;
  j && tn === "input" && (X ? (process.env.NODE_ENV !== "production" && (R || O) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), Zt = ge({
    type: void 0,
    minRows: X,
    maxRows: X
  }, Zt)) : Zt = ge({
    type: void 0,
    maxRows: O,
    minRows: R
  }, Zt), tn = gbe);
  const qn = (Qt) => {
    pt(Qt.animationName === "mui-auto-fill-cancel" ? Oe.current : {
      value: "x"
    });
  };
  ae.useEffect(() => {
    ze && ze.setAdornedStart(!!H);
  }, [ze, H]);
  const fn = ge({}, i, {
    color: fe.color || "primary",
    disabled: fe.disabled,
    endAdornment: y,
    error: fe.error,
    focused: fe.focused,
    formControl: ze,
    fullWidth: b,
    hiddenLabel: fe.hiddenLabel,
    multiline: j,
    size: fe.size,
    startAdornment: H,
    type: ie
  }), gr = IUe(fn), Zn = se.root || l.Root || rF, xr = Z.root || f.root || {}, Un = se.input || l.Input || iF;
  return Zt = ge({}, Zt, (r = Z.input) != null ? r : f.input), /* @__PURE__ */ pe.jsxs(ae.Fragment, {
    children: [!g && jUe, /* @__PURE__ */ pe.jsxs(Zn, ge({}, xr, !GT(Zn) && {
      ownerState: ge({}, fn, xr.ownerState)
    }, {
      ref: n,
      onClick: jr
    }, ye, {
      className: kn(gr.root, xr.className, u, q && "MuiInputBase-readOnly"),
      children: [H, /* @__PURE__ */ pe.jsx(bbe.Provider, {
        value: null,
        children: /* @__PURE__ */ pe.jsx(Un, ge({
          ownerState: fn,
          "aria-invalid": fe.error,
          "aria-describedby": o,
          autoComplete: a,
          autoFocus: s,
          defaultValue: h,
          disabled: fe.disabled,
          id: _,
          onAnimationStart: qn,
          name: $,
          placeholder: Q,
          readOnly: q,
          required: fe.required,
          rows: X,
          value: _e,
          onKeyDown: ee,
          onKeyUp: K,
          type: ie
        }, Zt, !GT(Un) && {
          as: tn,
          ownerState: ge({}, fn, Zt.ownerState)
        }, {
          ref: Me,
          className: kn(gr.input, Zt.className, q && "MuiInputBase-readOnly"),
          onBlur: Ot,
          onChange: mn,
          onFocus: _t
        }))
      }), y, te ? te(ge({}, fe, {
        startAdornment: H
      })) : null]
    }))]
  });
});
process.env.NODE_ENV !== "production" && (_be.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  "aria-describedby": N.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: N.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: N.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: N.oneOfType([N.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), N.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Input: N.elementType,
    Root: N.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: N.shape({
    input: N.object,
    root: N.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: N.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: N.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: N.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: N.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: N.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: N.bool,
  /**
   * The id of the `input` element.
   */
  id: N.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: Dz,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: N.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: mb,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: N.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: N.oneOfType([N.number, N.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: N.oneOfType([N.number, N.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: N.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: N.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: N.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: N.func,
  /**
   * @ignore
   */
  onClick: N.func,
  /**
   * @ignore
   */
  onFocus: N.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: N.func,
  /**
   * @ignore
   */
  onKeyDown: N.func,
  /**
   * @ignore
   */
  onKeyUp: N.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: N.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: N.bool,
  /**
   * @ignore
   */
  renderSuffix: N.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: N.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: N.oneOfType([N.number, N.string]),
  /**
   * The size of the component.
   */
  size: N.oneOfType([N.oneOf(["medium", "small"]), N.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: N.shape({
    input: N.object,
    root: N.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: N.shape({
    input: N.elementType,
    root: N.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: N.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: N.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: N.any
});
const oF = _be;
function LUe(e) {
  return gi("MuiInput", e);
}
const zUe = ge({}, JT, fi("MuiInput", ["root", "underline", "input"])), DA = zUe;
function FUe(e) {
  return gi("MuiOutlinedInput", e);
}
const BUe = ge({}, JT, fi("MuiOutlinedInput", ["root", "notchedOutline", "input"])), J1 = BUe;
function UUe(e) {
  return gi("MuiFilledInput", e);
}
const YUe = ge({}, JT, fi("MuiFilledInput", ["root", "underline", "input"])), uE = YUe, HUe = ZS(/* @__PURE__ */ pe.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), VUe = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"], WUe = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, Ebe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = _w(), i = {
    enter: r.transitions.duration.enteringScreen,
    exit: r.transitions.duration.leavingScreen
  }, {
    addEndListener: o,
    appear: a = !0,
    children: s,
    easing: u,
    in: l,
    onEnter: f,
    onEntered: h,
    onEntering: p,
    onExit: g,
    onExited: y,
    onExiting: b,
    style: _,
    timeout: S = i,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: C = W0e
  } = t, A = ln(t, VUe), O = ae.useRef(null), R = jd(O, s.ref, n), j = (Q) => (q) => {
    if (Q) {
      const te = O.current;
      q === void 0 ? Q(te) : Q(te, q);
    }
  }, $ = j(p), z = j((Q, q) => {
    q0e(Q);
    const te = Yj({
      style: _,
      timeout: S,
      easing: u
    }, {
      mode: "enter"
    });
    Q.style.webkitTransition = r.transitions.create("opacity", te), Q.style.transition = r.transitions.create("opacity", te), f && f(Q, q);
  }), W = j(h), Y = j(b), V = j((Q) => {
    const q = Yj({
      style: _,
      timeout: S,
      easing: u
    }, {
      mode: "exit"
    });
    Q.style.webkitTransition = r.transitions.create("opacity", q), Q.style.transition = r.transitions.create("opacity", q), g && g(Q);
  }), ee = j(y), K = (Q) => {
    o && o(O.current, Q);
  };
  return /* @__PURE__ */ pe.jsx(C, ge({
    appear: a,
    in: l,
    nodeRef: O,
    onEnter: z,
    onEntered: W,
    onEntering: $,
    onExit: V,
    onExited: ee,
    onExiting: Y,
    addEndListener: K,
    timeout: S
  }, A, {
    children: (Q, q) => /* @__PURE__ */ ae.cloneElement(s, ge({
      style: ge({
        opacity: 0,
        visibility: Q === "exited" && !l ? "hidden" : void 0
      }, WUe[Q], _, s.props.style),
      ref: R
    }, q))
  }));
});
process.env.NODE_ENV !== "production" && (Ebe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: N.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: N.bool,
  /**
   * A single child content element.
   */
  children: Nz.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: N.oneOfType([N.shape({
    enter: N.string,
    exit: N.string
  }), N.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: N.bool,
  /**
   * @ignore
   */
  onEnter: N.func,
  /**
   * @ignore
   */
  onEntered: N.func,
  /**
   * @ignore
   */
  onEntering: N.func,
  /**
   * @ignore
   */
  onExit: N.func,
  /**
   * @ignore
   */
  onExited: N.func,
  /**
   * @ignore
   */
  onExiting: N.func,
  /**
   * @ignore
   */
  style: N.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: N.oneOfType([N.number, N.shape({
    appear: N.number,
    enter: N.number,
    exit: N.number
  })])
});
const qUe = Ebe;
function GUe(e) {
  return gi("MuiBackdrop", e);
}
fi("MuiBackdrop", ["root", "invisible"]);
const QUe = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"], XUe = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return yi({
    root: ["root", n && "invisible"]
  }, GUe, t);
}, KUe = zt("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})(({
  ownerState: e
}) => ge({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, e.invisible && {
  backgroundColor: "transparent"
})), Sbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o;
  const a = mi({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: s,
    className: u,
    component: l = "div",
    components: f = {},
    componentsProps: h = {},
    invisible: p = !1,
    open: g,
    slotProps: y = {},
    slots: b = {},
    TransitionComponent: _ = qUe,
    transitionDuration: S
  } = a, C = ln(a, QUe), A = ge({}, a, {
    component: l,
    invisible: p
  }), O = XUe(A), R = (r = y.root) != null ? r : h.root;
  return /* @__PURE__ */ pe.jsx(_, ge({
    in: g,
    timeout: S
  }, C, {
    children: /* @__PURE__ */ pe.jsx(KUe, ge({
      "aria-hidden": !0
    }, R, {
      as: (i = (o = b.root) != null ? o : f.Root) != null ? i : l,
      className: kn(O.root, u, R == null ? void 0 : R.className),
      ownerState: ge({}, A, R == null ? void 0 : R.ownerState),
      classes: O,
      ref: n,
      children: s
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Sbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Root: N.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: N.shape({
    root: N.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: N.bool,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: N.shape({
    root: N.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: N.shape({
    root: N.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: N.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: N.oneOfType([N.number, N.shape({
    appear: N.number,
    enter: N.number,
    exit: N.number
  })])
});
const ZUe = Sbe, JUe = L0e(), Mbe = J8e({
  themeId: g$,
  defaultTheme: JUe,
  defaultClassName: "MuiBox-root",
  generateClassName: d0e.generate
});
process.env.NODE_ENV !== "production" && (Mbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: N.node,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const hR = Mbe;
function eYe(e) {
  return gi("MuiButton", e);
}
const tYe = fi("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), DI = tYe, Tbe = /* @__PURE__ */ ae.createContext({});
process.env.NODE_ENV !== "production" && (Tbe.displayName = "ButtonGroupContext");
const nYe = Tbe, rYe = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"], iYe = (e) => {
  const {
    color: t,
    disableElevation: n,
    fullWidth: r,
    size: i,
    variant: o,
    classes: a
  } = e, s = {
    root: ["root", o, `${o}${Xn(t)}`, `size${Xn(i)}`, `${o}Size${Xn(i)}`, t === "inherit" && "colorInherit", n && "disableElevation", r && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${Xn(i)}`],
    endIcon: ["endIcon", `iconSize${Xn(i)}`]
  }, u = yi(s, eYe, a);
  return ge({}, a, u);
}, Cbe = (e) => ge({}, e.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, e.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, e.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
}), oYe = zt(Zz, {
  shouldForwardProp: (e) => yb(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`${n.variant}${Xn(n.color)}`], t[`size${Xn(n.size)}`], t[`${n.variant}Size${Xn(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n, r;
  const i = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], o = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return ge({}, e.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": ge({
      textDecoration: "none",
      backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : bs(e.palette.text.primary, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "text" && t.color !== "inherit" && {
      backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : bs(e.palette[t.color].main, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "outlined" && t.color !== "inherit" && {
      border: `1px solid ${(e.vars || e).palette[t.color].main}`,
      backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : bs(e.palette[t.color].main, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "contained" && {
      backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedHoverBg : o,
      boxShadow: (e.vars || e).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (e.vars || e).shadows[2],
        backgroundColor: (e.vars || e).palette.grey[300]
      }
    }, t.variant === "contained" && t.color !== "inherit" && {
      backgroundColor: (e.vars || e).palette[t.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (e.vars || e).palette[t.color].main
      }
    }),
    "&:active": ge({}, t.variant === "contained" && {
      boxShadow: (e.vars || e).shadows[8]
    }),
    [`&.${DI.focusVisible}`]: ge({}, t.variant === "contained" && {
      boxShadow: (e.vars || e).shadows[6]
    }),
    [`&.${DI.disabled}`]: ge({
      color: (e.vars || e).palette.action.disabled
    }, t.variant === "outlined" && {
      border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
    }, t.variant === "contained" && {
      color: (e.vars || e).palette.action.disabled,
      boxShadow: (e.vars || e).shadows[0],
      backgroundColor: (e.vars || e).palette.action.disabledBackground
    })
  }, t.variant === "text" && {
    padding: "6px 8px"
  }, t.variant === "text" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].main
  }, t.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, t.variant === "outlined" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].main,
    border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${bs(e.palette[t.color].main, 0.5)}`
  }, t.variant === "contained" && {
    color: e.vars ? (
      // this is safe because grey does not change between default light/dark mode
      e.vars.palette.text.primary
    ) : (n = (r = e.palette).getContrastText) == null ? void 0 : n.call(r, e.palette.grey[300]),
    backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedBg : i,
    boxShadow: (e.vars || e).shadows[2]
  }, t.variant === "contained" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].contrastText,
    backgroundColor: (e.vars || e).palette[t.color].main
  }, t.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, t.size === "small" && t.variant === "text" && {
    padding: "4px 5px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "text" && {
    padding: "8px 11px",
    fontSize: e.typography.pxToRem(15)
  }, t.size === "small" && t.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: e.typography.pxToRem(15)
  }, t.size === "small" && t.variant === "contained" && {
    padding: "4px 10px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "contained" && {
    padding: "8px 22px",
    fontSize: e.typography.pxToRem(15)
  }, t.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState: e
}) => e.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${DI.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${DI.disabled}`]: {
    boxShadow: "none"
  }
}), aYe = zt("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.startIcon, t[`iconSize${Xn(n.size)}`]];
  }
})(({
  ownerState: e
}) => ge({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, e.size === "small" && {
  marginLeft: -2
}, Cbe(e))), sYe = zt("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.endIcon, t[`iconSize${Xn(n.size)}`]];
  }
})(({
  ownerState: e
}) => ge({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, e.size === "small" && {
  marginRight: -2
}, Cbe(e))), Nbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = ae.useContext(nYe), i = SX(r, t), o = mi({
    props: i,
    name: "MuiButton"
  }), {
    children: a,
    color: s = "primary",
    component: u = "button",
    className: l,
    disabled: f = !1,
    disableElevation: h = !1,
    disableFocusRipple: p = !1,
    endIcon: g,
    focusVisibleClassName: y,
    fullWidth: b = !1,
    size: _ = "medium",
    startIcon: S,
    type: C,
    variant: A = "text"
  } = o, O = ln(o, rYe), R = ge({}, o, {
    color: s,
    component: u,
    disabled: f,
    disableElevation: h,
    disableFocusRipple: p,
    fullWidth: b,
    size: _,
    type: C,
    variant: A
  }), j = iYe(R), $ = S && /* @__PURE__ */ pe.jsx(aYe, {
    className: j.startIcon,
    ownerState: R,
    children: S
  }), z = g && /* @__PURE__ */ pe.jsx(sYe, {
    className: j.endIcon,
    ownerState: R,
    children: g
  });
  return /* @__PURE__ */ pe.jsxs(oYe, ge({
    ownerState: R,
    className: kn(r.className, j.root, l),
    component: u,
    disabled: f,
    focusRipple: !p,
    focusVisibleClassName: kn(j.focusVisible, y),
    ref: n,
    type: C
  }, O, {
    classes: j,
    children: [$, a, z]
  }));
});
process.env.NODE_ENV !== "production" && (Nbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: N.oneOfType([N.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), N.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: N.bool,
  /**
   * If `true`, no elevation is used.
   * @default false
   */
  disableElevation: N.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: N.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: N.bool,
  /**
   * Element placed after the children.
   */
  endIcon: N.node,
  /**
   * @ignore
   */
  focusVisibleClassName: N.string,
  /**
   * If `true`, the button will take up the full width of its container.
   * @default false
   */
  fullWidth: N.bool,
  /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */
  href: N.string,
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: N.oneOfType([N.oneOf(["small", "medium", "large"]), N.string]),
  /**
   * Element placed before the children.
   */
  startIcon: N.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * @ignore
   */
  type: N.oneOfType([N.oneOf(["button", "reset", "submit"]), N.string]),
  /**
   * The variant to use.
   * @default 'text'
   */
  variant: N.oneOfType([N.oneOf(["contained", "outlined", "text"]), N.string])
});
const mW = Nbe, uYe = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "open", "slotProps", "slots", "theme"], lYe = zt("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !t.open && t.exited && {
  visibility: "hidden"
})), cYe = zt(ZUe, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), Dbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o, a, s, u;
  const l = mi({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: f = cYe,
    BackdropProps: h,
    classes: p,
    className: g,
    closeAfterTransition: y = !1,
    children: b,
    container: _,
    component: S,
    components: C = {},
    componentsProps: A = {},
    disableAutoFocus: O = !1,
    disableEnforceFocus: R = !1,
    disableEscapeKeyDown: j = !1,
    disablePortal: $ = !1,
    disableRestoreFocus: z = !1,
    disableScrollLock: W = !1,
    hideBackdrop: Y = !1,
    keepMounted: V = !1,
    onBackdropClick: ee,
    onClose: K,
    open: Q,
    slotProps: q,
    slots: te,
    // eslint-disable-next-line react/prop-types
    theme: X
  } = l, Z = ln(l, uYe), [se, H] = ae.useState(!0), ie = {
    container: _,
    closeAfterTransition: y,
    disableAutoFocus: O,
    disableEnforceFocus: R,
    disableEscapeKeyDown: j,
    disablePortal: $,
    disableRestoreFocus: z,
    disableScrollLock: W,
    hideBackdrop: Y,
    keepMounted: V,
    onBackdropClick: ee,
    onClose: K,
    open: Q
  }, he = ge({}, l, ie, {
    exited: se
  }), ye = (r = (i = te == null ? void 0 : te.root) != null ? i : C.Root) != null ? r : lYe, _e = (o = (a = te == null ? void 0 : te.backdrop) != null ? a : C.Backdrop) != null ? o : f, Ne = (s = q == null ? void 0 : q.root) != null ? s : A.root, Oe = (u = q == null ? void 0 : q.backdrop) != null ? u : A.backdrop;
  return /* @__PURE__ */ pe.jsx(pbe, ge({
    slots: {
      root: ye,
      backdrop: _e
    },
    slotProps: {
      root: () => ge({}, hW(Ne, he), !GT(ye) && {
        as: S,
        theme: X
      }, {
        className: kn(g, Ne == null ? void 0 : Ne.className, p == null ? void 0 : p.root, !he.open && he.exited && (p == null ? void 0 : p.hidden))
      }),
      backdrop: () => ge({}, h, hW(Oe, he), {
        className: kn(Oe == null ? void 0 : Oe.className, h == null ? void 0 : h.className, p == null ? void 0 : p.backdrop)
      })
    },
    onTransitionEnter: () => H(!1),
    onTransitionExited: () => H(!0),
    ref: n
  }, Z, ie, {
    children: b
  }));
});
process.env.NODE_ENV !== "production" && (Dbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: N.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: N.object,
  /**
   * A single child content element.
   */
  children: Nz.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: N.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Backdrop: N.elementType,
    Root: N.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: N.shape({
    backdrop: N.oneOfType([N.func, N.object]),
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: N.oneOfType([YT, N.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: N.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: N.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: N.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: N.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: N.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: N.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: N.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: N.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: N.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: N.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: N.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: N.func,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: N.shape({
    backdrop: N.oneOfType([N.func, N.object]),
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: N.shape({
    backdrop: N.elementType,
    root: N.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const fYe = Dbe;
function dYe(e) {
  return gi("MuiDivider", e);
}
const Mle = fi("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), hYe = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"], pYe = (e) => {
  const {
    absolute: t,
    children: n,
    classes: r,
    flexItem: i,
    light: o,
    orientation: a,
    textAlign: s,
    variant: u
  } = e;
  return yi({
    root: ["root", t && "absolute", u, o && "light", a === "vertical" && "vertical", i && "flexItem", n && "withChildren", n && a === "vertical" && "withChildrenVertical", s === "right" && a !== "vertical" && "textAlignRight", s === "left" && a !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", a === "vertical" && "wrapperVertical"]
  }, dYe, r);
}, gYe = zt("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (e.vars || e).palette.divider,
  borderBottomWidth: "thin"
}, t.absolute && {
  position: "absolute",
  bottom: 0,
  left: 0,
  width: "100%"
}, t.light && {
  borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : bs(e.palette.divider, 0.08)
}, t.variant === "inset" && {
  marginLeft: 72
}, t.variant === "middle" && t.orientation === "horizontal" && {
  marginLeft: e.spacing(2),
  marginRight: e.spacing(2)
}, t.variant === "middle" && t.orientation === "vertical" && {
  marginTop: e.spacing(1),
  marginBottom: e.spacing(1)
}, t.orientation === "vertical" && {
  height: "100%",
  borderBottomWidth: 0,
  borderRightWidth: "thin"
}, t.flexItem && {
  alignSelf: "stretch",
  height: "auto"
}), ({
  ownerState: e
}) => ge({}, e.children && {
  display: "flex",
  whiteSpace: "nowrap",
  textAlign: "center",
  border: 0,
  "&::before, &::after": {
    content: '""',
    alignSelf: "center"
  }
}), ({
  theme: e,
  ownerState: t
}) => ge({}, t.children && t.orientation !== "vertical" && {
  "&::before, &::after": {
    width: "100%",
    borderTop: `thin solid ${(e.vars || e).palette.divider}`
  }
}), ({
  theme: e,
  ownerState: t
}) => ge({}, t.children && t.orientation === "vertical" && {
  flexDirection: "column",
  "&::before, &::after": {
    height: "100%",
    borderLeft: `thin solid ${(e.vars || e).palette.divider}`
  }
}), ({
  ownerState: e
}) => ge({}, e.textAlign === "right" && e.orientation !== "vertical" && {
  "&::before": {
    width: "90%"
  },
  "&::after": {
    width: "10%"
  }
}, e.textAlign === "left" && e.orientation !== "vertical" && {
  "&::before": {
    width: "10%"
  },
  "&::after": {
    width: "90%"
  }
})), mYe = zt("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  display: "inline-block",
  paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
  paddingRight: `calc(${e.spacing(1)} * 1.2)`
}, t.orientation === "vertical" && {
  paddingTop: `calc(${e.spacing(1)} * 1.2)`,
  paddingBottom: `calc(${e.spacing(1)} * 1.2)`
})), JX = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiDivider"
  }), {
    absolute: i = !1,
    children: o,
    className: a,
    component: s = o ? "div" : "hr",
    flexItem: u = !1,
    light: l = !1,
    orientation: f = "horizontal",
    role: h = s !== "hr" ? "separator" : void 0,
    textAlign: p = "center",
    variant: g = "fullWidth"
  } = r, y = ln(r, hYe), b = ge({}, r, {
    absolute: i,
    component: s,
    flexItem: u,
    light: l,
    orientation: f,
    role: h,
    textAlign: p,
    variant: g
  }), _ = pYe(b);
  return /* @__PURE__ */ pe.jsx(gYe, ge({
    as: s,
    className: kn(_.root, a),
    role: h,
    ref: n,
    ownerState: b
  }, y, {
    children: o ? /* @__PURE__ */ pe.jsx(mYe, {
      className: _.wrapper,
      ownerState: b,
      children: o
    }) : null
  }));
});
JX.muiSkipListHighlight = !0;
process.env.NODE_ENV !== "production" && (JX.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Absolutely position the element.
   * @default false
   */
  absolute: N.bool,
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, a vertical divider will have the correct height when used in flex container.
   * (By default, a vertical divider will have a calculated height of `0px` if it is the child of a flex container.)
   * @default false
   */
  flexItem: N.bool,
  /**
   * If `true`, the divider will have a lighter color.
   * @default false
   */
  light: N.bool,
  /**
   * The component orientation.
   * @default 'horizontal'
   */
  orientation: N.oneOf(["horizontal", "vertical"]),
  /**
   * @ignore
   */
  role: N.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * The text alignment.
   * @default 'center'
   */
  textAlign: N.oneOf(["center", "left", "right"]),
  /**
   * The variant to use.
   * @default 'fullWidth'
   */
  variant: N.oneOfType([N.oneOf(["fullWidth", "inset", "middle"]), N.string])
});
const yYe = JX, vYe = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"], bYe = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, i = yi({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, UUe, t);
  return ge({}, t, i);
}, xYe = zt(rF, {
  shouldForwardProp: (e) => yb(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...tF(e, t), !n.disableUnderline && t.underline];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n;
  const r = e.palette.mode === "light", i = r ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", o = r ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", a = r ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", s = r ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return ge({
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : o,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : a,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : o
      }
    },
    [`&.${uE.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : o
    },
    [`&.${uE.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : s
    }
  }, !t.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(n = (e.vars || e).palette[t.color || "primary"]) == null ? void 0 : n.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: e.transitions.create("transform", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${uE.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${uE.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (e.vars || e).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : i}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: e.transitions.create("border-bottom-color", {
        duration: e.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${uE.disabled}, .${uE.error}):before`]: {
      borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
    },
    [`&.${uE.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, t.startAdornment && {
    paddingLeft: 12
  }, t.endAdornment && {
    paddingRight: 12
  }, t.multiline && ge({
    padding: "25px 12px 8px"
  }, t.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, t.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
}), wYe = zt(iF, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: nF
})(({
  theme: e,
  ownerState: t
}) => ge({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !e.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
    caretColor: e.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, e.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [e.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, t.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, t.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, t.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, t.startAdornment && {
  paddingLeft: 0
}, t.endAdornment && {
  paddingRight: 0
}, t.hiddenLabel && t.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
})), eK = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o, a;
  const s = mi({
    props: t,
    name: "MuiFilledInput"
  }), {
    components: u = {},
    componentsProps: l,
    fullWidth: f = !1,
    // declare here to prevent spreading to DOM
    inputComponent: h = "input",
    multiline: p = !1,
    slotProps: g,
    slots: y = {},
    type: b = "text"
  } = s, _ = ln(s, vYe), S = ge({}, s, {
    fullWidth: f,
    inputComponent: h,
    multiline: p,
    type: b
  }), C = bYe(s), A = {
    root: {
      ownerState: S
    },
    input: {
      ownerState: S
    }
  }, O = g ?? l ? ip(g ?? l, A) : A, R = (r = (i = y.root) != null ? i : u.Root) != null ? r : xYe, j = (o = (a = y.input) != null ? a : u.Input) != null ? o : wYe;
  return /* @__PURE__ */ pe.jsx(oF, ge({
    slots: {
      root: R,
      input: j
    },
    componentsProps: O,
    fullWidth: f,
    inputComponent: h,
    multiline: p,
    ref: n,
    type: b
  }, _, {
    classes: C
  }));
});
process.env.NODE_ENV !== "production" && (eK.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: N.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: N.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: N.oneOfType([N.oneOf(["primary", "secondary"]), N.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Input: N.elementType,
    Root: N.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: N.shape({
    input: N.object,
    root: N.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: N.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: N.bool,
  /**
   * If `true`, the input will not have an underline.
   */
  disableUnderline: N.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: N.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: N.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: N.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: N.bool,
  /**
   * The id of the `input` element.
   */
  id: N.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: N.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: N.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: mb,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: N.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: N.oneOfType([N.number, N.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: N.oneOfType([N.number, N.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: N.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: N.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: N.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: N.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: N.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: N.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: N.oneOfType([N.number, N.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: N.shape({
    input: N.object,
    root: N.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: N.shape({
    input: N.elementType,
    root: N.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: N.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: N.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: N.any
});
eK.muiName = "Input";
const _Ye = eK, Abe = /* @__PURE__ */ ae.createContext();
process.env.NODE_ENV !== "production" && (Abe.displayName = "GridContext");
const Tle = Abe;
function EYe(e) {
  return gi("MuiGrid", e);
}
const SYe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], MYe = ["column-reverse", "column", "row-reverse", "row"], TYe = ["nowrap", "wrap-reverse", "wrap"], AA = ["auto", !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], CYe = fi("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...SYe.map((e) => `spacing-xs-${e}`),
  // direction values
  ...MYe.map((e) => `direction-xs-${e}`),
  // wrap values
  ...TYe.map((e) => `wrap-xs-${e}`),
  // grid sizes for all breakpoints
  ...AA.map((e) => `grid-xs-${e}`),
  ...AA.map((e) => `grid-sm-${e}`),
  ...AA.map((e) => `grid-md-${e}`),
  ...AA.map((e) => `grid-lg-${e}`),
  ...AA.map((e) => `grid-xl-${e}`)
]), ik = CYe, NYe = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function MT(e) {
  const t = parseFloat(e);
  return `${t}${String(e).replace(String(t), "") || "px"}`;
}
function DYe({
  theme: e,
  ownerState: t
}) {
  let n;
  return e.breakpoints.keys.reduce((r, i) => {
    let o = {};
    if (t[i] && (n = t[i]), !n)
      return r;
    if (n === !0)
      o = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    else if (n === "auto")
      o = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    else {
      const a = Lz({
        values: t.columns,
        breakpoints: e.breakpoints.values
      }), s = typeof a == "object" ? a[i] : a;
      if (s == null)
        return r;
      const u = `${Math.round(n / s * 1e8) / 1e6}%`;
      let l = {};
      if (t.container && t.item && t.columnSpacing !== 0) {
        const f = e.spacing(t.columnSpacing);
        if (f !== "0px") {
          const h = `calc(${u} + ${MT(f)})`;
          l = {
            flexBasis: h,
            maxWidth: h
          };
        }
      }
      o = ge({
        flexBasis: u,
        flexGrow: 0,
        maxWidth: u
      }, l);
    }
    return e.breakpoints.values[i] === 0 ? Object.assign(r, o) : r[e.breakpoints.up(i)] = o, r;
  }, {});
}
function AYe({
  theme: e,
  ownerState: t
}) {
  const n = Lz({
    values: t.direction,
    breakpoints: e.breakpoints.values
  });
  return up({
    theme: e
  }, n, (r) => {
    const i = {
      flexDirection: r
    };
    return r.indexOf("column") === 0 && (i[`& > .${ik.item}`] = {
      maxWidth: "none"
    }), i;
  });
}
function Obe({
  breakpoints: e,
  values: t
}) {
  let n = "";
  Object.keys(t).forEach((i) => {
    n === "" && t[i] !== 0 && (n = i);
  });
  const r = Object.keys(e).sort((i, o) => e[i] - e[o]);
  return r.slice(0, r.indexOf(n));
}
function OYe({
  theme: e,
  ownerState: t
}) {
  const {
    container: n,
    rowSpacing: r
  } = t;
  let i = {};
  if (n && r !== 0) {
    const o = Lz({
      values: r,
      breakpoints: e.breakpoints.values
    });
    let a;
    typeof o == "object" && (a = Obe({
      breakpoints: e.breakpoints.values,
      values: o
    })), i = up({
      theme: e
    }, o, (s, u) => {
      var l;
      const f = e.spacing(s);
      return f !== "0px" ? {
        marginTop: `-${MT(f)}`,
        [`& > .${ik.item}`]: {
          paddingTop: MT(f)
        }
      } : (l = a) != null && l.includes(u) ? {} : {
        marginTop: 0,
        [`& > .${ik.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return i;
}
function RYe({
  theme: e,
  ownerState: t
}) {
  const {
    container: n,
    columnSpacing: r
  } = t;
  let i = {};
  if (n && r !== 0) {
    const o = Lz({
      values: r,
      breakpoints: e.breakpoints.values
    });
    let a;
    typeof o == "object" && (a = Obe({
      breakpoints: e.breakpoints.values,
      values: o
    })), i = up({
      theme: e
    }, o, (s, u) => {
      var l;
      const f = e.spacing(s);
      return f !== "0px" ? {
        width: `calc(100% + ${MT(f)})`,
        marginLeft: `-${MT(f)}`,
        [`& > .${ik.item}`]: {
          paddingLeft: MT(f)
        }
      } : (l = a) != null && l.includes(u) ? {} : {
        width: "100%",
        marginLeft: 0,
        [`& > .${ik.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return i;
}
function kYe(e, t, n = {}) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [n[`spacing-xs-${String(e)}`]];
  const r = [];
  return t.forEach((i) => {
    const o = e[i];
    Number(o) > 0 && r.push(n[`spacing-${i}-${String(o)}`]);
  }), r;
}
const $Ye = zt("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e, {
      container: r,
      direction: i,
      item: o,
      spacing: a,
      wrap: s,
      zeroMinWidth: u,
      breakpoints: l
    } = n;
    let f = [];
    r && (f = kYe(a, l, t));
    const h = [];
    return l.forEach((p) => {
      const g = n[p];
      g && h.push(t[`grid-${p}-${String(g)}`]);
    }), [t.root, r && t.container, o && t.item, u && t.zeroMinWidth, ...f, i !== "row" && t[`direction-xs-${String(i)}`], s !== "wrap" && t[`wrap-xs-${String(s)}`], ...h];
  }
})(({
  ownerState: e
}) => ge({
  boxSizing: "border-box"
}, e.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, e.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, e.zeroMinWidth && {
  minWidth: 0
}, e.wrap !== "wrap" && {
  flexWrap: e.wrap
}), AYe, OYe, RYe, DYe);
function PYe(e, t) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [`spacing-xs-${String(e)}`];
  const n = [];
  return t.forEach((r) => {
    const i = e[r];
    if (Number(i) > 0) {
      const o = `spacing-${r}-${String(i)}`;
      n.push(o);
    }
  }), n;
}
const IYe = (e) => {
  const {
    classes: t,
    container: n,
    direction: r,
    item: i,
    spacing: o,
    wrap: a,
    zeroMinWidth: s,
    breakpoints: u
  } = e;
  let l = [];
  n && (l = PYe(o, u));
  const f = [];
  u.forEach((p) => {
    const g = e[p];
    g && f.push(`grid-${p}-${String(g)}`);
  });
  const h = {
    root: ["root", n && "container", i && "item", s && "zeroMinWidth", ...l, r !== "row" && `direction-xs-${String(r)}`, a !== "wrap" && `wrap-xs-${String(a)}`, ...f]
  };
  return yi(h, EYe, t);
}, pR = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiGrid"
  }), {
    breakpoints: i
  } = _w(), o = jX(r), {
    className: a,
    columns: s,
    columnSpacing: u,
    component: l = "div",
    container: f = !1,
    direction: h = "row",
    item: p = !1,
    rowSpacing: g,
    spacing: y = 0,
    wrap: b = "wrap",
    zeroMinWidth: _ = !1
  } = o, S = ln(o, NYe), C = g || y, A = u || y, O = ae.useContext(Tle), R = f ? s || 12 : O, j = {}, $ = ge({}, S);
  i.keys.forEach((Y) => {
    S[Y] != null && (j[Y] = S[Y], delete $[Y]);
  });
  const z = ge({}, o, {
    columns: R,
    container: f,
    direction: h,
    item: p,
    rowSpacing: C,
    columnSpacing: A,
    wrap: b,
    zeroMinWidth: _,
    spacing: y
  }, j, {
    breakpoints: i.keys
  }), W = IYe(z);
  return /* @__PURE__ */ pe.jsx(Tle.Provider, {
    value: R,
    children: /* @__PURE__ */ pe.jsx($Ye, ge({
      ownerState: z,
      className: kn(W.root, a),
      as: l,
      ref: n
    }, $))
  });
});
process.env.NODE_ENV !== "production" && (pR.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The number of columns.
   * @default 12
   */
  columns: N.oneOfType([N.arrayOf(N.number), N.number, N.object]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: N.oneOfType([N.arrayOf(N.oneOfType([N.number, N.string])), N.number, N.object, N.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: N.bool,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: N.oneOfType([N.oneOf(["column-reverse", "column", "row-reverse", "row"]), N.arrayOf(N.oneOf(["column-reverse", "column", "row-reverse", "row"])), N.object]),
  /**
   * If `true`, the component will have the flex *item* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  item: N.bool,
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `lg` breakpoint and wider screens if not overridden.
   * @default false
   */
  lg: N.oneOfType([N.oneOf(["auto"]), N.number, N.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `md` breakpoint and wider screens if not overridden.
   * @default false
   */
  md: N.oneOfType([N.oneOf(["auto"]), N.number, N.bool]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: N.oneOfType([N.arrayOf(N.oneOfType([N.number, N.string])), N.number, N.object, N.string]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `sm` breakpoint and wider screens if not overridden.
   * @default false
   */
  sm: N.oneOfType([N.oneOf(["auto"]), N.number, N.bool]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: N.oneOfType([N.arrayOf(N.oneOfType([N.number, N.string])), N.number, N.object, N.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: N.oneOf(["nowrap", "wrap-reverse", "wrap"]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `xl` breakpoint and wider screens if not overridden.
   * @default false
   */
  xl: N.oneOfType([N.oneOf(["auto"]), N.number, N.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for all the screen sizes with the lowest priority.
   * @default false
   */
  xs: N.oneOfType([N.oneOf(["auto"]), N.number, N.bool]),
  /**
   * If `true`, it sets `min-width: 0` on the item.
   * Refer to the limitations section of the documentation to better understand the use case.
   * @default false
   */
  zeroMinWidth: N.bool
});
if (process.env.NODE_ENV !== "production") {
  const e = u0e("Grid", pR);
  pR["propTypes"] = ge({}, pR.propTypes, {
    direction: e("container"),
    lg: e("item"),
    md: e("item"),
    sm: e("item"),
    spacing: e("container"),
    wrap: e("container"),
    xs: e("item"),
    zeroMinWidth: e("item")
  });
}
const lY = pR, jYe = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function yW(e) {
  return `scale(${e}, ${e ** 2})`;
}
const LYe = {
  entering: {
    opacity: 1,
    transform: yW(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, cY = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), tK = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    addEndListener: r,
    appear: i = !0,
    children: o,
    easing: a,
    in: s,
    onEnter: u,
    onEntered: l,
    onEntering: f,
    onExit: h,
    onExited: p,
    onExiting: g,
    style: y,
    timeout: b = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: _ = W0e
  } = t, S = ln(t, jYe), C = ae.useRef(), A = ae.useRef(), O = _w(), R = ae.useRef(null), j = jd(R, o.ref, n), $ = (q) => (te) => {
    if (q) {
      const X = R.current;
      te === void 0 ? q(X) : q(X, te);
    }
  }, z = $(f), W = $((q, te) => {
    q0e(q);
    const {
      duration: X,
      delay: Z,
      easing: se
    } = Yj({
      style: y,
      timeout: b,
      easing: a
    }, {
      mode: "enter"
    });
    let H;
    b === "auto" ? (H = O.transitions.getAutoHeightDuration(q.clientHeight), A.current = H) : H = X, q.style.transition = [O.transitions.create("opacity", {
      duration: H,
      delay: Z
    }), O.transitions.create("transform", {
      duration: cY ? H : H * 0.666,
      delay: Z,
      easing: se
    })].join(","), u && u(q, te);
  }), Y = $(l), V = $(g), ee = $((q) => {
    const {
      duration: te,
      delay: X,
      easing: Z
    } = Yj({
      style: y,
      timeout: b,
      easing: a
    }, {
      mode: "exit"
    });
    let se;
    b === "auto" ? (se = O.transitions.getAutoHeightDuration(q.clientHeight), A.current = se) : se = te, q.style.transition = [O.transitions.create("opacity", {
      duration: se,
      delay: X
    }), O.transitions.create("transform", {
      duration: cY ? se : se * 0.666,
      delay: cY ? X : X || se * 0.333,
      easing: Z
    })].join(","), q.style.opacity = 0, q.style.transform = yW(0.75), h && h(q);
  }), K = $(p), Q = (q) => {
    b === "auto" && (C.current = setTimeout(q, A.current || 0)), r && r(R.current, q);
  };
  return ae.useEffect(() => () => {
    clearTimeout(C.current);
  }, []), /* @__PURE__ */ pe.jsx(_, ge({
    appear: i,
    in: s,
    nodeRef: R,
    onEnter: W,
    onEntered: Y,
    onEntering: z,
    onExit: ee,
    onExited: K,
    onExiting: V,
    addEndListener: Q,
    timeout: b === "auto" ? null : b
  }, S, {
    children: (q, te) => /* @__PURE__ */ ae.cloneElement(o, ge({
      style: ge({
        opacity: 0,
        transform: yW(0.75),
        visibility: q === "exited" && !s ? "hidden" : void 0
      }, LYe[q], y, o.props.style),
      ref: j
    }, te))
  }));
});
process.env.NODE_ENV !== "production" && (tK.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: N.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: N.bool,
  /**
   * A single child content element.
   */
  children: Nz.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: N.oneOfType([N.shape({
    enter: N.string,
    exit: N.string
  }), N.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: N.bool,
  /**
   * @ignore
   */
  onEnter: N.func,
  /**
   * @ignore
   */
  onEntered: N.func,
  /**
   * @ignore
   */
  onEntering: N.func,
  /**
   * @ignore
   */
  onExit: N.func,
  /**
   * @ignore
   */
  onExited: N.func,
  /**
   * @ignore
   */
  onExiting: N.func,
  /**
   * @ignore
   */
  style: N.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: N.oneOfType([N.oneOf(["auto"]), N.number, N.shape({
    appear: N.number,
    enter: N.number,
    exit: N.number
  })])
});
tK.muiSupportAuto = !0;
const vW = tK, zYe = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"], FYe = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, i = yi({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, LUe, t);
  return ge({}, t, i);
}, BYe = zt(rF, {
  shouldForwardProp: (e) => yb(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...tF(e, t), !n.disableUnderline && t.underline];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  let r = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (r = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), ge({
    position: "relative"
  }, t.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !t.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(e.vars || e).palette[t.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: e.transitions.create("transform", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${DA.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${DA.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (e.vars || e).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${r}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: e.transitions.create("border-bottom-color", {
        duration: e.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${DA.disabled}, .${DA.error}):before`]: {
      borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${r}`
      }
    },
    [`&.${DA.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
}), UYe = zt(iF, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: nF
})({}), nK = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o, a;
  const s = mi({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: u,
    components: l = {},
    componentsProps: f,
    fullWidth: h = !1,
    inputComponent: p = "input",
    multiline: g = !1,
    slotProps: y,
    slots: b = {},
    type: _ = "text"
  } = s, S = ln(s, zYe), C = FYe(s), O = {
    root: {
      ownerState: {
        disableUnderline: u
      }
    }
  }, R = y ?? f ? ip(y ?? f, O) : O, j = (r = (i = b.root) != null ? i : l.Root) != null ? r : BYe, $ = (o = (a = b.input) != null ? a : l.Input) != null ? o : UYe;
  return /* @__PURE__ */ pe.jsx(oF, ge({
    slots: {
      root: j,
      input: $
    },
    slotProps: R,
    fullWidth: h,
    inputComponent: p,
    multiline: g,
    ref: n,
    type: _
  }, S, {
    classes: C
  }));
});
process.env.NODE_ENV !== "production" && (nK.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: N.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: N.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: N.oneOfType([N.oneOf(["primary", "secondary"]), N.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Input: N.elementType,
    Root: N.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: N.shape({
    input: N.object,
    root: N.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: N.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: N.bool,
  /**
   * If `true`, the `input` will not have an underline.
   */
  disableUnderline: N.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: N.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: N.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: N.bool,
  /**
   * The id of the `input` element.
   */
  id: N.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: N.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: N.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: mb,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: N.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: N.oneOfType([N.number, N.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: N.oneOfType([N.number, N.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: N.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: N.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: N.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: N.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: N.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: N.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: N.oneOfType([N.number, N.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: N.shape({
    input: N.object,
    root: N.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: N.shape({
    input: N.elementType,
    root: N.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: N.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: N.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: N.any
});
nK.muiName = "Input";
const YYe = nK;
function HYe(e) {
  return gi("MuiLink", e);
}
const VYe = fi("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]), WYe = VYe, Rbe = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
}, qYe = (e) => Rbe[e] || e, GYe = ({
  theme: e,
  ownerState: t
}) => {
  const n = qYe(t.color), r = WT(e, `palette.${n}`, !1) || t.color, i = WT(e, `palette.${n}Channel`);
  return "vars" in e && i ? `rgba(${i} / 0.4)` : bs(r, 0.4);
}, QYe = GYe, XYe = ["className", "color", "component", "onBlur", "onFocus", "TypographyClasses", "underline", "variant", "sx"], KYe = (e) => {
  const {
    classes: t,
    component: n,
    focusVisible: r,
    underline: i
  } = e, o = {
    root: ["root", `underline${Xn(i)}`, n === "button" && "button", r && "focusVisible"]
  };
  return yi(o, HYe, t);
}, ZYe = zt(ebe, {
  name: "MuiLink",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`underline${Xn(n.underline)}`], n.component === "button" && t.button];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({}, t.underline === "none" && {
  textDecoration: "none"
}, t.underline === "hover" && {
  textDecoration: "none",
  "&:hover": {
    textDecoration: "underline"
  }
}, t.underline === "always" && ge({
  textDecoration: "underline"
}, t.color !== "inherit" && {
  textDecorationColor: QYe({
    theme: e,
    ownerState: t
  })
}, {
  "&:hover": {
    textDecorationColor: "inherit"
  }
}), t.component === "button" && {
  position: "relative",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${WYe.focusVisible}`]: {
    outline: "auto"
  }
})), kbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiLink"
  }), {
    className: i,
    color: o = "primary",
    component: a = "a",
    onBlur: s,
    onFocus: u,
    TypographyClasses: l,
    underline: f = "always",
    variant: h = "inherit",
    sx: p
  } = r, g = ln(r, XYe), {
    isFocusVisibleRef: y,
    onBlur: b,
    onFocus: _,
    ref: S
  } = Oz(), [C, A] = ae.useState(!1), O = jd(n, S), R = (W) => {
    b(W), y.current === !1 && A(!1), s && s(W);
  }, j = (W) => {
    _(W), y.current === !0 && A(!0), u && u(W);
  }, $ = ge({}, r, {
    color: o,
    component: a,
    focusVisible: C,
    underline: f,
    variant: h
  }), z = KYe($);
  return /* @__PURE__ */ pe.jsx(ZYe, ge({
    color: o,
    className: kn(z.root, i),
    classes: l,
    component: a,
    onBlur: R,
    onFocus: j,
    ref: O,
    ownerState: $,
    variant: h,
    sx: [...Object.keys(Rbe).includes(o) ? [] : [{
      color: o
    }], ...Array.isArray(p) ? p : [p]]
  }, g));
});
process.env.NODE_ENV !== "production" && (kbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The color of the link.
   * @default 'primary'
   */
  color: N.any,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: Dz,
  /**
   * @ignore
   */
  onBlur: N.func,
  /**
   * @ignore
   */
  onFocus: N.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * `classes` prop applied to the [`Typography`](/material-ui/api/typography/) element.
   */
  TypographyClasses: N.object,
  /**
   * Controls when the link should have an underline.
   * @default 'always'
   */
  underline: N.oneOf(["always", "hover", "none"]),
  /**
   * Applies the theme typography styles.
   * @default 'inherit'
   */
  variant: N.oneOfType([N.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), N.string])
});
const JYe = kbe, $be = /* @__PURE__ */ ae.createContext({});
process.env.NODE_ENV !== "production" && ($be.displayName = "ListContext");
const bW = $be;
function eHe(e) {
  return gi("MuiList", e);
}
fi("MuiList", ["root", "padding", "dense", "subheader"]);
const tHe = ["children", "className", "component", "dense", "disablePadding", "subheader"], nHe = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: i
  } = e;
  return yi({
    root: ["root", !n && "padding", r && "dense", i && "subheader"]
  }, eHe, t);
}, rHe = zt("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})(({
  ownerState: e
}) => ge({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !e.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, e.subheader && {
  paddingTop: 0
})), Pbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiList"
  }), {
    children: i,
    className: o,
    component: a = "ul",
    dense: s = !1,
    disablePadding: u = !1,
    subheader: l
  } = r, f = ln(r, tHe), h = ae.useMemo(() => ({
    dense: s
  }), [s]), p = ge({}, r, {
    component: a,
    dense: s,
    disablePadding: u
  }), g = nHe(p);
  return /* @__PURE__ */ pe.jsx(bW.Provider, {
    value: h,
    children: /* @__PURE__ */ pe.jsxs(rHe, ge({
      as: a,
      className: kn(g.root, o),
      ref: n,
      ownerState: p
    }, f, {
      children: [l, i]
    }))
  });
});
process.env.NODE_ENV !== "production" && (Pbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: N.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: N.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: N.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const iHe = Pbe, oHe = fi("MuiListItemIcon", ["root", "alignItemsFlexStart"]), Cle = oHe, aHe = fi("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), Nle = aHe, sHe = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function fY(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function Dle(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function Ibe(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.indexOf(t.keys.join("")) === 0;
}
function OA(e, t, n, r, i, o) {
  let a = !1, s = i(e, t, t ? n : !1);
  for (; s; ) {
    if (s === e.firstChild) {
      if (a)
        return !1;
      a = !0;
    }
    const u = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
    if (!s.hasAttribute("tabindex") || !Ibe(s, o) || u)
      s = i(e, s, n);
    else
      return s.focus(), !0;
  }
  return !1;
}
const jbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: r,
    autoFocus: i = !1,
    autoFocusItem: o = !1,
    children: a,
    className: s,
    disabledItemsFocusable: u = !1,
    disableListWrap: l = !1,
    onKeyDown: f,
    variant: h = "selectedMenu"
  } = t, p = ln(t, sHe), g = ae.useRef(null), y = ae.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  p$(() => {
    i && g.current.focus();
  }, [i]), ae.useImperativeHandle(r, () => ({
    adjustStyleForScrollbar: (A, O) => {
      const R = !g.current.style.width;
      if (A.clientHeight < g.current.clientHeight && R) {
        const j = `${DFe(hS(A))}px`;
        g.current.style[O.direction === "rtl" ? "paddingLeft" : "paddingRight"] = j, g.current.style.width = `calc(100% + ${j})`;
      }
      return g.current;
    }
  }), []);
  const b = (A) => {
    const O = g.current, R = A.key, j = hS(O).activeElement;
    if (R === "ArrowDown")
      A.preventDefault(), OA(O, j, l, u, fY);
    else if (R === "ArrowUp")
      A.preventDefault(), OA(O, j, l, u, Dle);
    else if (R === "Home")
      A.preventDefault(), OA(O, null, l, u, fY);
    else if (R === "End")
      A.preventDefault(), OA(O, null, l, u, Dle);
    else if (R.length === 1) {
      const $ = y.current, z = R.toLowerCase(), W = performance.now();
      $.keys.length > 0 && (W - $.lastTime > 500 ? ($.keys = [], $.repeating = !0, $.previousKeyMatched = !0) : $.repeating && z !== $.keys[0] && ($.repeating = !1)), $.lastTime = W, $.keys.push(z);
      const Y = j && !$.repeating && Ibe(j, $);
      $.previousKeyMatched && (Y || OA(O, j, !1, u, fY, $)) ? A.preventDefault() : $.previousKeyMatched = !1;
    }
    f && f(A);
  }, _ = jd(g, n);
  let S = -1;
  ae.Children.forEach(a, (A, O) => {
    if (!/* @__PURE__ */ ae.isValidElement(A)) {
      S === O && (S += 1, S >= a.length && (S = -1));
      return;
    }
    process.env.NODE_ENV !== "production" && dS.isFragment(A) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), A.props.disabled || (h === "selectedMenu" && A.props.selected || S === -1) && (S = O), S === O && (A.props.disabled || A.props.muiSkipListHighlight || A.type.muiSkipListHighlight) && (S += 1, S >= a.length && (S = -1));
  });
  const C = ae.Children.map(a, (A, O) => {
    if (O === S) {
      const R = {};
      return o && (R.autoFocus = !0), A.props.tabIndex === void 0 && h === "selectedMenu" && (R.tabIndex = 0), /* @__PURE__ */ ae.cloneElement(A, R);
    }
    return A;
  });
  return /* @__PURE__ */ pe.jsx(iHe, ge({
    role: "menu",
    ref: _,
    className: s,
    onKeyDown: b,
    tabIndex: i ? 0 : -1
  }, p, {
    children: C
  }));
});
process.env.NODE_ENV !== "production" && (jbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: N.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: N.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: N.node,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: N.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: N.bool,
  /**
   * @ignore
   */
  onKeyDown: N.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: N.oneOf(["menu", "selectedMenu"])
});
const uHe = jbe;
function lHe(e) {
  return gi("MuiPopover", e);
}
fi("MuiPopover", ["root", "paper"]);
const cHe = ["onEntering"], fHe = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"], dHe = ["slotProps"];
function Ale(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function Ole(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function Rle(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function K3(e) {
  return typeof e == "function" ? e() : e;
}
const hHe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"],
    paper: ["paper"]
  }, lHe, t);
}, pHe = zt(fYe, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), Lbe = zt(v7e, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), zbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o;
  const a = mi({
    props: t,
    name: "MuiPopover"
  }), {
    action: s,
    anchorEl: u,
    anchorOrigin: l = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: f,
    anchorReference: h = "anchorEl",
    children: p,
    className: g,
    container: y,
    elevation: b = 8,
    marginThreshold: _ = 16,
    open: S,
    PaperProps: C = {},
    slots: A,
    slotProps: O,
    transformOrigin: R = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: j = vW,
    transitionDuration: $ = "auto",
    TransitionProps: {
      onEntering: z
    } = {}
  } = a, W = ln(a.TransitionProps, cHe), Y = ln(a, fHe), V = (r = O == null ? void 0 : O.paper) != null ? r : C, ee = ae.useRef(), K = jd(ee, V.ref), Q = ge({}, a, {
    anchorOrigin: l,
    anchorReference: h,
    elevation: b,
    marginThreshold: _,
    externalPaperSlotProps: V,
    transformOrigin: R,
    TransitionComponent: j,
    transitionDuration: $,
    TransitionProps: W
  }), q = hHe(Q), te = ae.useCallback(() => {
    if (h === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (f || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), f;
    const fe = K3(u), Qe = fe && fe.nodeType === 1 ? fe : hS(ee.current).body, $e = Qe.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const pt = Qe.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && pt.top === 0 && pt.left === 0 && pt.right === 0 && pt.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: $e.top + Ale($e, l.vertical),
      left: $e.left + Ole($e, l.horizontal)
    };
  }, [u, l.horizontal, l.vertical, f, h]), X = ae.useCallback((fe) => ({
    vertical: Ale(fe, R.vertical),
    horizontal: Ole(fe, R.horizontal)
  }), [R.horizontal, R.vertical]), Z = ae.useCallback((fe) => {
    const Qe = {
      width: fe.offsetWidth,
      height: fe.offsetHeight
    }, $e = X(Qe);
    if (h === "none")
      return {
        top: null,
        left: null,
        transformOrigin: Rle($e)
      };
    const pt = te();
    let _t = pt.top - $e.vertical, Ot = pt.left - $e.horizontal;
    const mn = _t + Qe.height, jr = Ot + Qe.width, tn = nW(K3(u)), Zt = tn.innerHeight - _, qn = tn.innerWidth - _;
    if (_t < _) {
      const fn = _t - _;
      _t -= fn, $e.vertical += fn;
    } else if (mn > Zt) {
      const fn = mn - Zt;
      _t -= fn, $e.vertical += fn;
    }
    if (process.env.NODE_ENV !== "production" && Qe.height > Zt && Qe.height && Zt && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${Qe.height - Zt}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), Ot < _) {
      const fn = Ot - _;
      Ot -= fn, $e.horizontal += fn;
    } else if (jr > qn) {
      const fn = jr - qn;
      Ot -= fn, $e.horizontal += fn;
    }
    return {
      top: `${Math.round(_t)}px`,
      left: `${Math.round(Ot)}px`,
      transformOrigin: Rle($e)
    };
  }, [u, h, te, X, _]), [se, H] = ae.useState(S), ie = ae.useCallback(() => {
    const fe = ee.current;
    if (!fe)
      return;
    const Qe = Z(fe);
    Qe.top !== null && (fe.style.top = Qe.top), Qe.left !== null && (fe.style.left = Qe.left), fe.style.transformOrigin = Qe.transformOrigin, H(!0);
  }, [Z]), he = (fe, Qe) => {
    z && z(fe, Qe), ie();
  }, ye = () => {
    H(!1);
  };
  ae.useEffect(() => {
    S && ie();
  }), ae.useImperativeHandle(s, () => S ? {
    updatePosition: () => {
      ie();
    }
  } : null, [S, ie]), ae.useEffect(() => {
    if (!S)
      return;
    const fe = s0e(() => {
      ie();
    }), Qe = nW(u);
    return Qe.addEventListener("resize", fe), () => {
      fe.clear(), Qe.removeEventListener("resize", fe);
    };
  }, [u, S, ie]);
  let _e = $;
  $ === "auto" && !j.muiSupportAuto && (_e = void 0);
  const Ne = y || (u ? hS(K3(u)).body : void 0), Oe = (i = A == null ? void 0 : A.root) != null ? i : pHe, ke = (o = A == null ? void 0 : A.paper) != null ? o : Lbe, Me = mS({
    elementType: ke,
    externalSlotProps: ge({}, V, {
      style: se ? V.style : ge({}, V.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation: b,
      ref: K
    },
    ownerState: Q,
    className: kn(q.paper, V == null ? void 0 : V.className)
  }), we = mS({
    elementType: Oe,
    externalSlotProps: (O == null ? void 0 : O.root) || {},
    externalForwardedProps: Y,
    additionalProps: {
      ref: n,
      slotProps: {
        backdrop: {
          invisible: !0
        }
      },
      container: Ne,
      open: S
    },
    ownerState: Q,
    className: kn(q.root, g)
  }), {
    slotProps: Ye
  } = we, ze = ln(we, dHe);
  return /* @__PURE__ */ pe.jsx(Oe, ge({}, ze, !GT(Oe) && {
    slotProps: Ye
  }, {
    children: /* @__PURE__ */ pe.jsx(j, ge({
      appear: !0,
      in: S,
      onEntering: he,
      onExited: ye,
      timeout: _e
    }, W, {
      children: /* @__PURE__ */ pe.jsx(ke, ge({}, Me, {
        children: p
      }))
    }))
  }));
});
process.env.NODE_ENV !== "production" && (zbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: mb,
  /**
   * An HTML element, [PopoverVirtualElement](/material-ui/react-popover/#virtual-element),
   * or a function that returns either.
   * It's used to set the position of the popover.
   */
  anchorEl: KS(N.oneOfType([YT, N.func]), (e) => {
    if (e.open && (!e.anchorReference || e.anchorReference === "anchorEl")) {
      const t = K3(e.anchorEl);
      if (t && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${t}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: N.shape({
    horizontal: N.oneOfType([N.oneOf(["center", "left", "right"]), N.number]).isRequired,
    vertical: N.oneOfType([N.oneOf(["bottom", "center", "top"]), N.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: N.shape({
    left: N.number.isRequired,
    top: N.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: N.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: N.oneOfType([YT, N.func]),
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: sR,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * @default 16
   */
  marginThreshold: N.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: N.func,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   *
   * This prop is an alias for `slotProps.paper` and will be overriden by it if both are used.
   * @deprecated Use `slotProps.paper` instead.
   *
   * @default {}
   */
  PaperProps: N.shape({
    component: Dz
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @default {}
   */
  slotProps: N.shape({
    paper: N.oneOfType([N.func, N.object]),
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * The components used for each slot inside.
   *
   * @default {}
   */
  slots: N.shape({
    paper: N.elementType,
    root: N.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: N.shape({
    horizontal: N.oneOfType([N.oneOf(["center", "left", "right"]), N.number]).isRequired,
    vertical: N.oneOfType([N.oneOf(["bottom", "center", "top"]), N.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: N.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: N.oneOfType([N.oneOf(["auto"]), N.number, N.shape({
    appear: N.number,
    enter: N.number,
    exit: N.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: N.object
});
const gHe = zbe;
function mHe(e) {
  return gi("MuiMenu", e);
}
fi("MuiMenu", ["root", "paper", "list"]);
const yHe = ["onEntering"], vHe = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"], bHe = {
  vertical: "top",
  horizontal: "right"
}, xHe = {
  vertical: "top",
  horizontal: "left"
}, wHe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, mHe, t);
}, _He = zt(gHe, {
  shouldForwardProp: (e) => yb(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), EHe = zt(Lbe, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), SHe = zt(uHe, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (e, t) => t.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), Fbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i;
  const o = mi({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: a = !0,
    children: s,
    className: u,
    disableAutoFocusItem: l = !1,
    MenuListProps: f = {},
    onClose: h,
    open: p,
    PaperProps: g = {},
    PopoverClasses: y,
    transitionDuration: b = "auto",
    TransitionProps: {
      onEntering: _
    } = {},
    variant: S = "selectedMenu",
    slots: C = {},
    slotProps: A = {}
  } = o, O = ln(o.TransitionProps, yHe), R = ln(o, vHe), j = _w(), $ = j.direction === "rtl", z = ge({}, o, {
    autoFocus: a,
    disableAutoFocusItem: l,
    MenuListProps: f,
    onEntering: _,
    PaperProps: g,
    transitionDuration: b,
    TransitionProps: O,
    variant: S
  }), W = wHe(z), Y = a && !l && p, V = ae.useRef(null), ee = (se, H) => {
    V.current && V.current.adjustStyleForScrollbar(se, j), _ && _(se, H);
  }, K = (se) => {
    se.key === "Tab" && (se.preventDefault(), h && h(se, "tabKeyDown"));
  };
  let Q = -1;
  ae.Children.map(s, (se, H) => {
    /* @__PURE__ */ ae.isValidElement(se) && (process.env.NODE_ENV !== "production" && dS.isFragment(se) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), se.props.disabled || (S === "selectedMenu" && se.props.selected || Q === -1) && (Q = H));
  });
  const q = (r = C.paper) != null ? r : EHe, te = (i = A.paper) != null ? i : g, X = mS({
    elementType: C.root,
    externalSlotProps: A.root,
    ownerState: z,
    className: [W.root, u]
  }), Z = mS({
    elementType: q,
    externalSlotProps: te,
    ownerState: z,
    className: W.paper
  });
  return /* @__PURE__ */ pe.jsx(_He, ge({
    onClose: h,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: $ ? "right" : "left"
    },
    transformOrigin: $ ? bHe : xHe,
    slots: {
      paper: q,
      root: C.root
    },
    slotProps: {
      root: X,
      paper: Z
    },
    open: p,
    ref: n,
    transitionDuration: b,
    TransitionProps: ge({
      onEntering: ee
    }, O),
    ownerState: z
  }, R, {
    classes: y,
    children: /* @__PURE__ */ pe.jsx(SHe, ge({
      onKeyDown: K,
      actions: V,
      autoFocus: a && (Q === -1 || l),
      autoFocusItem: Y,
      variant: S
    }, f, {
      className: kn(W.list, f.className),
      children: s
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Fbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: N.oneOfType([YT, N.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: N.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: N.bool,
  /**
   * Props applied to the [`MenuList`](/material-ui/api/menu-list/) element.
   * @default {}
   */
  MenuListProps: N.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: N.func,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: N.object,
  /**
   * `classes` prop applied to the [`Popover`](/material-ui/api/popover/) element.
   */
  PopoverClasses: N.object,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @default {}
   */
  slotProps: N.shape({
    paper: N.oneOfType([N.func, N.object]),
    root: N.oneOfType([N.func, N.object])
  }),
  /**
   * The components used for each slot inside.
   *
   * @default {}
   */
  slots: N.shape({
    paper: N.elementType,
    root: N.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: N.oneOfType([N.oneOf(["auto"]), N.number, N.shape({
    appear: N.number,
    enter: N.number,
    exit: N.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: N.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: N.oneOf(["menu", "selectedMenu"])
});
const MHe = Fbe;
function THe(e) {
  return gi("MuiMenuItem", e);
}
const CHe = fi("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), RA = CHe, NHe = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"], DHe = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, AHe = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: i,
    selected: o,
    classes: a
  } = e, u = yi({
    root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", o && "selected"]
  }, THe, a);
  return ge({}, a, u);
}, OHe = zt(Zz, {
  shouldForwardProp: (e) => yb(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: DHe
})(({
  theme: e,
  ownerState: t
}) => ge({}, e.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !t.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, t.divider && {
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${RA.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : bs(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${RA.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : bs(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${RA.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : bs(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : bs(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  },
  [`&.${RA.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${RA.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${Mle.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${Mle.inset}`]: {
    marginLeft: 52
  },
  [`& .${Nle.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${Nle.inset}`]: {
    paddingLeft: 36
  },
  [`& .${Cle.root}`]: {
    minWidth: 36
  }
}, !t.dense && {
  [e.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, t.dense && ge({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, e.typography.body2, {
  [`& .${Cle.root} svg`]: {
    fontSize: "1.25rem"
  }
}))), Bbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: i = !1,
    component: o = "li",
    dense: a = !1,
    divider: s = !1,
    disableGutters: u = !1,
    focusVisibleClassName: l,
    role: f = "menuitem",
    tabIndex: h,
    className: p
  } = r, g = ln(r, NHe), y = ae.useContext(bW), b = ae.useMemo(() => ({
    dense: a || y.dense || !1,
    disableGutters: u
  }), [y.dense, a, u]), _ = ae.useRef(null);
  p$(() => {
    i && (_.current ? _.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [i]);
  const S = ge({}, r, {
    dense: b.dense,
    divider: s,
    disableGutters: u
  }), C = AHe(r), A = jd(_, n);
  let O;
  return r.disabled || (O = h !== void 0 ? h : -1), /* @__PURE__ */ pe.jsx(bW.Provider, {
    value: b,
    children: /* @__PURE__ */ pe.jsx(OHe, ge({
      ref: A,
      role: f,
      tabIndex: O,
      component: o,
      focusVisibleClassName: kn(C.focusVisible, l),
      className: kn(C.root, p)
    }, g, {
      ownerState: S,
      classes: C
    }))
  });
});
process.env.NODE_ENV !== "production" && (Bbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: N.bool,
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: N.bool,
  /**
   * @ignore
   */
  disabled: N.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: N.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: N.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: N.string,
  /**
   * @ignore
   */
  role: N.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * @default 0
   */
  tabIndex: N.number
});
const RHe = Bbe;
function kHe(e) {
  return gi("MuiNativeSelect", e);
}
const $He = fi("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), rK = $He, PHe = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"], IHe = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: o,
    error: a
  } = e, s = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${Xn(n)}`, o && "iconOpen", r && "disabled"]
  };
  return yi(s, kHe, t);
}, Ube = ({
  ownerState: e,
  theme: t
}) => ge({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": ge({}, t.vars ? {
    backgroundColor: `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: t.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${rK.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (t.vars || t).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, e.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, e.variant === "outlined" && {
  borderRadius: (t.vars || t).shape.borderRadius,
  "&:focus": {
    borderRadius: (t.vars || t).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
}), jHe = zt("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: yb,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${rK.multiple}`]: t.multiple
    }];
  }
})(Ube), Ybe = ({
  ownerState: e,
  theme: t
}) => ge({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (t.vars || t).palette.action.active,
  [`&.${rK.disabled}`]: {
    color: (t.vars || t).palette.action.disabled
  }
}, e.open && {
  transform: "rotate(180deg)"
}, e.variant === "filled" && {
  right: 7
}, e.variant === "outlined" && {
  right: 7
}), LHe = zt("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${Xn(n.variant)}`], n.open && t.iconOpen];
  }
})(Ybe), Hbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    className: r,
    disabled: i,
    error: o,
    IconComponent: a,
    inputRef: s,
    variant: u = "standard"
  } = t, l = ln(t, PHe), f = ge({}, t, {
    disabled: i,
    variant: u,
    error: o
  }), h = IHe(f);
  return /* @__PURE__ */ pe.jsxs(ae.Fragment, {
    children: [/* @__PURE__ */ pe.jsx(jHe, ge({
      ownerState: f,
      className: kn(h.select, r),
      disabled: i,
      ref: s || n
    }, l)), t.multiple ? null : /* @__PURE__ */ pe.jsx(LHe, {
      as: a,
      ownerState: f,
      className: h.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (Hbe.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: N.object,
  /**
   * The CSS class name of the select element.
   */
  className: N.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: N.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: N.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: N.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: mb,
  /**
   * @ignore
   */
  multiple: N.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: N.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: N.func,
  /**
   * The input value.
   */
  value: N.any,
  /**
   * The variant to use.
   */
  variant: N.oneOf(["standard", "outlined", "filled"])
});
const zHe = Hbe;
var kle;
const FHe = ["children", "classes", "className", "label", "notched"], BHe = zt("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), UHe = zt("legend")(({
  ownerState: e,
  theme: t
}) => ge({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !e.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: t.transitions.create("width", {
    duration: 150,
    easing: t.transitions.easing.easeOut
  })
}, e.withLabel && ge({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: t.transitions.create("max-width", {
    duration: 50,
    easing: t.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, e.notched && {
  maxWidth: "100%",
  transition: t.transitions.create("max-width", {
    duration: 100,
    easing: t.transitions.easing.easeOut,
    delay: 50
  })
})));
function Vbe(e) {
  const {
    className: t,
    label: n,
    notched: r
  } = e, i = ln(e, FHe), o = n != null && n !== "", a = ge({}, e, {
    notched: r,
    withLabel: o
  });
  return /* @__PURE__ */ pe.jsx(BHe, ge({
    "aria-hidden": !0,
    className: t,
    ownerState: a
  }, i, {
    children: /* @__PURE__ */ pe.jsx(UHe, {
      ownerState: a,
      children: o ? /* @__PURE__ */ pe.jsx("span", {
        children: n
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        kle || (kle = /* @__PURE__ */ pe.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      )
    })
  }));
}
process.env.NODE_ENV !== "production" && (Vbe.propTypes = {
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The label.
   */
  label: N.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: N.bool.isRequired,
  /**
   * @ignore
   */
  style: N.object
});
const YHe = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"], HHe = (e) => {
  const {
    classes: t
  } = e, r = yi({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, FUe, t);
  return ge({}, t, r);
}, VHe = zt(rF, {
  shouldForwardProp: (e) => yb(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: tF
})(({
  theme: e,
  ownerState: t
}) => {
  const n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return ge({
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${J1.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${J1.notchedOutline}`]: {
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : n
      }
    },
    [`&.${J1.focused} .${J1.notchedOutline}`]: {
      borderColor: (e.vars || e).palette[t.color].main,
      borderWidth: 2
    },
    [`&.${J1.error} .${J1.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.error.main
    },
    [`&.${J1.disabled} .${J1.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.action.disabled
    }
  }, t.startAdornment && {
    paddingLeft: 14
  }, t.endAdornment && {
    paddingRight: 14
  }, t.multiline && ge({
    padding: "16.5px 14px"
  }, t.size === "small" && {
    padding: "8.5px 14px"
  }));
}), WHe = zt(Vbe, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (e, t) => t.notchedOutline
})(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
}), qHe = zt(iF, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: nF
})(({
  theme: e,
  ownerState: t
}) => ge({
  padding: "16.5px 14px"
}, !e.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
    caretColor: e.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, e.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [e.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, t.size === "small" && {
  padding: "8.5px 14px"
}, t.multiline && {
  padding: 0
}, t.startAdornment && {
  paddingLeft: 0
}, t.endAdornment && {
  paddingRight: 0
})), iK = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o, a, s;
  const u = mi({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: l = {},
    fullWidth: f = !1,
    inputComponent: h = "input",
    label: p,
    multiline: g = !1,
    notched: y,
    slots: b = {},
    type: _ = "text"
  } = u, S = ln(u, YHe), C = HHe(u), A = ZX(), O = KX({
    props: u,
    muiFormControl: A,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), R = ge({}, u, {
    color: O.color || "primary",
    disabled: O.disabled,
    error: O.error,
    focused: O.focused,
    formControl: A,
    fullWidth: f,
    hiddenLabel: O.hiddenLabel,
    multiline: g,
    size: O.size,
    type: _
  }), j = (r = (i = b.root) != null ? i : l.Root) != null ? r : VHe, $ = (o = (a = b.input) != null ? a : l.Input) != null ? o : qHe;
  return /* @__PURE__ */ pe.jsx(oF, ge({
    slots: {
      root: j,
      input: $
    },
    renderSuffix: (z) => /* @__PURE__ */ pe.jsx(WHe, {
      ownerState: R,
      className: C.notchedOutline,
      label: p != null && p !== "" && O.required ? s || (s = /* @__PURE__ */ pe.jsxs(ae.Fragment, {
        children: [p, " ", "*"]
      })) : p,
      notched: typeof y < "u" ? y : !!(z.startAdornment || z.filled || z.focused)
    }),
    fullWidth: f,
    inputComponent: h,
    multiline: g,
    ref: n,
    type: _
  }, S, {
    classes: ge({}, C, {
      notchedOutline: null
    })
  }));
});
process.env.NODE_ENV !== "production" && (iK.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: N.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: N.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: N.oneOfType([N.oneOf(["primary", "secondary"]), N.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Input: N.elementType,
    Root: N.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: N.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: N.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: N.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: N.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: N.bool,
  /**
   * The id of the `input` element.
   */
  id: N.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: N.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: N.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: mb,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: N.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: N.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: N.oneOfType([N.number, N.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: N.oneOfType([N.number, N.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: N.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: N.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: N.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: N.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: N.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: N.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: N.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: N.oneOfType([N.number, N.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: N.shape({
    input: N.elementType,
    root: N.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: N.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: N.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: N.any
});
iK.muiName = "Input";
const GHe = iK, $le = ZS(/* @__PURE__ */ pe.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage"), Ple = ZS(/* @__PURE__ */ pe.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
function QHe(e) {
  return gi("MuiSelect", e);
}
const XHe = fi("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), kA = XHe;
var Ile;
const KHe = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"], ZHe = zt("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${kA.select}`]: t.select
      },
      {
        [`&.${kA.select}`]: t[n.variant]
      },
      {
        [`&.${kA.error}`]: t.error
      },
      {
        [`&.${kA.multiple}`]: t.multiple
      }
    ];
  }
})(Ube, {
  // Win specificity over the input base
  [`&.${kA.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), JHe = zt("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${Xn(n.variant)}`], n.open && t.iconOpen];
  }
})(Ybe), eVe = zt("input", {
  shouldForwardProp: (e) => F9e(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (e, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function jle(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function tVe(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const nVe = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: o,
    error: a
  } = e, s = {
    select: ["select", n, r && "disabled", i && "multiple", a && "error"],
    icon: ["icon", `icon${Xn(n)}`, o && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return yi(s, QHe, t);
}, Wbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    "aria-describedby": r,
    "aria-label": i,
    autoFocus: o,
    autoWidth: a,
    children: s,
    className: u,
    defaultOpen: l,
    defaultValue: f,
    disabled: h,
    displayEmpty: p,
    error: g = !1,
    IconComponent: y,
    inputRef: b,
    labelId: _,
    MenuProps: S = {},
    multiple: C,
    name: A,
    onBlur: O,
    onChange: R,
    onClose: j,
    onFocus: $,
    onOpen: z,
    open: W,
    readOnly: Y,
    renderValue: V,
    SelectDisplayProps: ee = {},
    tabIndex: K,
    value: Q,
    variant: q = "standard"
  } = t, te = ln(t, KHe), [X, Z] = Ij({
    controlled: Q,
    default: f,
    name: "Select"
  }), [se, H] = Ij({
    controlled: W,
    default: l,
    name: "Select"
  }), ie = ae.useRef(null), he = ae.useRef(null), [ye, _e] = ae.useState(null), {
    current: Ne
  } = ae.useRef(W != null), [Oe, ke] = ae.useState(), Me = jd(n, b), we = ae.useCallback((We) => {
    he.current = We, We && _e(We);
  }, []), Ye = ye == null ? void 0 : ye.parentNode;
  ae.useImperativeHandle(Me, () => ({
    focus: () => {
      he.current.focus();
    },
    node: ie.current,
    value: X
  }), [X]), ae.useEffect(() => {
    l && se && ye && !Ne && (ke(a ? null : Ye.clientWidth), he.current.focus());
  }, [ye, a]), ae.useEffect(() => {
    o && he.current.focus();
  }, [o]), ae.useEffect(() => {
    if (!_)
      return;
    const We = hS(he.current).getElementById(_);
    if (We) {
      const ht = () => {
        getSelection().isCollapsed && he.current.focus();
      };
      return We.addEventListener("click", ht), () => {
        We.removeEventListener("click", ht);
      };
    }
  }, [_]);
  const ze = (We, ht) => {
    We ? z && z(ht) : j && j(ht), Ne || (ke(a ? null : Ye.clientWidth), H(We));
  }, fe = (We) => {
    We.button === 0 && (We.preventDefault(), he.current.focus(), ze(!0, We));
  }, Qe = (We) => {
    ze(!1, We);
  }, $e = ae.Children.toArray(s), pt = (We) => {
    const ht = $e.find((Ft) => Ft.props.value === We.target.value);
    ht !== void 0 && (Z(ht.props.value), R && R(We, ht));
  }, _t = (We) => (ht) => {
    let Ft;
    if (ht.currentTarget.hasAttribute("tabindex")) {
      if (C) {
        Ft = Array.isArray(X) ? X.slice() : [];
        const _n = X.indexOf(We.props.value);
        _n === -1 ? Ft.push(We.props.value) : Ft.splice(_n, 1);
      } else
        Ft = We.props.value;
      if (We.props.onClick && We.props.onClick(ht), X !== Ft && (Z(Ft), R)) {
        const _n = ht.nativeEvent || ht, Dn = new _n.constructor(_n.type, _n);
        Object.defineProperty(Dn, "target", {
          writable: !0,
          value: {
            value: Ft,
            name: A
          }
        }), R(Dn, We);
      }
      C || ze(!1, ht);
    }
  }, Ot = (We) => {
    Y || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].indexOf(We.key) !== -1 && (We.preventDefault(), ze(!0, We));
  }, mn = ye !== null && se, jr = (We) => {
    !mn && O && (Object.defineProperty(We, "target", {
      writable: !0,
      value: {
        value: X,
        name: A
      }
    }), O(We));
  };
  delete te["aria-invalid"];
  let tn, Zt;
  const qn = [];
  let fn = !1, gr = !1;
  (wbe({
    value: X
  }) || p) && (V ? tn = V(X) : fn = !0);
  const Zn = $e.map((We) => {
    if (!/* @__PURE__ */ ae.isValidElement(We))
      return null;
    process.env.NODE_ENV !== "production" && dS.isFragment(We) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let ht;
    if (C) {
      if (!Array.isArray(X))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : Hx(2));
      ht = X.some((Ft) => jle(Ft, We.props.value)), ht && fn && qn.push(We.props.children);
    } else
      ht = jle(X, We.props.value), ht && fn && (Zt = We.props.children);
    return ht && (gr = !0), /* @__PURE__ */ ae.cloneElement(We, {
      "aria-selected": ht ? "true" : "false",
      onClick: _t(We),
      onKeyUp: (Ft) => {
        Ft.key === " " && Ft.preventDefault(), We.props.onKeyUp && We.props.onKeyUp(Ft);
      },
      role: "option",
      selected: ht,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": We.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && ae.useEffect(() => {
    if (!gr && !C && X !== "") {
      const We = $e.map((ht) => ht.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${X}\` for the select ${A ? `(name="${A}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${We.filter((ht) => ht != null).map((ht) => `\`${ht}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [gr, $e, C, A, X]), fn && (C ? qn.length === 0 ? tn = null : tn = qn.reduce((We, ht, Ft) => (We.push(ht), Ft < qn.length - 1 && We.push(", "), We), []) : tn = Zt);
  let xr = Oe;
  !a && Ne && ye && (xr = Ye.clientWidth);
  let Un;
  typeof K < "u" ? Un = K : Un = h ? null : 0;
  const Qt = ee.id || (A ? `mui-component-select-${A}` : void 0), Ut = ge({}, t, {
    variant: q,
    value: X,
    open: mn,
    error: g
  }), er = nVe(Ut);
  return /* @__PURE__ */ pe.jsxs(ae.Fragment, {
    children: [/* @__PURE__ */ pe.jsx(ZHe, ge({
      ref: we,
      tabIndex: Un,
      role: "button",
      "aria-disabled": h ? "true" : void 0,
      "aria-expanded": mn ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": i,
      "aria-labelledby": [_, Qt].filter(Boolean).join(" ") || void 0,
      "aria-describedby": r,
      onKeyDown: Ot,
      onMouseDown: h || Y ? null : fe,
      onBlur: jr,
      onFocus: $
    }, ee, {
      ownerState: Ut,
      className: kn(ee.className, er.select, u),
      id: Qt,
      children: tVe(tn) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        Ile || (Ile = /* @__PURE__ */ pe.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : tn
    })), /* @__PURE__ */ pe.jsx(eVe, ge({
      "aria-invalid": g,
      value: Array.isArray(X) ? X.join(",") : X,
      name: A,
      ref: ie,
      "aria-hidden": !0,
      onChange: pt,
      tabIndex: -1,
      disabled: h,
      className: er.nativeInput,
      autoFocus: o,
      ownerState: Ut
    }, te)), /* @__PURE__ */ pe.jsx(JHe, {
      as: y,
      className: er.icon,
      ownerState: Ut
    }), /* @__PURE__ */ pe.jsx(MHe, ge({
      id: `menu-${A || ""}`,
      anchorEl: Ye,
      open: mn,
      onClose: Qe,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, S, {
      MenuListProps: ge({
        "aria-labelledby": _,
        role: "listbox",
        disableListWrap: !0
      }, S.MenuListProps),
      PaperProps: ge({}, S.PaperProps, {
        style: ge({
          minWidth: xr
        }, S.PaperProps != null ? S.PaperProps.style : null)
      }),
      children: Zn
    }))]
  });
});
process.env.NODE_ENV !== "production" && (Wbe.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": N.string,
  /**
   * @ignore
   */
  "aria-label": N.string,
  /**
   * @ignore
   */
  autoFocus: N.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: N.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: N.object,
  /**
   * The CSS class name of the select element.
   */
  className: N.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: N.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: N.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: N.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: N.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: N.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: N.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: mb,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: N.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: N.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: N.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: N.string,
  /**
   * @ignore
   */
  onBlur: N.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: N.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: N.func,
  /**
   * @ignore
   */
  onFocus: N.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: N.func,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool,
  /**
   * @ignore
   */
  readOnly: N.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: N.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: N.object,
  /**
   * @ignore
   */
  tabIndex: N.oneOfType([N.number, N.string]),
  /**
   * @ignore
   */
  type: N.any,
  /**
   * The input value.
   */
  value: N.any,
  /**
   * The variant to use.
   */
  variant: N.oneOf(["standard", "outlined", "filled"])
});
const rVe = Wbe, iVe = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], oVe = (e) => {
  const {
    classes: t
  } = e;
  return t;
}, oK = {
  name: "MuiSelect",
  overridesResolver: (e, t) => t.root,
  shouldForwardProp: (e) => yb(e) && e !== "variant",
  slot: "Root"
}, aVe = zt(YYe, oK)(""), sVe = zt(GHe, oK)(""), uVe = zt(_Ye, oK)(""), aK = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: i = !1,
    children: o,
    classes: a = {},
    className: s,
    defaultOpen: u = !1,
    displayEmpty: l = !1,
    IconComponent: f = HUe,
    id: h,
    input: p,
    inputProps: g,
    label: y,
    labelId: b,
    MenuProps: _,
    multiple: S = !1,
    native: C = !1,
    onClose: A,
    onOpen: O,
    open: R,
    renderValue: j,
    SelectDisplayProps: $,
    variant: z = "outlined"
  } = r, W = ln(r, iVe), Y = C ? zHe : rVe, V = ZX(), ee = KX({
    props: r,
    muiFormControl: V,
    states: ["variant", "error"]
  }), K = ee.variant || z, Q = ge({}, r, {
    variant: K,
    classes: a
  }), q = oVe(Q), te = p || {
    standard: /* @__PURE__ */ pe.jsx(aVe, {
      ownerState: Q
    }),
    outlined: /* @__PURE__ */ pe.jsx(sVe, {
      label: y,
      ownerState: Q
    }),
    filled: /* @__PURE__ */ pe.jsx(uVe, {
      ownerState: Q
    })
  }[K], X = jd(n, te.ref);
  return /* @__PURE__ */ pe.jsx(ae.Fragment, {
    children: /* @__PURE__ */ ae.cloneElement(te, ge({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: Y,
      inputProps: ge({
        children: o,
        error: ee.error,
        IconComponent: f,
        variant: K,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: S
      }, C ? {
        id: h
      } : {
        autoWidth: i,
        defaultOpen: u,
        displayEmpty: l,
        labelId: b,
        MenuProps: _,
        onClose: A,
        onOpen: O,
        open: R,
        renderValue: j,
        SelectDisplayProps: ge({
          id: h
        }, $)
      }, g, {
        classes: g ? ip(q, g.classes) : q
      }, p ? p.props.inputProps : {})
    }, S && C && K === "outlined" ? {
      notched: !0
    } : {}, {
      ref: X,
      className: kn(te.props.className, s)
    }, !p && {
      variant: K
    }, W))
  });
});
process.env.NODE_ENV !== "production" && (aK.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: N.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * ⚠️The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: N.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: N.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   * ⚠️ When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: N.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: N.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: N.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: N.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: N.object,
  /**
   * See [OutlinedInput#label](/material-ui/api/outlined-input/#props)
   */
  label: N.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: N.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: N.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: N.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: N.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<Value>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: N.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapses).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: N.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: N.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: N.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: N.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: N.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: N.oneOfType([N.oneOf([""]), N.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: N.oneOf(["filled", "outlined", "standard"])
});
aK.muiName = "Select";
const lVe = aK;
function cVe(e) {
  return gi("MuiTooltip", e);
}
const fVe = fi("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]), Ex = fVe, dVe = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
function hVe(e) {
  return Math.round(e * 1e5) / 1e5;
}
const pVe = (e) => {
  const {
    classes: t,
    disableInteractive: n,
    arrow: r,
    touch: i,
    placement: o
  } = e, a = {
    popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
    tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${Xn(o.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return yi(a, cVe, t);
}, gVe = zt(ybe, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose];
  }
})(({
  theme: e,
  ownerState: t,
  open: n
}) => ge({
  zIndex: (e.vars || e).zIndex.tooltip,
  pointerEvents: "none"
}, !t.disableInteractive && {
  pointerEvents: "auto"
}, !n && {
  pointerEvents: "none"
}, t.arrow && {
  [`&[data-popper-placement*="bottom"] .${Ex.arrow}`]: {
    top: 0,
    marginTop: "-0.71em",
    "&::before": {
      transformOrigin: "0 100%"
    }
  },
  [`&[data-popper-placement*="top"] .${Ex.arrow}`]: {
    bottom: 0,
    marginBottom: "-0.71em",
    "&::before": {
      transformOrigin: "100% 0"
    }
  },
  [`&[data-popper-placement*="right"] .${Ex.arrow}`]: ge({}, t.isRtl ? {
    right: 0,
    marginRight: "-0.71em"
  } : {
    left: 0,
    marginLeft: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "100% 100%"
    }
  }),
  [`&[data-popper-placement*="left"] .${Ex.arrow}`]: ge({}, t.isRtl ? {
    left: 0,
    marginLeft: "-0.71em"
  } : {
    right: 0,
    marginRight: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "0 0"
    }
  })
})), mVe = zt("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${Xn(n.placement.split("-")[0])}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : bs(e.palette.grey[700], 0.92),
  borderRadius: (e.vars || e).shape.borderRadius,
  color: (e.vars || e).palette.common.white,
  fontFamily: e.typography.fontFamily,
  padding: "4px 8px",
  fontSize: e.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: e.typography.fontWeightMedium
}, t.arrow && {
  position: "relative",
  margin: 0
}, t.touch && {
  padding: "8px 16px",
  fontSize: e.typography.pxToRem(14),
  lineHeight: `${hVe(16 / 14)}em`,
  fontWeight: e.typography.fontWeightRegular
}, {
  [`.${Ex.popper}[data-popper-placement*="left"] &`]: ge({
    transformOrigin: "right center"
  }, t.isRtl ? ge({
    marginLeft: "14px"
  }, t.touch && {
    marginLeft: "24px"
  }) : ge({
    marginRight: "14px"
  }, t.touch && {
    marginRight: "24px"
  })),
  [`.${Ex.popper}[data-popper-placement*="right"] &`]: ge({
    transformOrigin: "left center"
  }, t.isRtl ? ge({
    marginRight: "14px"
  }, t.touch && {
    marginRight: "24px"
  }) : ge({
    marginLeft: "14px"
  }, t.touch && {
    marginLeft: "24px"
  })),
  [`.${Ex.popper}[data-popper-placement*="top"] &`]: ge({
    transformOrigin: "center bottom",
    marginBottom: "14px"
  }, t.touch && {
    marginBottom: "24px"
  }),
  [`.${Ex.popper}[data-popper-placement*="bottom"] &`]: ge({
    transformOrigin: "center top",
    marginTop: "14px"
  }, t.touch && {
    marginTop: "24px"
  })
})), yVe = zt("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (e, t) => t.arrow
})(({
  theme: e
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: e.vars ? e.vars.palette.Tooltip.bg : bs(e.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
}));
let AI = !1, dY = null, $A = {
  x: 0,
  y: 0
};
function OI(e, t) {
  return (n) => {
    t && t(n), e(n);
  };
}
const qbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  var r, i, o, a, s, u, l, f, h, p, g, y, b, _, S, C, A, O, R;
  const j = mi({
    props: t,
    name: "MuiTooltip"
  }), {
    arrow: $ = !1,
    children: z,
    components: W = {},
    componentsProps: Y = {},
    describeChild: V = !1,
    disableFocusListener: ee = !1,
    disableHoverListener: K = !1,
    disableInteractive: Q = !1,
    disableTouchListener: q = !1,
    enterDelay: te = 100,
    enterNextDelay: X = 0,
    enterTouchDelay: Z = 700,
    followCursor: se = !1,
    id: H,
    leaveDelay: ie = 0,
    leaveTouchDelay: he = 1500,
    onClose: ye,
    onOpen: _e,
    open: Ne,
    placement: Oe = "bottom",
    PopperComponent: ke,
    PopperProps: Me = {},
    slotProps: we = {},
    slots: Ye = {},
    title: ze,
    TransitionComponent: fe = vW,
    TransitionProps: Qe
  } = j, $e = ln(j, dVe), pt = /* @__PURE__ */ ae.isValidElement(z) ? z : /* @__PURE__ */ pe.jsx("span", {
    children: z
  }), _t = _w(), Ot = _t.direction === "rtl", [mn, jr] = ae.useState(), [tn, Zt] = ae.useState(null), qn = ae.useRef(!1), fn = Q || se, gr = ae.useRef(), Zn = ae.useRef(), xr = ae.useRef(), Un = ae.useRef(), [Qt, Ut] = Ij({
    controlled: Ne,
    default: !1,
    name: "Tooltip",
    state: "open"
  });
  let er = Qt;
  if (process.env.NODE_ENV !== "production") {
    const {
      current: nn
    } = ae.useRef(Ne !== void 0);
    ae.useEffect(() => {
      mn && mn.disabled && !nn && ze !== "" && mn.tagName.toLowerCase() === "button" && console.error(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
`));
    }, [ze, mn, nn]);
  }
  const We = Pj(H), ht = ae.useRef(), Ft = ae.useCallback(() => {
    ht.current !== void 0 && (document.body.style.WebkitUserSelect = ht.current, ht.current = void 0), clearTimeout(Un.current);
  }, []);
  ae.useEffect(() => () => {
    clearTimeout(gr.current), clearTimeout(Zn.current), clearTimeout(xr.current), Ft();
  }, [Ft]);
  const _n = (nn) => {
    clearTimeout(dY), AI = !0, Ut(!0), _e && !er && _e(nn);
  }, Dn = uT(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (nn) => {
      clearTimeout(dY), dY = setTimeout(() => {
        AI = !1;
      }, 800 + ie), Ut(!1), ye && er && ye(nn), clearTimeout(gr.current), gr.current = setTimeout(() => {
        qn.current = !1;
      }, _t.transitions.duration.shortest);
    }
  ), di = (nn) => {
    qn.current && nn.type !== "touchstart" || (mn && mn.removeAttribute("title"), clearTimeout(Zn.current), clearTimeout(xr.current), te || AI && X ? Zn.current = setTimeout(() => {
      _n(nn);
    }, AI ? X : te) : _n(nn));
  }, bi = (nn) => {
    clearTimeout(Zn.current), clearTimeout(xr.current), xr.current = setTimeout(() => {
      Dn(nn);
    }, ie);
  }, {
    isFocusVisibleRef: ua,
    onBlur: Zr,
    onFocus: Wa,
    ref: Lr
  } = Oz(), [, Ar] = ae.useState(!1), Ks = (nn) => {
    Zr(nn), ua.current === !1 && (Ar(!1), bi(nn));
  }, ws = (nn) => {
    mn || jr(nn.currentTarget), Wa(nn), ua.current === !0 && (Ar(!0), di(nn));
  }, Ql = (nn) => {
    qn.current = !0;
    const Oi = pt.props;
    Oi.onTouchStart && Oi.onTouchStart(nn);
  }, Lc = di, zc = bi, Xl = (nn) => {
    Ql(nn), clearTimeout(xr.current), clearTimeout(gr.current), Ft(), ht.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", Un.current = setTimeout(() => {
      document.body.style.WebkitUserSelect = ht.current, di(nn);
    }, Z);
  }, Fc = (nn) => {
    pt.props.onTouchEnd && pt.props.onTouchEnd(nn), Ft(), clearTimeout(xr.current), xr.current = setTimeout(() => {
      Dn(nn);
    }, he);
  };
  ae.useEffect(() => {
    if (!er)
      return;
    function nn(Oi) {
      (Oi.key === "Escape" || Oi.key === "Esc") && Dn(Oi);
    }
    return document.addEventListener("keydown", nn), () => {
      document.removeEventListener("keydown", nn);
    };
  }, [Dn, er]);
  const _s = jd(pt.ref, Lr, jr, n);
  !ze && ze !== 0 && (er = !1);
  const as = ae.useRef(), Es = (nn) => {
    const Oi = pt.props;
    Oi.onMouseMove && Oi.onMouseMove(nn), $A = {
      x: nn.clientX,
      y: nn.clientY
    }, as.current && as.current.update();
  }, xa = {}, la = typeof ze == "string";
  V ? (xa.title = !er && la && !K ? ze : null, xa["aria-describedby"] = er ? We : null) : (xa["aria-label"] = la ? ze : null, xa["aria-labelledby"] = er && !la ? We : null);
  const Hi = ge({}, xa, $e, pt.props, {
    className: kn($e.className, pt.props.className),
    onTouchStart: Ql,
    ref: _s
  }, se ? {
    onMouseMove: Es
  } : {});
  process.env.NODE_ENV !== "production" && (Hi["data-mui-internal-clone-element"] = !0, ae.useEffect(() => {
    mn && !mn.getAttribute("data-mui-internal-clone-element") && console.error(["MUI: The `children` component of the Tooltip is not forwarding its props correctly.", "Please make sure that props are spread on the same element that the ref is applied to."].join(`
`));
  }, [mn]));
  const ss = {};
  q || (Hi.onTouchStart = Xl, Hi.onTouchEnd = Fc), K || (Hi.onMouseOver = OI(Lc, Hi.onMouseOver), Hi.onMouseLeave = OI(zc, Hi.onMouseLeave), fn || (ss.onMouseOver = Lc, ss.onMouseLeave = zc)), ee || (Hi.onFocus = OI(ws, Hi.onFocus), Hi.onBlur = OI(Ks, Hi.onBlur), fn || (ss.onFocus = ws, ss.onBlur = Ks)), process.env.NODE_ENV !== "production" && pt.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${pt.props.title}\` or the Tooltip component.`].join(`
`));
  const xe = ae.useMemo(() => {
    var nn;
    let Oi = [{
      name: "arrow",
      enabled: !!tn,
      options: {
        element: tn,
        padding: 4
      }
    }];
    return (nn = Me.popperOptions) != null && nn.modifiers && (Oi = Oi.concat(Me.popperOptions.modifiers)), ge({}, Me.popperOptions, {
      modifiers: Oi
    });
  }, [tn, Me]), lt = ge({}, j, {
    isRtl: Ot,
    arrow: $,
    disableInteractive: fn,
    placement: Oe,
    PopperComponentProp: ke,
    touch: qn.current
  }), St = pVe(lt), $t = (r = (i = Ye.popper) != null ? i : W.Popper) != null ? r : gVe, In = (o = (a = (s = Ye.transition) != null ? s : W.Transition) != null ? a : fe) != null ? o : vW, lr = (u = (l = Ye.tooltip) != null ? l : W.Tooltip) != null ? u : mVe, zn = (f = (h = Ye.arrow) != null ? h : W.Arrow) != null ? f : yVe, sn = SO($t, ge({}, Me, (p = we.popper) != null ? p : Y.popper, {
    className: kn(St.popper, Me == null ? void 0 : Me.className, (g = (y = we.popper) != null ? y : Y.popper) == null ? void 0 : g.className)
  }), lt), No = SO(In, ge({}, Qe, (b = we.transition) != null ? b : Y.transition), lt), xi = SO(lr, ge({}, (_ = we.tooltip) != null ? _ : Y.tooltip, {
    className: kn(St.tooltip, (S = (C = we.tooltip) != null ? C : Y.tooltip) == null ? void 0 : S.className)
  }), lt), wi = SO(zn, ge({}, (A = we.arrow) != null ? A : Y.arrow, {
    className: kn(St.arrow, (O = (R = we.arrow) != null ? R : Y.arrow) == null ? void 0 : O.className)
  }), lt);
  return /* @__PURE__ */ pe.jsxs(ae.Fragment, {
    children: [/* @__PURE__ */ ae.cloneElement(pt, Hi), /* @__PURE__ */ pe.jsx($t, ge({
      as: ke ?? ybe,
      placement: Oe,
      anchorEl: se ? {
        getBoundingClientRect: () => ({
          top: $A.y,
          left: $A.x,
          right: $A.x,
          bottom: $A.y,
          width: 0,
          height: 0
        })
      } : mn,
      popperRef: as,
      open: mn ? er : !1,
      id: We,
      transition: !0
    }, ss, sn, {
      popperOptions: xe,
      children: ({
        TransitionProps: nn
      }) => /* @__PURE__ */ pe.jsx(In, ge({
        timeout: _t.transitions.duration.shorter
      }, nn, No, {
        children: /* @__PURE__ */ pe.jsxs(lr, ge({}, xi, {
          children: [ze, $ ? /* @__PURE__ */ pe.jsx(zn, ge({}, wi, {
            ref: Zt
          })) : null]
        }))
      }))
    }))]
  });
});
process.env.NODE_ENV !== "production" && (qbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, adds an arrow to the tooltip.
   * @default false
   */
  arrow: N.bool,
  /**
   * Tooltip reference element.
   */
  children: Nz.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: N.shape({
    Arrow: N.elementType,
    Popper: N.elementType,
    Tooltip: N.elementType,
    Transition: N.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: N.shape({
    arrow: N.object,
    popper: N.object,
    tooltip: N.object,
    transition: N.object
  }),
  /**
   * Set to `true` if the `title` acts as an accessible description.
   * By default the `title` acts as an accessible label for the child.
   * @default false
   */
  describeChild: N.bool,
  /**
   * Do not respond to focus-visible events.
   * @default false
   */
  disableFocusListener: N.bool,
  /**
   * Do not respond to hover events.
   * @default false
   */
  disableHoverListener: N.bool,
  /**
   * Makes a tooltip not interactive, i.e. it will close when the user
   * hovers over the tooltip before the `leaveDelay` is expired.
   * @default false
   */
  disableInteractive: N.bool,
  /**
   * Do not respond to long press touch events.
   * @default false
   */
  disableTouchListener: N.bool,
  /**
   * The number of milliseconds to wait before showing the tooltip.
   * This prop won't impact the enter touch delay (`enterTouchDelay`).
   * @default 100
   */
  enterDelay: N.number,
  /**
   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
   * @default 0
   */
  enterNextDelay: N.number,
  /**
   * The number of milliseconds a user must touch the element before showing the tooltip.
   * @default 700
   */
  enterTouchDelay: N.number,
  /**
   * If `true`, the tooltip follow the cursor over the wrapped element.
   * @default false
   */
  followCursor: N.bool,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: N.string,
  /**
   * The number of milliseconds to wait before hiding the tooltip.
   * This prop won't impact the leave touch delay (`leaveTouchDelay`).
   * @default 0
   */
  leaveDelay: N.number,
  /**
   * The number of milliseconds after the user stops touching an element before hiding the tooltip.
   * @default 1500
   */
  leaveTouchDelay: N.number,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onClose: N.func,
  /**
   * Callback fired when the component requests to be open.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onOpen: N.func,
  /**
   * If `true`, the component is shown.
   */
  open: N.bool,
  /**
   * Tooltip placement.
   * @default 'bottom'
   */
  placement: N.oneOf(["bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * The component used for the popper.
   * @default Popper
   */
  PopperComponent: N.elementType,
  /**
   * Props applied to the [`Popper`](/material-ui/api/popper/) element.
   * @default {}
   */
  PopperProps: N.object,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: N.shape({
    arrow: N.object,
    popper: N.object,
    tooltip: N.object,
    transition: N.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: N.shape({
    arrow: N.elementType,
    popper: N.elementType,
    tooltip: N.elementType,
    transition: N.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.
   */
  title: N.node,
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: N.elementType,
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   */
  TransitionProps: N.object
});
const Gbe = qbe, Qbe = /* @__PURE__ */ ae.createContext();
process.env.NODE_ENV !== "production" && (Qbe.displayName = "TableContext");
const Xbe = Qbe;
function vVe(e) {
  return gi("MuiTable", e);
}
fi("MuiTable", ["root", "stickyHeader"]);
const bVe = ["className", "component", "padding", "size", "stickyHeader"], xVe = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return yi({
    root: ["root", n && "stickyHeader"]
  }, vVe, t);
}, wVe = zt("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": ge({}, e.typography.body2, {
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  })
}, t.stickyHeader && {
  borderCollapse: "separate"
})), Lle = "table", Kbe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTable"
  }), {
    className: i,
    component: o = Lle,
    padding: a = "normal",
    size: s = "medium",
    stickyHeader: u = !1
  } = r, l = ln(r, bVe), f = ge({}, r, {
    component: o,
    padding: a,
    size: s,
    stickyHeader: u
  }), h = xVe(f), p = ae.useMemo(() => ({
    padding: a,
    size: s,
    stickyHeader: u
  }), [a, s, u]);
  return /* @__PURE__ */ pe.jsx(Xbe.Provider, {
    value: p,
    children: /* @__PURE__ */ pe.jsx(wVe, ge({
      as: o,
      role: o === Lle ? null : "table",
      ref: n,
      className: kn(h.root, i),
      ownerState: f
    }, l))
  });
});
process.env.NODE_ENV !== "production" && (Kbe.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the table, normally `TableHead` and `TableBody`.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * Allows TableCells to inherit padding of the Table.
   * @default 'normal'
   */
  padding: N.oneOf(["checkbox", "none", "normal"]),
  /**
   * Allows TableCells to inherit size of the Table.
   * @default 'medium'
   */
  size: N.oneOfType([N.oneOf(["medium", "small"]), N.string]),
  /**
   * Set the header sticky.
   *
   * ⚠️ It doesn't work with IE11.
   * @default false
   */
  stickyHeader: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const Zbe = Kbe, Jbe = /* @__PURE__ */ ae.createContext();
process.env.NODE_ENV !== "production" && (Jbe.displayName = "Tablelvl2Context");
const w$ = Jbe;
function _Ve(e) {
  return gi("MuiTableBody", e);
}
fi("MuiTableBody", ["root"]);
const EVe = ["className", "component"], SVe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"]
  }, _Ve, t);
}, MVe = zt("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-row-group"
}), TVe = {
  variant: "body"
}, zle = "tbody", e1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableBody"
  }), {
    className: i,
    component: o = zle
  } = r, a = ln(r, EVe), s = ge({}, r, {
    component: o
  }), u = SVe(s);
  return /* @__PURE__ */ pe.jsx(w$.Provider, {
    value: TVe,
    children: /* @__PURE__ */ pe.jsx(MVe, ge({
      className: kn(u.root, i),
      as: o,
      ref: n,
      role: o === zle ? null : "rowgroup",
      ownerState: s
    }, a))
  });
});
process.env.NODE_ENV !== "production" && (e1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally `TableRow`.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const t1e = e1e;
function CVe(e) {
  return gi("MuiTableCell", e);
}
const NVe = fi("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), DVe = NVe, AVe = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"], OVe = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: i,
    size: o,
    stickyHeader: a
  } = e, s = {
    root: ["root", n, a && "stickyHeader", r !== "inherit" && `align${Xn(r)}`, i !== "normal" && `padding${Xn(i)}`, `size${Xn(o)}`]
  };
  return yi(s, CVe, t);
}, RVe = zt("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${Xn(n.size)}`], n.padding !== "normal" && t[`padding${Xn(n.padding)}`], n.align !== "inherit" && t[`align${Xn(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({}, e.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? j0e(bs(e.palette.divider, 1), 0.88) : Fj(bs(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, t.variant === "head" && {
  color: (e.vars || e).palette.text.primary,
  lineHeight: e.typography.pxToRem(24),
  fontWeight: e.typography.fontWeightMedium
}, t.variant === "body" && {
  color: (e.vars || e).palette.text.primary
}, t.variant === "footer" && {
  color: (e.vars || e).palette.text.secondary,
  lineHeight: e.typography.pxToRem(21),
  fontSize: e.typography.pxToRem(12)
}, t.size === "small" && {
  padding: "6px 16px",
  [`&.${DVe.paddingCheckbox}`]: {
    width: 24,
    // prevent the checkbox column from growing
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, t.padding === "checkbox" && {
  width: 48,
  // prevent the checkbox column from growing
  padding: "0 0 0 4px"
}, t.padding === "none" && {
  padding: 0
}, t.align === "left" && {
  textAlign: "left"
}, t.align === "center" && {
  textAlign: "center"
}, t.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, t.align === "justify" && {
  textAlign: "justify"
}, t.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (e.vars || e).palette.background.default
})), n1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableCell"
  }), {
    align: i = "inherit",
    className: o,
    component: a,
    padding: s,
    scope: u,
    size: l,
    sortDirection: f,
    variant: h
  } = r, p = ln(r, AVe), g = ae.useContext(Xbe), y = ae.useContext(w$), b = y && y.variant === "head";
  let _;
  a ? _ = a : _ = b ? "th" : "td";
  let S = u;
  _ === "td" ? S = void 0 : !S && b && (S = "col");
  const C = h || y && y.variant, A = ge({}, r, {
    align: i,
    component: _,
    padding: s || (g && g.padding ? g.padding : "normal"),
    size: l || (g && g.size ? g.size : "medium"),
    sortDirection: f,
    stickyHeader: C === "head" && g && g.stickyHeader,
    variant: C
  }), O = OVe(A);
  let R = null;
  return f && (R = f === "asc" ? "ascending" : "descending"), /* @__PURE__ */ pe.jsx(RVe, ge({
    as: _,
    ref: n,
    className: kn(O.root, o),
    "aria-sort": R,
    scope: S,
    ownerState: A
  }, p));
});
process.env.NODE_ENV !== "production" && (n1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the table cell content.
   *
   * Monetary or generally number fields **should be right aligned** as that allows
   * you to add them up quickly in your head without having to worry about decimals.
   * @default 'inherit'
   */
  align: N.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * Sets the padding applied to the cell.
   * The prop defaults to the value (`'default'`) inherited from the parent Table component.
   */
  padding: N.oneOf(["checkbox", "none", "normal"]),
  /**
   * Set scope attribute.
   */
  scope: N.string,
  /**
   * Specify the size of the cell.
   * The prop defaults to the value (`'medium'`) inherited from the parent Table component.
   */
  size: N.oneOfType([N.oneOf(["medium", "small"]), N.string]),
  /**
   * Set aria-sort direction.
   */
  sortDirection: N.oneOf(["asc", "desc", !1]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * Specify the cell type.
   * The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components.
   */
  variant: N.oneOfType([N.oneOf(["body", "footer", "head"]), N.string])
});
const eC = n1e;
function kVe(e) {
  return gi("MuiTableContainer", e);
}
fi("MuiTableContainer", ["root"]);
const $Ve = ["className", "component"], PVe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"]
  }, kVe, t);
}, IVe = zt("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  width: "100%",
  overflowX: "auto"
}), r1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableContainer"
  }), {
    className: i,
    component: o = "div"
  } = r, a = ln(r, $Ve), s = ge({}, r, {
    component: o
  }), u = PVe(s);
  return /* @__PURE__ */ pe.jsx(IVe, ge({
    ref: n,
    as: o,
    className: kn(u.root, i),
    ownerState: s
  }, a));
});
process.env.NODE_ENV !== "production" && (r1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally `Table`.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const jVe = r1e;
function LVe(e) {
  return gi("MuiTableFooter", e);
}
fi("MuiTableFooter", ["root"]);
const zVe = ["className", "component"], FVe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"]
  }, LVe, t);
}, BVe = zt("tfoot", {
  name: "MuiTableFooter",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-footer-group"
}), UVe = {
  variant: "footer"
}, Fle = "tfoot", i1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableFooter"
  }), {
    className: i,
    component: o = Fle
  } = r, a = ln(r, zVe), s = ge({}, r, {
    component: o
  }), u = FVe(s);
  return /* @__PURE__ */ pe.jsx(w$.Provider, {
    value: UVe,
    children: /* @__PURE__ */ pe.jsx(BVe, ge({
      as: o,
      className: kn(u.root, i),
      ref: n,
      role: o === Fle ? null : "rowgroup",
      ownerState: s
    }, a))
  });
});
process.env.NODE_ENV !== "production" && (i1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally `TableRow`.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const YVe = i1e;
function HVe(e) {
  return gi("MuiTableHead", e);
}
fi("MuiTableHead", ["root"]);
const VVe = ["className", "component"], WVe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"]
  }, HVe, t);
}, qVe = zt("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-header-group"
}), GVe = {
  variant: "head"
}, Ble = "thead", o1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableHead"
  }), {
    className: i,
    component: o = Ble
  } = r, a = ln(r, VVe), s = ge({}, r, {
    component: o
  }), u = WVe(s);
  return /* @__PURE__ */ pe.jsx(w$.Provider, {
    value: GVe,
    children: /* @__PURE__ */ pe.jsx(qVe, ge({
      as: o,
      className: kn(u.root, i),
      ref: n,
      role: o === Ble ? null : "rowgroup",
      ownerState: s
    }, a))
  });
});
process.env.NODE_ENV !== "production" && (o1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally `TableRow`.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const a1e = o1e;
function QVe(e) {
  return gi("MuiToolbar", e);
}
fi("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const XVe = ["className", "component", "disableGutters", "variant"], KVe = (e) => {
  const {
    classes: t,
    disableGutters: n,
    variant: r
  } = e;
  return yi({
    root: ["root", !n && "gutters", r]
  }, QVe, t);
}, ZVe = zt("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disableGutters && t.gutters, t[n.variant]];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !t.disableGutters && {
  paddingLeft: e.spacing(2),
  paddingRight: e.spacing(2),
  [e.breakpoints.up("sm")]: {
    paddingLeft: e.spacing(3),
    paddingRight: e.spacing(3)
  }
}, t.variant === "dense" && {
  minHeight: 48
}), ({
  theme: e,
  ownerState: t
}) => t.variant === "regular" && e.mixins.toolbar), s1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiToolbar"
  }), {
    className: i,
    component: o = "div",
    disableGutters: a = !1,
    variant: s = "regular"
  } = r, u = ln(r, XVe), l = ge({}, r, {
    component: o,
    disableGutters: a,
    variant: s
  }), f = KVe(l);
  return /* @__PURE__ */ pe.jsx(ZVe, ge({
    as: o,
    className: kn(f.root, i),
    ref: n,
    ownerState: l
  }, u));
});
process.env.NODE_ENV !== "production" && (s1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The Toolbar children, usually a mixture of `IconButton`, `Button` and `Typography`.
   * The Toolbar is a flex container, allowing flex item properties to be used to lay out the children.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, disables gutter padding.
   * @default false
   */
  disableGutters: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object]),
  /**
   * The variant to use.
   * @default 'regular'
   */
  variant: N.oneOfType([N.oneOf(["dense", "regular"]), N.string])
});
const JVe = s1e, Ule = ZS(/* @__PURE__ */ pe.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft"), Yle = ZS(/* @__PURE__ */ pe.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
var Hle, Vle, Wle, qle, Gle, Qle, Xle, Kle;
const eWe = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"], u1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const {
    backIconButtonProps: r,
    count: i,
    getItemAriaLabel: o,
    nextIconButtonProps: a,
    onPageChange: s,
    page: u,
    rowsPerPage: l,
    showFirstButton: f,
    showLastButton: h
  } = t, p = ln(t, eWe), g = _w(), y = (C) => {
    s(C, 0);
  }, b = (C) => {
    s(C, u - 1);
  }, _ = (C) => {
    s(C, u + 1);
  }, S = (C) => {
    s(C, Math.max(0, Math.ceil(i / l) - 1));
  };
  return /* @__PURE__ */ pe.jsxs("div", ge({
    ref: n
  }, p, {
    children: [f && /* @__PURE__ */ pe.jsx(TI, {
      onClick: y,
      disabled: u === 0,
      "aria-label": o("first", u),
      title: o("first", u),
      children: g.direction === "rtl" ? Hle || (Hle = /* @__PURE__ */ pe.jsx(Ple, {})) : Vle || (Vle = /* @__PURE__ */ pe.jsx($le, {}))
    }), /* @__PURE__ */ pe.jsx(TI, ge({
      onClick: b,
      disabled: u === 0,
      color: "inherit",
      "aria-label": o("previous", u),
      title: o("previous", u)
    }, r, {
      children: g.direction === "rtl" ? Wle || (Wle = /* @__PURE__ */ pe.jsx(Yle, {})) : qle || (qle = /* @__PURE__ */ pe.jsx(Ule, {}))
    })), /* @__PURE__ */ pe.jsx(TI, ge({
      onClick: _,
      disabled: i !== -1 ? u >= Math.ceil(i / l) - 1 : !1,
      color: "inherit",
      "aria-label": o("next", u),
      title: o("next", u)
    }, a, {
      children: g.direction === "rtl" ? Gle || (Gle = /* @__PURE__ */ pe.jsx(Ule, {})) : Qle || (Qle = /* @__PURE__ */ pe.jsx(Yle, {}))
    })), h && /* @__PURE__ */ pe.jsx(TI, {
      onClick: S,
      disabled: u >= Math.ceil(i / l) - 1,
      "aria-label": o("last", u),
      title: o("last", u),
      children: g.direction === "rtl" ? Xle || (Xle = /* @__PURE__ */ pe.jsx($le, {})) : Kle || (Kle = /* @__PURE__ */ pe.jsx(Ple, {}))
    })]
  }));
});
process.env.NODE_ENV !== "production" && (u1e.propTypes = {
  /**
   * Props applied to the back arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  backIconButtonProps: N.object,
  /**
   * The total number of rows.
   */
  count: N.number.isRequired,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current page.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   *
   * @param {string} type The link or button type to format ('page' | 'first' | 'last' | 'next' | 'previous'). Defaults to 'page'.
   * @param {number} page The page number to format.
   * @returns {string}
   */
  getItemAriaLabel: N.func.isRequired,
  /**
   * Props applied to the next arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  nextIconButtonProps: N.object,
  /**
   * Callback fired when the page is changed.
   *
   * @param {object} event The event source of the callback.
   * @param {number} page The page selected.
   */
  onPageChange: N.func.isRequired,
  /**
   * The zero-based index of the current page.
   */
  page: N.number.isRequired,
  /**
   * The number of rows per page.
   */
  rowsPerPage: N.number.isRequired,
  /**
   * If `true`, show the first-page button.
   */
  showFirstButton: N.bool.isRequired,
  /**
   * If `true`, show the last-page button.
   */
  showLastButton: N.bool.isRequired
});
const tWe = u1e;
function nWe(e) {
  return gi("MuiTablePagination", e);
}
const rWe = fi("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]), gR = rWe;
var Zle;
const iWe = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"], oWe = zt(eC, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  overflow: "auto",
  color: (e.vars || e).palette.text.primary,
  fontSize: e.typography.pxToRem(14),
  // Increase the specificity to override TableCell.
  "&:last-child": {
    padding: 0
  }
})), aWe = zt(JVe, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (e, t) => ge({
    [`& .${gR.actions}`]: t.actions
  }, t.toolbar)
})(({
  theme: e
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${e.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [e.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${gR.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
})), sWe = zt("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (e, t) => t.spacer
})({
  flex: "1 1 100%"
}), uWe = zt("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (e, t) => t.selectLabel
})(({
  theme: e
}) => ge({}, e.typography.body2, {
  flexShrink: 0
})), lWe = zt(lVe, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (e, t) => ge({
    [`& .${gR.selectIcon}`]: t.selectIcon,
    [`& .${gR.select}`]: t.select
  }, t.input, t.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${gR.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
    // Align <select> on Chrome.
  }
}), cWe = zt(RHe, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (e, t) => t.menuItem
})({}), fWe = zt("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (e, t) => t.displayedRows
})(({
  theme: e
}) => ge({}, e.typography.body2, {
  flexShrink: 0
}));
function dWe({
  from: e,
  to: t,
  count: n
}) {
  return `${e}–${t} of ${n !== -1 ? n : `more than ${t}`}`;
}
function hWe(e) {
  return `Go to ${e} page`;
}
const pWe = (e) => {
  const {
    classes: t
  } = e;
  return yi({
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  }, nWe, t);
}, l1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTablePagination"
  }), {
    ActionsComponent: i = tWe,
    backIconButtonProps: o,
    className: a,
    colSpan: s,
    component: u = eC,
    count: l,
    getItemAriaLabel: f = hWe,
    labelDisplayedRows: h = dWe,
    labelRowsPerPage: p = "Rows per page:",
    nextIconButtonProps: g,
    onPageChange: y,
    onRowsPerPageChange: b,
    page: _,
    rowsPerPage: S,
    rowsPerPageOptions: C = [10, 25, 50, 100],
    SelectProps: A = {},
    showFirstButton: O = !1,
    showLastButton: R = !1
  } = r, j = ln(r, iWe), $ = r, z = pWe($), W = A.native ? "option" : cWe;
  let Y;
  (u === eC || u === "td") && (Y = s || 1e3);
  const V = Pj(A.id), ee = Pj(A.labelId), K = () => l === -1 ? (_ + 1) * S : S === -1 ? l : Math.min(l, (_ + 1) * S);
  return /* @__PURE__ */ pe.jsx(oWe, ge({
    colSpan: Y,
    ref: n,
    as: u,
    ownerState: $,
    className: kn(z.root, a)
  }, j, {
    children: /* @__PURE__ */ pe.jsxs(aWe, {
      className: z.toolbar,
      children: [/* @__PURE__ */ pe.jsx(sWe, {
        className: z.spacer
      }), C.length > 1 && /* @__PURE__ */ pe.jsx(uWe, {
        className: z.selectLabel,
        id: ee,
        children: p
      }), C.length > 1 && /* @__PURE__ */ pe.jsx(lWe, ge({
        variant: "standard"
      }, !A.variant && {
        input: Zle || (Zle = /* @__PURE__ */ pe.jsx(oF, {}))
      }, {
        value: S,
        onChange: b,
        id: V,
        labelId: ee
      }, A, {
        classes: ge({}, A.classes, {
          // TODO v5 remove `classes.input`
          root: kn(z.input, z.selectRoot, (A.classes || {}).root),
          select: kn(z.select, (A.classes || {}).select),
          // TODO v5 remove `selectIcon`
          icon: kn(z.selectIcon, (A.classes || {}).icon)
        }),
        children: C.map((Q) => /* @__PURE__ */ ae.createElement(W, ge({}, !GT(W) && {
          ownerState: $
        }, {
          className: z.menuItem,
          key: Q.label ? Q.label : Q,
          value: Q.value ? Q.value : Q
        }), Q.label ? Q.label : Q))
      })), /* @__PURE__ */ pe.jsx(fWe, {
        className: z.displayedRows,
        children: h({
          from: l === 0 ? 0 : _ * S + 1,
          to: K(),
          count: l === -1 ? -1 : l,
          page: _
        })
      }), /* @__PURE__ */ pe.jsx(i, {
        className: z.actions,
        backIconButtonProps: o,
        count: l,
        nextIconButtonProps: g,
        onPageChange: y,
        page: _,
        rowsPerPage: S,
        showFirstButton: O,
        showLastButton: R,
        getItemAriaLabel: f
      })]
    })
  }));
});
process.env.NODE_ENV !== "production" && (l1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The component used for displaying the actions.
   * Either a string to use a HTML element or a component.
   * @default TablePaginationActions
   */
  ActionsComponent: N.elementType,
  /**
   * Props applied to the back arrow [`IconButton`](/material-ui/api/icon-button/) component.
   */
  backIconButtonProps: N.object,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * @ignore
   */
  colSpan: N.number,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * The total number of rows.
   *
   * To enable server side pagination for an unknown number of items, provide -1.
   */
  count: sR.isRequired,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current page.
   * This is important for screen reader users.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @param {string} type The link or button type to format ('first' | 'last' | 'next' | 'previous').
   * @returns {string}
   * @default function defaultGetAriaLabel(type) {
   *   return `Go to ${type} page`;
   * }
   */
  getItemAriaLabel: N.func,
  /**
   * Customize the displayed rows label. Invoked with a `{ from, to, count, page }`
   * object.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @default function defaultLabelDisplayedRows({ from, to, count }) {
   *   return `${from}–${to} of ${count !== -1 ? count : `more than ${to}`}`;
   * }
   */
  labelDisplayedRows: N.func,
  /**
   * Customize the rows per page label.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @default 'Rows per page:'
   */
  labelRowsPerPage: N.node,
  /**
   * Props applied to the next arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  nextIconButtonProps: N.object,
  /**
   * Callback fired when the page is changed.
   *
   * @param {React.MouseEvent<HTMLButtonElement> | null} event The event source of the callback.
   * @param {number} page The page selected.
   */
  onPageChange: N.func.isRequired,
  /**
   * Callback fired when the number of rows per page is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   */
  onRowsPerPageChange: N.func,
  /**
   * The zero-based index of the current page.
   */
  page: KS(sR.isRequired, (e) => {
    const {
      count: t,
      page: n,
      rowsPerPage: r
    } = e;
    if (t === -1)
      return null;
    const i = Math.max(0, Math.ceil(t / r) - 1);
    return n < 0 || n > i ? new Error(`MUI: The page prop of a TablePagination is out of range (0 to ${i}, but page is ${n}).`) : null;
  }),
  /**
   * The number of rows per page.
   *
   * Set -1 to display all the rows.
   */
  rowsPerPage: sR.isRequired,
  /**
   * Customizes the options of the rows per page select field. If less than two options are
   * available, no select field will be displayed.
   * Use -1 for the value with a custom label to show all the rows.
   * @default [10, 25, 50, 100]
   */
  rowsPerPageOptions: N.arrayOf(N.oneOfType([N.number, N.shape({
    label: N.string.isRequired,
    value: N.number.isRequired
  })]).isRequired),
  /**
   * Props applied to the rows per page [`Select`](/material-ui/api/select/) element.
   * @default {}
   */
  SelectProps: N.object,
  /**
   * If `true`, show the first-page button.
   * @default false
   */
  showFirstButton: N.bool,
  /**
   * If `true`, show the last-page button.
   * @default false
   */
  showLastButton: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const gWe = l1e;
function mWe(e) {
  return gi("MuiTableRow", e);
}
const yWe = fi("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), Jle = yWe, vWe = ["className", "component", "hover", "selected"], bWe = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: i,
    footer: o
  } = e;
  return yi({
    root: ["root", n && "selected", r && "hover", i && "head", o && "footer"]
  }, mWe, t);
}, xWe = zt("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${Jle.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${Jle.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : bs(e.palette.primary.main, e.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : bs(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    }
  }
})), ece = "tr", c1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableRow"
  }), {
    className: i,
    component: o = ece,
    hover: a = !1,
    selected: s = !1
  } = r, u = ln(r, vWe), l = ae.useContext(w$), f = ge({}, r, {
    component: o,
    hover: a,
    selected: s,
    head: l && l.variant === "head",
    footer: l && l.variant === "footer"
  }), h = bWe(f);
  return /* @__PURE__ */ pe.jsx(xWe, ge({
    as: o,
    ref: n,
    className: kn(h.root, i),
    role: o === ece ? null : "row",
    ownerState: f
  }, u));
});
process.env.NODE_ENV !== "production" && (c1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Should be valid <tr> children such as `TableCell`.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: N.elementType,
  /**
   * If `true`, the table row will shade on hover.
   * @default false
   */
  hover: N.bool,
  /**
   * If `true`, the table row will have the selected shading.
   * @default false
   */
  selected: N.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const xW = c1e, wWe = ZS(/* @__PURE__ */ pe.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
function _We(e) {
  return gi("MuiTableSortLabel", e);
}
const EWe = fi("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc"]), hY = EWe, SWe = ["active", "children", "className", "direction", "hideSortIcon", "IconComponent"], MWe = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, i = {
    root: ["root", r && "active"],
    icon: ["icon", `iconDirection${Xn(n)}`]
  };
  return yi(i, _We, t);
}, TWe = zt(Zz, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${hY.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${hY.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${hY.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
})), CWe = zt("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${Xn(n.direction)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => ge({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none"
}, t.direction === "desc" && {
  transform: "rotate(0deg)"
}, t.direction === "asc" && {
  transform: "rotate(180deg)"
})), f1e = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  const r = mi({
    props: t,
    name: "MuiTableSortLabel"
  }), {
    active: i = !1,
    children: o,
    className: a,
    direction: s = "asc",
    hideSortIcon: u = !1,
    IconComponent: l = wWe
  } = r, f = ln(r, SWe), h = ge({}, r, {
    active: i,
    direction: s,
    hideSortIcon: u,
    IconComponent: l
  }), p = MWe(h);
  return /* @__PURE__ */ pe.jsxs(TWe, ge({
    className: kn(p.root, a),
    component: "span",
    disableRipple: !0,
    ownerState: h,
    ref: n
  }, f, {
    children: [o, u && !i ? null : /* @__PURE__ */ pe.jsx(CWe, {
      as: l,
      className: kn(p.icon),
      ownerState: h
    })]
  }));
});
process.env.NODE_ENV !== "production" && (f1e.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the label will have the active styling (should be true for the sorted column).
   * @default false
   */
  active: N.bool,
  /**
   * Label contents, the arrow will be appended automatically.
   */
  children: N.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: N.object,
  /**
   * @ignore
   */
  className: N.string,
  /**
   * The current sort direction.
   * @default 'asc'
   */
  direction: N.oneOf(["asc", "desc"]),
  /**
   * Hide sort icon when active is false.
   * @default false
   */
  hideSortIcon: N.bool,
  /**
   * Sort icon to use.
   * @default ArrowDownwardIcon
   */
  IconComponent: N.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: N.oneOfType([N.arrayOf(N.oneOfType([N.func, N.object, N.bool])), N.func, N.object])
});
const NWe = f1e, DWe = (e, t) => {
  const n = [];
  return e.forEach((i) => {
    n.push(i[t]);
  }), n.reduce((i, o) => Math.max(i, o), -1 / 0);
}, AWe = (e, t) => {
  const n = [], r = ar.get(t, jze, []), i = ar.get(t, Lze, []), o = r.concat(i), a = o.length;
  return o.forEach((s) => {
    const u = ar.get(s, "sorting.isEnabled", !0), l = ar.get(s, "indicator.indicatorType", "none"), f = ar.get(
      s,
      "indicator.indicatorColor",
      Bze
    ), h = {
      ...s,
      id: s.path.toUpperCase(),
      label: s.label,
      minColumnWidth: 740 / a,
      isSortingEnabled: u,
      indicatorType: l,
      indicatorColor: f
    }, p = e && e[0];
    for (let [g, y] of Object.entries(p))
      (g.toLowerCase() === s.path || g === s.path) && //If the array item at records[0] has number or null value, find max value of column
      (typeof y === _X || y === null) && (h[Ize] = DWe(e, g)), g === oue && (h[oue] = y);
    n.push(h);
  }), n;
}, sK = (e) => e >= 0 ? e.toLocaleString("en-US") : $x, d1e = (e) => {
  const t = Number(e.replaceAll(",", "")), n = "M", r = "K";
  return t >= 999950 ? `${(t / 1e6).toFixed(1).replace(/\.0$/, "")}${n}` : t >= 1e3 && t <= 999949 ? `${(t / 1e3).toFixed(1).replace(/\.0$/, "")}${r}` : t.toFixed(1).replace(/\.0$/, "");
}, OWe = (e, t, n) => {
  const r = ar.get(e, `${t}.records[0].${n}`);
  return typeof r === _X ? sK(r) : r || $x;
}, h1e = (e, t) => e.includes("${Data(") ? RWe(e, t) : e, RWe = (e, t) => {
  let n = "";
  return e.replace(/\${/g, "DELIMETER${").split("DELIMETER").forEach((o) => {
    if (o.includes("${Data(")) {
      const a = kWe(o, t);
      n += a;
    } else
      n += o;
  }), n;
}, kWe = (e, t) => {
  const n = e.indexOf("$"), r = e.indexOf("{"), i = e.indexOf("}"), o = e.slice(0, n), a = e.slice(i + 1), s = e.slice(r + 1, i), u = s.indexOf("("), l = s.indexOf(")"), h = s.slice(u + 1, l).replace(",", "").split(" ");
  return o + OWe(t, h[0], h[1]) + a;
}, $We = "_card_1hppd_1", PWe = "_labelWrapper_1hppd_11", IWe = "_cardLabel_1hppd_19", jWe = "_cardValue_1hppd_26", LWe = "_indicatorWrapper_1hppd_34", zWe = "_changeHistory_1hppd_40", FWe = "_upArrow_1hppd_44", BWe = "_indicatorValue_1hppd_48", _g = {
  card: $We,
  labelWrapper: PWe,
  cardLabel: IWe,
  cardValue: jWe,
  indicatorWrapper: LWe,
  changeHistory: zWe,
  upArrow: FWe,
  indicatorValue: BWe
}, UWe = ({
  label: e = $x,
  value: t,
  style: n
}) => {
  const r = t === $x ? $x : t && d1e(t);
  return /* @__PURE__ */ pe.jsxs("div", { id: "metricBlockWrapper", className: _g.card, children: [
    /* @__PURE__ */ pe.jsx("div", { className: _g.labelWrapper, children: /* @__PURE__ */ pe.jsx(
      "p",
      {
        id: "blockLabel",
        className: _g.cardLabel,
        style: { color: n == null ? void 0 : n.textColor, ...kj },
        children: e
      }
    ) }),
    /* @__PURE__ */ pe.jsx(Gbe, { arrow: !0, title: t, placement: "bottom-start", id: "tooltip", children: /* @__PURE__ */ pe.jsx(
      "div",
      {
        id: "blockValue",
        className: _g.cardValue,
        style: { color: n == null ? void 0 : n.textColor, ...wX },
        children: r
      }
    ) })
  ] });
};
function DE() {
  return DE = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, DE.apply(this, arguments);
}
const YWe = ["children", "options"], tce = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "className", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { for: "htmlFor" }), nce = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: " ", quot: "“" }, HWe = ["style", "script"], VWe = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, WWe = /mailto:/i, qWe = /\n{2,}$/, p1e = /^( *>[^\n]+(\n[^\n]+)*\n*)+\n{2,}/, GWe = /^ *> ?/gm, QWe = /^ {2,}\n/, XWe = /^(?:( *[-*_])){3,} *(?:\n *)+\n/, g1e = /^\s*(`{3,}|~{3,}) *(\S+)?([^\n]*?)?\n([\s\S]+?)\s*\1 *(?:\n *)*\n?/, m1e = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, KWe = /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, ZWe = /^(?:\n *)*\n/, JWe = /\r\n?/g, eqe = /^\[\^([^\]]+)](:.*)\n/, tqe = /^\[\^([^\]]+)]/, nqe = /\f/g, rqe = /^\s*?\[(x|\s)\]/, y1e = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, v1e = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, b1e = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/, wW = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?([^>]*)\/{0}>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1)[\s\S])*?)<\/\1>\n*/i, iqe = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, x1e = /^<!--[\s\S]*?(?:-->)/, oqe = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, _W = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, aqe = /^\{.*\}$/, sqe = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, uqe = /^<([^ >]+@[^ >]+)>/, lqe = /^<([^ >]+:\/[^ >]+)>/, cqe = /-([a-z])?/gi, w1e = /^(.*\|?.*)\n *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*)\n?/, fqe = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, dqe = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, hqe = /^\[([^\]]*)\] ?\[([^\]]*)\]/, pqe = /(\[|\])/g, gqe = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, mqe = /\t/g, yqe = /^ *\| */, vqe = /(^ *\||\| *$)/g, bqe = / *$/, xqe = /^ *:-+: *$/, wqe = /^ *:-+ *$/, _qe = /^ *-+: *$/, Eqe = /^([*_])\1((?:\[.*?\][([].*?[)\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\1\1(?!\1)/, Sqe = /^([*_])((?:\[.*?\][([].*?[)\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\1(?!\1|\w)/, Mqe = /^==((?:\[.*?\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)==/, Tqe = /^~~((?:\[.*?\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/, Cqe = /^\\([^0-9A-Za-z\s])/, Nqe = /^[\s\S]+?(?=[^0-9A-Z\s\u00c0-\uffff&#;.()'"]|\d+\.|\n\n| {2,}\n|\w+:\S|$)/i, Dqe = /^\n+/, Aqe = /^([ \t]*)/, Oqe = /\\([^\\])/g, rce = / *\n+$/, Rqe = /(?:^|\n)( *)$/, uK = "(?:\\d+\\.)", lK = "(?:[*+-])";
function _1e(e) {
  return "( *)(" + (e === 1 ? uK : lK) + ") +";
}
const E1e = _1e(1), S1e = _1e(2);
function M1e(e) {
  return new RegExp("^" + (e === 1 ? E1e : S1e));
}
const kqe = M1e(1), $qe = M1e(2);
function T1e(e) {
  return new RegExp("^" + (e === 1 ? E1e : S1e) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? uK : lK) + " )[^\\n]*)*(\\n|$)", "gm");
}
const C1e = T1e(1), N1e = T1e(2);
function D1e(e) {
  const t = e === 1 ? uK : lK;
  return new RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
}
const A1e = D1e(1), O1e = D1e(2);
function ice(e, t) {
  const n = t === 1, r = n ? A1e : O1e, i = n ? C1e : N1e, o = n ? kqe : $qe;
  return { t(a, s, u) {
    const l = Rqe.exec(u);
    return l && (s.o || !s._ && !s.u) ? r.exec(a = l[1] + a) : null;
  }, i: ei.HIGH, l(a, s, u) {
    const l = n ? +a[2] : void 0, f = a[0].replace(qWe, `
`).match(i);
    let h = !1;
    return { p: f.map(function(p, g) {
      const y = o.exec(p)[0].length, b = new RegExp("^ {1," + y + "}", "gm"), _ = p.replace(b, "").replace(o, ""), S = g === f.length - 1, C = _.indexOf(`

`) !== -1 || S && h;
      h = C;
      const A = u._, O = u.o;
      let R;
      u.o = !0, C ? (u._ = !1, R = _.replace(rce, `

`)) : (u._ = !0, R = _.replace(rce, ""));
      const j = s(R, u);
      return u._ = A, u.o = O, j;
    }), m: n, g: l };
  }, h: (a, s, u) => e(a.m ? "ol" : "ul", { key: u.k, start: a.g }, a.p.map(function(l, f) {
    return e("li", { key: f }, s(l, u));
  })) };
}
const Pqe = /^\[([^\]]*)]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/, Iqe = /^!\[([^\]]*)]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/, R1e = [p1e, g1e, m1e, y1e, b1e, v1e, x1e, w1e, C1e, A1e, N1e, O1e], jqe = [...R1e, /^[^\n]+(?:  \n|\n{2,})/, wW, _W];
function Lqe(e) {
  return e.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, "a").replace(/[çÇ]/g, "c").replace(/[ðÐ]/g, "d").replace(/[ÈÉÊËéèêë]/g, "e").replace(/[ÏïÎîÍíÌì]/g, "i").replace(/[Ññ]/g, "n").replace(/[øØœŒÕõÔôÓóÒò]/g, "o").replace(/[ÜüÛûÚúÙù]/g, "u").replace(/[ŸÿÝý]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function zqe(e) {
  return _qe.test(e) ? "right" : xqe.test(e) ? "center" : wqe.test(e) ? "left" : null;
}
function oce(e, t, n) {
  const r = n.$;
  n.$ = !0;
  const i = t(e.trim(), n);
  n.$ = r;
  let o = [[]];
  return i.forEach(function(a, s) {
    a.type === "tableSeparator" ? s !== 0 && s !== i.length - 1 && o.push([]) : (a.type !== "text" || i[s + 1] != null && i[s + 1].type !== "tableSeparator" || (a.v = a.v.replace(bqe, "")), o[o.length - 1].push(a));
  }), o;
}
function Fqe(e, t, n) {
  n._ = !0;
  const r = oce(e[1], t, n), i = e[2].replace(vqe, "").split("|").map(zqe), o = function(a, s, u) {
    return a.trim().split(`
`).map(function(l) {
      return oce(l, s, u);
    });
  }(e[3], t, n);
  return n._ = !1, { S: i, A: o, L: r, type: "table" };
}
function ace(e, t) {
  return e.S[t] == null ? {} : { textAlign: e.S[t] };
}
function ex(e) {
  return function(t, n) {
    return n._ ? e.exec(t) : null;
  };
}
function tx(e) {
  return function(t, n) {
    return n._ || n.u ? e.exec(t) : null;
  };
}
function S0(e) {
  return function(t, n) {
    return n._ || n.u ? null : e.exec(t);
  };
}
function PA(e) {
  return function(t) {
    return e.exec(t);
  };
}
function Bqe(e, t, n) {
  if (t._ || t.u || n && !n.endsWith(`
`))
    return null;
  let r = "";
  e.split(`
`).every((o) => !R1e.some((a) => a.test(o)) && (r += o + `
`, o.trim()));
  const i = r.trimEnd();
  return i == "" ? null : [r, i];
}
function $M(e) {
  try {
    if (decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "").match(/^\s*(javascript|vbscript|data(?!:image)):/i))
      return;
  } catch {
    return null;
  }
  return e;
}
function sce(e) {
  return e.replace(Oqe, "$1");
}
function Z3(e, t, n) {
  const r = n._ || !1, i = n.u || !1;
  n._ = !0, n.u = !0;
  const o = e(t, n);
  return n._ = r, n.u = i, o;
}
function Uqe(e, t, n) {
  const r = n._ || !1, i = n.u || !1;
  n._ = !1, n.u = !0;
  const o = e(t, n);
  return n._ = r, n.u = i, o;
}
function Yqe(e, t, n) {
  return n._ = !1, e(t, n);
}
const pY = (e, t, n) => ({ v: Z3(t, e[1], n) });
function gY() {
  return {};
}
function mY() {
  return null;
}
function Hqe(...e) {
  return e.filter(Boolean).join(" ");
}
function yY(e, t, n) {
  let r = e;
  const i = t.split(".");
  for (; i.length && (r = r[i[0]], r !== void 0); )
    i.shift();
  return r || n;
}
var ei;
function Vqe(e, t = {}) {
  t.overrides = t.overrides || {}, t.slugify = t.slugify || Lqe, t.namedCodesToUnicode = t.namedCodesToUnicode ? DE({}, nce, t.namedCodesToUnicode) : nce;
  const n = t.createElement || ae.createElement;
  function r(g, y, ...b) {
    const _ = yY(t.overrides, `${g}.props`, {});
    return n(function(S, C) {
      const A = yY(C, S);
      return A ? typeof A == "function" || typeof A == "object" && "render" in A ? A : yY(C, `${S}.component`, S) : S;
    }(g, t.overrides), DE({}, y, _, { className: Hqe(y == null ? void 0 : y.className, _.className) || void 0 }), ...b);
  }
  function i(g) {
    let y = !1;
    t.forceInline ? y = !0 : t.forceBlock || (y = gqe.test(g) === !1);
    const b = f(l(y ? g : `${g.trimEnd().replace(Dqe, "")}

`, { _: y }));
    for (; typeof b[b.length - 1] == "string" && !b[b.length - 1].trim(); )
      b.pop();
    if (t.wrapper === null)
      return b;
    const _ = t.wrapper || (y ? "span" : "div");
    let S;
    if (b.length > 1 || t.forceWrapper)
      S = b;
    else {
      if (b.length === 1)
        return S = b[0], typeof S == "string" ? r("span", { key: "outer" }, S) : S;
      S = null;
    }
    return ae.createElement(_, { key: "outer" }, S);
  }
  function o(g) {
    const y = g.match(VWe);
    return y ? y.reduce(function(b, _, S) {
      const C = _.indexOf("=");
      if (C !== -1) {
        const A = function($) {
          return $.indexOf("-") !== -1 && $.match(oqe) === null && ($ = $.replace(cqe, function(z, W) {
            return W.toUpperCase();
          })), $;
        }(_.slice(0, C)).trim(), O = function($) {
          const z = $[0];
          return (z === '"' || z === "'") && $.length >= 2 && $[$.length - 1] === z ? $.slice(1, -1) : $;
        }(_.slice(C + 1).trim()), R = tce[A] || A, j = b[R] = function($, z) {
          return $ === "style" ? z.split(/;\s?/).reduce(function(W, Y) {
            const V = Y.slice(0, Y.indexOf(":"));
            return W[V.replace(/(-[a-z])/g, (ee) => ee[1].toUpperCase())] = Y.slice(V.length + 1).trim(), W;
          }, {}) : $ === "href" ? $M(z) : (z.match(aqe) && (z = z.slice(1, z.length - 1)), z === "true" || z !== "false" && z);
        }(A, O);
        typeof j == "string" && (wW.test(j) || _W.test(j)) && (b[R] = ae.cloneElement(i(j.trim()), { key: S }));
      } else
        _ !== "style" && (b[tce[_] || _] = !0);
      return b;
    }, {}) : null;
  }
  const a = [], s = {}, u = { blockQuote: { t: S0(p1e), i: ei.HIGH, l: (g, y, b) => ({ v: y(g[0].replace(GWe, ""), b) }), h: (g, y, b) => r("blockquote", { key: b.k }, y(g.v, b)) }, breakLine: { t: PA(QWe), i: ei.HIGH, l: gY, h: (g, y, b) => r("br", { key: b.k }) }, breakThematic: { t: S0(XWe), i: ei.HIGH, l: gY, h: (g, y, b) => r("hr", { key: b.k }) }, codeBlock: { t: S0(m1e), i: ei.MAX, l: (g) => ({ v: g[0].replace(/^ {4}/gm, "").replace(/\n+$/, ""), M: void 0 }), h: (g, y, b) => r("pre", { key: b.k }, r("code", DE({}, g.O, { className: g.M ? `lang-${g.M}` : "" }), g.v)) }, codeFenced: { t: S0(g1e), i: ei.MAX, l: (g) => ({ O: o(g[3] || ""), v: g[4], M: g[2] || void 0, type: "codeBlock" }) }, codeInline: { t: tx(KWe), i: ei.LOW, l: (g) => ({ v: g[2] }), h: (g, y, b) => r("code", { key: b.k }, g.v) }, footnote: { t: S0(eqe), i: ei.MAX, l: (g) => (a.push({ I: g[2], j: g[1] }), {}), h: mY }, footnoteReference: { t: ex(tqe), i: ei.HIGH, l: (g) => ({ v: g[1], B: `#${t.slugify(g[1])}` }), h: (g, y, b) => r("a", { key: b.k, href: $M(g.B) }, r("sup", { key: b.k }, g.v)) }, gfmTask: { t: ex(rqe), i: ei.HIGH, l: (g) => ({ R: g[1].toLowerCase() === "x" }), h: (g, y, b) => r("input", { checked: g.R, key: b.k, readOnly: !0, type: "checkbox" }) }, heading: { t: S0(t.enforceAtxHeadings ? v1e : y1e), i: ei.HIGH, l: (g, y, b) => ({ v: Z3(y, g[2], b), T: t.slugify(g[2]), C: g[1].length }), h: (g, y, b) => r(`h${g.C}`, { id: g.T, key: b.k }, y(g.v, b)) }, headingSetext: { t: S0(b1e), i: ei.MAX, l: (g, y, b) => ({ v: Z3(y, g[1], b), C: g[2] === "=" ? 1 : 2, type: "heading" }) }, htmlComment: { t: PA(x1e), i: ei.HIGH, l: () => ({}), h: mY }, image: { t: tx(Iqe), i: ei.HIGH, l: (g) => ({ D: g[1], B: sce(g[2]), F: g[3] }), h: (g, y, b) => r("img", { key: b.k, alt: g.D || void 0, title: g.F || void 0, src: $M(g.B) }) }, link: { t: ex(Pqe), i: ei.LOW, l: (g, y, b) => ({ v: Uqe(y, g[1], b), B: sce(g[2]), F: g[3] }), h: (g, y, b) => r("a", { key: b.k, href: $M(g.B), title: g.F }, y(g.v, b)) }, linkAngleBraceStyleDetector: { t: ex(lqe), i: ei.MAX, l: (g) => ({ v: [{ v: g[1], type: "text" }], B: g[1], type: "link" }) }, linkBareUrlDetector: { t: (g, y) => y.N ? null : ex(sqe)(g, y), i: ei.MAX, l: (g) => ({ v: [{ v: g[1], type: "text" }], B: g[1], F: void 0, type: "link" }) }, linkMailtoDetector: { t: ex(uqe), i: ei.MAX, l(g) {
    let y = g[1], b = g[1];
    return WWe.test(b) || (b = "mailto:" + b), { v: [{ v: y.replace("mailto:", ""), type: "text" }], B: b, type: "link" };
  } }, orderedList: ice(r, 1), unorderedList: ice(r, 2), newlineCoalescer: { t: S0(ZWe), i: ei.LOW, l: gY, h: () => `
` }, paragraph: { t: Bqe, i: ei.LOW, l: pY, h: (g, y, b) => r("p", { key: b.k }, y(g.v, b)) }, ref: { t: ex(fqe), i: ei.MAX, l: (g) => (s[g[1]] = { B: g[2], F: g[4] }, {}), h: mY }, refImage: { t: tx(dqe), i: ei.MAX, l: (g) => ({ D: g[1] || void 0, P: g[2] }), h: (g, y, b) => r("img", { key: b.k, alt: g.D, src: $M(s[g.P].B), title: s[g.P].F }) }, refLink: { t: ex(hqe), i: ei.MAX, l: (g, y, b) => ({ v: y(g[1], b), Z: y(g[0].replace(pqe, "\\$1"), b), P: g[2] }), h: (g, y, b) => s[g.P] ? r("a", { key: b.k, href: $M(s[g.P].B), title: s[g.P].F }, y(g.v, b)) : r("span", { key: b.k }, y(g.Z, b)) }, table: { t: S0(w1e), i: ei.HIGH, l: Fqe, h: (g, y, b) => r("table", { key: b.k }, r("thead", null, r("tr", null, g.L.map(function(_, S) {
    return r("th", { key: S, style: ace(g, S) }, y(_, b));
  }))), r("tbody", null, g.A.map(function(_, S) {
    return r("tr", { key: S }, _.map(function(C, A) {
      return r("td", { key: A, style: ace(g, A) }, y(C, b));
    }));
  }))) }, tableSeparator: { t: function(g, y) {
    return y.$ ? (y._ = !0, yqe.exec(g)) : null;
  }, i: ei.HIGH, l: function() {
    return { type: "tableSeparator" };
  }, h: () => " | " }, text: { t: PA(Nqe), i: ei.MIN, l: (g) => ({ v: g[0].replace(iqe, (y, b) => t.namedCodesToUnicode[b] ? t.namedCodesToUnicode[b] : y) }), h: (g) => g.v }, textBolded: { t: tx(Eqe), i: ei.MED, l: (g, y, b) => ({ v: y(g[2], b) }), h: (g, y, b) => r("strong", { key: b.k }, y(g.v, b)) }, textEmphasized: { t: tx(Sqe), i: ei.LOW, l: (g, y, b) => ({ v: y(g[2], b) }), h: (g, y, b) => r("em", { key: b.k }, y(g.v, b)) }, textEscaped: { t: tx(Cqe), i: ei.HIGH, l: (g) => ({ v: g[1], type: "text" }) }, textMarked: { t: tx(Mqe), i: ei.LOW, l: pY, h: (g, y, b) => r("mark", { key: b.k }, y(g.v, b)) }, textStrikethroughed: { t: tx(Tqe), i: ei.LOW, l: pY, h: (g, y, b) => r("del", { key: b.k }, y(g.v, b)) } };
  t.disableParsingRawHTML !== !0 && (u.htmlBlock = { t: PA(wW), i: ei.HIGH, l(g, y, b) {
    const [, _] = g[3].match(Aqe), S = new RegExp(`^${_}`, "gm"), C = g[3].replace(S, ""), A = (O = C, jqe.some((z) => z.test(O)) ? Yqe : Z3);
    var O;
    const R = g[1].toLowerCase(), j = HWe.indexOf(R) !== -1;
    b.N = b.N || R === "a";
    const $ = j ? g[3] : A(y, C, b);
    return b.N = !1, { O: o(g[2]), v: $, G: j, H: j ? R : g[1] };
  }, h: (g, y, b) => r(g.H, DE({ key: b.k }, g.O), g.G ? g.v : y(g.v, b)) }, u.htmlSelfClosing = { t: PA(_W), i: ei.HIGH, l: (g) => ({ O: o(g[2] || ""), H: g[1] }), h: (g, y, b) => r(g.H, DE({}, g.O, { key: b.k })) });
  const l = function(g) {
    let y = Object.keys(g);
    function b(_, S) {
      let C = [], A = "";
      for (; _; ) {
        let O = 0;
        for (; O < y.length; ) {
          const R = y[O], j = g[R], $ = j.t(_, S, A);
          if ($) {
            const z = $[0];
            _ = _.substring(z.length);
            const W = j.l($, b, S);
            W.type == null && (W.type = R), C.push(W), A = z;
            break;
          }
          O++;
        }
      }
      return C;
    }
    return y.sort(function(_, S) {
      let C = g[_].i, A = g[S].i;
      return C !== A ? C - A : _ < S ? -1 : 1;
    }), function(_, S) {
      return b(function(C) {
        return C.replace(JWe, `
`).replace(nqe, "").replace(mqe, "    ");
      }(_), S);
    };
  }(u), f = (h = function(g) {
    return function(y, b, _) {
      return g[y.type].h(y, b, _);
    };
  }(u), function g(y, b = {}) {
    if (Array.isArray(y)) {
      const _ = b.k, S = [];
      let C = !1;
      for (let A = 0; A < y.length; A++) {
        b.k = A;
        const O = g(y[A], b), R = typeof O == "string";
        R && C ? S[S.length - 1] += O : O !== null && S.push(O), C = R;
      }
      return b.k = _, S;
    }
    return h(y, g, b);
  });
  var h;
  const p = i(e);
  return a.length ? r("div", null, p, r("footer", { key: "footer" }, a.map(function(g) {
    return r("div", { id: t.slugify(g.j), key: g.j }, g.j, f(l(g.I, { _: !0 })));
  }))) : p;
}
(function(e) {
  e[e.MAX = 0] = "MAX", e[e.HIGH = 1] = "HIGH", e[e.MED = 2] = "MED", e[e.LOW = 3] = "LOW", e[e.MIN = 4] = "MIN";
})(ei || (ei = {}));
const Wqe = (e) => {
  let { children: t, options: n } = e, r = function(i, o) {
    if (i == null)
      return {};
    var a, s, u = {}, l = Object.keys(i);
    for (s = 0; s < l.length; s++)
      o.indexOf(a = l[s]) >= 0 || (u[a] = i[a]);
    return u;
  }(e, YWe);
  return ae.cloneElement(Vqe(t, n), r);
};
var zi = function() {
  return zi = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++)
      for (var i in t = arguments[n])
        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    return e;
  }, zi.apply(this, arguments);
};
function M0(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  }
  return n;
}
var EW = zt(hR)(function() {
  return {};
}), nx = zt(ebe)(function() {
  return {};
}), qqe = zt(yYe)(function() {
  return {};
}), Gqe = zt(JYe)(function() {
  return {};
}), Qqe = function(e) {
  var t = e.children, n = t === void 0 ? "" : t, r = e.language, i = r === void 0 ? "tsx" : r, o = e.Highlight, a = e.themes, s = e.theme, u = e.hideLineNumbers;
  return pe.jsx(o, zi({ code: n, language: i, theme: s || a.vsDark }, { children: function(l) {
    var f = l.style, h = l.tokens, p = l.getLineProps, g = l.getTokenProps;
    return pe.jsx("pre", zi({ style: zi(zi({ borderRadius: "0.5rem", padding: "0.5rem 0.75rem", overflow: "auto" }, f), e.styles) }, { children: h.map(function(y, b) {
      return pe.jsxs("div", zi({}, p({ line: y }), { children: [!u && pe.jsxs("span", { children: [b + 1, " "] }), y.map(function(_, S) {
        return pe.jsx("span", zi({}, g({ token: _ })), S);
      })] }), b);
    }) }));
  } }));
}, Xqe = function(e) {
  var t = e.children, n = t === void 0 ? "" : t, r = e.styles;
  return pe.jsx("pre", zi({ style: zi({ borderRadius: "0.5rem", padding: "0.5rem 0.75rem", overflow: "auto" }, r) }, { children: n }));
}, k1e = function(e) {
  var t = e.children, n = e.Highlight, r = e.themes, i = e.theme, o = e.styles, a = e.hideLineNumbers;
  if (t && t.props && t.props.className && t.props.className.startsWith("lang-")) {
    var s = t.props.children, u = t.props.className ? t.props.className.replace("lang-", "") : "tsx";
    return n && r ? pe.jsx(Qqe, zi({ Highlight: n, themes: r, language: u, theme: i, styles: o, hideLineNumbers: a }, { children: s })) : pe.jsx(Xqe, zi({ styles: o }, { children: s }));
  }
  return pe.jsx(EW, zi({ component: "pre", sx: { whiteSpace: "pre-wrap" } }, { children: t }));
}, Kqe = zt(t1e)(function() {
  return {};
}), uce = zt(eC)(function() {
  return { whiteSpace: "nowrap" };
}), Zqe = zt(YVe)(function() {
  return {};
}), Jqe = zt(a1e)(function() {
  return {};
}), eGe = zt(xW)(function() {
  return {};
}), tGe = zt(Zbe)(function() {
  return {};
}), nGe = { a: Gqe, blockquote: function(e) {
  var t = e.children;
  return pe.jsx(EW, zi({ component: "blockquote", dir: "auto", sx: { borderInlineStart: "3px solid", paddingInlineStart: "1.5rem", borderColor: "text.secondary", m: "0.25rem 0" } }, { children: t }));
}, code: function(e) {
  var t = e.children, n = _w().palette;
  return pe.jsx("code", zi({ style: { backgroundColor: Fj(n.background.default, 0.07), borderRadius: "0.25rem", padding: "0.25rem 0.5rem" } }, { children: t }));
}, h1: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "h1" : n, i = e.variant, o = i === void 0 ? "h1" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, h2: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "h2" : n, i = e.variant, o = i === void 0 ? "h2" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, h3: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "h3" : n, i = e.variant, o = i === void 0 ? "h3" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, h4: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "h4" : n, i = e.variant, o = i === void 0 ? "h4" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, h5: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "h5" : n, i = e.variant, o = i === void 0 ? "h5" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, h6: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "h6" : n, i = e.variant, o = i === void 0 ? "h6" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, hr: qqe, p: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "p" : n, i = e.variant, o = i === void 0 ? "body1" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, pre: k1e, span: function(e) {
  var t = e.children, n = e.component, r = n === void 0 ? "span" : n, i = e.variant, o = i === void 0 ? "body1" : i, a = M0(e, ["children", "component", "variant"]);
  return pe.jsx(nx, zi({ component: r, variant: o }, a, { children: t }));
}, table: function(e) {
  var t = e.children, n = e.sx, r = M0(e, ["children", "sx"]);
  return pe.jsx(EW, zi({ sx: n || function(i) {
    var o = i.palette;
    return zi({ overflow: "auto" }, function(a) {
      return { "::-webkit-scrollbar": { width: "8px", height: "6px" }, "::-webkit-scrollbar-track": { background: a.mode === "dark" ? a.background.default : a.background.paper, borderRadius: "8px", overflow: "hidden" }, "::-webkit-scrollbar-thumb": { background: Fj(a.background.default, 0.05), borderRadius: "8px" } };
    }(o));
  } }, { children: pe.jsx(tGe, zi({}, r, { children: t })) }));
}, tbody: Kqe, td: uce, tfoot: Zqe, th: uce, thead: Jqe, tr: eGe }, rGe = function(e) {
  var t = e === void 0 ? {} : e, n = t.hideLineNumbers, r = t.theme, i = t.styles, o = t.Highlight, a = t.themes;
  return zi(zi({}, nGe), { pre: { component: k1e, props: { theme: r, styles: i, Highlight: o, themes: a, hideLineNumbers: n } } });
}, iGe = function(e) {
  var t = e.children, n = t === void 0 ? "" : t, r = function(i) {
    var o = i.options, a = i.overrides, s = rGe(i);
    return o ? o.overrides ? o : zi(zi({}, o), { overrides: s }) : { overrides: a || s };
  }(e);
  return function(i) {
    return "options" in i && "overrides" in i;
  }(e) && console.error("Cannot set both 'options' and 'overrides' in the MuiMarkdown component props."), pe.jsx(Wqe, zi({ options: r }, { children: n || "" }));
};
const tv = ae.createContext(JV), oGe = "_markdownWrapper_1ek5m_1", aGe = {
  markdownWrapper: oGe
}, SW = ({
  markdownText: e,
  style: t = {}
}) => {
  const n = ae.useContext(tv);
  return /* @__PURE__ */ pe.jsx(
    "span",
    {
      id: "markdownContentWrapper",
      className: aGe.markdownWrapper,
      style: {
        color: t != null && t.textColor ? `${t.textColor}` : "black"
      },
      children: /* @__PURE__ */ pe.jsx(
        iGe,
        {
          overrides: {
            h1: { props: { style: Rze } },
            h2: { props: { style: wX } },
            h3: {
              props: {
                style: {
                  color: t != null && t.textColor ? `${t.textColor}` : "black",
                  ...Jve
                }
              }
            },
            h4: { props: { style: ZU } },
            h5: { props: { style: ZU } },
            h6: { props: { style: ZU } },
            p: {
              props: {
                style: {
                  color: t != null && t.textColor ? `${t.textColor}` : "black",
                  ...kj
                }
              }
            },
            span: { props: { style: kj } }
          },
          children: h1e(e, n)
        }
      )
    }
  );
};
var $1e = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (o) {
          var a = typeof o;
          if (a === "string" || a === "number")
            r.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var s = n.apply(null, o);
              s && r.push(s);
            }
          } else if (a === "object") {
            if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]")) {
              r.push(o.toString());
              continue;
            }
            for (var u in o)
              t.call(o, u) && o[u] && r.push(u);
          }
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})($1e);
var sGe = $1e.exports;
const uGe = /* @__PURE__ */ KC(sGe), lGe = "_title_1dyu3_1", cGe = "_markdownTitleWrapper_1dyu3_5", vY = {
  title: lGe,
  markdownTitleWrapper: cGe
}, JS = ({ contentTitle: e, style: t }) => {
  const n = ar.get(e, "text"), r = ar.get(e, "markdown"), i = ae.useContext(tv);
  return /* @__PURE__ */ pe.jsxs("div", { id: "titleWrapper", children: [
    n && /* @__PURE__ */ pe.jsx(
      "h3",
      {
        id: "textTitle",
        className: vY.title,
        style: { color: t == null ? void 0 : t.textColor, ...Jve },
        children: h1e(n, i)
      }
    ),
    r && /* @__PURE__ */ pe.jsx(
      "div",
      {
        id: "markdownTitleWrapper",
        className: uGe(vY.markdownTitleWrapper, vY.title),
        children: /* @__PURE__ */ pe.jsx(SW, { markdownText: r, style: t })
      }
    )
  ] });
}, P1e = (e, t, n) => {
  const r = ar.get(t[n], "namespace", ""), i = ar.get(t[n], "path", ""), o = ar.get(
    e,
    `${r}.records[0].${i}`
  );
  return sK(o);
}, fGe = (e, t, n) => {
  const r = ar.get(t[n], "change.valueNamespace"), i = ar.get(t[n], "change.valuePath"), o = ar.get(
    e,
    `${r}.records[0].${i}`
  ), a = ar.get(
    t[n],
    "change.indicatorSignNamespace"
  ), s = ar.get(t[n], "change.indicatorSignPath"), u = ar.get(
    e,
    `${a}.records[0].${s}`
  );
  return { indicatorValue: o, indicatorSign: u };
}, dGe = "_cardSection_hv645_1", hGe = "_bannerLabel_hv645_9", pGe = "_secondaryBannerLabel_hv645_14", gGe = "_metricBlockWrapper_hv645_18", qj = {
  cardSection: dGe,
  bannerLabel: hGe,
  secondaryBannerLabel: pGe,
  metricBlockWrapper: gGe
}, mGe = ({ style: e = {}, content: t }) => {
  const n = ae.useContext(tv), r = ar.get(t, "metrics", []);
  return /* @__PURE__ */ pe.jsxs(
    "div",
    {
      id: "kpiBannerV1",
      className: qj.cardSection,
      style: {
        background: `${e == null ? void 0 : e.bgColor}`,
        color: `${e == null ? void 0 : e.textColor}`
      },
      children: [
        /* @__PURE__ */ pe.jsx(JS, { contentTitle: t.title, style: e }),
        /* @__PURE__ */ pe.jsx("div", { id: "metricBlockWrapper", className: qj.metricBlockWrapper, children: r.map((i, o) => /* @__PURE__ */ pe.jsx(
          UWe,
          {
            label: i.label,
            value: P1e(n, r, o),
            style: e
          },
          o
        )) })
      ]
    }
  );
};
var cK = {}, I1e = { exports: {} };
(function(e) {
  function t(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(I1e);
var yGe = I1e.exports, bY = {};
const vGe = /* @__PURE__ */ X5e(i7e);
var lce;
function bGe() {
  return lce || (lce = 1, function(e) {
    "use client";
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "default", {
      enumerable: !0,
      get: function() {
        return t.createSvgIcon;
      }
    });
    var t = vGe;
  }(bY)), bY;
}
var xGe = yGe;
Object.defineProperty(cK, "__esModule", {
  value: !0
});
var j1e = cK.default = void 0, wGe = xGe(bGe()), _Ge = pe, EGe = (0, wGe.default)(/* @__PURE__ */ (0, _Ge.jsx)("path", {
  d: "m7 14 5-5 5 5z"
}), "ArrowDropUp");
j1e = cK.default = EGe;
const SGe = ({
  label: e = $x,
  value: t,
  indicator: n,
  style: r
}) => {
  const i = n != null && n.indicatorSign && (n == null ? void 0 : n.indicatorSign) !== "0" ? n.indicatorSign.toString() : null, o = {
    color: "#00C64A"
  }, a = {
    color: "#FF0120",
    transform: "rotate(180deg)"
  }, s = t === $x ? $x : t && d1e(t), u = i === "1" ? o : i === "-1" ? a : {};
  return /* @__PURE__ */ pe.jsxs("div", { id: "metricBlockWrapper", className: _g.card, children: [
    /* @__PURE__ */ pe.jsx("div", { className: _g.labelWrapper, children: /* @__PURE__ */ pe.jsx(
      "p",
      {
        id: "blockLabel",
        className: _g.cardLabel,
        style: { color: r == null ? void 0 : r.textColor, ...kj },
        children: e
      }
    ) }),
    /* @__PURE__ */ pe.jsx(Gbe, { arrow: !0, title: t, placement: "bottom-start", id: "tooltip", children: /* @__PURE__ */ pe.jsx(
      "div",
      {
        id: "blockValue",
        className: _g.cardValue,
        style: { color: r == null ? void 0 : r.textColor, ...wX },
        children: s
      }
    ) }),
    (n == null ? void 0 : n.indicatorValue) && /* @__PURE__ */ pe.jsxs("div", { id: "indicatorWrapper", className: _g.indicatorWrapper, children: [
      !!i && /* @__PURE__ */ pe.jsx(
        "div",
        {
          id: "indicatorSignWrapper",
          className: _g.changeHistory,
          children: /* @__PURE__ */ pe.jsx(j1e, { style: u })
        }
      ),
      /* @__PURE__ */ pe.jsx(
        "div",
        {
          id: "indicatorValue",
          style: { color: r == null ? void 0 : r.textColor },
          className: _g.indicatorValue,
          children: n.indicatorValue
        }
      )
    ] })
  ] });
}, MGe = ({ style: e = {}, content: t }) => {
  const n = ae.useContext(tv), r = ar.get(t, "metrics", []);
  return /* @__PURE__ */ pe.jsxs(
    "div",
    {
      id: "kpiBannerV2",
      className: qj.cardSection,
      style: {
        background: `${e == null ? void 0 : e.bgColor}`,
        color: `${e == null ? void 0 : e.textColor}`
      },
      children: [
        /* @__PURE__ */ pe.jsx(JS, { contentTitle: t.title, style: e }),
        /* @__PURE__ */ pe.jsx("div", { id: "metricBlockWrapper", className: qj.metricBlockWrapper, children: r.map((i, o) => /* @__PURE__ */ pe.jsx(
          SGe,
          {
            label: i.label,
            value: P1e(n, r, o),
            indicator: fGe(n, r, o),
            style: e
          },
          o
        )) })
      ]
    }
  );
}, TGe = ({ style: e = {}, content: t, version: n }) => {
  const r = () => {
    let i;
    switch (n) {
      case "1":
        i = /* @__PURE__ */ pe.jsx(mGe, { style: e, content: t });
        break;
      case "2":
        i = /* @__PURE__ */ pe.jsx(MGe, { style: e, content: t });
        break;
      default:
        console.log(
          `KPI List Version ${n} is not yet supported in this application.`
        );
        break;
    }
    return /* @__PURE__ */ pe.jsx("div", { children: i });
  };
  return /* @__PURE__ */ pe.jsx("div", { "data-test": "listKPIsWrapper", children: r() });
}, CGe = "_markdownComponentWrapper_119og_1", NGe = "_title_119og_10", DGe = "_markdownWrapper_119og_11", AGe = {
  markdownComponentWrapper: CGe,
  title: NGe,
  markdownWrapper: DGe
}, OGe = ({ style: e = {}, content: t }) => {
  const n = ar.get(t, "body", ""), r = ar.get(t, "markdown", "");
  return /* @__PURE__ */ pe.jsxs(
    "div",
    {
      id: "markdownWrapper",
      className: AGe.markdownComponentWrapper,
      style: {
        background: `${e == null ? void 0 : e.bgColor}`,
        color: `${e == null ? void 0 : e.textColor}`
      },
      children: [
        /* @__PURE__ */ pe.jsx(JS, { contentTitle: t.title, style: e }),
        n && /* @__PURE__ */ pe.jsx(SW, { markdownText: n, style: e }),
        r && /* @__PURE__ */ pe.jsx(SW, { markdownText: r, style: e })
      ]
    }
  );
};
/**
 * @remix-run/router v1.8.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function MW() {
  return MW = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, MW.apply(this, arguments);
}
var cce;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})(cce || (cce = {}));
function Vs(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function aF(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function TW(e) {
  let {
    pathname: t = "/",
    search: n = "",
    hash: r = ""
  } = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t;
}
function L1e(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e);
  }
  return t;
}
var fce;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})(fce || (fce = {}));
function CW(e, t) {
  if (t === "/")
    return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function RGe(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? L1e(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : kGe(n, t) : t,
    search: $Ge(r),
    hash: PGe(i)
  };
}
function kGe(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function xY(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function z1e(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0);
}
function F1e(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string" ? i = L1e(e) : (i = MW({}, e), Vs(!i.pathname || !i.pathname.includes("?"), xY("?", "pathname", "search", i)), Vs(!i.pathname || !i.pathname.includes("#"), xY("#", "pathname", "hash", i)), Vs(!i.search || !i.search.includes("#"), xY("#", "search", "hash", i)));
  let o = e === "" || i.pathname === "", a = o ? "/" : i.pathname, s;
  if (r || a == null)
    s = n;
  else {
    let h = t.length - 1;
    if (a.startsWith("..")) {
      let p = a.split("/");
      for (; p[0] === ".."; )
        p.shift(), h -= 1;
      i.pathname = p.join("/");
    }
    s = h >= 0 ? t[h] : "/";
  }
  let u = RGe(i, s), l = a && a !== "/" && a.endsWith("/"), f = (o || a === ".") && n.endsWith("/");
  return !u.pathname.endsWith("/") && (l || f) && (u.pathname += "/"), u;
}
const fK = (e) => e.join("/").replace(/\/\/+/g, "/"), $Ge = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, PGe = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, B1e = ["post", "put", "patch", "delete"];
new Set(B1e);
const IGe = ["get", ...B1e];
new Set(IGe);
/**
 * React Router v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function NW() {
  return NW = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, NW.apply(this, arguments);
}
const sF = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (sF.displayName = "DataRouter");
const U1e = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (U1e.displayName = "DataRouterState");
const jGe = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (jGe.displayName = "Await");
const Sw = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (Sw.displayName = "Navigation");
const dK = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (dK.displayName = "Location");
const eN = /* @__PURE__ */ ae.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (eN.displayName = "Route");
const LGe = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (LGe.displayName = "RouteError");
function zGe(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t;
  hK() || (process.env.NODE_ENV !== "production" ? Vs(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : Vs(!1));
  let {
    basename: r,
    navigator: i
  } = ae.useContext(Sw), {
    hash: o,
    pathname: a,
    search: s
  } = uF(e, {
    relative: n
  }), u = a;
  return r !== "/" && (u = a === "/" ? r : fK([r, a])), i.createHref({
    pathname: u,
    search: s,
    hash: o
  });
}
function hK() {
  return ae.useContext(dK) != null;
}
function _$() {
  return hK() || (process.env.NODE_ENV !== "production" ? Vs(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : Vs(!1)), ae.useContext(dK).location;
}
const Y1e = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function H1e(e) {
  ae.useContext(Sw).static || ae.useLayoutEffect(e);
}
function FGe() {
  let {
    isDataRoute: e
  } = ae.useContext(eN);
  return e ? VGe() : BGe();
}
function BGe() {
  hK() || (process.env.NODE_ENV !== "production" ? Vs(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : Vs(!1));
  let e = ae.useContext(sF), {
    basename: t,
    navigator: n
  } = ae.useContext(Sw), {
    matches: r
  } = ae.useContext(eN), {
    pathname: i
  } = _$(), o = JSON.stringify(z1e(r).map((u) => u.pathnameBase)), a = ae.useRef(!1);
  return H1e(() => {
    a.current = !0;
  }), ae.useCallback(function(u, l) {
    if (l === void 0 && (l = {}), process.env.NODE_ENV !== "production" && aF(a.current, Y1e), !a.current)
      return;
    if (typeof u == "number") {
      n.go(u);
      return;
    }
    let f = F1e(u, JSON.parse(o), i, l.relative === "path");
    e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : fK([t, f.pathname])), (l.replace ? n.replace : n.push)(f, l.state, l);
  }, [t, n, o, i, e]);
}
function uF(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    matches: r
  } = ae.useContext(eN), {
    pathname: i
  } = _$(), o = JSON.stringify(z1e(r).map((a) => a.pathnameBase));
  return ae.useMemo(() => F1e(e, JSON.parse(o), i, n === "path"), [e, o, i, n]);
}
var V1e = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(V1e || {}), pK = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(pK || {});
function W1e(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function UGe(e) {
  let t = ae.useContext(sF);
  return t || (process.env.NODE_ENV !== "production" ? Vs(!1, W1e(e)) : Vs(!1)), t;
}
function YGe(e) {
  let t = ae.useContext(eN);
  return t || (process.env.NODE_ENV !== "production" ? Vs(!1, W1e(e)) : Vs(!1)), t;
}
function q1e(e) {
  let t = YGe(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (process.env.NODE_ENV !== "production" ? Vs(!1, e + ' can only be used on routes that contain a unique "id"') : Vs(!1)), n.route.id;
}
function HGe() {
  return q1e(pK.UseRouteId);
}
function VGe() {
  let {
    router: e
  } = UGe(V1e.UseNavigateStable), t = q1e(pK.UseNavigateStable), n = ae.useRef(!1);
  return H1e(() => {
    n.current = !0;
  }), ae.useCallback(function(i, o) {
    o === void 0 && (o = {}), process.env.NODE_ENV !== "production" && aF(n.current, Y1e), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, NW({
      fromRouteId: t
    }, o)));
  }, [e, t]);
}
new Promise(() => {
});
/**
 * React Router DOM v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function vS() {
  return vS = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vS.apply(this, arguments);
}
function gK(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
const J3 = "get", ej = "application/x-www-form-urlencoded";
function lF(e) {
  return e != null && typeof e.tagName == "string";
}
function WGe(e) {
  return lF(e) && e.tagName.toLowerCase() === "button";
}
function qGe(e) {
  return lF(e) && e.tagName.toLowerCase() === "form";
}
function GGe(e) {
  return lF(e) && e.tagName.toLowerCase() === "input";
}
function QGe(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function XGe(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !QGe(e);
}
let RI = null;
function KGe() {
  if (RI === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), RI = !1;
    } catch {
      RI = !0;
    }
  return RI;
}
const ZGe = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function wY(e) {
  return e != null && !ZGe.has(e) ? (process.env.NODE_ENV !== "production" && aF(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + ej + '"')), null) : e;
}
function JGe(e, t) {
  let n, r, i, o, a;
  if (qGe(e)) {
    let s = e.getAttribute("action");
    r = s ? CW(s, t) : null, n = e.getAttribute("method") || J3, i = wY(e.getAttribute("enctype")) || ej, o = new FormData(e);
  } else if (WGe(e) || GGe(e) && (e.type === "submit" || e.type === "image")) {
    let s = e.form;
    if (s == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let u = e.getAttribute("formaction") || s.getAttribute("action");
    if (r = u ? CW(u, t) : null, n = e.getAttribute("formmethod") || s.getAttribute("method") || J3, i = wY(e.getAttribute("formenctype")) || wY(s.getAttribute("enctype")) || ej, o = new FormData(s, e), !KGe()) {
      let {
        name: l,
        type: f,
        value: h
      } = e;
      if (f === "image") {
        let p = l ? l + "." : "";
        o.append(p + "x", "0"), o.append(p + "y", "0");
      } else
        l && o.append(l, h);
    }
  } else {
    if (lF(e))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    n = J3, r = null, i = ej, a = e;
  }
  return o && i === "text/plain" && (a = o, o = void 0), {
    action: r,
    method: n.toLowerCase(),
    encType: i,
    formData: o,
    body: a
  };
}
const eQe = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], tQe = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], nQe = ["reloadDocument", "replace", "state", "method", "action", "onSubmit", "submit", "relative", "preventScrollReset"];
process.env.NODE_ENV;
const rQe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", iQe = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, mK = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  let {
    onClick: r,
    relative: i,
    reloadDocument: o,
    replace: a,
    state: s,
    target: u,
    to: l,
    preventScrollReset: f
  } = t, h = gK(t, eQe), {
    basename: p
  } = ae.useContext(Sw), g, y = !1;
  if (typeof l == "string" && iQe.test(l) && (g = l, rQe))
    try {
      let C = new URL(window.location.href), A = l.startsWith("//") ? new URL(C.protocol + l) : new URL(l), O = CW(A.pathname, p);
      A.origin === C.origin && O != null ? l = O + A.search + A.hash : y = !0;
    } catch {
      process.env.NODE_ENV !== "production" && aF(!1, '<Link to="' + l + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let b = zGe(l, {
    relative: i
  }), _ = lQe(l, {
    replace: a,
    state: s,
    target: u,
    preventScrollReset: f,
    relative: i
  });
  function S(C) {
    r && r(C), C.defaultPrevented || _(C);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ ae.createElement("a", vS({}, h, {
      href: g || b,
      onClick: y || o ? r : S,
      ref: n,
      target: u
    }))
  );
});
process.env.NODE_ENV !== "production" && (mK.displayName = "Link");
const oQe = /* @__PURE__ */ ae.forwardRef(function(t, n) {
  let {
    "aria-current": r = "page",
    caseSensitive: i = !1,
    className: o = "",
    end: a = !1,
    style: s,
    to: u,
    children: l
  } = t, f = gK(t, tQe), h = uF(u, {
    relative: f.relative
  }), p = _$(), g = ae.useContext(U1e), {
    navigator: y
  } = ae.useContext(Sw), b = y.encodeLocation ? y.encodeLocation(h).pathname : h.pathname, _ = p.pathname, S = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
  i || (_ = _.toLowerCase(), S = S ? S.toLowerCase() : null, b = b.toLowerCase());
  let C = _ === b || !a && _.startsWith(b) && _.charAt(b.length) === "/", A = S != null && (S === b || !a && S.startsWith(b) && S.charAt(b.length) === "/"), O = C ? r : void 0, R;
  typeof o == "function" ? R = o({
    isActive: C,
    isPending: A
  }) : R = [o, C ? "active" : null, A ? "pending" : null].filter(Boolean).join(" ");
  let j = typeof s == "function" ? s({
    isActive: C,
    isPending: A
  }) : s;
  return /* @__PURE__ */ ae.createElement(mK, vS({}, f, {
    "aria-current": O,
    className: R,
    ref: n,
    style: j,
    to: u
  }), typeof l == "function" ? l({
    isActive: C,
    isPending: A
  }) : l);
});
process.env.NODE_ENV !== "production" && (oQe.displayName = "NavLink");
const aQe = /* @__PURE__ */ ae.forwardRef((e, t) => {
  let n = fQe();
  return /* @__PURE__ */ ae.createElement(G1e, vS({}, e, {
    submit: n,
    ref: t
  }));
});
process.env.NODE_ENV !== "production" && (aQe.displayName = "Form");
const G1e = /* @__PURE__ */ ae.forwardRef((e, t) => {
  let {
    reloadDocument: n,
    replace: r,
    state: i,
    method: o = J3,
    action: a,
    onSubmit: s,
    submit: u,
    relative: l,
    preventScrollReset: f
  } = e, h = gK(e, nQe), p = o.toLowerCase() === "get" ? "get" : "post", g = dQe(a, {
    relative: l
  }), y = (b) => {
    if (s && s(b), b.defaultPrevented)
      return;
    b.preventDefault();
    let _ = b.nativeEvent.submitter, S = (_ == null ? void 0 : _.getAttribute("formmethod")) || o;
    u(_ || b.currentTarget, {
      method: S,
      replace: r,
      state: i,
      relative: l,
      preventScrollReset: f
    });
  };
  return /* @__PURE__ */ ae.createElement("form", vS({
    ref: t,
    method: p,
    action: g,
    onSubmit: n ? s : y
  }, h));
});
process.env.NODE_ENV !== "production" && (G1e.displayName = "FormImpl");
process.env.NODE_ENV;
var DW;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher";
})(DW || (DW = {}));
var dce;
(function(e) {
  e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration";
})(dce || (dce = {}));
function sQe(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function uQe(e) {
  let t = ae.useContext(sF);
  return t || (process.env.NODE_ENV !== "production" ? Vs(!1, sQe(e)) : Vs(!1)), t;
}
function lQe(e, t) {
  let {
    target: n,
    replace: r,
    state: i,
    preventScrollReset: o,
    relative: a
  } = t === void 0 ? {} : t, s = FGe(), u = _$(), l = uF(e, {
    relative: a
  });
  return ae.useCallback((f) => {
    if (XGe(f, n)) {
      f.preventDefault();
      let h = r !== void 0 ? r : TW(u) === TW(l);
      s(e, {
        replace: h,
        state: i,
        preventScrollReset: o,
        relative: a
      });
    }
  }, [u, s, l, r, i, n, e, o, a]);
}
function cQe() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
function fQe() {
  let {
    router: e
  } = uQe(DW.UseSubmit), {
    basename: t
  } = ae.useContext(Sw), n = HGe();
  return ae.useCallback(function(r, i) {
    i === void 0 && (i = {}), cQe();
    let {
      action: o,
      method: a,
      encType: s,
      formData: u,
      body: l
    } = JGe(r, t);
    e.navigate(i.action || o, {
      preventScrollReset: i.preventScrollReset,
      formData: u,
      body: l,
      formMethod: i.method || a,
      formEncType: i.encType || s,
      replace: i.replace,
      state: i.state,
      fromRouteId: n
    });
  }, [e, t, n]);
}
function dQe(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    basename: r
  } = ae.useContext(Sw), i = ae.useContext(eN);
  i || (process.env.NODE_ENV !== "production" ? Vs(!1, "useFormAction must be used inside a RouteContext") : Vs(!1));
  let [o] = i.matches.slice(-1), a = vS({}, uF(e || ".", {
    relative: n
  })), s = _$();
  if (e == null && (a.search = s.search, o.route.index)) {
    let u = new URLSearchParams(a.search);
    u.delete("index"), a.search = u.toString() ? "?" + u.toString() : "";
  }
  return (!e || e === ".") && o.route.index && (a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (a.pathname = a.pathname === "/" ? r : fK([r, a.pathname])), TW(a);
}
var hQe = { fieldSeparator: ",", decimalSeparator: ".", quoteStrings: !0, quoteCharacter: '"', showTitle: !1, title: "My Generated Report", filename: "generated", showColumnHeaders: !0, useTextFile: !1, useBom: !0, columnHeaders: [], useKeysAsHeaders: !1, boolDisplay: { true: "TRUE", false: "FALSE" }, replaceUndefinedWith: "" }, pQe = `\r
`, gQe = "\uFEFF", yK = (e) => Object.assign({}, hQe, e);
class mQe extends Error {
  constructor(t) {
    super(t), this.name = "CsvGenerationError";
  }
}
class yQe extends Error {
  constructor(t) {
    super(t), this.name = "EmptyHeadersError";
  }
}
let vQe = class extends Error {
  constructor(t) {
    super(t), this.name = "CsvDownloadEnvironmentError";
  }
};
var E$ = (e) => e, zg = (e) => e, cF = E$, ok = E$, hce = E$, pce = E$, bQe = function(e, t) {
  return t == '"' && e.indexOf('"') > -1 ? e.replace(/"/g, '""') : e;
}, xQe = (e) => hce(typeof e == "object" ? e.key : e), wQe = (e) => pce(typeof e == "object" ? e.displayLabel : e), _Qe = (e, ...t) => t.reduce((n, r) => r(n), e), EQe = (e) => (t) => e.useBom ? cF(zg(t) + gQe) : t, SQe = (e) => (t) => e.showTitle ? cF(zg(t) + e.title) : t, Q1e = (e) => (t) => cF(zg(e) + zg(t) + pQe), X1e = (e) => (t, n) => MQe(e)(ok(t + n)), MQe = (e) => (t) => E$(zg(t) + e.fieldSeparator), TQe = (e, t) => (n) => {
  if (!e.showColumnHeaders)
    return n;
  if (t.length < 1)
    throw new yQe("Option to show headers but none supplied. Make sure there are keys in your collection or that you've supplied headers through the config options.");
  let r = ok("");
  for (let i = 0; i < t.length; i++) {
    const o = wQe(t[i]);
    r = X1e(e)(r, K1e(e, o));
  }
  return r = ok(zg(r).slice(0, -1)), Q1e(n)(r);
}, CQe = (e, t, n) => (r) => {
  let i = r;
  for (var o = 0; o < n.length; o++) {
    let a = ok("");
    for (let s = 0; s < t.length; s++) {
      const u = xQe(t[s]), l = typeof n[o][zg(u)] > "u" ? e.replaceUndefinedWith : n[o][zg(u)];
      a = X1e(e)(a, K1e(e, l));
    }
    a = ok(zg(a).slice(0, -1)), i = Q1e(i)(a);
  }
  return i;
}, gce = (e) => +e === e && (!isFinite(e) || !!(e % 1)), K1e = (e, t) => {
  if (e.decimalSeparator === "locale" && gce(t))
    return t.toLocaleString();
  if (e.decimalSeparator !== "." && gce(t))
    return t.toString().replace(".", e.decimalSeparator);
  if (typeof t == "string") {
    let n = t;
    return (e.quoteStrings || e.fieldSeparator && t.indexOf(e.fieldSeparator) > -1 || e.quoteCharacter && t.indexOf(e.quoteCharacter) > -1 || t.indexOf(`
`) > -1 || t.indexOf("\r") > -1) && (n = e.quoteCharacter + bQe(t, e.quoteCharacter) + e.quoteCharacter), n;
  }
  if (typeof t == "boolean" && e.boolDisplay) {
    const n = t ? "true" : "false";
    return e.boolDisplay[n];
  }
  return t;
}, NQe = (e) => (t) => {
  const n = yK(e), r = n.useKeysAsHeaders ? Object.keys(t[0]) : n.columnHeaders;
  let i = _Qe(cF(""), EQe(n), SQe(n), TQe(n, r), CQe(n, r, t));
  if (zg(i).length < 1)
    throw new mQe("Output is empty. Is your data formatted correctly?");
  return i;
}, DQe = (e) => (t) => {
  if (!window)
    throw new vQe("Downloading only supported in a browser environment.");
  const n = yK(e), r = zg(t), i = n.useTextFile ? "plain" : "csv", o = n.useTextFile ? "txt" : "csv";
  let a = new Blob([r], { type: `text/${i};charset=utf8;` }), s = document.createElement("a");
  s.download = `${n.filename}.${o}`, s.href = URL.createObjectURL(a), s.setAttribute("visibility", "hidden"), document.body.appendChild(s), s.click(), document.body.removeChild(s);
};
const AQe = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0xMS4wODMzIDdWMTEuMDgzM0gyLjkxNjY3VjdIMS43NVYxMS4wODMzQzEuNzUgMTEuNzI1IDIuMjc1IDEyLjI1IDIuOTE2NjcgMTIuMjVIMTEuMDgzM0MxMS43MjUgMTIuMjUgMTIuMjUgMTEuNzI1IDEyLjI1IDExLjA4MzNWN0gxMS4wODMzWk03LjU4MzMzIDcuMzkwODNMOS4wOTQxNyA1Ljg4NTgzTDkuOTE2NjcgNi43MDgzM0w3IDkuNjI1TDQuMDgzMzMgNi43MDgzM0w0LjkwNTgzIDUuODg1ODNMNi40MTY2NyA3LjM5MDgzVjEuNzVINy41ODMzM1Y3LjM5MDgzWiIgZmlsbD0iIzE4NzFFOCIvPgo8L3N2Zz4=", OQe = "_dataGrid_pfb30_1", RQe = "_urlStyling_pfb30_6", kQe = "_notAvailable_pfb30_15", $Qe = "_tableCell_pfb30_19", PQe = "_tableNumberCell_pfb30_29", IA = {
  dataGrid: OQe,
  urlStyling: RQe,
  notAvailable: kQe,
  tableCell: $Qe,
  tableNumberCell: PQe
};
function Ya() {
  return Ya = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ya.apply(this, arguments);
}
function rT(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Z1e(e) {
  if (!rT(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = Z1e(e[n]);
  }), t;
}
function AW(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? Ya({}, e) : e;
  return rT(e) && rT(t) && Object.keys(t).forEach((i) => {
    i !== "__proto__" && (rT(t[i]) && i in e && rT(e[i]) ? r[i] = AW(e[i], t[i], n) : n.clone ? r[i] = rT(t[i]) ? Z1e(t[i]) : t[i] : r[i] = t[i]);
  }), r;
}
const IQe = "exact-prop: ​";
function jQe(e) {
  return process.env.NODE_ENV === "production" ? e : Ya({}, e, {
    [IQe]: (t) => {
      const n = Object.keys(t).filter((r) => !e.hasOwnProperty(r));
      return n.length > 0 ? new Error(`The following props are not supported: ${n.map((r) => `\`${r}\``).join(", ")}. Please remove them.`) : null;
    }
  });
}
function LQe(e) {
  let t = "https://mui.com/production-error/?code=" + e;
  for (let n = 1; n < arguments.length; n += 1)
    t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified MUI error #" + e + "; visit " + t + " for the full message.";
}
const zQe = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function FQe(e) {
  const t = `${e}`.match(zQe);
  return t && t[1] || "";
}
function J1e(e, t = "") {
  return e.displayName || e.name || FQe(e) || t;
}
function mce(e, t, n) {
  const r = J1e(t);
  return e.displayName || (r !== "" ? `${n}(${r})` : n);
}
function _Y(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return J1e(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case dS.ForwardRef:
          return mce(e, e.render, "ForwardRef");
        case dS.Memo:
          return mce(e, e.type, "memo");
        default:
          return;
      }
  }
}
function EY(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : LQe(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const exe = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (exe.displayName = "ThemeContext");
const BQe = exe;
function UQe() {
  const e = ae.useContext(BQe);
  return process.env.NODE_ENV !== "production" && ae.useDebugValue(e), e;
}
const YQe = typeof Symbol == "function" && Symbol.for, HQe = YQe ? Symbol.for("mui.nested") : "__THEME_NESTED__", VQe = ["checked", "disabled", "error", "focused", "focusVisible", "required", "expanded", "selected"];
function WQe(e = {}) {
  const {
    disableGlobal: t = !1,
    productionPrefix: n = "jss",
    seed: r = ""
  } = e, i = r === "" ? "" : `${r}-`;
  let o = 0;
  const a = () => (o += 1, process.env.NODE_ENV !== "production" && o >= 1e10 && console.warn(["MUI: You might have a memory leak.", "The ruleCounter is not supposed to grow that much."].join("")), o);
  return (s, u) => {
    const l = u.options.name;
    if (l && l.indexOf("Mui") === 0 && !u.options.link && !t) {
      if (VQe.indexOf(s.key) !== -1)
        return `Mui-${s.key}`;
      const h = `${i}${l}-${s.key}`;
      return !u.options.theme[HQe] || r !== "" ? h : `${h}-${a()}`;
    }
    if (process.env.NODE_ENV === "production")
      return `${i}${n}${a()}`;
    const f = `${s.key}-${a()}`;
    return u.options.classNamePrefix ? `${i}${u.options.classNamePrefix}-${f}` : `${i}${f}`;
  };
}
var qQe = process.env.NODE_ENV === "production";
function Pn(e, t) {
  if (!qQe) {
    if (e)
      return;
    var n = "Warning: " + t;
    typeof console < "u" && console.warn(n);
    try {
      throw Error(n);
    } catch {
    }
  }
}
function Od() {
  return Od = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Od.apply(this, arguments);
}
var yce = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
  return typeof e;
} : function(e) {
  return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
}, bb = (typeof window > "u" ? "undefined" : yce(window)) === "object" && (typeof document > "u" ? "undefined" : yce(document)) === "object" && document.nodeType === 9;
function ak(e) {
  "@babel/helpers - typeof";
  return ak = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ak(e);
}
function GQe(e, t) {
  if (ak(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ak(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function QQe(e) {
  var t = GQe(e, "string");
  return ak(t) == "symbol" ? t : t + "";
}
function vce(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, QQe(r.key), r);
  }
}
function txe(e, t, n) {
  return t && vce(e.prototype, t), n && vce(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function OW(e, t) {
  return OW = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, OW(e, t);
}
function nxe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, OW(e, t);
}
function bce(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function XQe(e, t) {
  if (e == null)
    return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0)
        continue;
      n[r] = e[r];
    }
  return n;
}
var KQe = {}.constructor;
function RW(e) {
  if (e == null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    return e.map(RW);
  if (e.constructor !== KQe)
    return e;
  var t = {};
  for (var n in e)
    t[n] = RW(e[n]);
  return t;
}
function vK(e, t, n) {
  e === void 0 && (e = "unnamed");
  var r = n.jss, i = RW(t), o = r.plugins.onCreateRule(e, i, n);
  return o || (e[0] === "@" && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Unknown rule " + e), null);
}
var xce = function(t, n) {
  for (var r = "", i = 0; i < t.length && t[i] !== "!important"; i++)
    r && (r += n), r += t[i];
  return r;
}, mR = function(t) {
  if (!Array.isArray(t))
    return t;
  var n = "";
  if (Array.isArray(t[0]))
    for (var r = 0; r < t.length && t[r] !== "!important"; r++)
      n && (n += ", "), n += xce(t[r], " ");
  else
    n = xce(t, ", ");
  return t[t.length - 1] === "!important" && (n += " !important"), n;
};
function tN(e) {
  return e && e.format === !1 ? {
    linebreak: "",
    space: ""
  } : {
    linebreak: `
`,
    space: " "
  };
}
function jA(e, t) {
  for (var n = "", r = 0; r < t; r++)
    n += "  ";
  return n + e;
}
function sk(e, t, n) {
  n === void 0 && (n = {});
  var r = "";
  if (!t)
    return r;
  var i = n, o = i.indent, a = o === void 0 ? 0 : o, s = t.fallbacks;
  n.format === !1 && (a = -1 / 0);
  var u = tN(n), l = u.linebreak, f = u.space;
  if (e && a++, s)
    if (Array.isArray(s))
      for (var h = 0; h < s.length; h++) {
        var p = s[h];
        for (var g in p) {
          var y = p[g];
          y != null && (r && (r += l), r += jA(g + ":" + f + mR(y) + ";", a));
        }
      }
    else
      for (var b in s) {
        var _ = s[b];
        _ != null && (r && (r += l), r += jA(b + ":" + f + mR(_) + ";", a));
      }
  for (var S in t) {
    var C = t[S];
    C != null && S !== "fallbacks" && (r && (r += l), r += jA(S + ":" + f + mR(C) + ";", a));
  }
  return !r && !n.allowEmpty || !e ? r : (a--, r && (r = "" + l + r + l), jA("" + e + f + "{" + r, a) + jA("}", a));
}
var ZQe = /([[\].#*$><+~=|^:(),"'`\s])/g, wce = typeof CSS < "u" && CSS.escape, bK = function(e) {
  return wce ? wce(e) : e.replace(ZQe, "\\$1");
}, rxe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "style", this.isProcessed = !1;
    var o = i.sheet, a = i.Renderer;
    this.key = n, this.options = i, this.style = r, o ? this.renderer = o.renderer : a && (this.renderer = new a());
  }
  var t = e.prototype;
  return t.prop = function(r, i, o) {
    if (i === void 0)
      return this.style[r];
    var a = o ? o.force : !1;
    if (!a && this.style[r] === i)
      return this;
    var s = i;
    (!o || o.process !== !1) && (s = this.options.jss.plugins.onChangeValue(i, r, this));
    var u = s == null || s === !1, l = r in this.style;
    if (u && !l && !a)
      return this;
    var f = u && l;
    if (f ? delete this.style[r] : this.style[r] = s, this.renderable && this.renderer)
      return f ? this.renderer.removeProperty(this.renderable, r) : this.renderer.setProperty(this.renderable, r, s), this;
    var h = this.options.sheet;
    return h && h.attached && process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Rule is not linked. Missing sheet option "link: true".'), this;
  }, e;
}(), kW = /* @__PURE__ */ function(e) {
  nxe(t, e);
  function t(r, i, o) {
    var a;
    a = e.call(this, r, i, o) || this;
    var s = o.selector, u = o.scoped, l = o.sheet, f = o.generateId;
    return s ? a.selectorText = s : u !== !1 && (a.id = f(bce(bce(a)), l), a.selectorText = "." + bK(a.id)), a;
  }
  var n = t.prototype;
  return n.applyTo = function(i) {
    var o = this.renderer;
    if (o) {
      var a = this.toJSON();
      for (var s in a)
        o.setProperty(i, s, a[s]);
    }
    return this;
  }, n.toJSON = function() {
    var i = {};
    for (var o in this.style) {
      var a = this.style[o];
      typeof a != "object" ? i[o] = a : Array.isArray(a) && (i[o] = mR(a));
    }
    return i;
  }, n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? Od({}, i, {
      allowEmpty: !0
    }) : i;
    return sk(this.selectorText, this.style, s);
  }, txe(t, [{
    key: "selector",
    set: function(i) {
      if (i !== this.selectorText) {
        this.selectorText = i;
        var o = this.renderer, a = this.renderable;
        if (!(!a || !o)) {
          var s = o.setSelector(a, i);
          s || o.replaceRule(a, this);
        }
      }
    },
    get: function() {
      return this.selectorText;
    }
  }]), t;
}(rxe), JQe = {
  onCreateRule: function(t, n, r) {
    return t[0] === "@" || r.parent && r.parent.type === "keyframes" ? null : new kW(t, n, r);
  }
}, SY = {
  indent: 1,
  children: !0
}, eXe = /@([\w-]+)/, tXe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "conditional", this.isProcessed = !1, this.key = n;
    var o = n.match(eXe);
    this.at = o ? o[1] : "unknown", this.query = i.name || "@" + this.at, this.options = i, this.rules = new xK(Od({}, i, {
      parent: this
    }));
    for (var a in r)
      this.rules.add(a, r[a]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.getRule = function(r) {
    return this.rules.get(r);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.addRule = function(r, i, o) {
    var a = this.rules.add(r, i, o);
    return a ? (this.options.jss.plugins.onProcessRule(a), a) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.replace(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.toString = function(r) {
    r === void 0 && (r = SY);
    var i = tN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = SY.indent), r.children == null && (r.children = SY.children), r.children === !1)
      return this.query + " {}";
    var a = this.rules.toString(r);
    return a ? this.query + " {" + o + a + o + "}" : "";
  }, e;
}(), nXe = /@container|@media|@supports\s+/, rXe = {
  onCreateRule: function(t, n, r) {
    return nXe.test(t) ? new tXe(t, n, r) : null;
  }
}, MY = {
  indent: 1,
  children: !0
}, iXe = /@keyframes\s+([\w-]+)/, $W = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1;
    var o = n.match(iXe);
    o && o[1] ? this.name = o[1] : (this.name = "noname", process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Bad keyframes name " + n)), this.key = this.type + "-" + this.name, this.options = i;
    var a = i.scoped, s = i.sheet, u = i.generateId;
    this.id = a === !1 ? this.name : bK(u(this, s)), this.rules = new xK(Od({}, i, {
      parent: this
    }));
    for (var l in r)
      this.rules.add(l, r[l], Od({}, i, {
        parent: this
      }));
    this.rules.process();
  }
  var t = e.prototype;
  return t.toString = function(r) {
    r === void 0 && (r = MY);
    var i = tN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = MY.indent), r.children == null && (r.children = MY.children), r.children === !1)
      return this.at + " " + this.id + " {}";
    var a = this.rules.toString(r);
    return a && (a = "" + o + a + o), this.at + " " + this.id + " {" + a + "}";
  }, e;
}(), oXe = /@keyframes\s+/, aXe = /\$([\w-]+)/g, PW = function(t, n) {
  return typeof t == "string" ? t.replace(aXe, function(r, i) {
    return i in n ? n[i] : (process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Referenced keyframes rule "' + i + '" is not defined.'), r);
  }) : t;
}, _ce = function(t, n, r) {
  var i = t[n], o = PW(i, r);
  o !== i && (t[n] = o);
}, sXe = {
  onCreateRule: function(t, n, r) {
    return typeof t == "string" && oXe.test(t) ? new $W(t, n, r) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function(t, n, r) {
    return n.type !== "style" || !r || ("animation-name" in t && _ce(t, "animation-name", r.keyframes), "animation" in t && _ce(t, "animation", r.keyframes)), t;
  },
  onChangeValue: function(t, n, r) {
    var i = r.options.sheet;
    if (!i)
      return t;
    switch (n) {
      case "animation":
        return PW(t, i.keyframes);
      case "animation-name":
        return PW(t, i.keyframes);
      default:
        return t;
    }
  }
}, uXe = /* @__PURE__ */ function(e) {
  nxe(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var n = t.prototype;
  return n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? Od({}, i, {
      allowEmpty: !0
    }) : i;
    return sk(this.key, this.style, s);
  }, t;
}(rxe), lXe = {
  onCreateRule: function(t, n, r) {
    return r.parent && r.parent.type === "keyframes" ? new uXe(t, n, r) : null;
  }
}, cXe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    var i = tN(r), o = i.linebreak;
    if (Array.isArray(this.style)) {
      for (var a = "", s = 0; s < this.style.length; s++)
        a += sk(this.at, this.style[s]), this.style[s + 1] && (a += o);
      return a;
    }
    return sk(this.at, this.style, r);
  }, e;
}(), fXe = /@font-face/, dXe = {
  onCreateRule: function(t, n, r) {
    return fXe.test(t) ? new cXe(t, n, r) : null;
  }
}, hXe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    return sk(this.key, this.style, r);
  }, e;
}(), pXe = {
  onCreateRule: function(t, n, r) {
    return t === "@viewport" || t === "@-ms-viewport" ? new hXe(t, n, r) : null;
  }
}, gXe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "simple", this.isProcessed = !1, this.key = n, this.value = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    if (Array.isArray(this.value)) {
      for (var i = "", o = 0; o < this.value.length; o++)
        i += this.key + " " + this.value[o] + ";", this.value[o + 1] && (i += `
`);
      return i;
    }
    return this.key + " " + this.value + ";";
  }, e;
}(), mXe = {
  "@charset": !0,
  "@import": !0,
  "@namespace": !0
}, yXe = {
  onCreateRule: function(t, n, r) {
    return t in mXe ? new gXe(t, n, r) : null;
  }
}, Ece = [JQe, rXe, sXe, lXe, dXe, pXe, yXe], vXe = {
  process: !0
}, Sce = {
  force: !0,
  process: !0
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */
}, xK = /* @__PURE__ */ function() {
  function e(n) {
    this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = n, this.classes = n.classes, this.keyframes = n.keyframes;
  }
  var t = e.prototype;
  return t.add = function(r, i, o) {
    var a = this.options, s = a.parent, u = a.sheet, l = a.jss, f = a.Renderer, h = a.generateId, p = a.scoped, g = Od({
      classes: this.classes,
      parent: s,
      sheet: u,
      jss: l,
      Renderer: f,
      generateId: h,
      scoped: p,
      name: r,
      keyframes: this.keyframes,
      selector: void 0
    }, o), y = r;
    r in this.raw && (y = r + "-d" + this.counter++), this.raw[y] = i, y in this.classes && (g.selector = "." + bK(this.classes[y]));
    var b = vK(y, i, g);
    if (!b)
      return null;
    this.register(b);
    var _ = g.index === void 0 ? this.index.length : g.index;
    return this.index.splice(_, 0, b), b;
  }, t.replace = function(r, i, o) {
    var a = this.get(r), s = this.index.indexOf(a);
    a && this.remove(a);
    var u = o;
    return s !== -1 && (u = Od({}, o, {
      index: s
    })), this.add(r, i, u);
  }, t.get = function(r) {
    return this.map[r];
  }, t.remove = function(r) {
    this.unregister(r), delete this.raw[r.key], this.index.splice(this.index.indexOf(r), 1);
  }, t.indexOf = function(r) {
    return this.index.indexOf(r);
  }, t.process = function() {
    var r = this.options.jss.plugins;
    this.index.slice(0).forEach(r.onProcessRule, r);
  }, t.register = function(r) {
    this.map[r.key] = r, r instanceof kW ? (this.map[r.selector] = r, r.id && (this.classes[r.key] = r.id)) : r instanceof $W && this.keyframes && (this.keyframes[r.name] = r.id);
  }, t.unregister = function(r) {
    delete this.map[r.key], r instanceof kW ? (delete this.map[r.selector], delete this.classes[r.key]) : r instanceof $W && delete this.keyframes[r.name];
  }, t.update = function() {
    var r, i, o;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (r = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], o = arguments.length <= 2 ? void 0 : arguments[2]) : (i = arguments.length <= 0 ? void 0 : arguments[0], o = arguments.length <= 1 ? void 0 : arguments[1], r = null), r)
      this.updateOne(this.get(r), i, o);
    else
      for (var a = 0; a < this.index.length; a++)
        this.updateOne(this.index[a], i, o);
  }, t.updateOne = function(r, i, o) {
    o === void 0 && (o = vXe);
    var a = this.options, s = a.jss.plugins, u = a.sheet;
    if (r.rules instanceof e) {
      r.rules.update(i, o);
      return;
    }
    var l = r.style;
    if (s.onUpdate(i, r, u, o), o.process && l && l !== r.style) {
      s.onProcessStyle(r.style, r, u);
      for (var f in r.style) {
        var h = r.style[f], p = l[f];
        h !== p && r.prop(f, h, Sce);
      }
      for (var g in l) {
        var y = r.style[g], b = l[g];
        y == null && y !== b && r.prop(g, null, Sce);
      }
    }
  }, t.toString = function(r) {
    for (var i = "", o = this.options.sheet, a = o ? o.options.link : !1, s = tN(r), u = s.linebreak, l = 0; l < this.index.length; l++) {
      var f = this.index[l], h = f.toString(r);
      !h && !a || (i && (i += u), i += h);
    }
    return i;
  }, e;
}(), ixe = /* @__PURE__ */ function() {
  function e(n, r) {
    this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = Od({}, r, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    }), r.Renderer && (this.renderer = new r.Renderer(this)), this.rules = new xK(this.options);
    for (var i in n)
      this.rules.add(i, n[i]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.attach = function() {
    return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this);
  }, t.detach = function() {
    return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this;
  }, t.addRule = function(r, i, o) {
    var a = this.queue;
    this.attached && !a && (this.queue = []);
    var s = this.rules.add(r, i, o);
    return s ? (this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && (a ? a.push(s) : (this.insertRule(s), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), s) : (this.deployed = !1, s)) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.get(r);
    if (!a)
      return this.addRule(r, i, o);
    var s = this.rules.replace(r, i, o);
    return s && this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && this.renderer && (s ? a.renderable && this.renderer.replaceRule(a.renderable, s) : this.renderer.deleteRule(a)), s) : (this.deployed = !1, s);
  }, t.insertRule = function(r) {
    this.renderer && this.renderer.insertRule(r);
  }, t.addRules = function(r, i) {
    var o = [];
    for (var a in r) {
      var s = this.addRule(a, r[a], i);
      s && o.push(s);
    }
    return o;
  }, t.getRule = function(r) {
    return this.rules.get(r);
  }, t.deleteRule = function(r) {
    var i = typeof r == "object" ? r : this.rules.get(r);
    return !i || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !i.renderable ? !1 : (this.rules.remove(i), this.attached && i.renderable && this.renderer ? this.renderer.deleteRule(i.renderable) : !0);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.deploy = function() {
    return this.renderer && this.renderer.deploy(), this.deployed = !0, this;
  }, t.update = function() {
    var r;
    return (r = this.rules).update.apply(r, arguments), this;
  }, t.updateOne = function(r, i, o) {
    return this.rules.updateOne(r, i, o), this;
  }, t.toString = function(r) {
    return this.rules.toString(r);
  }, e;
}(), bXe = /* @__PURE__ */ function() {
  function e() {
    this.plugins = {
      internal: [],
      external: []
    }, this.registry = {};
  }
  var t = e.prototype;
  return t.onCreateRule = function(r, i, o) {
    for (var a = 0; a < this.registry.onCreateRule.length; a++) {
      var s = this.registry.onCreateRule[a](r, i, o);
      if (s)
        return s;
    }
    return null;
  }, t.onProcessRule = function(r) {
    if (!r.isProcessed) {
      for (var i = r.options.sheet, o = 0; o < this.registry.onProcessRule.length; o++)
        this.registry.onProcessRule[o](r, i);
      r.style && this.onProcessStyle(r.style, r, i), r.isProcessed = !0;
    }
  }, t.onProcessStyle = function(r, i, o) {
    for (var a = 0; a < this.registry.onProcessStyle.length; a++)
      i.style = this.registry.onProcessStyle[a](i.style, i, o);
  }, t.onProcessSheet = function(r) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++)
      this.registry.onProcessSheet[i](r);
  }, t.onUpdate = function(r, i, o, a) {
    for (var s = 0; s < this.registry.onUpdate.length; s++)
      this.registry.onUpdate[s](r, i, o, a);
  }, t.onChangeValue = function(r, i, o) {
    for (var a = r, s = 0; s < this.registry.onChangeValue.length; s++)
      a = this.registry.onChangeValue[s](a, i, o);
    return a;
  }, t.use = function(r, i) {
    i === void 0 && (i = {
      queue: "external"
    });
    var o = this.plugins[i.queue];
    o.indexOf(r) === -1 && (o.push(r), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(a, s) {
      for (var u in s)
        u in a ? a[u].push(s[u]) : process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Unknown hook "' + u + '".');
      return a;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    }));
  }, e;
}(), xXe = /* @__PURE__ */ function() {
  function e() {
    this.registry = [];
  }
  var t = e.prototype;
  return t.add = function(r) {
    var i = this.registry, o = r.options.index;
    if (i.indexOf(r) === -1) {
      if (i.length === 0 || o >= this.index) {
        i.push(r);
        return;
      }
      for (var a = 0; a < i.length; a++)
        if (i[a].options.index > o) {
          i.splice(a, 0, r);
          return;
        }
    }
  }, t.reset = function() {
    this.registry = [];
  }, t.remove = function(r) {
    var i = this.registry.indexOf(r);
    this.registry.splice(i, 1);
  }, t.toString = function(r) {
    for (var i = r === void 0 ? {} : r, o = i.attached, a = XQe(i, ["attached"]), s = tN(a), u = s.linebreak, l = "", f = 0; f < this.registry.length; f++) {
      var h = this.registry[f];
      o != null && h.attached !== o || (l && (l += u), l += h.toString(a));
    }
    return l;
  }, txe(e, [{
    key: "index",
    /**
     * Current highest index number.
     */
    get: function() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]), e;
}(), yR = new xXe(), IW = typeof globalThis < "u" ? globalThis : typeof window < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), jW = "2f1acc6c3a606b082e5eef5e54414ffb";
IW[jW] == null && (IW[jW] = 0);
var Mce = IW[jW]++, wXe = 1e10, Tce = function(t) {
  t === void 0 && (t = {});
  var n = 0, r = function(o, a) {
    n += 1, n > wXe && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] You might have a memory leak. Rule counter is at " + n + ".");
    var s = "", u = "";
    return a && (a.options.classNamePrefix && (u = a.options.classNamePrefix), a.options.jss.id != null && (s = String(a.options.jss.id))), t.minify ? "" + (u || "c") + Mce + s + n : u + o.key + "-" + Mce + (s ? "-" + s : "") + "-" + n;
  };
  return r;
}, oxe = function(t) {
  var n;
  return function() {
    return n || (n = t()), n;
  };
}, _Xe = function(t, n) {
  try {
    return t.attributeStyleMap ? t.attributeStyleMap.get(n) : t.style.getPropertyValue(n);
  } catch {
    return "";
  }
}, EXe = function(t, n, r) {
  try {
    var i = r;
    if (Array.isArray(r) && (i = mR(r)), t.attributeStyleMap)
      t.attributeStyleMap.set(n, i);
    else {
      var o = i ? i.indexOf("!important") : -1, a = o > -1 ? i.substr(0, o - 1) : i;
      t.style.setProperty(n, a, o > -1 ? "important" : "");
    }
  } catch {
    return !1;
  }
  return !0;
}, SXe = function(t, n) {
  try {
    t.attributeStyleMap ? t.attributeStyleMap.delete(n) : t.style.removeProperty(n);
  } catch (r) {
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] DOMException "' + r.message + '" was thrown. Tried to remove property "' + n + '".');
  }
}, MXe = function(t, n) {
  return t.selectorText = n, t.selectorText === n;
}, axe = oxe(function() {
  return document.querySelector("head");
});
function TXe(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    if (r.attached && r.options.index > t.index && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function CXe(e, t) {
  for (var n = e.length - 1; n >= 0; n--) {
    var r = e[n];
    if (r.attached && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function NXe(e) {
  for (var t = axe(), n = 0; n < t.childNodes.length; n++) {
    var r = t.childNodes[n];
    if (r.nodeType === 8 && r.nodeValue.trim() === e)
      return r;
  }
  return null;
}
function DXe(e) {
  var t = yR.registry;
  if (t.length > 0) {
    var n = TXe(t, e);
    if (n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element
      };
    if (n = CXe(t, e), n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element.nextSibling
      };
  }
  var r = e.insertionPoint;
  if (r && typeof r == "string") {
    var i = NXe(r);
    if (i)
      return {
        parent: i.parentNode,
        node: i.nextSibling
      };
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Insertion point "' + r + '" not found.');
  }
  return !1;
}
function AXe(e, t) {
  var n = t.insertionPoint, r = DXe(t);
  if (r !== !1 && r.parent) {
    r.parent.insertBefore(e, r.node);
    return;
  }
  if (n && typeof n.nodeType == "number") {
    var i = n, o = i.parentNode;
    o ? o.insertBefore(e, i.nextSibling) : process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Insertion point is not in the DOM.");
    return;
  }
  axe().appendChild(e);
}
var OXe = oxe(function() {
  var e = document.querySelector('meta[property="csp-nonce"]');
  return e ? e.getAttribute("content") : null;
}), Cce = function(t, n, r) {
  try {
    "insertRule" in t ? t.insertRule(n, r) : "appendRule" in t && t.appendRule(n);
  } catch (i) {
    return process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] " + i.message), !1;
  }
  return t.cssRules[r];
}, Nce = function(t, n) {
  var r = t.cssRules.length;
  return n === void 0 || n > r ? r : n;
}, RXe = function() {
  var t = document.createElement("style");
  return t.textContent = `
`, t;
}, kXe = /* @__PURE__ */ function() {
  function e(n) {
    this.getPropertyValue = _Xe, this.setProperty = EXe, this.removeProperty = SXe, this.setSelector = MXe, this.hasInsertedRules = !1, this.cssRules = [], n && yR.add(n), this.sheet = n;
    var r = this.sheet ? this.sheet.options : {}, i = r.media, o = r.meta, a = r.element;
    this.element = a || RXe(), this.element.setAttribute("data-jss", ""), i && this.element.setAttribute("media", i), o && this.element.setAttribute("data-meta", o);
    var s = OXe();
    s && this.element.setAttribute("nonce", s);
  }
  var t = e.prototype;
  return t.attach = function() {
    if (!(this.element.parentNode || !this.sheet)) {
      AXe(this.element, this.sheet.options);
      var r = !!(this.sheet && this.sheet.deployed);
      this.hasInsertedRules && r && (this.hasInsertedRules = !1, this.deploy());
    }
  }, t.detach = function() {
    if (this.sheet) {
      var r = this.element.parentNode;
      r && r.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`);
    }
  }, t.deploy = function() {
    var r = this.sheet;
    if (r) {
      if (r.options.link) {
        this.insertRules(r.rules);
        return;
      }
      this.element.textContent = `
` + r.toString() + `
`;
    }
  }, t.insertRules = function(r, i) {
    for (var o = 0; o < r.index.length; o++)
      this.insertRule(r.index[o], o, i);
  }, t.insertRule = function(r, i, o) {
    if (o === void 0 && (o = this.element.sheet), r.rules) {
      var a = r, s = o;
      if (r.type === "conditional" || r.type === "keyframes") {
        var u = Nce(o, i);
        if (s = Cce(o, a.toString({
          children: !1
        }), u), s === !1)
          return !1;
        this.refCssRule(r, u, s);
      }
      return this.insertRules(a.rules, s), s;
    }
    var l = r.toString();
    if (!l)
      return !1;
    var f = Nce(o, i), h = Cce(o, l, f);
    return h === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(r, f, h), h);
  }, t.refCssRule = function(r, i, o) {
    r.renderable = o, r.options.parent instanceof ixe && this.cssRules.splice(i, 0, o);
  }, t.deleteRule = function(r) {
    var i = this.element.sheet, o = this.indexOf(r);
    return o === -1 ? !1 : (i.deleteRule(o), this.cssRules.splice(o, 1), !0);
  }, t.indexOf = function(r) {
    return this.cssRules.indexOf(r);
  }, t.replaceRule = function(r, i) {
    var o = this.indexOf(r);
    return o === -1 ? !1 : (this.element.sheet.deleteRule(o), this.cssRules.splice(o, 1), this.insertRule(i, o));
  }, t.getRules = function() {
    return this.element.sheet.cssRules;
  }, e;
}(), $Xe = 0, PXe = /* @__PURE__ */ function() {
  function e(n) {
    this.id = $Xe++, this.version = "10.10.0", this.plugins = new bXe(), this.options = {
      id: {
        minify: !1
      },
      createGenerateId: Tce,
      Renderer: bb ? kXe : null,
      plugins: []
    }, this.generateId = Tce({
      minify: !1
    });
    for (var r = 0; r < Ece.length; r++)
      this.plugins.use(Ece[r], {
        queue: "internal"
      });
    this.setup(n);
  }
  var t = e.prototype;
  return t.setup = function(r) {
    return r === void 0 && (r = {}), r.createGenerateId && (this.options.createGenerateId = r.createGenerateId), r.id && (this.options.id = Od({}, this.options.id, r.id)), (r.createGenerateId || r.id) && (this.generateId = this.options.createGenerateId(this.options.id)), r.insertionPoint != null && (this.options.insertionPoint = r.insertionPoint), "Renderer" in r && (this.options.Renderer = r.Renderer), r.plugins && this.use.apply(this, r.plugins), this;
  }, t.createStyleSheet = function(r, i) {
    i === void 0 && (i = {});
    var o = i, a = o.index;
    typeof a != "number" && (a = yR.index === 0 ? 0 : yR.index + 1);
    var s = new ixe(r, Od({}, i, {
      jss: this,
      generateId: i.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: a
    }));
    return this.plugins.onProcessSheet(s), s;
  }, t.removeStyleSheet = function(r) {
    return r.detach(), yR.remove(r), this;
  }, t.createRule = function(r, i, o) {
    if (i === void 0 && (i = {}), o === void 0 && (o = {}), typeof r == "object")
      return this.createRule(void 0, r, i);
    var a = Od({}, o, {
      name: r,
      jss: this,
      Renderer: this.options.Renderer
    });
    a.generateId || (a.generateId = this.generateId), a.classes || (a.classes = {}), a.keyframes || (a.keyframes = {});
    var s = vK(r, i, a);
    return s && this.plugins.onProcessRule(s), s;
  }, t.use = function() {
    for (var r = this, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return o.forEach(function(s) {
      r.plugins.use(s);
    }), this;
  }, e;
}(), IXe = function(t) {
  return new PXe(t);
};
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
IXe();
var sxe = Date.now(), TY = "fnValues" + sxe, CY = "fnStyle" + ++sxe, jXe = function() {
  return {
    onCreateRule: function(n, r, i) {
      if (typeof r != "function")
        return null;
      var o = vK(n, {}, i);
      return o[CY] = r, o;
    },
    onProcessStyle: function(n, r) {
      if (TY in r || CY in r)
        return n;
      var i = {};
      for (var o in n) {
        var a = n[o];
        typeof a == "function" && (delete n[o], i[o] = a);
      }
      return r[TY] = i, n;
    },
    onUpdate: function(n, r, i, o) {
      var a = r, s = a[CY];
      if (s && (a.style = s(n) || {}, process.env.NODE_ENV === "development")) {
        for (var u in a.style)
          if (typeof a.style[u] == "function") {
            process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Function values inside function rules are not supported.");
            break;
          }
      }
      var l = a[TY];
      if (l)
        for (var f in l)
          a.prop(f, l[f](n), o);
    }
  };
};
const LXe = jXe;
function nl() {
  return nl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, nl.apply(this, arguments);
}
function uk(e) {
  "@babel/helpers - typeof";
  return uk = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, uk(e);
}
function zXe(e, t) {
  if (uk(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (uk(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function FXe(e) {
  var t = zXe(e, "string");
  return uk(t) == "symbol" ? t : t + "";
}
function Dce(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, FXe(r.key), r);
  }
}
function uxe(e, t, n) {
  return t && Dce(e.prototype, t), n && Dce(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function LW(e, t) {
  return LW = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, LW(e, t);
}
function lxe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, LW(e, t);
}
function Ace(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function BXe(e, t) {
  if (e == null)
    return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0)
        continue;
      n[r] = e[r];
    }
  return n;
}
var UXe = {}.constructor;
function zW(e) {
  if (e == null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    return e.map(zW);
  if (e.constructor !== UXe)
    return e;
  var t = {};
  for (var n in e)
    t[n] = zW(e[n]);
  return t;
}
function cxe(e, t, n) {
  e === void 0 && (e = "unnamed");
  var r = n.jss, i = zW(t), o = r.plugins.onCreateRule(e, i, n);
  return o || (e[0] === "@" && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Unknown rule " + e), null);
}
var Oce = function(t, n) {
  for (var r = "", i = 0; i < t.length && t[i] !== "!important"; i++)
    r && (r += n), r += t[i];
  return r;
}, vR = function(t) {
  if (!Array.isArray(t))
    return t;
  var n = "";
  if (Array.isArray(t[0]))
    for (var r = 0; r < t.length && t[r] !== "!important"; r++)
      n && (n += ", "), n += Oce(t[r], " ");
  else
    n = Oce(t, ", ");
  return t[t.length - 1] === "!important" && (n += " !important"), n;
};
function nN(e) {
  return e && e.format === !1 ? {
    linebreak: "",
    space: ""
  } : {
    linebreak: `
`,
    space: " "
  };
}
function LA(e, t) {
  for (var n = "", r = 0; r < t; r++)
    n += "  ";
  return n + e;
}
function lk(e, t, n) {
  n === void 0 && (n = {});
  var r = "";
  if (!t)
    return r;
  var i = n, o = i.indent, a = o === void 0 ? 0 : o, s = t.fallbacks;
  n.format === !1 && (a = -1 / 0);
  var u = nN(n), l = u.linebreak, f = u.space;
  if (e && a++, s)
    if (Array.isArray(s))
      for (var h = 0; h < s.length; h++) {
        var p = s[h];
        for (var g in p) {
          var y = p[g];
          y != null && (r && (r += l), r += LA(g + ":" + f + vR(y) + ";", a));
        }
      }
    else
      for (var b in s) {
        var _ = s[b];
        _ != null && (r && (r += l), r += LA(b + ":" + f + vR(_) + ";", a));
      }
  for (var S in t) {
    var C = t[S];
    C != null && S !== "fallbacks" && (r && (r += l), r += LA(S + ":" + f + vR(C) + ";", a));
  }
  return !r && !n.allowEmpty || !e ? r : (a--, r && (r = "" + l + r + l), LA("" + e + f + "{" + r, a) + LA("}", a));
}
var YXe = /([[\].#*$><+~=|^:(),"'`\s])/g, Rce = typeof CSS < "u" && CSS.escape, wK = function(e) {
  return Rce ? Rce(e) : e.replace(YXe, "\\$1");
}, fxe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "style", this.isProcessed = !1;
    var o = i.sheet, a = i.Renderer;
    this.key = n, this.options = i, this.style = r, o ? this.renderer = o.renderer : a && (this.renderer = new a());
  }
  var t = e.prototype;
  return t.prop = function(r, i, o) {
    if (i === void 0)
      return this.style[r];
    var a = o ? o.force : !1;
    if (!a && this.style[r] === i)
      return this;
    var s = i;
    (!o || o.process !== !1) && (s = this.options.jss.plugins.onChangeValue(i, r, this));
    var u = s == null || s === !1, l = r in this.style;
    if (u && !l && !a)
      return this;
    var f = u && l;
    if (f ? delete this.style[r] : this.style[r] = s, this.renderable && this.renderer)
      return f ? this.renderer.removeProperty(this.renderable, r) : this.renderer.setProperty(this.renderable, r, s), this;
    var h = this.options.sheet;
    return h && h.attached && process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Rule is not linked. Missing sheet option "link: true".'), this;
  }, e;
}(), FW = /* @__PURE__ */ function(e) {
  lxe(t, e);
  function t(r, i, o) {
    var a;
    a = e.call(this, r, i, o) || this;
    var s = o.selector, u = o.scoped, l = o.sheet, f = o.generateId;
    return s ? a.selectorText = s : u !== !1 && (a.id = f(Ace(Ace(a)), l), a.selectorText = "." + wK(a.id)), a;
  }
  var n = t.prototype;
  return n.applyTo = function(i) {
    var o = this.renderer;
    if (o) {
      var a = this.toJSON();
      for (var s in a)
        o.setProperty(i, s, a[s]);
    }
    return this;
  }, n.toJSON = function() {
    var i = {};
    for (var o in this.style) {
      var a = this.style[o];
      typeof a != "object" ? i[o] = a : Array.isArray(a) && (i[o] = vR(a));
    }
    return i;
  }, n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? nl({}, i, {
      allowEmpty: !0
    }) : i;
    return lk(this.selectorText, this.style, s);
  }, uxe(t, [{
    key: "selector",
    set: function(i) {
      if (i !== this.selectorText) {
        this.selectorText = i;
        var o = this.renderer, a = this.renderable;
        if (!(!a || !o)) {
          var s = o.setSelector(a, i);
          s || o.replaceRule(a, this);
        }
      }
    },
    get: function() {
      return this.selectorText;
    }
  }]), t;
}(fxe), HXe = {
  onCreateRule: function(t, n, r) {
    return t[0] === "@" || r.parent && r.parent.type === "keyframes" ? null : new FW(t, n, r);
  }
}, NY = {
  indent: 1,
  children: !0
}, VXe = /@([\w-]+)/, WXe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "conditional", this.isProcessed = !1, this.key = n;
    var o = n.match(VXe);
    this.at = o ? o[1] : "unknown", this.query = i.name || "@" + this.at, this.options = i, this.rules = new fF(nl({}, i, {
      parent: this
    }));
    for (var a in r)
      this.rules.add(a, r[a]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.getRule = function(r) {
    return this.rules.get(r);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.addRule = function(r, i, o) {
    var a = this.rules.add(r, i, o);
    return a ? (this.options.jss.plugins.onProcessRule(a), a) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.replace(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.toString = function(r) {
    r === void 0 && (r = NY);
    var i = nN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = NY.indent), r.children == null && (r.children = NY.children), r.children === !1)
      return this.query + " {}";
    var a = this.rules.toString(r);
    return a ? this.query + " {" + o + a + o + "}" : "";
  }, e;
}(), qXe = /@container|@media|@supports\s+/, GXe = {
  onCreateRule: function(t, n, r) {
    return qXe.test(t) ? new WXe(t, n, r) : null;
  }
}, DY = {
  indent: 1,
  children: !0
}, QXe = /@keyframes\s+([\w-]+)/, BW = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1;
    var o = n.match(QXe);
    o && o[1] ? this.name = o[1] : (this.name = "noname", process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Bad keyframes name " + n)), this.key = this.type + "-" + this.name, this.options = i;
    var a = i.scoped, s = i.sheet, u = i.generateId;
    this.id = a === !1 ? this.name : wK(u(this, s)), this.rules = new fF(nl({}, i, {
      parent: this
    }));
    for (var l in r)
      this.rules.add(l, r[l], nl({}, i, {
        parent: this
      }));
    this.rules.process();
  }
  var t = e.prototype;
  return t.toString = function(r) {
    r === void 0 && (r = DY);
    var i = nN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = DY.indent), r.children == null && (r.children = DY.children), r.children === !1)
      return this.at + " " + this.id + " {}";
    var a = this.rules.toString(r);
    return a && (a = "" + o + a + o), this.at + " " + this.id + " {" + a + "}";
  }, e;
}(), XXe = /@keyframes\s+/, KXe = /\$([\w-]+)/g, UW = function(t, n) {
  return typeof t == "string" ? t.replace(KXe, function(r, i) {
    return i in n ? n[i] : (process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Referenced keyframes rule "' + i + '" is not defined.'), r);
  }) : t;
}, kce = function(t, n, r) {
  var i = t[n], o = UW(i, r);
  o !== i && (t[n] = o);
}, ZXe = {
  onCreateRule: function(t, n, r) {
    return typeof t == "string" && XXe.test(t) ? new BW(t, n, r) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function(t, n, r) {
    return n.type !== "style" || !r || ("animation-name" in t && kce(t, "animation-name", r.keyframes), "animation" in t && kce(t, "animation", r.keyframes)), t;
  },
  onChangeValue: function(t, n, r) {
    var i = r.options.sheet;
    if (!i)
      return t;
    switch (n) {
      case "animation":
        return UW(t, i.keyframes);
      case "animation-name":
        return UW(t, i.keyframes);
      default:
        return t;
    }
  }
}, JXe = /* @__PURE__ */ function(e) {
  lxe(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var n = t.prototype;
  return n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? nl({}, i, {
      allowEmpty: !0
    }) : i;
    return lk(this.key, this.style, s);
  }, t;
}(fxe), eKe = {
  onCreateRule: function(t, n, r) {
    return r.parent && r.parent.type === "keyframes" ? new JXe(t, n, r) : null;
  }
}, tKe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    var i = nN(r), o = i.linebreak;
    if (Array.isArray(this.style)) {
      for (var a = "", s = 0; s < this.style.length; s++)
        a += lk(this.at, this.style[s]), this.style[s + 1] && (a += o);
      return a;
    }
    return lk(this.at, this.style, r);
  }, e;
}(), nKe = /@font-face/, rKe = {
  onCreateRule: function(t, n, r) {
    return nKe.test(t) ? new tKe(t, n, r) : null;
  }
}, iKe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    return lk(this.key, this.style, r);
  }, e;
}(), oKe = {
  onCreateRule: function(t, n, r) {
    return t === "@viewport" || t === "@-ms-viewport" ? new iKe(t, n, r) : null;
  }
}, aKe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "simple", this.isProcessed = !1, this.key = n, this.value = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    if (Array.isArray(this.value)) {
      for (var i = "", o = 0; o < this.value.length; o++)
        i += this.key + " " + this.value[o] + ";", this.value[o + 1] && (i += `
`);
      return i;
    }
    return this.key + " " + this.value + ";";
  }, e;
}(), sKe = {
  "@charset": !0,
  "@import": !0,
  "@namespace": !0
}, uKe = {
  onCreateRule: function(t, n, r) {
    return t in sKe ? new aKe(t, n, r) : null;
  }
}, $ce = [HXe, GXe, ZXe, eKe, rKe, oKe, uKe], lKe = {
  process: !0
}, Pce = {
  force: !0,
  process: !0
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */
}, fF = /* @__PURE__ */ function() {
  function e(n) {
    this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = n, this.classes = n.classes, this.keyframes = n.keyframes;
  }
  var t = e.prototype;
  return t.add = function(r, i, o) {
    var a = this.options, s = a.parent, u = a.sheet, l = a.jss, f = a.Renderer, h = a.generateId, p = a.scoped, g = nl({
      classes: this.classes,
      parent: s,
      sheet: u,
      jss: l,
      Renderer: f,
      generateId: h,
      scoped: p,
      name: r,
      keyframes: this.keyframes,
      selector: void 0
    }, o), y = r;
    r in this.raw && (y = r + "-d" + this.counter++), this.raw[y] = i, y in this.classes && (g.selector = "." + wK(this.classes[y]));
    var b = cxe(y, i, g);
    if (!b)
      return null;
    this.register(b);
    var _ = g.index === void 0 ? this.index.length : g.index;
    return this.index.splice(_, 0, b), b;
  }, t.replace = function(r, i, o) {
    var a = this.get(r), s = this.index.indexOf(a);
    a && this.remove(a);
    var u = o;
    return s !== -1 && (u = nl({}, o, {
      index: s
    })), this.add(r, i, u);
  }, t.get = function(r) {
    return this.map[r];
  }, t.remove = function(r) {
    this.unregister(r), delete this.raw[r.key], this.index.splice(this.index.indexOf(r), 1);
  }, t.indexOf = function(r) {
    return this.index.indexOf(r);
  }, t.process = function() {
    var r = this.options.jss.plugins;
    this.index.slice(0).forEach(r.onProcessRule, r);
  }, t.register = function(r) {
    this.map[r.key] = r, r instanceof FW ? (this.map[r.selector] = r, r.id && (this.classes[r.key] = r.id)) : r instanceof BW && this.keyframes && (this.keyframes[r.name] = r.id);
  }, t.unregister = function(r) {
    delete this.map[r.key], r instanceof FW ? (delete this.map[r.selector], delete this.classes[r.key]) : r instanceof BW && delete this.keyframes[r.name];
  }, t.update = function() {
    var r, i, o;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (r = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], o = arguments.length <= 2 ? void 0 : arguments[2]) : (i = arguments.length <= 0 ? void 0 : arguments[0], o = arguments.length <= 1 ? void 0 : arguments[1], r = null), r)
      this.updateOne(this.get(r), i, o);
    else
      for (var a = 0; a < this.index.length; a++)
        this.updateOne(this.index[a], i, o);
  }, t.updateOne = function(r, i, o) {
    o === void 0 && (o = lKe);
    var a = this.options, s = a.jss.plugins, u = a.sheet;
    if (r.rules instanceof e) {
      r.rules.update(i, o);
      return;
    }
    var l = r.style;
    if (s.onUpdate(i, r, u, o), o.process && l && l !== r.style) {
      s.onProcessStyle(r.style, r, u);
      for (var f in r.style) {
        var h = r.style[f], p = l[f];
        h !== p && r.prop(f, h, Pce);
      }
      for (var g in l) {
        var y = r.style[g], b = l[g];
        y == null && y !== b && r.prop(g, null, Pce);
      }
    }
  }, t.toString = function(r) {
    for (var i = "", o = this.options.sheet, a = o ? o.options.link : !1, s = nN(r), u = s.linebreak, l = 0; l < this.index.length; l++) {
      var f = this.index[l], h = f.toString(r);
      !h && !a || (i && (i += u), i += h);
    }
    return i;
  }, e;
}(), dxe = /* @__PURE__ */ function() {
  function e(n, r) {
    this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = nl({}, r, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    }), r.Renderer && (this.renderer = new r.Renderer(this)), this.rules = new fF(this.options);
    for (var i in n)
      this.rules.add(i, n[i]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.attach = function() {
    return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this);
  }, t.detach = function() {
    return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this;
  }, t.addRule = function(r, i, o) {
    var a = this.queue;
    this.attached && !a && (this.queue = []);
    var s = this.rules.add(r, i, o);
    return s ? (this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && (a ? a.push(s) : (this.insertRule(s), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), s) : (this.deployed = !1, s)) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.get(r);
    if (!a)
      return this.addRule(r, i, o);
    var s = this.rules.replace(r, i, o);
    return s && this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && this.renderer && (s ? a.renderable && this.renderer.replaceRule(a.renderable, s) : this.renderer.deleteRule(a)), s) : (this.deployed = !1, s);
  }, t.insertRule = function(r) {
    this.renderer && this.renderer.insertRule(r);
  }, t.addRules = function(r, i) {
    var o = [];
    for (var a in r) {
      var s = this.addRule(a, r[a], i);
      s && o.push(s);
    }
    return o;
  }, t.getRule = function(r) {
    return this.rules.get(r);
  }, t.deleteRule = function(r) {
    var i = typeof r == "object" ? r : this.rules.get(r);
    return !i || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !i.renderable ? !1 : (this.rules.remove(i), this.attached && i.renderable && this.renderer ? this.renderer.deleteRule(i.renderable) : !0);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.deploy = function() {
    return this.renderer && this.renderer.deploy(), this.deployed = !0, this;
  }, t.update = function() {
    var r;
    return (r = this.rules).update.apply(r, arguments), this;
  }, t.updateOne = function(r, i, o) {
    return this.rules.updateOne(r, i, o), this;
  }, t.toString = function(r) {
    return this.rules.toString(r);
  }, e;
}(), cKe = /* @__PURE__ */ function() {
  function e() {
    this.plugins = {
      internal: [],
      external: []
    }, this.registry = {};
  }
  var t = e.prototype;
  return t.onCreateRule = function(r, i, o) {
    for (var a = 0; a < this.registry.onCreateRule.length; a++) {
      var s = this.registry.onCreateRule[a](r, i, o);
      if (s)
        return s;
    }
    return null;
  }, t.onProcessRule = function(r) {
    if (!r.isProcessed) {
      for (var i = r.options.sheet, o = 0; o < this.registry.onProcessRule.length; o++)
        this.registry.onProcessRule[o](r, i);
      r.style && this.onProcessStyle(r.style, r, i), r.isProcessed = !0;
    }
  }, t.onProcessStyle = function(r, i, o) {
    for (var a = 0; a < this.registry.onProcessStyle.length; a++)
      i.style = this.registry.onProcessStyle[a](i.style, i, o);
  }, t.onProcessSheet = function(r) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++)
      this.registry.onProcessSheet[i](r);
  }, t.onUpdate = function(r, i, o, a) {
    for (var s = 0; s < this.registry.onUpdate.length; s++)
      this.registry.onUpdate[s](r, i, o, a);
  }, t.onChangeValue = function(r, i, o) {
    for (var a = r, s = 0; s < this.registry.onChangeValue.length; s++)
      a = this.registry.onChangeValue[s](a, i, o);
    return a;
  }, t.use = function(r, i) {
    i === void 0 && (i = {
      queue: "external"
    });
    var o = this.plugins[i.queue];
    o.indexOf(r) === -1 && (o.push(r), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(a, s) {
      for (var u in s)
        u in a ? a[u].push(s[u]) : process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Unknown hook "' + u + '".');
      return a;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    }));
  }, e;
}(), fKe = /* @__PURE__ */ function() {
  function e() {
    this.registry = [];
  }
  var t = e.prototype;
  return t.add = function(r) {
    var i = this.registry, o = r.options.index;
    if (i.indexOf(r) === -1) {
      if (i.length === 0 || o >= this.index) {
        i.push(r);
        return;
      }
      for (var a = 0; a < i.length; a++)
        if (i[a].options.index > o) {
          i.splice(a, 0, r);
          return;
        }
    }
  }, t.reset = function() {
    this.registry = [];
  }, t.remove = function(r) {
    var i = this.registry.indexOf(r);
    this.registry.splice(i, 1);
  }, t.toString = function(r) {
    for (var i = r === void 0 ? {} : r, o = i.attached, a = BXe(i, ["attached"]), s = nN(a), u = s.linebreak, l = "", f = 0; f < this.registry.length; f++) {
      var h = this.registry[f];
      o != null && h.attached !== o || (l && (l += u), l += h.toString(a));
    }
    return l;
  }, uxe(e, [{
    key: "index",
    /**
     * Current highest index number.
     */
    get: function() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]), e;
}(), bR = new fKe(), YW = typeof globalThis < "u" ? globalThis : typeof window < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), HW = "2f1acc6c3a606b082e5eef5e54414ffb";
YW[HW] == null && (YW[HW] = 0);
var Ice = YW[HW]++, dKe = 1e10, jce = function(t) {
  t === void 0 && (t = {});
  var n = 0, r = function(o, a) {
    n += 1, n > dKe && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] You might have a memory leak. Rule counter is at " + n + ".");
    var s = "", u = "";
    return a && (a.options.classNamePrefix && (u = a.options.classNamePrefix), a.options.jss.id != null && (s = String(a.options.jss.id))), t.minify ? "" + (u || "c") + Ice + s + n : u + o.key + "-" + Ice + (s ? "-" + s : "") + "-" + n;
  };
  return r;
}, hxe = function(t) {
  var n;
  return function() {
    return n || (n = t()), n;
  };
}, hKe = function(t, n) {
  try {
    return t.attributeStyleMap ? t.attributeStyleMap.get(n) : t.style.getPropertyValue(n);
  } catch {
    return "";
  }
}, pKe = function(t, n, r) {
  try {
    var i = r;
    if (Array.isArray(r) && (i = vR(r)), t.attributeStyleMap)
      t.attributeStyleMap.set(n, i);
    else {
      var o = i ? i.indexOf("!important") : -1, a = o > -1 ? i.substr(0, o - 1) : i;
      t.style.setProperty(n, a, o > -1 ? "important" : "");
    }
  } catch {
    return !1;
  }
  return !0;
}, gKe = function(t, n) {
  try {
    t.attributeStyleMap ? t.attributeStyleMap.delete(n) : t.style.removeProperty(n);
  } catch (r) {
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] DOMException "' + r.message + '" was thrown. Tried to remove property "' + n + '".');
  }
}, mKe = function(t, n) {
  return t.selectorText = n, t.selectorText === n;
}, pxe = hxe(function() {
  return document.querySelector("head");
});
function yKe(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    if (r.attached && r.options.index > t.index && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function vKe(e, t) {
  for (var n = e.length - 1; n >= 0; n--) {
    var r = e[n];
    if (r.attached && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function bKe(e) {
  for (var t = pxe(), n = 0; n < t.childNodes.length; n++) {
    var r = t.childNodes[n];
    if (r.nodeType === 8 && r.nodeValue.trim() === e)
      return r;
  }
  return null;
}
function xKe(e) {
  var t = bR.registry;
  if (t.length > 0) {
    var n = yKe(t, e);
    if (n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element
      };
    if (n = vKe(t, e), n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element.nextSibling
      };
  }
  var r = e.insertionPoint;
  if (r && typeof r == "string") {
    var i = bKe(r);
    if (i)
      return {
        parent: i.parentNode,
        node: i.nextSibling
      };
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Insertion point "' + r + '" not found.');
  }
  return !1;
}
function wKe(e, t) {
  var n = t.insertionPoint, r = xKe(t);
  if (r !== !1 && r.parent) {
    r.parent.insertBefore(e, r.node);
    return;
  }
  if (n && typeof n.nodeType == "number") {
    var i = n, o = i.parentNode;
    o ? o.insertBefore(e, i.nextSibling) : process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Insertion point is not in the DOM.");
    return;
  }
  pxe().appendChild(e);
}
var _Ke = hxe(function() {
  var e = document.querySelector('meta[property="csp-nonce"]');
  return e ? e.getAttribute("content") : null;
}), Lce = function(t, n, r) {
  try {
    "insertRule" in t ? t.insertRule(n, r) : "appendRule" in t && t.appendRule(n);
  } catch (i) {
    return process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] " + i.message), !1;
  }
  return t.cssRules[r];
}, zce = function(t, n) {
  var r = t.cssRules.length;
  return n === void 0 || n > r ? r : n;
}, EKe = function() {
  var t = document.createElement("style");
  return t.textContent = `
`, t;
}, SKe = /* @__PURE__ */ function() {
  function e(n) {
    this.getPropertyValue = hKe, this.setProperty = pKe, this.removeProperty = gKe, this.setSelector = mKe, this.hasInsertedRules = !1, this.cssRules = [], n && bR.add(n), this.sheet = n;
    var r = this.sheet ? this.sheet.options : {}, i = r.media, o = r.meta, a = r.element;
    this.element = a || EKe(), this.element.setAttribute("data-jss", ""), i && this.element.setAttribute("media", i), o && this.element.setAttribute("data-meta", o);
    var s = _Ke();
    s && this.element.setAttribute("nonce", s);
  }
  var t = e.prototype;
  return t.attach = function() {
    if (!(this.element.parentNode || !this.sheet)) {
      wKe(this.element, this.sheet.options);
      var r = !!(this.sheet && this.sheet.deployed);
      this.hasInsertedRules && r && (this.hasInsertedRules = !1, this.deploy());
    }
  }, t.detach = function() {
    if (this.sheet) {
      var r = this.element.parentNode;
      r && r.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`);
    }
  }, t.deploy = function() {
    var r = this.sheet;
    if (r) {
      if (r.options.link) {
        this.insertRules(r.rules);
        return;
      }
      this.element.textContent = `
` + r.toString() + `
`;
    }
  }, t.insertRules = function(r, i) {
    for (var o = 0; o < r.index.length; o++)
      this.insertRule(r.index[o], o, i);
  }, t.insertRule = function(r, i, o) {
    if (o === void 0 && (o = this.element.sheet), r.rules) {
      var a = r, s = o;
      if (r.type === "conditional" || r.type === "keyframes") {
        var u = zce(o, i);
        if (s = Lce(o, a.toString({
          children: !1
        }), u), s === !1)
          return !1;
        this.refCssRule(r, u, s);
      }
      return this.insertRules(a.rules, s), s;
    }
    var l = r.toString();
    if (!l)
      return !1;
    var f = zce(o, i), h = Lce(o, l, f);
    return h === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(r, f, h), h);
  }, t.refCssRule = function(r, i, o) {
    r.renderable = o, r.options.parent instanceof dxe && this.cssRules.splice(i, 0, o);
  }, t.deleteRule = function(r) {
    var i = this.element.sheet, o = this.indexOf(r);
    return o === -1 ? !1 : (i.deleteRule(o), this.cssRules.splice(o, 1), !0);
  }, t.indexOf = function(r) {
    return this.cssRules.indexOf(r);
  }, t.replaceRule = function(r, i) {
    var o = this.indexOf(r);
    return o === -1 ? !1 : (this.element.sheet.deleteRule(o), this.cssRules.splice(o, 1), this.insertRule(i, o));
  }, t.getRules = function() {
    return this.element.sheet.cssRules;
  }, e;
}(), MKe = 0, TKe = /* @__PURE__ */ function() {
  function e(n) {
    this.id = MKe++, this.version = "10.10.0", this.plugins = new cKe(), this.options = {
      id: {
        minify: !1
      },
      createGenerateId: jce,
      Renderer: bb ? SKe : null,
      plugins: []
    }, this.generateId = jce({
      minify: !1
    });
    for (var r = 0; r < $ce.length; r++)
      this.plugins.use($ce[r], {
        queue: "internal"
      });
    this.setup(n);
  }
  var t = e.prototype;
  return t.setup = function(r) {
    return r === void 0 && (r = {}), r.createGenerateId && (this.options.createGenerateId = r.createGenerateId), r.id && (this.options.id = nl({}, this.options.id, r.id)), (r.createGenerateId || r.id) && (this.generateId = this.options.createGenerateId(this.options.id)), r.insertionPoint != null && (this.options.insertionPoint = r.insertionPoint), "Renderer" in r && (this.options.Renderer = r.Renderer), r.plugins && this.use.apply(this, r.plugins), this;
  }, t.createStyleSheet = function(r, i) {
    i === void 0 && (i = {});
    var o = i, a = o.index;
    typeof a != "number" && (a = bR.index === 0 ? 0 : bR.index + 1);
    var s = new dxe(r, nl({}, i, {
      jss: this,
      generateId: i.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: a
    }));
    return this.plugins.onProcessSheet(s), s;
  }, t.removeStyleSheet = function(r) {
    return r.detach(), bR.remove(r), this;
  }, t.createRule = function(r, i, o) {
    if (i === void 0 && (i = {}), o === void 0 && (o = {}), typeof r == "object")
      return this.createRule(void 0, r, i);
    var a = nl({}, o, {
      name: r,
      jss: this,
      Renderer: this.options.Renderer
    });
    a.generateId || (a.generateId = this.generateId), a.classes || (a.classes = {}), a.keyframes || (a.keyframes = {});
    var s = cxe(r, i, a);
    return s && this.plugins.onProcessRule(s), s;
  }, t.use = function() {
    for (var r = this, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return o.forEach(function(s) {
      r.plugins.use(s);
    }), this;
  }, e;
}(), CKe = function(t) {
  return new TKe(t);
};
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
CKe();
var Px = "@global", VW = "@global ", NKe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "global", this.at = Px, this.isProcessed = !1, this.key = n, this.options = i, this.rules = new fF(nl({}, i, {
      parent: this
    }));
    for (var o in r)
      this.rules.add(o, r[o]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.getRule = function(r) {
    return this.rules.get(r);
  }, t.addRule = function(r, i, o) {
    var a = this.rules.add(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.replace(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.toString = function(r) {
    return this.rules.toString(r);
  }, e;
}(), DKe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "global", this.at = Px, this.isProcessed = !1, this.key = n, this.options = i;
    var o = n.substr(VW.length);
    this.rule = i.jss.createRule(o, r, nl({}, i, {
      parent: this
    }));
  }
  var t = e.prototype;
  return t.toString = function(r) {
    return this.rule ? this.rule.toString(r) : "";
  }, e;
}(), AKe = /\s*,\s*/g;
function gxe(e, t) {
  for (var n = e.split(AKe), r = "", i = 0; i < n.length; i++)
    r += t + " " + n[i].trim(), n[i + 1] && (r += ", ");
  return r;
}
function OKe(e, t) {
  var n = e.options, r = e.style, i = r ? r[Px] : null;
  if (i) {
    for (var o in i)
      t.addRule(o, i[o], nl({}, n, {
        selector: gxe(o, e.selector)
      }));
    delete r[Px];
  }
}
function RKe(e, t) {
  var n = e.options, r = e.style;
  for (var i in r)
    if (!(i[0] !== "@" || i.substr(0, Px.length) !== Px)) {
      var o = gxe(i.substr(Px.length), e.selector);
      t.addRule(o, r[i], nl({}, n, {
        selector: o
      })), delete r[i];
    }
}
function kKe() {
  function e(n, r, i) {
    if (!n)
      return null;
    if (n === Px)
      return new NKe(n, r, i);
    if (n[0] === "@" && n.substr(0, VW.length) === VW)
      return new DKe(n, r, i);
    var o = i.parent;
    return o && (o.type === "global" || o.options.parent && o.options.parent.type === "global") && (i.scoped = !1), !i.selector && i.scoped === !1 && (i.selector = n), null;
  }
  function t(n, r) {
    n.type !== "style" || !r || (OKe(n, r), RKe(n, r));
  }
  return {
    onCreateRule: e,
    onProcessRule: t
  };
}
function lT() {
  return lT = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, lT.apply(this, arguments);
}
var Fce = /\s*,\s*/g, $Ke = /&/g, PKe = /\$([\w-]+)/g;
function IKe() {
  function e(i, o) {
    return function(a, s) {
      var u = i.getRule(s) || o && o.getRule(s);
      return u ? u.selector : (process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Could not find the referenced rule "' + s + '" in "' + (i.options.meta || i.toString()) + '".'), s);
    };
  }
  function t(i, o) {
    for (var a = o.split(Fce), s = i.split(Fce), u = "", l = 0; l < a.length; l++)
      for (var f = a[l], h = 0; h < s.length; h++) {
        var p = s[h];
        u && (u += ", "), u += p.indexOf("&") !== -1 ? p.replace($Ke, f) : f + " " + p;
      }
    return u;
  }
  function n(i, o, a) {
    if (a)
      return lT({}, a, {
        index: a.index + 1
      });
    var s = i.options.nestingLevel;
    s = s === void 0 ? 1 : s + 1;
    var u = lT({}, i.options, {
      nestingLevel: s,
      index: o.indexOf(i) + 1
      // We don't need the parent name to be set options for chlid.
    });
    return delete u.name, u;
  }
  function r(i, o, a) {
    if (o.type !== "style")
      return i;
    var s = o, u = s.options.parent, l, f;
    for (var h in i) {
      var p = h.indexOf("&") !== -1, g = h[0] === "@";
      if (!(!p && !g)) {
        if (l = n(s, u, l), p) {
          var y = t(h, s.selector);
          f || (f = e(u, a)), y = y.replace(PKe, f);
          var b = s.key + "-" + h;
          "replaceRule" in u ? u.replaceRule(b, i[h], lT({}, l, {
            selector: y
          })) : u.addRule(b, i[h], lT({}, l, {
            selector: y
          }));
        } else
          g && u.addRule(h, {}, l).addRule(s.key, i[h], {
            selector: s.selector
          });
        delete i[h];
      }
    }
    return i;
  }
  return {
    onProcessStyle: r
  };
}
var jKe = /[A-Z]/g, LKe = /^ms-/, AY = {};
function zKe(e) {
  return "-" + e.toLowerCase();
}
function mxe(e) {
  if (AY.hasOwnProperty(e))
    return AY[e];
  var t = e.replace(jKe, zKe);
  return AY[e] = LKe.test(t) ? "-" + t : t;
}
function Gj(e) {
  var t = {};
  for (var n in e) {
    var r = n.indexOf("--") === 0 ? n : mxe(n);
    t[r] = e[n];
  }
  return e.fallbacks && (Array.isArray(e.fallbacks) ? t.fallbacks = e.fallbacks.map(Gj) : t.fallbacks = Gj(e.fallbacks)), t;
}
function FKe() {
  function e(n) {
    if (Array.isArray(n)) {
      for (var r = 0; r < n.length; r++)
        n[r] = Gj(n[r]);
      return n;
    }
    return Gj(n);
  }
  function t(n, r, i) {
    if (r.indexOf("--") === 0)
      return n;
    var o = mxe(r);
    return r === o ? n : (i.prop(o, n), null);
  }
  return {
    onProcessStyle: e,
    onChangeValue: t
  };
}
function Rd() {
  return Rd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Rd.apply(this, arguments);
}
function ck(e) {
  "@babel/helpers - typeof";
  return ck = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ck(e);
}
function BKe(e, t) {
  if (ck(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ck(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function UKe(e) {
  var t = BKe(e, "string");
  return ck(t) == "symbol" ? t : t + "";
}
function Bce(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, UKe(r.key), r);
  }
}
function yxe(e, t, n) {
  return t && Bce(e.prototype, t), n && Bce(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function WW(e, t) {
  return WW = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, WW(e, t);
}
function vxe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, WW(e, t);
}
function Uce(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function YKe(e, t) {
  if (e == null)
    return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0)
        continue;
      n[r] = e[r];
    }
  return n;
}
var HKe = {}.constructor;
function qW(e) {
  if (e == null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    return e.map(qW);
  if (e.constructor !== HKe)
    return e;
  var t = {};
  for (var n in e)
    t[n] = qW(e[n]);
  return t;
}
function bxe(e, t, n) {
  e === void 0 && (e = "unnamed");
  var r = n.jss, i = qW(t), o = r.plugins.onCreateRule(e, i, n);
  return o || (e[0] === "@" && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Unknown rule " + e), null);
}
var Yce = function(t, n) {
  for (var r = "", i = 0; i < t.length && t[i] !== "!important"; i++)
    r && (r += n), r += t[i];
  return r;
}, xR = function(t) {
  if (!Array.isArray(t))
    return t;
  var n = "";
  if (Array.isArray(t[0]))
    for (var r = 0; r < t.length && t[r] !== "!important"; r++)
      n && (n += ", "), n += Yce(t[r], " ");
  else
    n = Yce(t, ", ");
  return t[t.length - 1] === "!important" && (n += " !important"), n;
};
function rN(e) {
  return e && e.format === !1 ? {
    linebreak: "",
    space: ""
  } : {
    linebreak: `
`,
    space: " "
  };
}
function zA(e, t) {
  for (var n = "", r = 0; r < t; r++)
    n += "  ";
  return n + e;
}
function fk(e, t, n) {
  n === void 0 && (n = {});
  var r = "";
  if (!t)
    return r;
  var i = n, o = i.indent, a = o === void 0 ? 0 : o, s = t.fallbacks;
  n.format === !1 && (a = -1 / 0);
  var u = rN(n), l = u.linebreak, f = u.space;
  if (e && a++, s)
    if (Array.isArray(s))
      for (var h = 0; h < s.length; h++) {
        var p = s[h];
        for (var g in p) {
          var y = p[g];
          y != null && (r && (r += l), r += zA(g + ":" + f + xR(y) + ";", a));
        }
      }
    else
      for (var b in s) {
        var _ = s[b];
        _ != null && (r && (r += l), r += zA(b + ":" + f + xR(_) + ";", a));
      }
  for (var S in t) {
    var C = t[S];
    C != null && S !== "fallbacks" && (r && (r += l), r += zA(S + ":" + f + xR(C) + ";", a));
  }
  return !r && !n.allowEmpty || !e ? r : (a--, r && (r = "" + l + r + l), zA("" + e + f + "{" + r, a) + zA("}", a));
}
var VKe = /([[\].#*$><+~=|^:(),"'`\s])/g, Hce = typeof CSS < "u" && CSS.escape, _K = function(e) {
  return Hce ? Hce(e) : e.replace(VKe, "\\$1");
}, xxe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "style", this.isProcessed = !1;
    var o = i.sheet, a = i.Renderer;
    this.key = n, this.options = i, this.style = r, o ? this.renderer = o.renderer : a && (this.renderer = new a());
  }
  var t = e.prototype;
  return t.prop = function(r, i, o) {
    if (i === void 0)
      return this.style[r];
    var a = o ? o.force : !1;
    if (!a && this.style[r] === i)
      return this;
    var s = i;
    (!o || o.process !== !1) && (s = this.options.jss.plugins.onChangeValue(i, r, this));
    var u = s == null || s === !1, l = r in this.style;
    if (u && !l && !a)
      return this;
    var f = u && l;
    if (f ? delete this.style[r] : this.style[r] = s, this.renderable && this.renderer)
      return f ? this.renderer.removeProperty(this.renderable, r) : this.renderer.setProperty(this.renderable, r, s), this;
    var h = this.options.sheet;
    return h && h.attached && process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Rule is not linked. Missing sheet option "link: true".'), this;
  }, e;
}(), GW = /* @__PURE__ */ function(e) {
  vxe(t, e);
  function t(r, i, o) {
    var a;
    a = e.call(this, r, i, o) || this;
    var s = o.selector, u = o.scoped, l = o.sheet, f = o.generateId;
    return s ? a.selectorText = s : u !== !1 && (a.id = f(Uce(Uce(a)), l), a.selectorText = "." + _K(a.id)), a;
  }
  var n = t.prototype;
  return n.applyTo = function(i) {
    var o = this.renderer;
    if (o) {
      var a = this.toJSON();
      for (var s in a)
        o.setProperty(i, s, a[s]);
    }
    return this;
  }, n.toJSON = function() {
    var i = {};
    for (var o in this.style) {
      var a = this.style[o];
      typeof a != "object" ? i[o] = a : Array.isArray(a) && (i[o] = xR(a));
    }
    return i;
  }, n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? Rd({}, i, {
      allowEmpty: !0
    }) : i;
    return fk(this.selectorText, this.style, s);
  }, yxe(t, [{
    key: "selector",
    set: function(i) {
      if (i !== this.selectorText) {
        this.selectorText = i;
        var o = this.renderer, a = this.renderable;
        if (!(!a || !o)) {
          var s = o.setSelector(a, i);
          s || o.replaceRule(a, this);
        }
      }
    },
    get: function() {
      return this.selectorText;
    }
  }]), t;
}(xxe), WKe = {
  onCreateRule: function(t, n, r) {
    return t[0] === "@" || r.parent && r.parent.type === "keyframes" ? null : new GW(t, n, r);
  }
}, OY = {
  indent: 1,
  children: !0
}, qKe = /@([\w-]+)/, GKe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "conditional", this.isProcessed = !1, this.key = n;
    var o = n.match(qKe);
    this.at = o ? o[1] : "unknown", this.query = i.name || "@" + this.at, this.options = i, this.rules = new EK(Rd({}, i, {
      parent: this
    }));
    for (var a in r)
      this.rules.add(a, r[a]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.getRule = function(r) {
    return this.rules.get(r);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.addRule = function(r, i, o) {
    var a = this.rules.add(r, i, o);
    return a ? (this.options.jss.plugins.onProcessRule(a), a) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.replace(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.toString = function(r) {
    r === void 0 && (r = OY);
    var i = rN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = OY.indent), r.children == null && (r.children = OY.children), r.children === !1)
      return this.query + " {}";
    var a = this.rules.toString(r);
    return a ? this.query + " {" + o + a + o + "}" : "";
  }, e;
}(), QKe = /@container|@media|@supports\s+/, XKe = {
  onCreateRule: function(t, n, r) {
    return QKe.test(t) ? new GKe(t, n, r) : null;
  }
}, RY = {
  indent: 1,
  children: !0
}, KKe = /@keyframes\s+([\w-]+)/, QW = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1;
    var o = n.match(KKe);
    o && o[1] ? this.name = o[1] : (this.name = "noname", process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Bad keyframes name " + n)), this.key = this.type + "-" + this.name, this.options = i;
    var a = i.scoped, s = i.sheet, u = i.generateId;
    this.id = a === !1 ? this.name : _K(u(this, s)), this.rules = new EK(Rd({}, i, {
      parent: this
    }));
    for (var l in r)
      this.rules.add(l, r[l], Rd({}, i, {
        parent: this
      }));
    this.rules.process();
  }
  var t = e.prototype;
  return t.toString = function(r) {
    r === void 0 && (r = RY);
    var i = rN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = RY.indent), r.children == null && (r.children = RY.children), r.children === !1)
      return this.at + " " + this.id + " {}";
    var a = this.rules.toString(r);
    return a && (a = "" + o + a + o), this.at + " " + this.id + " {" + a + "}";
  }, e;
}(), ZKe = /@keyframes\s+/, JKe = /\$([\w-]+)/g, XW = function(t, n) {
  return typeof t == "string" ? t.replace(JKe, function(r, i) {
    return i in n ? n[i] : (process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Referenced keyframes rule "' + i + '" is not defined.'), r);
  }) : t;
}, Vce = function(t, n, r) {
  var i = t[n], o = XW(i, r);
  o !== i && (t[n] = o);
}, eZe = {
  onCreateRule: function(t, n, r) {
    return typeof t == "string" && ZKe.test(t) ? new QW(t, n, r) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function(t, n, r) {
    return n.type !== "style" || !r || ("animation-name" in t && Vce(t, "animation-name", r.keyframes), "animation" in t && Vce(t, "animation", r.keyframes)), t;
  },
  onChangeValue: function(t, n, r) {
    var i = r.options.sheet;
    if (!i)
      return t;
    switch (n) {
      case "animation":
        return XW(t, i.keyframes);
      case "animation-name":
        return XW(t, i.keyframes);
      default:
        return t;
    }
  }
}, tZe = /* @__PURE__ */ function(e) {
  vxe(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var n = t.prototype;
  return n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? Rd({}, i, {
      allowEmpty: !0
    }) : i;
    return fk(this.key, this.style, s);
  }, t;
}(xxe), nZe = {
  onCreateRule: function(t, n, r) {
    return r.parent && r.parent.type === "keyframes" ? new tZe(t, n, r) : null;
  }
}, rZe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    var i = rN(r), o = i.linebreak;
    if (Array.isArray(this.style)) {
      for (var a = "", s = 0; s < this.style.length; s++)
        a += fk(this.at, this.style[s]), this.style[s + 1] && (a += o);
      return a;
    }
    return fk(this.at, this.style, r);
  }, e;
}(), iZe = /@font-face/, oZe = {
  onCreateRule: function(t, n, r) {
    return iZe.test(t) ? new rZe(t, n, r) : null;
  }
}, aZe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    return fk(this.key, this.style, r);
  }, e;
}(), sZe = {
  onCreateRule: function(t, n, r) {
    return t === "@viewport" || t === "@-ms-viewport" ? new aZe(t, n, r) : null;
  }
}, uZe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "simple", this.isProcessed = !1, this.key = n, this.value = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    if (Array.isArray(this.value)) {
      for (var i = "", o = 0; o < this.value.length; o++)
        i += this.key + " " + this.value[o] + ";", this.value[o + 1] && (i += `
`);
      return i;
    }
    return this.key + " " + this.value + ";";
  }, e;
}(), lZe = {
  "@charset": !0,
  "@import": !0,
  "@namespace": !0
}, cZe = {
  onCreateRule: function(t, n, r) {
    return t in lZe ? new uZe(t, n, r) : null;
  }
}, Wce = [WKe, XKe, eZe, nZe, oZe, sZe, cZe], fZe = {
  process: !0
}, qce = {
  force: !0,
  process: !0
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */
}, EK = /* @__PURE__ */ function() {
  function e(n) {
    this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = n, this.classes = n.classes, this.keyframes = n.keyframes;
  }
  var t = e.prototype;
  return t.add = function(r, i, o) {
    var a = this.options, s = a.parent, u = a.sheet, l = a.jss, f = a.Renderer, h = a.generateId, p = a.scoped, g = Rd({
      classes: this.classes,
      parent: s,
      sheet: u,
      jss: l,
      Renderer: f,
      generateId: h,
      scoped: p,
      name: r,
      keyframes: this.keyframes,
      selector: void 0
    }, o), y = r;
    r in this.raw && (y = r + "-d" + this.counter++), this.raw[y] = i, y in this.classes && (g.selector = "." + _K(this.classes[y]));
    var b = bxe(y, i, g);
    if (!b)
      return null;
    this.register(b);
    var _ = g.index === void 0 ? this.index.length : g.index;
    return this.index.splice(_, 0, b), b;
  }, t.replace = function(r, i, o) {
    var a = this.get(r), s = this.index.indexOf(a);
    a && this.remove(a);
    var u = o;
    return s !== -1 && (u = Rd({}, o, {
      index: s
    })), this.add(r, i, u);
  }, t.get = function(r) {
    return this.map[r];
  }, t.remove = function(r) {
    this.unregister(r), delete this.raw[r.key], this.index.splice(this.index.indexOf(r), 1);
  }, t.indexOf = function(r) {
    return this.index.indexOf(r);
  }, t.process = function() {
    var r = this.options.jss.plugins;
    this.index.slice(0).forEach(r.onProcessRule, r);
  }, t.register = function(r) {
    this.map[r.key] = r, r instanceof GW ? (this.map[r.selector] = r, r.id && (this.classes[r.key] = r.id)) : r instanceof QW && this.keyframes && (this.keyframes[r.name] = r.id);
  }, t.unregister = function(r) {
    delete this.map[r.key], r instanceof GW ? (delete this.map[r.selector], delete this.classes[r.key]) : r instanceof QW && delete this.keyframes[r.name];
  }, t.update = function() {
    var r, i, o;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (r = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], o = arguments.length <= 2 ? void 0 : arguments[2]) : (i = arguments.length <= 0 ? void 0 : arguments[0], o = arguments.length <= 1 ? void 0 : arguments[1], r = null), r)
      this.updateOne(this.get(r), i, o);
    else
      for (var a = 0; a < this.index.length; a++)
        this.updateOne(this.index[a], i, o);
  }, t.updateOne = function(r, i, o) {
    o === void 0 && (o = fZe);
    var a = this.options, s = a.jss.plugins, u = a.sheet;
    if (r.rules instanceof e) {
      r.rules.update(i, o);
      return;
    }
    var l = r.style;
    if (s.onUpdate(i, r, u, o), o.process && l && l !== r.style) {
      s.onProcessStyle(r.style, r, u);
      for (var f in r.style) {
        var h = r.style[f], p = l[f];
        h !== p && r.prop(f, h, qce);
      }
      for (var g in l) {
        var y = r.style[g], b = l[g];
        y == null && y !== b && r.prop(g, null, qce);
      }
    }
  }, t.toString = function(r) {
    for (var i = "", o = this.options.sheet, a = o ? o.options.link : !1, s = rN(r), u = s.linebreak, l = 0; l < this.index.length; l++) {
      var f = this.index[l], h = f.toString(r);
      !h && !a || (i && (i += u), i += h);
    }
    return i;
  }, e;
}(), wxe = /* @__PURE__ */ function() {
  function e(n, r) {
    this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = Rd({}, r, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    }), r.Renderer && (this.renderer = new r.Renderer(this)), this.rules = new EK(this.options);
    for (var i in n)
      this.rules.add(i, n[i]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.attach = function() {
    return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this);
  }, t.detach = function() {
    return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this;
  }, t.addRule = function(r, i, o) {
    var a = this.queue;
    this.attached && !a && (this.queue = []);
    var s = this.rules.add(r, i, o);
    return s ? (this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && (a ? a.push(s) : (this.insertRule(s), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), s) : (this.deployed = !1, s)) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.get(r);
    if (!a)
      return this.addRule(r, i, o);
    var s = this.rules.replace(r, i, o);
    return s && this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && this.renderer && (s ? a.renderable && this.renderer.replaceRule(a.renderable, s) : this.renderer.deleteRule(a)), s) : (this.deployed = !1, s);
  }, t.insertRule = function(r) {
    this.renderer && this.renderer.insertRule(r);
  }, t.addRules = function(r, i) {
    var o = [];
    for (var a in r) {
      var s = this.addRule(a, r[a], i);
      s && o.push(s);
    }
    return o;
  }, t.getRule = function(r) {
    return this.rules.get(r);
  }, t.deleteRule = function(r) {
    var i = typeof r == "object" ? r : this.rules.get(r);
    return !i || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !i.renderable ? !1 : (this.rules.remove(i), this.attached && i.renderable && this.renderer ? this.renderer.deleteRule(i.renderable) : !0);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.deploy = function() {
    return this.renderer && this.renderer.deploy(), this.deployed = !0, this;
  }, t.update = function() {
    var r;
    return (r = this.rules).update.apply(r, arguments), this;
  }, t.updateOne = function(r, i, o) {
    return this.rules.updateOne(r, i, o), this;
  }, t.toString = function(r) {
    return this.rules.toString(r);
  }, e;
}(), dZe = /* @__PURE__ */ function() {
  function e() {
    this.plugins = {
      internal: [],
      external: []
    }, this.registry = {};
  }
  var t = e.prototype;
  return t.onCreateRule = function(r, i, o) {
    for (var a = 0; a < this.registry.onCreateRule.length; a++) {
      var s = this.registry.onCreateRule[a](r, i, o);
      if (s)
        return s;
    }
    return null;
  }, t.onProcessRule = function(r) {
    if (!r.isProcessed) {
      for (var i = r.options.sheet, o = 0; o < this.registry.onProcessRule.length; o++)
        this.registry.onProcessRule[o](r, i);
      r.style && this.onProcessStyle(r.style, r, i), r.isProcessed = !0;
    }
  }, t.onProcessStyle = function(r, i, o) {
    for (var a = 0; a < this.registry.onProcessStyle.length; a++)
      i.style = this.registry.onProcessStyle[a](i.style, i, o);
  }, t.onProcessSheet = function(r) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++)
      this.registry.onProcessSheet[i](r);
  }, t.onUpdate = function(r, i, o, a) {
    for (var s = 0; s < this.registry.onUpdate.length; s++)
      this.registry.onUpdate[s](r, i, o, a);
  }, t.onChangeValue = function(r, i, o) {
    for (var a = r, s = 0; s < this.registry.onChangeValue.length; s++)
      a = this.registry.onChangeValue[s](a, i, o);
    return a;
  }, t.use = function(r, i) {
    i === void 0 && (i = {
      queue: "external"
    });
    var o = this.plugins[i.queue];
    o.indexOf(r) === -1 && (o.push(r), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(a, s) {
      for (var u in s)
        u in a ? a[u].push(s[u]) : process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Unknown hook "' + u + '".');
      return a;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    }));
  }, e;
}(), hZe = /* @__PURE__ */ function() {
  function e() {
    this.registry = [];
  }
  var t = e.prototype;
  return t.add = function(r) {
    var i = this.registry, o = r.options.index;
    if (i.indexOf(r) === -1) {
      if (i.length === 0 || o >= this.index) {
        i.push(r);
        return;
      }
      for (var a = 0; a < i.length; a++)
        if (i[a].options.index > o) {
          i.splice(a, 0, r);
          return;
        }
    }
  }, t.reset = function() {
    this.registry = [];
  }, t.remove = function(r) {
    var i = this.registry.indexOf(r);
    this.registry.splice(i, 1);
  }, t.toString = function(r) {
    for (var i = r === void 0 ? {} : r, o = i.attached, a = YKe(i, ["attached"]), s = rN(a), u = s.linebreak, l = "", f = 0; f < this.registry.length; f++) {
      var h = this.registry[f];
      o != null && h.attached !== o || (l && (l += u), l += h.toString(a));
    }
    return l;
  }, yxe(e, [{
    key: "index",
    /**
     * Current highest index number.
     */
    get: function() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]), e;
}(), wR = new hZe(), KW = typeof globalThis < "u" ? globalThis : typeof window < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), ZW = "2f1acc6c3a606b082e5eef5e54414ffb";
KW[ZW] == null && (KW[ZW] = 0);
var Gce = KW[ZW]++, pZe = 1e10, Qce = function(t) {
  t === void 0 && (t = {});
  var n = 0, r = function(o, a) {
    n += 1, n > pZe && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] You might have a memory leak. Rule counter is at " + n + ".");
    var s = "", u = "";
    return a && (a.options.classNamePrefix && (u = a.options.classNamePrefix), a.options.jss.id != null && (s = String(a.options.jss.id))), t.minify ? "" + (u || "c") + Gce + s + n : u + o.key + "-" + Gce + (s ? "-" + s : "") + "-" + n;
  };
  return r;
}, _xe = function(t) {
  var n;
  return function() {
    return n || (n = t()), n;
  };
}, gZe = function(t, n) {
  try {
    return t.attributeStyleMap ? t.attributeStyleMap.get(n) : t.style.getPropertyValue(n);
  } catch {
    return "";
  }
}, mZe = function(t, n, r) {
  try {
    var i = r;
    if (Array.isArray(r) && (i = xR(r)), t.attributeStyleMap)
      t.attributeStyleMap.set(n, i);
    else {
      var o = i ? i.indexOf("!important") : -1, a = o > -1 ? i.substr(0, o - 1) : i;
      t.style.setProperty(n, a, o > -1 ? "important" : "");
    }
  } catch {
    return !1;
  }
  return !0;
}, yZe = function(t, n) {
  try {
    t.attributeStyleMap ? t.attributeStyleMap.delete(n) : t.style.removeProperty(n);
  } catch (r) {
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] DOMException "' + r.message + '" was thrown. Tried to remove property "' + n + '".');
  }
}, vZe = function(t, n) {
  return t.selectorText = n, t.selectorText === n;
}, Exe = _xe(function() {
  return document.querySelector("head");
});
function bZe(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    if (r.attached && r.options.index > t.index && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function xZe(e, t) {
  for (var n = e.length - 1; n >= 0; n--) {
    var r = e[n];
    if (r.attached && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function wZe(e) {
  for (var t = Exe(), n = 0; n < t.childNodes.length; n++) {
    var r = t.childNodes[n];
    if (r.nodeType === 8 && r.nodeValue.trim() === e)
      return r;
  }
  return null;
}
function _Ze(e) {
  var t = wR.registry;
  if (t.length > 0) {
    var n = bZe(t, e);
    if (n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element
      };
    if (n = xZe(t, e), n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element.nextSibling
      };
  }
  var r = e.insertionPoint;
  if (r && typeof r == "string") {
    var i = wZe(r);
    if (i)
      return {
        parent: i.parentNode,
        node: i.nextSibling
      };
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Insertion point "' + r + '" not found.');
  }
  return !1;
}
function EZe(e, t) {
  var n = t.insertionPoint, r = _Ze(t);
  if (r !== !1 && r.parent) {
    r.parent.insertBefore(e, r.node);
    return;
  }
  if (n && typeof n.nodeType == "number") {
    var i = n, o = i.parentNode;
    o ? o.insertBefore(e, i.nextSibling) : process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Insertion point is not in the DOM.");
    return;
  }
  Exe().appendChild(e);
}
var SZe = _xe(function() {
  var e = document.querySelector('meta[property="csp-nonce"]');
  return e ? e.getAttribute("content") : null;
}), Xce = function(t, n, r) {
  try {
    "insertRule" in t ? t.insertRule(n, r) : "appendRule" in t && t.appendRule(n);
  } catch (i) {
    return process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] " + i.message), !1;
  }
  return t.cssRules[r];
}, Kce = function(t, n) {
  var r = t.cssRules.length;
  return n === void 0 || n > r ? r : n;
}, MZe = function() {
  var t = document.createElement("style");
  return t.textContent = `
`, t;
}, TZe = /* @__PURE__ */ function() {
  function e(n) {
    this.getPropertyValue = gZe, this.setProperty = mZe, this.removeProperty = yZe, this.setSelector = vZe, this.hasInsertedRules = !1, this.cssRules = [], n && wR.add(n), this.sheet = n;
    var r = this.sheet ? this.sheet.options : {}, i = r.media, o = r.meta, a = r.element;
    this.element = a || MZe(), this.element.setAttribute("data-jss", ""), i && this.element.setAttribute("media", i), o && this.element.setAttribute("data-meta", o);
    var s = SZe();
    s && this.element.setAttribute("nonce", s);
  }
  var t = e.prototype;
  return t.attach = function() {
    if (!(this.element.parentNode || !this.sheet)) {
      EZe(this.element, this.sheet.options);
      var r = !!(this.sheet && this.sheet.deployed);
      this.hasInsertedRules && r && (this.hasInsertedRules = !1, this.deploy());
    }
  }, t.detach = function() {
    if (this.sheet) {
      var r = this.element.parentNode;
      r && r.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`);
    }
  }, t.deploy = function() {
    var r = this.sheet;
    if (r) {
      if (r.options.link) {
        this.insertRules(r.rules);
        return;
      }
      this.element.textContent = `
` + r.toString() + `
`;
    }
  }, t.insertRules = function(r, i) {
    for (var o = 0; o < r.index.length; o++)
      this.insertRule(r.index[o], o, i);
  }, t.insertRule = function(r, i, o) {
    if (o === void 0 && (o = this.element.sheet), r.rules) {
      var a = r, s = o;
      if (r.type === "conditional" || r.type === "keyframes") {
        var u = Kce(o, i);
        if (s = Xce(o, a.toString({
          children: !1
        }), u), s === !1)
          return !1;
        this.refCssRule(r, u, s);
      }
      return this.insertRules(a.rules, s), s;
    }
    var l = r.toString();
    if (!l)
      return !1;
    var f = Kce(o, i), h = Xce(o, l, f);
    return h === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(r, f, h), h);
  }, t.refCssRule = function(r, i, o) {
    r.renderable = o, r.options.parent instanceof wxe && this.cssRules.splice(i, 0, o);
  }, t.deleteRule = function(r) {
    var i = this.element.sheet, o = this.indexOf(r);
    return o === -1 ? !1 : (i.deleteRule(o), this.cssRules.splice(o, 1), !0);
  }, t.indexOf = function(r) {
    return this.cssRules.indexOf(r);
  }, t.replaceRule = function(r, i) {
    var o = this.indexOf(r);
    return o === -1 ? !1 : (this.element.sheet.deleteRule(o), this.cssRules.splice(o, 1), this.insertRule(i, o));
  }, t.getRules = function() {
    return this.element.sheet.cssRules;
  }, e;
}(), CZe = 0, NZe = /* @__PURE__ */ function() {
  function e(n) {
    this.id = CZe++, this.version = "10.10.0", this.plugins = new dZe(), this.options = {
      id: {
        minify: !1
      },
      createGenerateId: Qce,
      Renderer: bb ? TZe : null,
      plugins: []
    }, this.generateId = Qce({
      minify: !1
    });
    for (var r = 0; r < Wce.length; r++)
      this.plugins.use(Wce[r], {
        queue: "internal"
      });
    this.setup(n);
  }
  var t = e.prototype;
  return t.setup = function(r) {
    return r === void 0 && (r = {}), r.createGenerateId && (this.options.createGenerateId = r.createGenerateId), r.id && (this.options.id = Rd({}, this.options.id, r.id)), (r.createGenerateId || r.id) && (this.generateId = this.options.createGenerateId(this.options.id)), r.insertionPoint != null && (this.options.insertionPoint = r.insertionPoint), "Renderer" in r && (this.options.Renderer = r.Renderer), r.plugins && this.use.apply(this, r.plugins), this;
  }, t.createStyleSheet = function(r, i) {
    i === void 0 && (i = {});
    var o = i, a = o.index;
    typeof a != "number" && (a = wR.index === 0 ? 0 : wR.index + 1);
    var s = new wxe(r, Rd({}, i, {
      jss: this,
      generateId: i.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: a
    }));
    return this.plugins.onProcessSheet(s), s;
  }, t.removeStyleSheet = function(r) {
    return r.detach(), wR.remove(r), this;
  }, t.createRule = function(r, i, o) {
    if (i === void 0 && (i = {}), o === void 0 && (o = {}), typeof r == "object")
      return this.createRule(void 0, r, i);
    var a = Rd({}, o, {
      name: r,
      jss: this,
      Renderer: this.options.Renderer
    });
    a.generateId || (a.generateId = this.generateId), a.classes || (a.classes = {}), a.keyframes || (a.keyframes = {});
    var s = bxe(r, i, a);
    return s && this.plugins.onProcessRule(s), s;
  }, t.use = function() {
    for (var r = this, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return o.forEach(function(s) {
      r.plugins.use(s);
    }), this;
  }, e;
}(), DZe = function(t) {
  return new NZe(t);
}, SK = typeof CSS == "object" && CSS != null && "number" in CSS;
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
DZe();
var ot = SK && CSS ? CSS.px : "px", kI = SK && CSS ? CSS.ms : "ms", PM = SK && CSS ? CSS.percent : "%", AZe = {
  // Animation properties
  "animation-delay": kI,
  "animation-duration": kI,
  // Background properties
  "background-position": ot,
  "background-position-x": ot,
  "background-position-y": ot,
  "background-size": ot,
  // Border Properties
  border: ot,
  "border-bottom": ot,
  "border-bottom-left-radius": ot,
  "border-bottom-right-radius": ot,
  "border-bottom-width": ot,
  "border-left": ot,
  "border-left-width": ot,
  "border-radius": ot,
  "border-right": ot,
  "border-right-width": ot,
  "border-top": ot,
  "border-top-left-radius": ot,
  "border-top-right-radius": ot,
  "border-top-width": ot,
  "border-width": ot,
  "border-block": ot,
  "border-block-end": ot,
  "border-block-end-width": ot,
  "border-block-start": ot,
  "border-block-start-width": ot,
  "border-block-width": ot,
  "border-inline": ot,
  "border-inline-end": ot,
  "border-inline-end-width": ot,
  "border-inline-start": ot,
  "border-inline-start-width": ot,
  "border-inline-width": ot,
  "border-start-start-radius": ot,
  "border-start-end-radius": ot,
  "border-end-start-radius": ot,
  "border-end-end-radius": ot,
  // Margin properties
  margin: ot,
  "margin-bottom": ot,
  "margin-left": ot,
  "margin-right": ot,
  "margin-top": ot,
  "margin-block": ot,
  "margin-block-end": ot,
  "margin-block-start": ot,
  "margin-inline": ot,
  "margin-inline-end": ot,
  "margin-inline-start": ot,
  // Padding properties
  padding: ot,
  "padding-bottom": ot,
  "padding-left": ot,
  "padding-right": ot,
  "padding-top": ot,
  "padding-block": ot,
  "padding-block-end": ot,
  "padding-block-start": ot,
  "padding-inline": ot,
  "padding-inline-end": ot,
  "padding-inline-start": ot,
  // Mask properties
  "mask-position-x": ot,
  "mask-position-y": ot,
  "mask-size": ot,
  // Width and height properties
  height: ot,
  width: ot,
  "min-height": ot,
  "max-height": ot,
  "min-width": ot,
  "max-width": ot,
  // Position properties
  bottom: ot,
  left: ot,
  top: ot,
  right: ot,
  inset: ot,
  "inset-block": ot,
  "inset-block-end": ot,
  "inset-block-start": ot,
  "inset-inline": ot,
  "inset-inline-end": ot,
  "inset-inline-start": ot,
  // Shadow properties
  "box-shadow": ot,
  "text-shadow": ot,
  // Column properties
  "column-gap": ot,
  "column-rule": ot,
  "column-rule-width": ot,
  "column-width": ot,
  // Font and text properties
  "font-size": ot,
  "font-size-delta": ot,
  "letter-spacing": ot,
  "text-decoration-thickness": ot,
  "text-indent": ot,
  "text-stroke": ot,
  "text-stroke-width": ot,
  "word-spacing": ot,
  // Motion properties
  motion: ot,
  "motion-offset": ot,
  // Outline properties
  outline: ot,
  "outline-offset": ot,
  "outline-width": ot,
  // Perspective properties
  perspective: ot,
  "perspective-origin-x": PM,
  "perspective-origin-y": PM,
  // Transform properties
  "transform-origin": PM,
  "transform-origin-x": PM,
  "transform-origin-y": PM,
  "transform-origin-z": PM,
  // Transition properties
  "transition-delay": kI,
  "transition-duration": kI,
  // Alignment properties
  "vertical-align": ot,
  "flex-basis": ot,
  // Some random properties
  "shape-margin": ot,
  size: ot,
  gap: ot,
  // Grid properties
  grid: ot,
  "grid-gap": ot,
  "row-gap": ot,
  "grid-row-gap": ot,
  "grid-column-gap": ot,
  "grid-template-rows": ot,
  "grid-template-columns": ot,
  "grid-auto-rows": ot,
  "grid-auto-columns": ot,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  "box-shadow-x": ot,
  "box-shadow-y": ot,
  "box-shadow-blur": ot,
  "box-shadow-spread": ot,
  "font-line-height": ot,
  "text-shadow-x": ot,
  "text-shadow-y": ot,
  "text-shadow-blur": ot
};
function Sxe(e) {
  var t = /(-[a-z])/g, n = function(a) {
    return a[1].toUpperCase();
  }, r = {};
  for (var i in e)
    r[i] = e[i], r[i.replace(t, n)] = e[i];
  return r;
}
var OZe = Sxe(AZe);
function _R(e, t, n) {
  if (t == null)
    return t;
  if (Array.isArray(t))
    for (var r = 0; r < t.length; r++)
      t[r] = _R(e, t[r], n);
  else if (typeof t == "object")
    if (e === "fallbacks")
      for (var i in t)
        t[i] = _R(i, t[i], n);
    else
      for (var o in t)
        t[o] = _R(e + "-" + o, t[o], n);
  else if (typeof t == "number" && isNaN(t) === !1) {
    var a = n[e] || OZe[e];
    return a && !(t === 0 && a === ot) ? typeof a == "function" ? a(t).toString() : "" + t + a : t.toString();
  }
  return t;
}
function RZe(e) {
  e === void 0 && (e = {});
  var t = Sxe(e);
  function n(i, o) {
    if (o.type !== "style")
      return i;
    for (var a in i)
      i[a] = _R(a, i[a], t);
    return i;
  }
  function r(i, o) {
    return _R(o, i, t);
  }
  return {
    onProcessStyle: n,
    onChangeValue: r
  };
}
function JW(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function kZe(e) {
  if (Array.isArray(e))
    return JW(e);
}
function $Ze(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function PZe(e, t) {
  if (e) {
    if (typeof e == "string")
      return JW(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return JW(e, t);
  }
}
function IZe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jZe(e) {
  return kZe(e) || $Ze(e) || PZe(e) || IZe();
}
var MO = "", eq = "", Mxe = "", Txe = "", LZe = bb && "ontouchstart" in document.documentElement;
if (bb) {
  var kY = {
    Moz: "-moz-",
    ms: "-ms-",
    O: "-o-",
    Webkit: "-webkit-"
  }, zZe = document.createElement("p"), $Y = zZe.style, FZe = "Transform";
  for (var PY in kY)
    if (PY + FZe in $Y) {
      MO = PY, eq = kY[PY];
      break;
    }
  MO === "Webkit" && "msHyphens" in $Y && (MO = "ms", eq = kY.ms, Txe = "edge"), MO === "Webkit" && "-apple-trailing-word" in $Y && (Mxe = "apple");
}
var dr = {
  js: MO,
  css: eq,
  vendor: Mxe,
  browser: Txe,
  isTouch: LZe
};
function BZe(e) {
  return e[1] === "-" || dr.js === "ms" ? e : "@" + dr.css + "keyframes" + e.substr(10);
}
var UZe = {
  noPrefill: ["appearance"],
  supportedProperty: function(t) {
    return t !== "appearance" ? !1 : dr.js === "ms" ? "-webkit-" + t : dr.css + t;
  }
}, YZe = {
  noPrefill: ["color-adjust"],
  supportedProperty: function(t) {
    return t !== "color-adjust" ? !1 : dr.js === "Webkit" ? dr.css + "print-" + t : t;
  }
}, HZe = /[-\s]+(.)?/g;
function VZe(e, t) {
  return t ? t.toUpperCase() : "";
}
function MK(e) {
  return e.replace(HZe, VZe);
}
function Vx(e) {
  return MK("-" + e);
}
var WZe = {
  noPrefill: ["mask"],
  supportedProperty: function(t, n) {
    if (!/^mask/.test(t))
      return !1;
    if (dr.js === "Webkit") {
      var r = "mask-image";
      if (MK(r) in n)
        return t;
      if (dr.js + Vx(r) in n)
        return dr.css + t;
    }
    return t;
  }
}, qZe = {
  noPrefill: ["text-orientation"],
  supportedProperty: function(t) {
    return t !== "text-orientation" ? !1 : dr.vendor === "apple" && !dr.isTouch ? dr.css + t : t;
  }
}, GZe = {
  noPrefill: ["transform"],
  supportedProperty: function(t, n, r) {
    return t !== "transform" ? !1 : r.transform ? t : dr.css + t;
  }
}, QZe = {
  noPrefill: ["transition"],
  supportedProperty: function(t, n, r) {
    return t !== "transition" ? !1 : r.transition ? t : dr.css + t;
  }
}, XZe = {
  noPrefill: ["writing-mode"],
  supportedProperty: function(t) {
    return t !== "writing-mode" ? !1 : dr.js === "Webkit" || dr.js === "ms" && dr.browser !== "edge" ? dr.css + t : t;
  }
}, KZe = {
  noPrefill: ["user-select"],
  supportedProperty: function(t) {
    return t !== "user-select" ? !1 : dr.js === "Moz" || dr.js === "ms" || dr.vendor === "apple" ? dr.css + t : t;
  }
}, ZZe = {
  supportedProperty: function(t, n) {
    if (!/^break-/.test(t))
      return !1;
    if (dr.js === "Webkit") {
      var r = "WebkitColumn" + Vx(t);
      return r in n ? dr.css + "column-" + t : !1;
    }
    if (dr.js === "Moz") {
      var i = "page" + Vx(t);
      return i in n ? "page-" + t : !1;
    }
    return !1;
  }
}, JZe = {
  supportedProperty: function(t, n) {
    if (!/^(border|margin|padding)-inline/.test(t))
      return !1;
    if (dr.js === "Moz")
      return t;
    var r = t.replace("-inline", "");
    return dr.js + Vx(r) in n ? dr.css + r : !1;
  }
}, eJe = {
  supportedProperty: function(t, n) {
    return MK(t) in n ? t : !1;
  }
}, tJe = {
  supportedProperty: function(t, n) {
    var r = Vx(t);
    return t[0] === "-" || t[0] === "-" && t[1] === "-" ? t : dr.js + r in n ? dr.css + t : dr.js !== "Webkit" && "Webkit" + r in n ? "-webkit-" + t : !1;
  }
}, nJe = {
  supportedProperty: function(t) {
    return t.substring(0, 11) !== "scroll-snap" ? !1 : dr.js === "ms" ? "" + dr.css + t : t;
  }
}, rJe = {
  supportedProperty: function(t) {
    return t !== "overscroll-behavior" ? !1 : dr.js === "ms" ? dr.css + "scroll-chaining" : t;
  }
}, iJe = {
  "flex-grow": "flex-positive",
  "flex-shrink": "flex-negative",
  "flex-basis": "flex-preferred-size",
  "justify-content": "flex-pack",
  order: "flex-order",
  "align-items": "flex-align",
  "align-content": "flex-line-pack"
  // 'align-self' is handled by 'align-self' plugin.
}, oJe = {
  supportedProperty: function(t, n) {
    var r = iJe[t];
    return r && dr.js + Vx(r) in n ? dr.css + r : !1;
  }
}, Cxe = {
  flex: "box-flex",
  "flex-grow": "box-flex",
  "flex-direction": ["box-orient", "box-direction"],
  order: "box-ordinal-group",
  "align-items": "box-align",
  "flex-flow": ["box-orient", "box-direction"],
  "justify-content": "box-pack"
}, aJe = Object.keys(Cxe), sJe = function(t) {
  return dr.css + t;
}, uJe = {
  supportedProperty: function(t, n, r) {
    var i = r.multiple;
    if (aJe.indexOf(t) > -1) {
      var o = Cxe[t];
      if (!Array.isArray(o))
        return dr.js + Vx(o) in n ? dr.css + o : !1;
      if (!i)
        return !1;
      for (var a = 0; a < o.length; a++)
        if (!(dr.js + Vx(o[0]) in n))
          return !1;
      return o.map(sJe);
    }
    return !1;
  }
}, Nxe = [UZe, YZe, WZe, qZe, GZe, QZe, XZe, KZe, ZZe, JZe, eJe, tJe, nJe, rJe, oJe, uJe], Zce = Nxe.filter(function(e) {
  return e.supportedProperty;
}).map(function(e) {
  return e.supportedProperty;
}), lJe = Nxe.filter(function(e) {
  return e.noPrefill;
}).reduce(function(e, t) {
  return e.push.apply(e, jZe(t.noPrefill)), e;
}, []), TO, AE = {};
if (bb) {
  TO = document.createElement("p");
  var IY = window.getComputedStyle(document.documentElement, "");
  for (var jY in IY)
    isNaN(jY) || (AE[IY[jY]] = IY[jY]);
  lJe.forEach(function(e) {
    return delete AE[e];
  });
}
function tq(e, t) {
  if (t === void 0 && (t = {}), !TO)
    return e;
  if (process.env.NODE_ENV !== "benchmark" && AE[e] != null)
    return AE[e];
  (e === "transition" || e === "transform") && (t[e] = e in TO.style);
  for (var n = 0; n < Zce.length && (AE[e] = Zce[n](e, TO.style, t), !AE[e]); n++)
    ;
  try {
    TO.style[e] = "";
  } catch {
    return !1;
  }
  return AE[e];
}
var IM = {}, cJe = {
  transition: 1,
  "transition-property": 1,
  "-webkit-transition": 1,
  "-webkit-transition-property": 1
}, fJe = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g, ox;
function dJe(e, t, n) {
  if (t === "var")
    return "var";
  if (t === "all")
    return "all";
  if (n === "all")
    return ", all";
  var r = t ? tq(t) : ", " + tq(n);
  return r || t || n;
}
bb && (ox = document.createElement("p"));
function Jce(e, t) {
  var n = t;
  if (!ox || e === "content")
    return t;
  if (typeof n != "string" || !isNaN(parseInt(n, 10)))
    return n;
  var r = e + n;
  if (process.env.NODE_ENV !== "benchmark" && IM[r] != null)
    return IM[r];
  try {
    ox.style[e] = n;
  } catch {
    return IM[r] = !1, !1;
  }
  if (cJe[e])
    n = n.replace(fJe, dJe);
  else if (ox.style[e] === "" && (n = dr.css + n, n === "-ms-flex" && (ox.style[e] = "-ms-flexbox"), ox.style[e] = n, ox.style[e] === ""))
    return IM[r] = !1, !1;
  return ox.style[e] = "", IM[r] = n, IM[r];
}
function kd() {
  return kd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, kd.apply(this, arguments);
}
function dk(e) {
  "@babel/helpers - typeof";
  return dk = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dk(e);
}
function hJe(e, t) {
  if (dk(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (dk(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function pJe(e) {
  var t = hJe(e, "string");
  return dk(t) == "symbol" ? t : t + "";
}
function efe(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, pJe(r.key), r);
  }
}
function Dxe(e, t, n) {
  return t && efe(e.prototype, t), n && efe(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function nq(e, t) {
  return nq = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, nq(e, t);
}
function Axe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, nq(e, t);
}
function tfe(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function gJe(e, t) {
  if (e == null)
    return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0)
        continue;
      n[r] = e[r];
    }
  return n;
}
var mJe = {}.constructor;
function rq(e) {
  if (e == null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    return e.map(rq);
  if (e.constructor !== mJe)
    return e;
  var t = {};
  for (var n in e)
    t[n] = rq(e[n]);
  return t;
}
function Oxe(e, t, n) {
  e === void 0 && (e = "unnamed");
  var r = n.jss, i = rq(t), o = r.plugins.onCreateRule(e, i, n);
  return o || (e[0] === "@" && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Unknown rule " + e), null);
}
var nfe = function(t, n) {
  for (var r = "", i = 0; i < t.length && t[i] !== "!important"; i++)
    r && (r += n), r += t[i];
  return r;
}, QE = function(t) {
  if (!Array.isArray(t))
    return t;
  var n = "";
  if (Array.isArray(t[0]))
    for (var r = 0; r < t.length && t[r] !== "!important"; r++)
      n && (n += ", "), n += nfe(t[r], " ");
  else
    n = nfe(t, ", ");
  return t[t.length - 1] === "!important" && (n += " !important"), n;
};
function iN(e) {
  return e && e.format === !1 ? {
    linebreak: "",
    space: ""
  } : {
    linebreak: `
`,
    space: " "
  };
}
function FA(e, t) {
  for (var n = "", r = 0; r < t; r++)
    n += "  ";
  return n + e;
}
function hk(e, t, n) {
  n === void 0 && (n = {});
  var r = "";
  if (!t)
    return r;
  var i = n, o = i.indent, a = o === void 0 ? 0 : o, s = t.fallbacks;
  n.format === !1 && (a = -1 / 0);
  var u = iN(n), l = u.linebreak, f = u.space;
  if (e && a++, s)
    if (Array.isArray(s))
      for (var h = 0; h < s.length; h++) {
        var p = s[h];
        for (var g in p) {
          var y = p[g];
          y != null && (r && (r += l), r += FA(g + ":" + f + QE(y) + ";", a));
        }
      }
    else
      for (var b in s) {
        var _ = s[b];
        _ != null && (r && (r += l), r += FA(b + ":" + f + QE(_) + ";", a));
      }
  for (var S in t) {
    var C = t[S];
    C != null && S !== "fallbacks" && (r && (r += l), r += FA(S + ":" + f + QE(C) + ";", a));
  }
  return !r && !n.allowEmpty || !e ? r : (a--, r && (r = "" + l + r + l), FA("" + e + f + "{" + r, a) + FA("}", a));
}
var yJe = /([[\].#*$><+~=|^:(),"'`\s])/g, rfe = typeof CSS < "u" && CSS.escape, TK = function(e) {
  return rfe ? rfe(e) : e.replace(yJe, "\\$1");
}, Rxe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "style", this.isProcessed = !1;
    var o = i.sheet, a = i.Renderer;
    this.key = n, this.options = i, this.style = r, o ? this.renderer = o.renderer : a && (this.renderer = new a());
  }
  var t = e.prototype;
  return t.prop = function(r, i, o) {
    if (i === void 0)
      return this.style[r];
    var a = o ? o.force : !1;
    if (!a && this.style[r] === i)
      return this;
    var s = i;
    (!o || o.process !== !1) && (s = this.options.jss.plugins.onChangeValue(i, r, this));
    var u = s == null || s === !1, l = r in this.style;
    if (u && !l && !a)
      return this;
    var f = u && l;
    if (f ? delete this.style[r] : this.style[r] = s, this.renderable && this.renderer)
      return f ? this.renderer.removeProperty(this.renderable, r) : this.renderer.setProperty(this.renderable, r, s), this;
    var h = this.options.sheet;
    return h && h.attached && process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Rule is not linked. Missing sheet option "link: true".'), this;
  }, e;
}(), iq = /* @__PURE__ */ function(e) {
  Axe(t, e);
  function t(r, i, o) {
    var a;
    a = e.call(this, r, i, o) || this;
    var s = o.selector, u = o.scoped, l = o.sheet, f = o.generateId;
    return s ? a.selectorText = s : u !== !1 && (a.id = f(tfe(tfe(a)), l), a.selectorText = "." + TK(a.id)), a;
  }
  var n = t.prototype;
  return n.applyTo = function(i) {
    var o = this.renderer;
    if (o) {
      var a = this.toJSON();
      for (var s in a)
        o.setProperty(i, s, a[s]);
    }
    return this;
  }, n.toJSON = function() {
    var i = {};
    for (var o in this.style) {
      var a = this.style[o];
      typeof a != "object" ? i[o] = a : Array.isArray(a) && (i[o] = QE(a));
    }
    return i;
  }, n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? kd({}, i, {
      allowEmpty: !0
    }) : i;
    return hk(this.selectorText, this.style, s);
  }, Dxe(t, [{
    key: "selector",
    set: function(i) {
      if (i !== this.selectorText) {
        this.selectorText = i;
        var o = this.renderer, a = this.renderable;
        if (!(!a || !o)) {
          var s = o.setSelector(a, i);
          s || o.replaceRule(a, this);
        }
      }
    },
    get: function() {
      return this.selectorText;
    }
  }]), t;
}(Rxe), vJe = {
  onCreateRule: function(t, n, r) {
    return t[0] === "@" || r.parent && r.parent.type === "keyframes" ? null : new iq(t, n, r);
  }
}, LY = {
  indent: 1,
  children: !0
}, bJe = /@([\w-]+)/, xJe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "conditional", this.isProcessed = !1, this.key = n;
    var o = n.match(bJe);
    this.at = o ? o[1] : "unknown", this.query = i.name || "@" + this.at, this.options = i, this.rules = new CK(kd({}, i, {
      parent: this
    }));
    for (var a in r)
      this.rules.add(a, r[a]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.getRule = function(r) {
    return this.rules.get(r);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.addRule = function(r, i, o) {
    var a = this.rules.add(r, i, o);
    return a ? (this.options.jss.plugins.onProcessRule(a), a) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.replace(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.toString = function(r) {
    r === void 0 && (r = LY);
    var i = iN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = LY.indent), r.children == null && (r.children = LY.children), r.children === !1)
      return this.query + " {}";
    var a = this.rules.toString(r);
    return a ? this.query + " {" + o + a + o + "}" : "";
  }, e;
}(), wJe = /@container|@media|@supports\s+/, _Je = {
  onCreateRule: function(t, n, r) {
    return wJe.test(t) ? new xJe(t, n, r) : null;
  }
}, zY = {
  indent: 1,
  children: !0
}, EJe = /@keyframes\s+([\w-]+)/, oq = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1;
    var o = n.match(EJe);
    o && o[1] ? this.name = o[1] : (this.name = "noname", process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Bad keyframes name " + n)), this.key = this.type + "-" + this.name, this.options = i;
    var a = i.scoped, s = i.sheet, u = i.generateId;
    this.id = a === !1 ? this.name : TK(u(this, s)), this.rules = new CK(kd({}, i, {
      parent: this
    }));
    for (var l in r)
      this.rules.add(l, r[l], kd({}, i, {
        parent: this
      }));
    this.rules.process();
  }
  var t = e.prototype;
  return t.toString = function(r) {
    r === void 0 && (r = zY);
    var i = iN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = zY.indent), r.children == null && (r.children = zY.children), r.children === !1)
      return this.at + " " + this.id + " {}";
    var a = this.rules.toString(r);
    return a && (a = "" + o + a + o), this.at + " " + this.id + " {" + a + "}";
  }, e;
}(), SJe = /@keyframes\s+/, MJe = /\$([\w-]+)/g, aq = function(t, n) {
  return typeof t == "string" ? t.replace(MJe, function(r, i) {
    return i in n ? n[i] : (process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Referenced keyframes rule "' + i + '" is not defined.'), r);
  }) : t;
}, ife = function(t, n, r) {
  var i = t[n], o = aq(i, r);
  o !== i && (t[n] = o);
}, TJe = {
  onCreateRule: function(t, n, r) {
    return typeof t == "string" && SJe.test(t) ? new oq(t, n, r) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function(t, n, r) {
    return n.type !== "style" || !r || ("animation-name" in t && ife(t, "animation-name", r.keyframes), "animation" in t && ife(t, "animation", r.keyframes)), t;
  },
  onChangeValue: function(t, n, r) {
    var i = r.options.sheet;
    if (!i)
      return t;
    switch (n) {
      case "animation":
        return aq(t, i.keyframes);
      case "animation-name":
        return aq(t, i.keyframes);
      default:
        return t;
    }
  }
}, CJe = /* @__PURE__ */ function(e) {
  Axe(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var n = t.prototype;
  return n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? kd({}, i, {
      allowEmpty: !0
    }) : i;
    return hk(this.key, this.style, s);
  }, t;
}(Rxe), NJe = {
  onCreateRule: function(t, n, r) {
    return r.parent && r.parent.type === "keyframes" ? new CJe(t, n, r) : null;
  }
}, DJe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    var i = iN(r), o = i.linebreak;
    if (Array.isArray(this.style)) {
      for (var a = "", s = 0; s < this.style.length; s++)
        a += hk(this.at, this.style[s]), this.style[s + 1] && (a += o);
      return a;
    }
    return hk(this.at, this.style, r);
  }, e;
}(), AJe = /@font-face/, OJe = {
  onCreateRule: function(t, n, r) {
    return AJe.test(t) ? new DJe(t, n, r) : null;
  }
}, RJe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    return hk(this.key, this.style, r);
  }, e;
}(), kJe = {
  onCreateRule: function(t, n, r) {
    return t === "@viewport" || t === "@-ms-viewport" ? new RJe(t, n, r) : null;
  }
}, $Je = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "simple", this.isProcessed = !1, this.key = n, this.value = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    if (Array.isArray(this.value)) {
      for (var i = "", o = 0; o < this.value.length; o++)
        i += this.key + " " + this.value[o] + ";", this.value[o + 1] && (i += `
`);
      return i;
    }
    return this.key + " " + this.value + ";";
  }, e;
}(), PJe = {
  "@charset": !0,
  "@import": !0,
  "@namespace": !0
}, IJe = {
  onCreateRule: function(t, n, r) {
    return t in PJe ? new $Je(t, n, r) : null;
  }
}, ofe = [vJe, _Je, TJe, NJe, OJe, kJe, IJe], jJe = {
  process: !0
}, afe = {
  force: !0,
  process: !0
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */
}, CK = /* @__PURE__ */ function() {
  function e(n) {
    this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = n, this.classes = n.classes, this.keyframes = n.keyframes;
  }
  var t = e.prototype;
  return t.add = function(r, i, o) {
    var a = this.options, s = a.parent, u = a.sheet, l = a.jss, f = a.Renderer, h = a.generateId, p = a.scoped, g = kd({
      classes: this.classes,
      parent: s,
      sheet: u,
      jss: l,
      Renderer: f,
      generateId: h,
      scoped: p,
      name: r,
      keyframes: this.keyframes,
      selector: void 0
    }, o), y = r;
    r in this.raw && (y = r + "-d" + this.counter++), this.raw[y] = i, y in this.classes && (g.selector = "." + TK(this.classes[y]));
    var b = Oxe(y, i, g);
    if (!b)
      return null;
    this.register(b);
    var _ = g.index === void 0 ? this.index.length : g.index;
    return this.index.splice(_, 0, b), b;
  }, t.replace = function(r, i, o) {
    var a = this.get(r), s = this.index.indexOf(a);
    a && this.remove(a);
    var u = o;
    return s !== -1 && (u = kd({}, o, {
      index: s
    })), this.add(r, i, u);
  }, t.get = function(r) {
    return this.map[r];
  }, t.remove = function(r) {
    this.unregister(r), delete this.raw[r.key], this.index.splice(this.index.indexOf(r), 1);
  }, t.indexOf = function(r) {
    return this.index.indexOf(r);
  }, t.process = function() {
    var r = this.options.jss.plugins;
    this.index.slice(0).forEach(r.onProcessRule, r);
  }, t.register = function(r) {
    this.map[r.key] = r, r instanceof iq ? (this.map[r.selector] = r, r.id && (this.classes[r.key] = r.id)) : r instanceof oq && this.keyframes && (this.keyframes[r.name] = r.id);
  }, t.unregister = function(r) {
    delete this.map[r.key], r instanceof iq ? (delete this.map[r.selector], delete this.classes[r.key]) : r instanceof oq && delete this.keyframes[r.name];
  }, t.update = function() {
    var r, i, o;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (r = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], o = arguments.length <= 2 ? void 0 : arguments[2]) : (i = arguments.length <= 0 ? void 0 : arguments[0], o = arguments.length <= 1 ? void 0 : arguments[1], r = null), r)
      this.updateOne(this.get(r), i, o);
    else
      for (var a = 0; a < this.index.length; a++)
        this.updateOne(this.index[a], i, o);
  }, t.updateOne = function(r, i, o) {
    o === void 0 && (o = jJe);
    var a = this.options, s = a.jss.plugins, u = a.sheet;
    if (r.rules instanceof e) {
      r.rules.update(i, o);
      return;
    }
    var l = r.style;
    if (s.onUpdate(i, r, u, o), o.process && l && l !== r.style) {
      s.onProcessStyle(r.style, r, u);
      for (var f in r.style) {
        var h = r.style[f], p = l[f];
        h !== p && r.prop(f, h, afe);
      }
      for (var g in l) {
        var y = r.style[g], b = l[g];
        y == null && y !== b && r.prop(g, null, afe);
      }
    }
  }, t.toString = function(r) {
    for (var i = "", o = this.options.sheet, a = o ? o.options.link : !1, s = iN(r), u = s.linebreak, l = 0; l < this.index.length; l++) {
      var f = this.index[l], h = f.toString(r);
      !h && !a || (i && (i += u), i += h);
    }
    return i;
  }, e;
}(), kxe = /* @__PURE__ */ function() {
  function e(n, r) {
    this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = kd({}, r, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    }), r.Renderer && (this.renderer = new r.Renderer(this)), this.rules = new CK(this.options);
    for (var i in n)
      this.rules.add(i, n[i]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.attach = function() {
    return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this);
  }, t.detach = function() {
    return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this;
  }, t.addRule = function(r, i, o) {
    var a = this.queue;
    this.attached && !a && (this.queue = []);
    var s = this.rules.add(r, i, o);
    return s ? (this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && (a ? a.push(s) : (this.insertRule(s), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), s) : (this.deployed = !1, s)) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.get(r);
    if (!a)
      return this.addRule(r, i, o);
    var s = this.rules.replace(r, i, o);
    return s && this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && this.renderer && (s ? a.renderable && this.renderer.replaceRule(a.renderable, s) : this.renderer.deleteRule(a)), s) : (this.deployed = !1, s);
  }, t.insertRule = function(r) {
    this.renderer && this.renderer.insertRule(r);
  }, t.addRules = function(r, i) {
    var o = [];
    for (var a in r) {
      var s = this.addRule(a, r[a], i);
      s && o.push(s);
    }
    return o;
  }, t.getRule = function(r) {
    return this.rules.get(r);
  }, t.deleteRule = function(r) {
    var i = typeof r == "object" ? r : this.rules.get(r);
    return !i || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !i.renderable ? !1 : (this.rules.remove(i), this.attached && i.renderable && this.renderer ? this.renderer.deleteRule(i.renderable) : !0);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.deploy = function() {
    return this.renderer && this.renderer.deploy(), this.deployed = !0, this;
  }, t.update = function() {
    var r;
    return (r = this.rules).update.apply(r, arguments), this;
  }, t.updateOne = function(r, i, o) {
    return this.rules.updateOne(r, i, o), this;
  }, t.toString = function(r) {
    return this.rules.toString(r);
  }, e;
}(), LJe = /* @__PURE__ */ function() {
  function e() {
    this.plugins = {
      internal: [],
      external: []
    }, this.registry = {};
  }
  var t = e.prototype;
  return t.onCreateRule = function(r, i, o) {
    for (var a = 0; a < this.registry.onCreateRule.length; a++) {
      var s = this.registry.onCreateRule[a](r, i, o);
      if (s)
        return s;
    }
    return null;
  }, t.onProcessRule = function(r) {
    if (!r.isProcessed) {
      for (var i = r.options.sheet, o = 0; o < this.registry.onProcessRule.length; o++)
        this.registry.onProcessRule[o](r, i);
      r.style && this.onProcessStyle(r.style, r, i), r.isProcessed = !0;
    }
  }, t.onProcessStyle = function(r, i, o) {
    for (var a = 0; a < this.registry.onProcessStyle.length; a++)
      i.style = this.registry.onProcessStyle[a](i.style, i, o);
  }, t.onProcessSheet = function(r) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++)
      this.registry.onProcessSheet[i](r);
  }, t.onUpdate = function(r, i, o, a) {
    for (var s = 0; s < this.registry.onUpdate.length; s++)
      this.registry.onUpdate[s](r, i, o, a);
  }, t.onChangeValue = function(r, i, o) {
    for (var a = r, s = 0; s < this.registry.onChangeValue.length; s++)
      a = this.registry.onChangeValue[s](a, i, o);
    return a;
  }, t.use = function(r, i) {
    i === void 0 && (i = {
      queue: "external"
    });
    var o = this.plugins[i.queue];
    o.indexOf(r) === -1 && (o.push(r), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(a, s) {
      for (var u in s)
        u in a ? a[u].push(s[u]) : process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Unknown hook "' + u + '".');
      return a;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    }));
  }, e;
}(), zJe = /* @__PURE__ */ function() {
  function e() {
    this.registry = [];
  }
  var t = e.prototype;
  return t.add = function(r) {
    var i = this.registry, o = r.options.index;
    if (i.indexOf(r) === -1) {
      if (i.length === 0 || o >= this.index) {
        i.push(r);
        return;
      }
      for (var a = 0; a < i.length; a++)
        if (i[a].options.index > o) {
          i.splice(a, 0, r);
          return;
        }
    }
  }, t.reset = function() {
    this.registry = [];
  }, t.remove = function(r) {
    var i = this.registry.indexOf(r);
    this.registry.splice(i, 1);
  }, t.toString = function(r) {
    for (var i = r === void 0 ? {} : r, o = i.attached, a = gJe(i, ["attached"]), s = iN(a), u = s.linebreak, l = "", f = 0; f < this.registry.length; f++) {
      var h = this.registry[f];
      o != null && h.attached !== o || (l && (l += u), l += h.toString(a));
    }
    return l;
  }, Dxe(e, [{
    key: "index",
    /**
     * Current highest index number.
     */
    get: function() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]), e;
}(), ER = new zJe(), sq = typeof globalThis < "u" ? globalThis : typeof window < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), uq = "2f1acc6c3a606b082e5eef5e54414ffb";
sq[uq] == null && (sq[uq] = 0);
var sfe = sq[uq]++, FJe = 1e10, ufe = function(t) {
  t === void 0 && (t = {});
  var n = 0, r = function(o, a) {
    n += 1, n > FJe && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] You might have a memory leak. Rule counter is at " + n + ".");
    var s = "", u = "";
    return a && (a.options.classNamePrefix && (u = a.options.classNamePrefix), a.options.jss.id != null && (s = String(a.options.jss.id))), t.minify ? "" + (u || "c") + sfe + s + n : u + o.key + "-" + sfe + (s ? "-" + s : "") + "-" + n;
  };
  return r;
}, $xe = function(t) {
  var n;
  return function() {
    return n || (n = t()), n;
  };
}, BJe = function(t, n) {
  try {
    return t.attributeStyleMap ? t.attributeStyleMap.get(n) : t.style.getPropertyValue(n);
  } catch {
    return "";
  }
}, UJe = function(t, n, r) {
  try {
    var i = r;
    if (Array.isArray(r) && (i = QE(r)), t.attributeStyleMap)
      t.attributeStyleMap.set(n, i);
    else {
      var o = i ? i.indexOf("!important") : -1, a = o > -1 ? i.substr(0, o - 1) : i;
      t.style.setProperty(n, a, o > -1 ? "important" : "");
    }
  } catch {
    return !1;
  }
  return !0;
}, YJe = function(t, n) {
  try {
    t.attributeStyleMap ? t.attributeStyleMap.delete(n) : t.style.removeProperty(n);
  } catch (r) {
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] DOMException "' + r.message + '" was thrown. Tried to remove property "' + n + '".');
  }
}, HJe = function(t, n) {
  return t.selectorText = n, t.selectorText === n;
}, Pxe = $xe(function() {
  return document.querySelector("head");
});
function VJe(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    if (r.attached && r.options.index > t.index && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function WJe(e, t) {
  for (var n = e.length - 1; n >= 0; n--) {
    var r = e[n];
    if (r.attached && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function qJe(e) {
  for (var t = Pxe(), n = 0; n < t.childNodes.length; n++) {
    var r = t.childNodes[n];
    if (r.nodeType === 8 && r.nodeValue.trim() === e)
      return r;
  }
  return null;
}
function GJe(e) {
  var t = ER.registry;
  if (t.length > 0) {
    var n = VJe(t, e);
    if (n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element
      };
    if (n = WJe(t, e), n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element.nextSibling
      };
  }
  var r = e.insertionPoint;
  if (r && typeof r == "string") {
    var i = qJe(r);
    if (i)
      return {
        parent: i.parentNode,
        node: i.nextSibling
      };
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Insertion point "' + r + '" not found.');
  }
  return !1;
}
function QJe(e, t) {
  var n = t.insertionPoint, r = GJe(t);
  if (r !== !1 && r.parent) {
    r.parent.insertBefore(e, r.node);
    return;
  }
  if (n && typeof n.nodeType == "number") {
    var i = n, o = i.parentNode;
    o ? o.insertBefore(e, i.nextSibling) : process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Insertion point is not in the DOM.");
    return;
  }
  Pxe().appendChild(e);
}
var XJe = $xe(function() {
  var e = document.querySelector('meta[property="csp-nonce"]');
  return e ? e.getAttribute("content") : null;
}), lfe = function(t, n, r) {
  try {
    "insertRule" in t ? t.insertRule(n, r) : "appendRule" in t && t.appendRule(n);
  } catch (i) {
    return process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] " + i.message), !1;
  }
  return t.cssRules[r];
}, cfe = function(t, n) {
  var r = t.cssRules.length;
  return n === void 0 || n > r ? r : n;
}, KJe = function() {
  var t = document.createElement("style");
  return t.textContent = `
`, t;
}, ZJe = /* @__PURE__ */ function() {
  function e(n) {
    this.getPropertyValue = BJe, this.setProperty = UJe, this.removeProperty = YJe, this.setSelector = HJe, this.hasInsertedRules = !1, this.cssRules = [], n && ER.add(n), this.sheet = n;
    var r = this.sheet ? this.sheet.options : {}, i = r.media, o = r.meta, a = r.element;
    this.element = a || KJe(), this.element.setAttribute("data-jss", ""), i && this.element.setAttribute("media", i), o && this.element.setAttribute("data-meta", o);
    var s = XJe();
    s && this.element.setAttribute("nonce", s);
  }
  var t = e.prototype;
  return t.attach = function() {
    if (!(this.element.parentNode || !this.sheet)) {
      QJe(this.element, this.sheet.options);
      var r = !!(this.sheet && this.sheet.deployed);
      this.hasInsertedRules && r && (this.hasInsertedRules = !1, this.deploy());
    }
  }, t.detach = function() {
    if (this.sheet) {
      var r = this.element.parentNode;
      r && r.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`);
    }
  }, t.deploy = function() {
    var r = this.sheet;
    if (r) {
      if (r.options.link) {
        this.insertRules(r.rules);
        return;
      }
      this.element.textContent = `
` + r.toString() + `
`;
    }
  }, t.insertRules = function(r, i) {
    for (var o = 0; o < r.index.length; o++)
      this.insertRule(r.index[o], o, i);
  }, t.insertRule = function(r, i, o) {
    if (o === void 0 && (o = this.element.sheet), r.rules) {
      var a = r, s = o;
      if (r.type === "conditional" || r.type === "keyframes") {
        var u = cfe(o, i);
        if (s = lfe(o, a.toString({
          children: !1
        }), u), s === !1)
          return !1;
        this.refCssRule(r, u, s);
      }
      return this.insertRules(a.rules, s), s;
    }
    var l = r.toString();
    if (!l)
      return !1;
    var f = cfe(o, i), h = lfe(o, l, f);
    return h === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(r, f, h), h);
  }, t.refCssRule = function(r, i, o) {
    r.renderable = o, r.options.parent instanceof kxe && this.cssRules.splice(i, 0, o);
  }, t.deleteRule = function(r) {
    var i = this.element.sheet, o = this.indexOf(r);
    return o === -1 ? !1 : (i.deleteRule(o), this.cssRules.splice(o, 1), !0);
  }, t.indexOf = function(r) {
    return this.cssRules.indexOf(r);
  }, t.replaceRule = function(r, i) {
    var o = this.indexOf(r);
    return o === -1 ? !1 : (this.element.sheet.deleteRule(o), this.cssRules.splice(o, 1), this.insertRule(i, o));
  }, t.getRules = function() {
    return this.element.sheet.cssRules;
  }, e;
}(), JJe = 0, eet = /* @__PURE__ */ function() {
  function e(n) {
    this.id = JJe++, this.version = "10.10.0", this.plugins = new LJe(), this.options = {
      id: {
        minify: !1
      },
      createGenerateId: ufe,
      Renderer: bb ? ZJe : null,
      plugins: []
    }, this.generateId = ufe({
      minify: !1
    });
    for (var r = 0; r < ofe.length; r++)
      this.plugins.use(ofe[r], {
        queue: "internal"
      });
    this.setup(n);
  }
  var t = e.prototype;
  return t.setup = function(r) {
    return r === void 0 && (r = {}), r.createGenerateId && (this.options.createGenerateId = r.createGenerateId), r.id && (this.options.id = kd({}, this.options.id, r.id)), (r.createGenerateId || r.id) && (this.generateId = this.options.createGenerateId(this.options.id)), r.insertionPoint != null && (this.options.insertionPoint = r.insertionPoint), "Renderer" in r && (this.options.Renderer = r.Renderer), r.plugins && this.use.apply(this, r.plugins), this;
  }, t.createStyleSheet = function(r, i) {
    i === void 0 && (i = {});
    var o = i, a = o.index;
    typeof a != "number" && (a = ER.index === 0 ? 0 : ER.index + 1);
    var s = new kxe(r, kd({}, i, {
      jss: this,
      generateId: i.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: a
    }));
    return this.plugins.onProcessSheet(s), s;
  }, t.removeStyleSheet = function(r) {
    return r.detach(), ER.remove(r), this;
  }, t.createRule = function(r, i, o) {
    if (i === void 0 && (i = {}), o === void 0 && (o = {}), typeof r == "object")
      return this.createRule(void 0, r, i);
    var a = kd({}, o, {
      name: r,
      jss: this,
      Renderer: this.options.Renderer
    });
    a.generateId || (a.generateId = this.generateId), a.classes || (a.classes = {}), a.keyframes || (a.keyframes = {});
    var s = Oxe(r, i, a);
    return s && this.plugins.onProcessRule(s), s;
  }, t.use = function() {
    for (var r = this, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return o.forEach(function(s) {
      r.plugins.use(s);
    }), this;
  }, e;
}(), tet = function(t) {
  return new eet(t);
};
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
tet();
function net() {
  function e(i) {
    if (i.type === "keyframes") {
      var o = i;
      o.at = BZe(o.at);
    }
  }
  function t(i) {
    for (var o in i) {
      var a = i[o];
      if (o === "fallbacks" && Array.isArray(a)) {
        i[o] = a.map(t);
        continue;
      }
      var s = !1, u = tq(o);
      u && u !== o && (s = !0);
      var l = !1, f = Jce(u, QE(a));
      f && f !== a && (l = !0), (s || l) && (s && delete i[o], i[u || o] = f || a);
    }
    return i;
  }
  function n(i, o) {
    return o.type !== "style" ? i : t(i);
  }
  function r(i, o) {
    return Jce(o, QE(i)) || i;
  }
  return {
    onProcessRule: e,
    onProcessStyle: n,
    onChangeValue: r
  };
}
function ret() {
  var e = function(n, r) {
    return n.length === r.length ? n > r ? 1 : -1 : n.length - r.length;
  };
  return {
    onProcessStyle: function(n, r) {
      if (r.type !== "style")
        return n;
      for (var i = {}, o = Object.keys(n).sort(e), a = 0; a < o.length; a++)
        i[o[a]] = n[o[a]];
      return i;
    }
  };
}
function Ixe() {
  return {
    plugins: [
      LXe(),
      kKe(),
      IKe(),
      FKe(),
      RZe(),
      // Disable the vendor prefixer server-side, it does nothing.
      // This way, we can get a performance boost.
      // In the documentation, we are using `autoprefixer` to solve this problem.
      typeof window > "u" ? null : net(),
      ret()
    ]
  };
}
function dF(e, t) {
  if (e == null)
    return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0)
        continue;
      n[r] = e[r];
    }
  return n;
}
function pk(e) {
  "@babel/helpers - typeof";
  return pk = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pk(e);
}
function iet(e, t) {
  if (pk(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (pk(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oet(e) {
  var t = iet(e, "string");
  return pk(t) == "symbol" ? t : t + "";
}
function ffe(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, oet(r.key), r);
  }
}
function jxe(e, t, n) {
  return t && ffe(e.prototype, t), n && ffe(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function lq(e, t) {
  return lq = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, lq(e, t);
}
function Lxe(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, lq(e, t);
}
function dfe(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
var aet = {}.constructor;
function cq(e) {
  if (e == null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    return e.map(cq);
  if (e.constructor !== aet)
    return e;
  var t = {};
  for (var n in e)
    t[n] = cq(e[n]);
  return t;
}
function zxe(e, t, n) {
  e === void 0 && (e = "unnamed");
  var r = n.jss, i = cq(t), o = r.plugins.onCreateRule(e, i, n);
  return o || (e[0] === "@" && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Unknown rule " + e), null);
}
var hfe = function(t, n) {
  for (var r = "", i = 0; i < t.length && t[i] !== "!important"; i++)
    r && (r += n), r += t[i];
  return r;
}, SR = function(t) {
  if (!Array.isArray(t))
    return t;
  var n = "";
  if (Array.isArray(t[0]))
    for (var r = 0; r < t.length && t[r] !== "!important"; r++)
      n && (n += ", "), n += hfe(t[r], " ");
  else
    n = hfe(t, ", ");
  return t[t.length - 1] === "!important" && (n += " !important"), n;
};
function oN(e) {
  return e && e.format === !1 ? {
    linebreak: "",
    space: ""
  } : {
    linebreak: `
`,
    space: " "
  };
}
function BA(e, t) {
  for (var n = "", r = 0; r < t; r++)
    n += "  ";
  return n + e;
}
function gk(e, t, n) {
  n === void 0 && (n = {});
  var r = "";
  if (!t)
    return r;
  var i = n, o = i.indent, a = o === void 0 ? 0 : o, s = t.fallbacks;
  n.format === !1 && (a = -1 / 0);
  var u = oN(n), l = u.linebreak, f = u.space;
  if (e && a++, s)
    if (Array.isArray(s))
      for (var h = 0; h < s.length; h++) {
        var p = s[h];
        for (var g in p) {
          var y = p[g];
          y != null && (r && (r += l), r += BA(g + ":" + f + SR(y) + ";", a));
        }
      }
    else
      for (var b in s) {
        var _ = s[b];
        _ != null && (r && (r += l), r += BA(b + ":" + f + SR(_) + ";", a));
      }
  for (var S in t) {
    var C = t[S];
    C != null && S !== "fallbacks" && (r && (r += l), r += BA(S + ":" + f + SR(C) + ";", a));
  }
  return !r && !n.allowEmpty || !e ? r : (a--, r && (r = "" + l + r + l), BA("" + e + f + "{" + r, a) + BA("}", a));
}
var set = /([[\].#*$><+~=|^:(),"'`\s])/g, pfe = typeof CSS < "u" && CSS.escape, NK = function(e) {
  return pfe ? pfe(e) : e.replace(set, "\\$1");
}, Fxe = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "style", this.isProcessed = !1;
    var o = i.sheet, a = i.Renderer;
    this.key = n, this.options = i, this.style = r, o ? this.renderer = o.renderer : a && (this.renderer = new a());
  }
  var t = e.prototype;
  return t.prop = function(r, i, o) {
    if (i === void 0)
      return this.style[r];
    var a = o ? o.force : !1;
    if (!a && this.style[r] === i)
      return this;
    var s = i;
    (!o || o.process !== !1) && (s = this.options.jss.plugins.onChangeValue(i, r, this));
    var u = s == null || s === !1, l = r in this.style;
    if (u && !l && !a)
      return this;
    var f = u && l;
    if (f ? delete this.style[r] : this.style[r] = s, this.renderable && this.renderer)
      return f ? this.renderer.removeProperty(this.renderable, r) : this.renderer.setProperty(this.renderable, r, s), this;
    var h = this.options.sheet;
    return h && h.attached && process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Rule is not linked. Missing sheet option "link: true".'), this;
  }, e;
}(), fq = /* @__PURE__ */ function(e) {
  Lxe(t, e);
  function t(r, i, o) {
    var a;
    a = e.call(this, r, i, o) || this;
    var s = o.selector, u = o.scoped, l = o.sheet, f = o.generateId;
    return s ? a.selectorText = s : u !== !1 && (a.id = f(dfe(dfe(a)), l), a.selectorText = "." + NK(a.id)), a;
  }
  var n = t.prototype;
  return n.applyTo = function(i) {
    var o = this.renderer;
    if (o) {
      var a = this.toJSON();
      for (var s in a)
        o.setProperty(i, s, a[s]);
    }
    return this;
  }, n.toJSON = function() {
    var i = {};
    for (var o in this.style) {
      var a = this.style[o];
      typeof a != "object" ? i[o] = a : Array.isArray(a) && (i[o] = SR(a));
    }
    return i;
  }, n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? Ya({}, i, {
      allowEmpty: !0
    }) : i;
    return gk(this.selectorText, this.style, s);
  }, jxe(t, [{
    key: "selector",
    set: function(i) {
      if (i !== this.selectorText) {
        this.selectorText = i;
        var o = this.renderer, a = this.renderable;
        if (!(!a || !o)) {
          var s = o.setSelector(a, i);
          s || o.replaceRule(a, this);
        }
      }
    },
    get: function() {
      return this.selectorText;
    }
  }]), t;
}(Fxe), uet = {
  onCreateRule: function(t, n, r) {
    return t[0] === "@" || r.parent && r.parent.type === "keyframes" ? null : new fq(t, n, r);
  }
}, FY = {
  indent: 1,
  children: !0
}, cet = /@([\w-]+)/, fet = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "conditional", this.isProcessed = !1, this.key = n;
    var o = n.match(cet);
    this.at = o ? o[1] : "unknown", this.query = i.name || "@" + this.at, this.options = i, this.rules = new DK(Ya({}, i, {
      parent: this
    }));
    for (var a in r)
      this.rules.add(a, r[a]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.getRule = function(r) {
    return this.rules.get(r);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.addRule = function(r, i, o) {
    var a = this.rules.add(r, i, o);
    return a ? (this.options.jss.plugins.onProcessRule(a), a) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.replace(r, i, o);
    return a && this.options.jss.plugins.onProcessRule(a), a;
  }, t.toString = function(r) {
    r === void 0 && (r = FY);
    var i = oN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = FY.indent), r.children == null && (r.children = FY.children), r.children === !1)
      return this.query + " {}";
    var a = this.rules.toString(r);
    return a ? this.query + " {" + o + a + o + "}" : "";
  }, e;
}(), det = /@container|@media|@supports\s+/, het = {
  onCreateRule: function(t, n, r) {
    return det.test(t) ? new fet(t, n, r) : null;
  }
}, BY = {
  indent: 1,
  children: !0
}, pet = /@keyframes\s+([\w-]+)/, dq = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1;
    var o = n.match(pet);
    o && o[1] ? this.name = o[1] : (this.name = "noname", process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Bad keyframes name " + n)), this.key = this.type + "-" + this.name, this.options = i;
    var a = i.scoped, s = i.sheet, u = i.generateId;
    this.id = a === !1 ? this.name : NK(u(this, s)), this.rules = new DK(Ya({}, i, {
      parent: this
    }));
    for (var l in r)
      this.rules.add(l, r[l], Ya({}, i, {
        parent: this
      }));
    this.rules.process();
  }
  var t = e.prototype;
  return t.toString = function(r) {
    r === void 0 && (r = BY);
    var i = oN(r), o = i.linebreak;
    if (r.indent == null && (r.indent = BY.indent), r.children == null && (r.children = BY.children), r.children === !1)
      return this.at + " " + this.id + " {}";
    var a = this.rules.toString(r);
    return a && (a = "" + o + a + o), this.at + " " + this.id + " {" + a + "}";
  }, e;
}(), get = /@keyframes\s+/, met = /\$([\w-]+)/g, hq = function(t, n) {
  return typeof t == "string" ? t.replace(met, function(r, i) {
    return i in n ? n[i] : (process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Referenced keyframes rule "' + i + '" is not defined.'), r);
  }) : t;
}, gfe = function(t, n, r) {
  var i = t[n], o = hq(i, r);
  o !== i && (t[n] = o);
}, yet = {
  onCreateRule: function(t, n, r) {
    return typeof t == "string" && get.test(t) ? new dq(t, n, r) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function(t, n, r) {
    return n.type !== "style" || !r || ("animation-name" in t && gfe(t, "animation-name", r.keyframes), "animation" in t && gfe(t, "animation", r.keyframes)), t;
  },
  onChangeValue: function(t, n, r) {
    var i = r.options.sheet;
    if (!i)
      return t;
    switch (n) {
      case "animation":
        return hq(t, i.keyframes);
      case "animation-name":
        return hq(t, i.keyframes);
      default:
        return t;
    }
  }
}, vet = /* @__PURE__ */ function(e) {
  Lxe(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var n = t.prototype;
  return n.toString = function(i) {
    var o = this.options.sheet, a = o ? o.options.link : !1, s = a ? Ya({}, i, {
      allowEmpty: !0
    }) : i;
    return gk(this.key, this.style, s);
  }, t;
}(Fxe), bet = {
  onCreateRule: function(t, n, r) {
    return r.parent && r.parent.type === "keyframes" ? new vet(t, n, r) : null;
  }
}, xet = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    var i = oN(r), o = i.linebreak;
    if (Array.isArray(this.style)) {
      for (var a = "", s = 0; s < this.style.length; s++)
        a += gk(this.at, this.style[s]), this.style[s + 1] && (a += o);
      return a;
    }
    return gk(this.at, this.style, r);
  }, e;
}(), wet = /@font-face/, _et = {
  onCreateRule: function(t, n, r) {
    return wet.test(t) ? new xet(t, n, r) : null;
  }
}, Eet = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = n, this.style = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    return gk(this.key, this.style, r);
  }, e;
}(), Met = {
  onCreateRule: function(t, n, r) {
    return t === "@viewport" || t === "@-ms-viewport" ? new Eet(t, n, r) : null;
  }
}, Tet = /* @__PURE__ */ function() {
  function e(n, r, i) {
    this.type = "simple", this.isProcessed = !1, this.key = n, this.value = r, this.options = i;
  }
  var t = e.prototype;
  return t.toString = function(r) {
    if (Array.isArray(this.value)) {
      for (var i = "", o = 0; o < this.value.length; o++)
        i += this.key + " " + this.value[o] + ";", this.value[o + 1] && (i += `
`);
      return i;
    }
    return this.key + " " + this.value + ";";
  }, e;
}(), Cet = {
  "@charset": !0,
  "@import": !0,
  "@namespace": !0
}, Net = {
  onCreateRule: function(t, n, r) {
    return t in Cet ? new Tet(t, n, r) : null;
  }
}, mfe = [uet, het, yet, bet, _et, Met, Net], Det = {
  process: !0
}, yfe = {
  force: !0,
  process: !0
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */
}, DK = /* @__PURE__ */ function() {
  function e(n) {
    this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = n, this.classes = n.classes, this.keyframes = n.keyframes;
  }
  var t = e.prototype;
  return t.add = function(r, i, o) {
    var a = this.options, s = a.parent, u = a.sheet, l = a.jss, f = a.Renderer, h = a.generateId, p = a.scoped, g = Ya({
      classes: this.classes,
      parent: s,
      sheet: u,
      jss: l,
      Renderer: f,
      generateId: h,
      scoped: p,
      name: r,
      keyframes: this.keyframes,
      selector: void 0
    }, o), y = r;
    r in this.raw && (y = r + "-d" + this.counter++), this.raw[y] = i, y in this.classes && (g.selector = "." + NK(this.classes[y]));
    var b = zxe(y, i, g);
    if (!b)
      return null;
    this.register(b);
    var _ = g.index === void 0 ? this.index.length : g.index;
    return this.index.splice(_, 0, b), b;
  }, t.replace = function(r, i, o) {
    var a = this.get(r), s = this.index.indexOf(a);
    a && this.remove(a);
    var u = o;
    return s !== -1 && (u = Ya({}, o, {
      index: s
    })), this.add(r, i, u);
  }, t.get = function(r) {
    return this.map[r];
  }, t.remove = function(r) {
    this.unregister(r), delete this.raw[r.key], this.index.splice(this.index.indexOf(r), 1);
  }, t.indexOf = function(r) {
    return this.index.indexOf(r);
  }, t.process = function() {
    var r = this.options.jss.plugins;
    this.index.slice(0).forEach(r.onProcessRule, r);
  }, t.register = function(r) {
    this.map[r.key] = r, r instanceof fq ? (this.map[r.selector] = r, r.id && (this.classes[r.key] = r.id)) : r instanceof dq && this.keyframes && (this.keyframes[r.name] = r.id);
  }, t.unregister = function(r) {
    delete this.map[r.key], r instanceof fq ? (delete this.map[r.selector], delete this.classes[r.key]) : r instanceof dq && delete this.keyframes[r.name];
  }, t.update = function() {
    var r, i, o;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (r = arguments.length <= 0 ? void 0 : arguments[0], i = arguments.length <= 1 ? void 0 : arguments[1], o = arguments.length <= 2 ? void 0 : arguments[2]) : (i = arguments.length <= 0 ? void 0 : arguments[0], o = arguments.length <= 1 ? void 0 : arguments[1], r = null), r)
      this.updateOne(this.get(r), i, o);
    else
      for (var a = 0; a < this.index.length; a++)
        this.updateOne(this.index[a], i, o);
  }, t.updateOne = function(r, i, o) {
    o === void 0 && (o = Det);
    var a = this.options, s = a.jss.plugins, u = a.sheet;
    if (r.rules instanceof e) {
      r.rules.update(i, o);
      return;
    }
    var l = r.style;
    if (s.onUpdate(i, r, u, o), o.process && l && l !== r.style) {
      s.onProcessStyle(r.style, r, u);
      for (var f in r.style) {
        var h = r.style[f], p = l[f];
        h !== p && r.prop(f, h, yfe);
      }
      for (var g in l) {
        var y = r.style[g], b = l[g];
        y == null && y !== b && r.prop(g, null, yfe);
      }
    }
  }, t.toString = function(r) {
    for (var i = "", o = this.options.sheet, a = o ? o.options.link : !1, s = oN(r), u = s.linebreak, l = 0; l < this.index.length; l++) {
      var f = this.index[l], h = f.toString(r);
      !h && !a || (i && (i += u), i += h);
    }
    return i;
  }, e;
}(), Bxe = /* @__PURE__ */ function() {
  function e(n, r) {
    this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = Ya({}, r, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    }), r.Renderer && (this.renderer = new r.Renderer(this)), this.rules = new DK(this.options);
    for (var i in n)
      this.rules.add(i, n[i]);
    this.rules.process();
  }
  var t = e.prototype;
  return t.attach = function() {
    return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this);
  }, t.detach = function() {
    return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this;
  }, t.addRule = function(r, i, o) {
    var a = this.queue;
    this.attached && !a && (this.queue = []);
    var s = this.rules.add(r, i, o);
    return s ? (this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && (a ? a.push(s) : (this.insertRule(s), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), s) : (this.deployed = !1, s)) : null;
  }, t.replaceRule = function(r, i, o) {
    var a = this.rules.get(r);
    if (!a)
      return this.addRule(r, i, o);
    var s = this.rules.replace(r, i, o);
    return s && this.options.jss.plugins.onProcessRule(s), this.attached ? (this.deployed && this.renderer && (s ? a.renderable && this.renderer.replaceRule(a.renderable, s) : this.renderer.deleteRule(a)), s) : (this.deployed = !1, s);
  }, t.insertRule = function(r) {
    this.renderer && this.renderer.insertRule(r);
  }, t.addRules = function(r, i) {
    var o = [];
    for (var a in r) {
      var s = this.addRule(a, r[a], i);
      s && o.push(s);
    }
    return o;
  }, t.getRule = function(r) {
    return this.rules.get(r);
  }, t.deleteRule = function(r) {
    var i = typeof r == "object" ? r : this.rules.get(r);
    return !i || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !i.renderable ? !1 : (this.rules.remove(i), this.attached && i.renderable && this.renderer ? this.renderer.deleteRule(i.renderable) : !0);
  }, t.indexOf = function(r) {
    return this.rules.indexOf(r);
  }, t.deploy = function() {
    return this.renderer && this.renderer.deploy(), this.deployed = !0, this;
  }, t.update = function() {
    var r;
    return (r = this.rules).update.apply(r, arguments), this;
  }, t.updateOne = function(r, i, o) {
    return this.rules.updateOne(r, i, o), this;
  }, t.toString = function(r) {
    return this.rules.toString(r);
  }, e;
}(), Aet = /* @__PURE__ */ function() {
  function e() {
    this.plugins = {
      internal: [],
      external: []
    }, this.registry = {};
  }
  var t = e.prototype;
  return t.onCreateRule = function(r, i, o) {
    for (var a = 0; a < this.registry.onCreateRule.length; a++) {
      var s = this.registry.onCreateRule[a](r, i, o);
      if (s)
        return s;
    }
    return null;
  }, t.onProcessRule = function(r) {
    if (!r.isProcessed) {
      for (var i = r.options.sheet, o = 0; o < this.registry.onProcessRule.length; o++)
        this.registry.onProcessRule[o](r, i);
      r.style && this.onProcessStyle(r.style, r, i), r.isProcessed = !0;
    }
  }, t.onProcessStyle = function(r, i, o) {
    for (var a = 0; a < this.registry.onProcessStyle.length; a++)
      i.style = this.registry.onProcessStyle[a](i.style, i, o);
  }, t.onProcessSheet = function(r) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++)
      this.registry.onProcessSheet[i](r);
  }, t.onUpdate = function(r, i, o, a) {
    for (var s = 0; s < this.registry.onUpdate.length; s++)
      this.registry.onUpdate[s](r, i, o, a);
  }, t.onChangeValue = function(r, i, o) {
    for (var a = r, s = 0; s < this.registry.onChangeValue.length; s++)
      a = this.registry.onChangeValue[s](a, i, o);
    return a;
  }, t.use = function(r, i) {
    i === void 0 && (i = {
      queue: "external"
    });
    var o = this.plugins[i.queue];
    o.indexOf(r) === -1 && (o.push(r), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(a, s) {
      for (var u in s)
        u in a ? a[u].push(s[u]) : process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Unknown hook "' + u + '".');
      return a;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    }));
  }, e;
}(), Oet = /* @__PURE__ */ function() {
  function e() {
    this.registry = [];
  }
  var t = e.prototype;
  return t.add = function(r) {
    var i = this.registry, o = r.options.index;
    if (i.indexOf(r) === -1) {
      if (i.length === 0 || o >= this.index) {
        i.push(r);
        return;
      }
      for (var a = 0; a < i.length; a++)
        if (i[a].options.index > o) {
          i.splice(a, 0, r);
          return;
        }
    }
  }, t.reset = function() {
    this.registry = [];
  }, t.remove = function(r) {
    var i = this.registry.indexOf(r);
    this.registry.splice(i, 1);
  }, t.toString = function(r) {
    for (var i = r === void 0 ? {} : r, o = i.attached, a = dF(i, ["attached"]), s = oN(a), u = s.linebreak, l = "", f = 0; f < this.registry.length; f++) {
      var h = this.registry[f];
      o != null && h.attached !== o || (l && (l += u), l += h.toString(a));
    }
    return l;
  }, jxe(e, [{
    key: "index",
    /**
     * Current highest index number.
     */
    get: function() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]), e;
}(), MR = new Oet(), pq = typeof globalThis < "u" ? globalThis : typeof window < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), gq = "2f1acc6c3a606b082e5eef5e54414ffb";
pq[gq] == null && (pq[gq] = 0);
var vfe = pq[gq]++, Ret = 1e10, bfe = function(t) {
  t === void 0 && (t = {});
  var n = 0, r = function(o, a) {
    n += 1, n > Ret && process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] You might have a memory leak. Rule counter is at " + n + ".");
    var s = "", u = "";
    return a && (a.options.classNamePrefix && (u = a.options.classNamePrefix), a.options.jss.id != null && (s = String(a.options.jss.id))), t.minify ? "" + (u || "c") + vfe + s + n : u + o.key + "-" + vfe + (s ? "-" + s : "") + "-" + n;
  };
  return r;
}, Uxe = function(t) {
  var n;
  return function() {
    return n || (n = t()), n;
  };
}, ket = function(t, n) {
  try {
    return t.attributeStyleMap ? t.attributeStyleMap.get(n) : t.style.getPropertyValue(n);
  } catch {
    return "";
  }
}, $et = function(t, n, r) {
  try {
    var i = r;
    if (Array.isArray(r) && (i = SR(r)), t.attributeStyleMap)
      t.attributeStyleMap.set(n, i);
    else {
      var o = i ? i.indexOf("!important") : -1, a = o > -1 ? i.substr(0, o - 1) : i;
      t.style.setProperty(n, a, o > -1 ? "important" : "");
    }
  } catch {
    return !1;
  }
  return !0;
}, Pet = function(t, n) {
  try {
    t.attributeStyleMap ? t.attributeStyleMap.delete(n) : t.style.removeProperty(n);
  } catch (r) {
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] DOMException "' + r.message + '" was thrown. Tried to remove property "' + n + '".');
  }
}, Iet = function(t, n) {
  return t.selectorText = n, t.selectorText === n;
}, Yxe = Uxe(function() {
  return document.querySelector("head");
});
function jet(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    if (r.attached && r.options.index > t.index && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function Let(e, t) {
  for (var n = e.length - 1; n >= 0; n--) {
    var r = e[n];
    if (r.attached && r.options.insertionPoint === t.insertionPoint)
      return r;
  }
  return null;
}
function zet(e) {
  for (var t = Yxe(), n = 0; n < t.childNodes.length; n++) {
    var r = t.childNodes[n];
    if (r.nodeType === 8 && r.nodeValue.trim() === e)
      return r;
  }
  return null;
}
function Fet(e) {
  var t = MR.registry;
  if (t.length > 0) {
    var n = jet(t, e);
    if (n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element
      };
    if (n = Let(t, e), n && n.renderer)
      return {
        parent: n.renderer.element.parentNode,
        node: n.renderer.element.nextSibling
      };
  }
  var r = e.insertionPoint;
  if (r && typeof r == "string") {
    var i = zet(r);
    if (i)
      return {
        parent: i.parentNode,
        node: i.nextSibling
      };
    process.env.NODE_ENV !== "production" && Pn(!1, '[JSS] Insertion point "' + r + '" not found.');
  }
  return !1;
}
function Bet(e, t) {
  var n = t.insertionPoint, r = Fet(t);
  if (r !== !1 && r.parent) {
    r.parent.insertBefore(e, r.node);
    return;
  }
  if (n && typeof n.nodeType == "number") {
    var i = n, o = i.parentNode;
    o ? o.insertBefore(e, i.nextSibling) : process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] Insertion point is not in the DOM.");
    return;
  }
  Yxe().appendChild(e);
}
var Uet = Uxe(function() {
  var e = document.querySelector('meta[property="csp-nonce"]');
  return e ? e.getAttribute("content") : null;
}), xfe = function(t, n, r) {
  try {
    "insertRule" in t ? t.insertRule(n, r) : "appendRule" in t && t.appendRule(n);
  } catch (i) {
    return process.env.NODE_ENV !== "production" && Pn(!1, "[JSS] " + i.message), !1;
  }
  return t.cssRules[r];
}, wfe = function(t, n) {
  var r = t.cssRules.length;
  return n === void 0 || n > r ? r : n;
}, Yet = function() {
  var t = document.createElement("style");
  return t.textContent = `
`, t;
}, Het = /* @__PURE__ */ function() {
  function e(n) {
    this.getPropertyValue = ket, this.setProperty = $et, this.removeProperty = Pet, this.setSelector = Iet, this.hasInsertedRules = !1, this.cssRules = [], n && MR.add(n), this.sheet = n;
    var r = this.sheet ? this.sheet.options : {}, i = r.media, o = r.meta, a = r.element;
    this.element = a || Yet(), this.element.setAttribute("data-jss", ""), i && this.element.setAttribute("media", i), o && this.element.setAttribute("data-meta", o);
    var s = Uet();
    s && this.element.setAttribute("nonce", s);
  }
  var t = e.prototype;
  return t.attach = function() {
    if (!(this.element.parentNode || !this.sheet)) {
      Bet(this.element, this.sheet.options);
      var r = !!(this.sheet && this.sheet.deployed);
      this.hasInsertedRules && r && (this.hasInsertedRules = !1, this.deploy());
    }
  }, t.detach = function() {
    if (this.sheet) {
      var r = this.element.parentNode;
      r && r.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`);
    }
  }, t.deploy = function() {
    var r = this.sheet;
    if (r) {
      if (r.options.link) {
        this.insertRules(r.rules);
        return;
      }
      this.element.textContent = `
` + r.toString() + `
`;
    }
  }, t.insertRules = function(r, i) {
    for (var o = 0; o < r.index.length; o++)
      this.insertRule(r.index[o], o, i);
  }, t.insertRule = function(r, i, o) {
    if (o === void 0 && (o = this.element.sheet), r.rules) {
      var a = r, s = o;
      if (r.type === "conditional" || r.type === "keyframes") {
        var u = wfe(o, i);
        if (s = xfe(o, a.toString({
          children: !1
        }), u), s === !1)
          return !1;
        this.refCssRule(r, u, s);
      }
      return this.insertRules(a.rules, s), s;
    }
    var l = r.toString();
    if (!l)
      return !1;
    var f = wfe(o, i), h = xfe(o, l, f);
    return h === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(r, f, h), h);
  }, t.refCssRule = function(r, i, o) {
    r.renderable = o, r.options.parent instanceof Bxe && this.cssRules.splice(i, 0, o);
  }, t.deleteRule = function(r) {
    var i = this.element.sheet, o = this.indexOf(r);
    return o === -1 ? !1 : (i.deleteRule(o), this.cssRules.splice(o, 1), !0);
  }, t.indexOf = function(r) {
    return this.cssRules.indexOf(r);
  }, t.replaceRule = function(r, i) {
    var o = this.indexOf(r);
    return o === -1 ? !1 : (this.element.sheet.deleteRule(o), this.cssRules.splice(o, 1), this.insertRule(i, o));
  }, t.getRules = function() {
    return this.element.sheet.cssRules;
  }, e;
}(), Vet = 0, Wet = /* @__PURE__ */ function() {
  function e(n) {
    this.id = Vet++, this.version = "10.10.0", this.plugins = new Aet(), this.options = {
      id: {
        minify: !1
      },
      createGenerateId: bfe,
      Renderer: bb ? Het : null,
      plugins: []
    }, this.generateId = bfe({
      minify: !1
    });
    for (var r = 0; r < mfe.length; r++)
      this.plugins.use(mfe[r], {
        queue: "internal"
      });
    this.setup(n);
  }
  var t = e.prototype;
  return t.setup = function(r) {
    return r === void 0 && (r = {}), r.createGenerateId && (this.options.createGenerateId = r.createGenerateId), r.id && (this.options.id = Ya({}, this.options.id, r.id)), (r.createGenerateId || r.id) && (this.generateId = this.options.createGenerateId(this.options.id)), r.insertionPoint != null && (this.options.insertionPoint = r.insertionPoint), "Renderer" in r && (this.options.Renderer = r.Renderer), r.plugins && this.use.apply(this, r.plugins), this;
  }, t.createStyleSheet = function(r, i) {
    i === void 0 && (i = {});
    var o = i, a = o.index;
    typeof a != "number" && (a = MR.index === 0 ? 0 : MR.index + 1);
    var s = new Bxe(r, Ya({}, i, {
      jss: this,
      generateId: i.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: a
    }));
    return this.plugins.onProcessSheet(s), s;
  }, t.removeStyleSheet = function(r) {
    return r.detach(), MR.remove(r), this;
  }, t.createRule = function(r, i, o) {
    if (i === void 0 && (i = {}), o === void 0 && (o = {}), typeof r == "object")
      return this.createRule(void 0, r, i);
    var a = Ya({}, o, {
      name: r,
      jss: this,
      Renderer: this.options.Renderer
    });
    a.generateId || (a.generateId = this.generateId), a.classes || (a.classes = {}), a.keyframes || (a.keyframes = {});
    var s = zxe(r, i, a);
    return s && this.plugins.onProcessRule(s), s;
  }, t.use = function() {
    for (var r = this, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return o.forEach(function(s) {
      r.plugins.use(s);
    }), this;
  }, e;
}(), AK = function(t) {
  return new Wet(t);
};
function Hxe(e) {
  var t = null;
  for (var n in e) {
    var r = e[n], i = typeof r;
    if (i === "function")
      t || (t = {}), t[n] = r;
    else if (i === "object" && r !== null && !Array.isArray(r)) {
      var o = Hxe(r);
      o && (t || (t = {}), t[n] = o);
    }
  }
  return t;
}
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
AK();
function Vxe(e = {}) {
  const {
    baseClasses: t,
    newClasses: n,
    Component: r
  } = e;
  if (!n)
    return t;
  const i = Ya({}, t);
  return process.env.NODE_ENV !== "production" && typeof n == "string" ? (console.error([`MUI: The value \`${n}\` provided to the classes prop of ${_Y(r)} is incorrect.`, "You might want to use the className prop instead."].join(`
`)), t) : (Object.keys(n).forEach((o) => {
    process.env.NODE_ENV !== "production" && (!t[o] && n[o] && console.error([`MUI: The key \`${o}\` provided to the classes prop is not implemented in ${_Y(r)}.`, `You can only override one of the following: ${Object.keys(t).join(",")}.`].join(`
`)), n[o] && typeof n[o] != "string" && console.error([`MUI: The key \`${o}\` provided to the classes prop is not valid for ${_Y(r)}.`, `You need to provide a non empty string instead of: ${n[o]}.`].join(`
`))), n[o] && (i[o] = `${t[o]} ${n[o]}`);
  }), i);
}
const qet = {
  set: (e, t, n, r) => {
    let i = e.get(t);
    i || (i = /* @__PURE__ */ new Map(), e.set(t, i)), i.set(n, r);
  },
  get: (e, t, n) => {
    const r = e.get(t);
    return r ? r.get(n) : void 0;
  },
  delete: (e, t, n) => {
    e.get(t).delete(n);
  }
}, cT = qet;
function Get() {
  var e;
  const t = UQe();
  return (e = t == null ? void 0 : t.$$material) != null ? e : t;
}
const Qet = ["children", "injectFirst", "disableGeneration"], Xet = AK(Ixe()), Ket = WQe(), Zet = /* @__PURE__ */ new Map(), Jet = {
  disableGeneration: !1,
  generateClassName: Ket,
  jss: Xet,
  sheetsCache: null,
  sheetsManager: Zet,
  sheetsRegistry: null
}, Qj = /* @__PURE__ */ ae.createContext(Jet);
process.env.NODE_ENV !== "production" && (Qj.displayName = "StylesContext");
let $I;
function mq(e) {
  const {
    children: t,
    injectFirst: n = !1,
    disableGeneration: r = !1
  } = e, i = dF(e, Qet), o = ae.useContext(Qj), {
    generateClassName: a,
    jss: s,
    serverGenerateClassName: u,
    sheetsCache: l,
    sheetsManager: f,
    sheetsRegistry: h
  } = Ya({}, o, i);
  process.env.NODE_ENV !== "production" && n && i.jss && console.error("MUI: You cannot use the jss and injectFirst props at the same time.");
  const p = ae.useMemo(() => {
    const g = {
      disableGeneration: r,
      generateClassName: a,
      jss: s,
      serverGenerateClassName: u,
      sheetsCache: l,
      sheetsManager: f,
      sheetsRegistry: h
    };
    if (process.env.NODE_ENV !== "production" && typeof window > "u" && !g.sheetsManager && console.error("MUI: You need to use the ServerStyleSheets API when rendering on the server."), process.env.NODE_ENV !== "production" && g.jss.options.insertionPoint && n && console.error("MUI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time."), !g.jss.options.insertionPoint && n && typeof window < "u") {
      if (!$I) {
        const y = document.head;
        $I = document.createComment("mui-inject-first"), y.insertBefore($I, y.firstChild);
      }
      g.jss = AK({
        plugins: Ixe().plugins,
        insertionPoint: $I
      });
    }
    return g;
  }, [n, r, a, s, u, l, f, h]);
  return /* @__PURE__ */ pe.jsx(Qj.Provider, {
    value: p,
    children: t
  });
}
process.env.NODE_ENV !== "production" && (mq.propTypes = {
  /**
   * Your component tree.
   */
  children: N.node,
  /**
   * You can disable the generation of the styles with this option.
   * It can be useful when traversing the React tree outside of the HTML
   * rendering step on the server.
   * Let's say you are using react-apollo to extract all
   * the queries made by the interface server-side - you can significantly speed up the traversal with this prop.
   */
  disableGeneration: N.bool,
  /**
   * JSS's class name generator.
   */
  generateClassName: N.func,
  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: N.bool,
  /**
   * JSS's instance.
   */
  jss: N.object,
  /**
   * @ignore
   */
  serverGenerateClassName: N.func,
  /**
   * @ignore
   *
   * Beta feature.
   *
   * Cache for the sheets.
   */
  sheetsCache: N.object,
  /**
   * @ignore
   *
   * The sheetsManager is used to deduplicate style sheet injection in the page.
   * It's deduplicating using the (theme, styles) couple.
   * On the server, you should provide a new instance for each request.
   */
  sheetsManager: N.object,
  /**
   * @ignore
   *
   * Collect the sheets.
   */
  sheetsRegistry: N.object
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (mq.propTypes = jQe(mq.propTypes));
let UY = -1e9;
function ett() {
  return UY += 1, process.env.NODE_ENV !== "production" && UY >= 0 && console.warn(["MUI: You might have a memory leak.", "The indexCounter is not supposed to grow that much."].join(`
`)), UY;
}
const ttt = ["variant"];
function _fe(e) {
  return e.length === 0;
}
function ntt(e) {
  const {
    variant: t
  } = e, n = dF(e, ttt);
  let r = t || "";
  return Object.keys(n).sort().forEach((i) => {
    i === "color" ? r += _fe(r) ? e[i] : EY(e[i]) : r += `${_fe(r) ? i : EY(i)}${EY(e[i].toString())}`;
  }), r;
}
const rtt = {}, Wxe = rtt;
function itt(e) {
  const t = typeof e == "function";
  return process.env.NODE_ENV !== "production" && typeof e != "object" && !t && console.error(["MUI: The `styles` argument provided is invalid.", "You need to provide a function generating the styles or a styles object."].join(`
`)), {
    create: (n, r) => {
      let i;
      try {
        i = t ? e(n) : e;
      } catch (u) {
        throw process.env.NODE_ENV !== "production" && t === !0 && n === Wxe && console.error(["MUI: The `styles` argument provided is invalid.", "You are providing a function without a theme in the context.", "One of the parent elements needs to use a ThemeProvider."].join(`
`)), u;
      }
      if (!r || !n.components || !n.components[r] || !n.components[r].styleOverrides && !n.components[r].variants)
        return i;
      const o = n.components[r].styleOverrides || {}, a = n.components[r].variants || [], s = Ya({}, i);
      return Object.keys(o).forEach((u) => {
        process.env.NODE_ENV !== "production" && (s[u] || console.warn(["MUI: You are trying to override a style that does not exist.", `Fix the \`${u}\` key of \`theme.components.${r}.styleOverrides\`.`, "", `If you intentionally wanted to add a new key, please use the theme.components[${r}].variants option.`].join(`
`))), s[u] = AW(s[u] || {}, o[u]);
      }), a.forEach((u) => {
        const l = ntt(u.props);
        s[l] = AW(s[l] || {}, u.style);
      }), s;
    },
    options: {}
  };
}
const ott = ["name", "classNamePrefix", "Component", "defaultTheme"];
function att({
  state: e,
  stylesOptions: t
}, n, r) {
  if (t.disableGeneration)
    return n || {};
  e.cacheClasses || (e.cacheClasses = {
    // Cache for the finalized classes value.
    value: null,
    // Cache for the last used classes prop pointer.
    lastProp: null,
    // Cache for the last used rendered classes pointer.
    lastJSS: {}
  });
  let i = !1;
  return e.classes !== e.cacheClasses.lastJSS && (e.cacheClasses.lastJSS = e.classes, i = !0), n !== e.cacheClasses.lastProp && (e.cacheClasses.lastProp = n, i = !0), i && (e.cacheClasses.value = Vxe({
    baseClasses: e.cacheClasses.lastJSS,
    newClasses: n,
    Component: r
  })), e.cacheClasses.value;
}
function stt({
  state: e,
  theme: t,
  stylesOptions: n,
  stylesCreator: r,
  name: i
}, o) {
  if (n.disableGeneration)
    return;
  let a = cT.get(n.sheetsManager, r, t);
  a || (a = {
    refs: 0,
    staticSheet: null,
    dynamicStyles: null
  }, cT.set(n.sheetsManager, r, t, a));
  const s = Ya({}, r.options, n, {
    theme: t,
    flip: typeof n.flip == "boolean" ? n.flip : t.direction === "rtl"
  });
  s.generateId = s.serverGenerateClassName || s.generateClassName;
  const u = n.sheetsRegistry;
  if (a.refs === 0) {
    let l;
    n.sheetsCache && (l = cT.get(n.sheetsCache, r, t));
    const f = r.create(t, i);
    l || (l = n.jss.createStyleSheet(f, Ya({
      link: !1
    }, s)), l.attach(), n.sheetsCache && cT.set(n.sheetsCache, r, t, l)), u && u.add(l), a.staticSheet = l, a.dynamicStyles = Hxe(f);
  }
  if (a.dynamicStyles) {
    const l = n.jss.createStyleSheet(a.dynamicStyles, Ya({
      link: !0
    }, s));
    l.update(o), l.attach(), e.dynamicSheet = l, e.classes = Vxe({
      baseClasses: a.staticSheet.classes,
      newClasses: l.classes
    }), u && u.add(l);
  } else
    e.classes = a.staticSheet.classes;
  a.refs += 1;
}
function utt({
  state: e
}, t) {
  e.dynamicSheet && e.dynamicSheet.update(t);
}
function ltt({
  state: e,
  theme: t,
  stylesOptions: n,
  stylesCreator: r
}) {
  if (n.disableGeneration)
    return;
  const i = cT.get(n.sheetsManager, r, t);
  i.refs -= 1;
  const o = n.sheetsRegistry;
  i.refs === 0 && (cT.delete(n.sheetsManager, r, t), n.jss.removeStyleSheet(i.staticSheet), o && o.remove(i.staticSheet)), e.dynamicSheet && (n.jss.removeStyleSheet(e.dynamicSheet), o && o.remove(e.dynamicSheet));
}
function ctt(e, t) {
  const n = ae.useRef([]);
  let r;
  const i = ae.useMemo(() => ({}), t);
  n.current !== i && (n.current = i, r = e()), ae.useEffect(
    () => () => {
      r && r();
    },
    [i]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
}
function ftt(e, t = {}) {
  const {
    // alias for classNamePrefix, if provided will listen to theme (required for theme.components[name].styleOverrides)
    name: n,
    // Help with debuggability.
    classNamePrefix: r,
    Component: i,
    defaultTheme: o = Wxe
  } = t, a = dF(t, ott), s = itt(e), u = n || r || "makeStyles";
  return s.options = {
    index: ett(),
    name: n,
    meta: u,
    classNamePrefix: u
  }, (f = {}) => {
    const h = Get() || o, p = Ya({}, ae.useContext(Qj), a), g = ae.useRef(), y = ae.useRef();
    ctt(() => {
      const _ = {
        name: n,
        state: {},
        stylesCreator: s,
        stylesOptions: p,
        theme: h
      };
      return stt(_, f), y.current = !1, g.current = _, () => {
        ltt(_);
      };
    }, [h, s]), ae.useEffect(() => {
      y.current && utt(g.current, f), y.current = !0;
    });
    const b = att(g.current, f.classes, i);
    return process.env.NODE_ENV !== "production" && ae.useDebugValue(b), process.env.NODE_ENV !== "production" && n && ["MuiAvatar", "MuiBadge", "MuiButton", "MuiButtonGroup", "MuiChip", "MuiDivider", "MuiFab", "MuiPaper", "MuiToolbar", "MuiTypography", "MuiAlert", "MuiPagination", "MuiPaginationItem", "MuiSkeleton", "MuiTimelineDot"].indexOf(n) >= 0 && f.variant && !b[f.variant] && console.error([`MUI: You are using a variant value \`${f.variant}\` for which you didn't define styles.`, "Please create a new variant matcher in your theme for this variant. To learn more about matchers visit https://mui.com/r/custom-component-variants."].join(`
`)), b;
  };
}
const dtt = ftt({
  customTableContainer: {
    overflowX: "initial"
  }
}), htt = ({ content: e, setQueryString: t, style: n = {} }) => {
  const r = ae.useContext(tv), i = ar.get(e, "pagination.defaultPageSize") || Uze, o = ar.get(e, "pagination.pageSizeSelection") || Yze, a = ar.get(
    e,
    "dimensions[0].namespace",
    ""
  ), s = ar.get(
    r,
    `${a}.records` || []
  ), u = s && AWe(s, e), [l, f] = ae.useState(0), [h, p] = ae.useState(i), [g, y] = ae.useState(EI), [b, _] = ae.useState(""), [S, C] = ae.useState(s), A = dtt(), O = (ee) => {
    const K = ar.orderBy(s, [ee], g);
    C(K);
  }, R = (ee) => {
    y(g === EI ? Fze : EI), _(ee), O(ee);
  }, j = (ee, K) => {
    f(K);
  }, $ = (ee) => {
    p(+ee.target.value), f(0);
  }, z = (ee) => {
    t(ee);
  }, W = s && S && S.length && u && u.length, Y = () => {
    let ee = "", K = ar.get(e, ["metrics", 0, "namespace"]);
    K && (K = K.split("."), ee = K[K.length - 1]);
    let Q = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    ptt(ee.concat("-", Q), S);
  }, V = () => e.settings && e.settings.dataExport;
  return /* @__PURE__ */ pe.jsx("div", { children: W ? /* @__PURE__ */ pe.jsxs("div", { id: "dataGrid", className: IA.dataGrid, children: [
    /* @__PURE__ */ pe.jsx(JS, { contentTitle: e.title, style: n }),
    /* @__PURE__ */ pe.jsx(jVe, { classes: { root: A.customTableContainer }, children: /* @__PURE__ */ pe.jsxs(Zbe, { stickyHeader: !0, "aria-label": "sticky table", children: [
      /* @__PURE__ */ pe.jsx(a1e, { id: "tableHead", children: /* @__PURE__ */ pe.jsx(xW, { children: u.map((ee, K) => /* @__PURE__ */ pe.jsx(
        eC,
        {
          align: iue,
          sx: {
            ...kze,
            minWidth: ar.get(ee, "style.minWidth", "") || ee.minColumnWidth,
            wordBreak: ar.get(ee, "style.wordBreak", "")
          },
          onClick: () => ee.isSortingEnabled && //@ts-ignore
          R(ee.id),
          sortDirection: g,
          children: ee.isSortingEnabled ? /* @__PURE__ */ pe.jsx(
            NWe,
            {
              active: b === ee.id,
              direction: g || EI,
              children: ee.label
            }
          ) : ee.label
        },
        `${ee.id}${K}`
      )) }) }),
      /* @__PURE__ */ pe.jsx(t1e, { id: "tableBody", children: S.slice(l * h, l * h + h).map((ee, K) => /* @__PURE__ */ pe.jsx(xW, { tabIndex: -1, children: u.map((Q, q) => {
        const te = ar.get(
          e,
          `dimensions[${q}].url_path`,
          ""
        ), X = ee[te], Z = ee[Q.id], se = Number(Q.max) > 0 && Q.indicatorType === zze ? {
          background: Q.indicatorColor,
          //@ts-ignore
          width: `${Z / Q.max * 95}%`,
          borderRadius: "2px"
        } : {};
        return /* @__PURE__ */ pe.jsx(
          eC,
          {
            align: iue,
            sx: {
              ...$ze
            },
            children: typeof Z === _X ? /* @__PURE__ */ pe.jsx(
              "div",
              {
                style: {
                  ...se
                },
                className: IA.tableNumberCell,
                children: sK(Number(Z))
              }
            ) : (
              //otherwise apply general styling
              /* @__PURE__ */ pe.jsx(
                "div",
                {
                  style: {
                    wordBreak: ar.get(
                      Q,
                      "style.wordBreak",
                      "break-all"
                    )
                  },
                  className: IA.tableCell,
                  onClick: () => X && z(X),
                  children: X ? /* @__PURE__ */ pe.jsx(
                    mK,
                    {
                      to: X,
                      className: IA.urlStyling,
                      children: Z
                    }
                  ) : (
                    // otherwise render value as is
                    Z
                  )
                }
              )
            )
          },
          `${Q.id}${q}`
        );
      }) }, K)) })
    ] }) }),
    /* @__PURE__ */ pe.jsxs(lY, { container: !0, justifyContent: "space-between", alignItems: "center", children: [
      /* @__PURE__ */ pe.jsx(lY, { children: s.length > i && /* @__PURE__ */ pe.jsx(
        gWe,
        {
          id: "tablePagination",
          rowsPerPageOptions: o,
          component: "div",
          count: s.length,
          rowsPerPage: h,
          page: l,
          onPageChange: j,
          onRowsPerPageChange: $,
          sx: {
            position: "sticky",
            top: "1000px",
            display: "flex",
            ".MuiTablePagination-toolbar": {
              paddingLeft: 0
            }
          }
        }
      ) }),
      /* @__PURE__ */ pe.jsx(lY, { children: /* @__PURE__ */ pe.jsx(
        hR,
        {
          alignItems: "right",
          sx: {
            position: "sticky",
            top: "1000px",
            display: "flex",
            ".MuiTablePagination-toolbar": {
              paddingLeft: "10px"
            }
          },
          children: V() && /* @__PURE__ */ pe.jsx(
            mW,
            {
              variant: "text",
              startIcon: /* @__PURE__ */ pe.jsx("img", { src: AQe, alt: "" }),
              onClick: Y,
              style: { textTransform: "none" },
              children: "Export Data"
            }
          )
        }
      ) })
    ] })
  ] }) : /* @__PURE__ */ pe.jsx("div", { className: IA.notAvailable, children: e0e }) });
};
function ptt(e, t) {
  let n = yK({ useKeysAsHeaders: !0, filename: e }), r = NQe(n)(t);
  DQe(n)(r);
}
function hF(e) {
  return Number(e) !== e;
}
function gtt(e) {
  return {}.toString.call(e);
}
function xd(e) {
  if (e != null && !Cn(e)) {
    let t = Number(e);
    return hF(t) && tC(e) && e != "" ? xd(e.replace(/[^0-9.\-]+/g, "")) : t;
  }
  return e;
}
function mtt(e) {
  if (yq(e))
    return new Date(e);
  if (Cn(e))
    return new Date(e);
  {
    let t = Number(e);
    return Cn(t) ? new Date(t) : new Date(e);
  }
}
function ytt(e) {
  if (hF(e))
    return "NaN";
  if (e === 1 / 0)
    return "Infinity";
  if (e === -1 / 0)
    return "-Infinity";
  if (e === 0 && 1 / e === -1 / 0)
    return "-0";
  let t = e < 0;
  e = Math.abs(e);
  let n = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + e), r = n[1], i = n[2] || "", o;
  if (n[3] === void 0)
    o = i === "" ? r : r + "." + i;
  else {
    let a = +n[3];
    if (e < 1) {
      let s = a - 1;
      o = "0." + Efe("0", s) + r + i;
    } else {
      let s = a - i.length;
      s === 0 ? o = r + i : s < 0 ? o = r + i.slice(0, s) + "." + i.slice(s) : o = r + i + Efe("0", s);
    }
  }
  return t ? "-" + o : o;
}
function Efe(e, t) {
  return new Array(t + 1).join(e);
}
function yq(e) {
  return gtt(e) === "[object Date]";
}
function tC(e) {
  return typeof e == "string";
}
function Cn(e) {
  return typeof e == "number" && Number(e) == e;
}
function pF(e) {
  return typeof e == "object" && e !== null;
}
const Wx = "__§§§__", fT = "__§§§§__";
function Xj(e, t) {
  const n = e.length;
  for (let r = 0; r < n; ++r)
    if (e[r] === t)
      return r;
  return -1;
}
function vtt(e, t) {
  const n = e.length;
  for (let r = 0; r < n; ++r)
    if (t(e[r]))
      return !0;
  return !1;
}
function vq(e, t) {
  const n = e.length, r = new Array(n);
  for (let i = 0; i < n; ++i)
    r[i] = t(e[i], i);
  return r;
}
function ut(e, t) {
  const n = e.length;
  for (let r = 0; r < n; ++r)
    t(e[r], r);
}
function TR(e, t) {
  let n = e.length;
  for (; n > 0; )
    --n, t(e[n], n);
}
function qxe(e, t) {
  const n = e.length;
  for (let r = 0; r < n && t(e[r], r); ++r)
    ;
}
function mx(e, t) {
  let n = !1, r = 0;
  for (; ; ) {
    if (r = e.indexOf(t, r), r === -1)
      return n;
    n = !0, e.splice(r, 1);
  }
}
function Md(e, t) {
  let n = e.indexOf(t);
  return n !== -1 ? (e.splice(n, 1), !0) : !1;
}
function mk(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function btt(e) {
  const t = e.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = e[r];
  return n;
}
function YY(e, t, n) {
  e.splice(t, 0, n);
}
function Sfe(e, t) {
  e.splice(t, 1);
}
function Gxe(e, t) {
  const n = e.length;
  for (let r = 0; r < n; ++r)
    if (t(e[r], r))
      return r;
  return -1;
}
function xtt(e, t) {
  let n = e.length;
  for (; n > 0; )
    if (--n, t(e[n], n))
      return n;
  return -1;
}
function Qxe(e, t) {
  const n = Gxe(e, t);
  if (n !== -1)
    return e[n];
}
function wtt(e, t) {
  const n = xtt(e, t);
  if (n !== -1)
    return e[n];
}
function _tt(e, t) {
  let n = 0, r = e.length, i = !1;
  for (; n < r; ) {
    const o = n + r >> 1, a = t(e[o]);
    a < 0 ? n = o + 1 : a === 0 ? (i = !0, n = o + 1) : r = o;
  }
  return {
    found: i,
    index: i ? n - 1 : n
  };
}
function Ett(e, t) {
  let n = 0, r = e.length, i = !1;
  for (; n < r; ) {
    const o = n + r >> 1, a = t(e[o]);
    a < 0 ? n = o + 1 : (a === 0 && (i = !0), r = o);
  }
  return {
    found: i,
    index: n
  };
}
function gF(e, t) {
  let n = e.length;
  for (; n > 0; )
    --n, t(e[n]) || e.splice(n, 1);
}
class OK {
  /**
   * Constructor.
   */
  constructor() {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Bs {
  /**
   * Constructor.
   *
   * @param dispose  Function that disposes object
   */
  constructor(t) {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1, this._dispose = t;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Stt extends OK {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _dispose() {
    ut(this._disposers, (t) => {
      t.dispose();
    });
  }
}
class wd extends OK {
  constructor(t) {
    super(), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposers = t;
  }
  _dispose() {
    ut(this._disposers, (t) => {
      t.dispose();
    });
  }
  get disposers() {
    return this._disposers;
  }
}
class Xxe extends Bs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_counter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  /**
   * [increment description]
   *
   * @todo Description
   */
  increment() {
    return ++this._counter, new Bs(() => {
      --this._counter, this._counter === 0 && this.dispose();
    });
  }
}
class aN {
  /**
   * Constructor
   */
  constructor() {
    Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_killed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_iterating", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_enabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._listeners = [], this._killed = [], this._disabled = {}, this._iterating = 0, this._enabled = !0, this._disposed = !1;
  }
  /**
   * Returns if this object has been already disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Dispose (destroy) this object.
   */
  dispose() {
    if (!this._disposed) {
      this._disposed = !0;
      const t = this._listeners;
      this._iterating = 1, this._listeners = null, this._disabled = null;
      try {
        ut(t, (n) => {
          n.disposer.dispose();
        });
      } finally {
        this._killed = null, this._iterating = null;
      }
    }
  }
  /**
   * Checks if this particular event dispatcher has any listeners set.
   *
   * @return Has listeners?
   */
  hasListeners() {
    return this._listeners.length !== 0;
  }
  /**
   * Checks if this particular event dispatcher has any particular listeners set.
   *
   * @return Has particular event listeners?
   */
  hasListenersByType(t) {
    return vtt(this._listeners, (n) => (n.type === null || n.type === t) && !n.killed);
  }
  /**
   * Enable dispatching of events if they were previously disabled by
   * `disable()`.
   */
  enable() {
    this._enabled = !0;
  }
  /**
   * Disable dispatching of events until re-enabled by `enable()`.
   */
  disable() {
    this._enabled = !1;
  }
  /**
   * Enable dispatching particular event, if it was disabled before by
   * `disableType()`.
   *
   * @param type Event type
   */
  enableType(t) {
    delete this._disabled[t];
  }
  /**
   * Disable dispatching of events for a certain event type.
   *
   * Optionally, can set how many dispatches to skip before automatically
   * re-enabling the dispatching.
   *
   * @param type    Event type
   * @param amount  Number of event dispatches to skip
   */
  disableType(t, n = 1 / 0) {
    this._disabled[t] = n;
  }
  /**
   * Removes listener from dispatcher.
   *
   * Will throw an exception if such listener does not exists.
   *
   * @param listener Listener to remove
   */
  _removeListener(t) {
    if (this._iterating === 0) {
      const n = this._listeners.indexOf(t);
      if (n === -1)
        throw new Error("Invalid state: could not remove listener");
      this._listeners.splice(n, 1);
    } else
      this._killed.push(t);
  }
  /**
   * Removes existing listener by certain parameters.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  _removeExistingListener(t, n, r, i) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((o) => {
      o.once === t && // TODO is this correct ?
      o.type === n && (r === void 0 || o.callback === r) && o.context === i && o.disposer.dispose();
    });
  }
  /**
   * Checks if dispatching for particular event type is enabled.
   *
   * @param type  Event type
   * @return Enabled?
   */
  isEnabled(t) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(t) && this._disabled[t] === void 0;
  }
  /**
   * Removes all listeners of a particular event type
   *
   * @param type  Listener's type
   */
  removeType(t) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((n) => {
      n.type === t && n.disposer.dispose();
    });
  }
  /**
   * Checks if there's already a listener with specific parameters.
   *
   * @param type      Listener's type
   * @param callback  Callback function
   * @param context   Callback context
   * @return Has listener?
   */
  has(t, n, r) {
    return Gxe(this._listeners, (o) => o.once !== !0 && // Ignoring "once" listeners
    o.type === t && (n === void 0 || o.callback === n) && o.context === r) !== -1;
  }
  /**
   * Checks whether event of the particular type should be dispatched.
   *
   * @param type  Event type
   * @return Dispatch?
   */
  _shouldDispatch(t) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    const n = this._disabled[t];
    return Cn(n) ? (n <= 1 ? delete this._disabled[t] : --this._disabled[t], !1) : this._enabled;
  }
  /**
   * [_eachListener description]
   *
   * All of this extra code is needed when a listener is removed while iterating
   *
   * @todo Description
   * @param fn [description]
   */
  _eachListener(t) {
    ++this._iterating;
    try {
      ut(this._listeners, t);
    } finally {
      --this._iterating, this._iterating === 0 && this._killed.length !== 0 && (ut(this._killed, (n) => {
        this._removeListener(n);
      }), this._killed.length = 0);
    }
  }
  /**
   * Dispatches an event immediately without waiting for next cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  dispatch(t, n) {
    this._shouldDispatch(t) && this._eachListener((r) => {
      !r.killed && (r.type === null || r.type === t) && r.dispatch(t, n);
    });
  }
  /**
   * Shelves the event to be dispatched within next update cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
      if (this._shouldDispatch(type)) {
          this._eachListener((listener) => {
              // TODO check if it's faster to use an object of listeners rather than a single big array
              if (!listener.killed && (listener.type === null || listener.type === type)) {
                  // TODO if the function throws, maybe it should keep going ?
                  // TODO dispatch during the update cycle, rather than using whenIdle
                  $async.whenIdle(() => {
                      if (!listener.killed) {
                          listener.dispatch(type, event);
                      }
                  });
              }
          });
      }
  }*/
  /**
   * Creates, catalogs and returns an [[EventListener]].
   *
   * Event listener can be disposed.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @param dispatch
   * @returns An event listener
   */
  _on(t, n, r, i, o, a) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._removeExistingListener(t, n, r, i);
    const s = {
      type: n,
      callback: r,
      context: i,
      shouldClone: o,
      dispatch: a,
      killed: !1,
      once: t,
      disposer: new Bs(() => {
        s.killed = !0, this._removeListener(s);
      })
    };
    return this._listeners.push(s), s;
  }
  /**
   * Creates an event listener to be invoked on **any** event.
   *
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  onAll(t, n, r = !0) {
    return this._on(!1, null, t, n, r, (i, o) => t.call(n, o)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler whenever series we put
   * event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  on(t, n, r, i = !0) {
    return this._on(!1, t, n, r, i, (o, a) => n.call(r, a)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type once.
   *
   * Once the event listener is invoked, it is automatically disposed.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler the first time series we
   * put event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  once(t, n, r, i = !0) {
    const o = this._on(!0, t, n, r, i, (a, s) => {
      o.disposer.dispose(), n.call(r, s);
    });
    return o.disposer;
  }
  /**
   * Removes the event listener with specific parameters.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  off(t, n, r) {
    this._removeExistingListener(!1, t, n, r);
  }
  /**
   * Copies all dispatcher parameters, including listeners, from another event
   * dispatcher.
   *
   * @param source Source event dispatcher
   * @ignore
   */
  copyFrom(t) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    if (t === this)
      throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
    const n = [];
    return ut(t._listeners, (r) => {
      !r.killed && r.shouldClone && (r.type === null ? n.push(this.onAll(r.callback, r.context)) : r.once ? n.push(this.once(r.type, r.callback, r.context)) : n.push(this.on(r.type, r.callback, r.context)));
    }), new wd(n);
  }
}
function UA(e, t) {
  if (!(e >= 0 && e < t))
    throw new Error("Index out of bounds: " + e);
}
class mF {
  /**
   * Constructor
   *
   * @param initial  Inital list of values to add to list
   */
  constructor(t = []) {
    Object.defineProperty(this, "_values", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new aN()
    }), this._values = t;
  }
  /**
   * An array of values in the list.
   *
   * Do not use this property to add values. Rather use dedicated methods, like
   * `push()`, `removeIndex()`, etc.
   *
   * @readonly
   * @return List values
   */
  get values() {
    return this._values;
  }
  /**
   * Checks if list contains specific item reference.
   *
   * @param item  Item to search for
   * @return `true` if found, `false` if not found
   */
  contains(t) {
    return this._values.indexOf(t) !== -1;
  }
  /**
   * Removes specific item from the list.
   *
   * @param item An item to remove
   */
  removeValue(t) {
    let n = 0, r = this._values.length;
    for (; n < r; )
      this._values[n] === t ? (this.removeIndex(n), --r) : ++n;
  }
  /**
   * Searches the list for specific item and returns its index.
   *
   * @param item  An item to search for
   * @return Index or -1 if not found
   */
  indexOf(t) {
    return Xj(this._values, t);
  }
  /**
   * Number of items in list.
   *
   * @readonly
   * @return Number of items
   */
  get length() {
    return this._values.length;
  }
  /**
   * Checks if there's a value at specific index.
   *
   * @param index  Index
   * @return Value exists?
   */
  hasIndex(t) {
    return t >= 0 && t < this._values.length;
  }
  /**
   * Returns an item at specified index.
   *
   * @param index  Index
   * @return List item
   */
  getIndex(t) {
    return this._values[t];
  }
  _onPush(t) {
    this.events.isEnabled("push") && this.events.dispatch("push", {
      type: "push",
      target: this,
      newValue: t
    });
  }
  _onInsertIndex(t, n) {
    this.events.isEnabled("insertIndex") && this.events.dispatch("insertIndex", {
      type: "insertIndex",
      target: this,
      index: t,
      newValue: n
    });
  }
  _onSetIndex(t, n, r) {
    this.events.isEnabled("setIndex") && this.events.dispatch("setIndex", {
      type: "setIndex",
      target: this,
      index: t,
      oldValue: n,
      newValue: r
    });
  }
  _onRemoveIndex(t, n) {
    this.events.isEnabled("removeIndex") && this.events.dispatch("removeIndex", {
      type: "removeIndex",
      target: this,
      index: t,
      oldValue: n
    });
  }
  _onMoveIndex(t, n, r) {
    this.events.isEnabled("moveIndex") && this.events.dispatch("moveIndex", {
      type: "moveIndex",
      target: this,
      oldIndex: t,
      newIndex: n,
      value: r
    });
  }
  _onClear(t) {
    this.events.isEnabled("clear") && this.events.dispatch("clear", {
      type: "clear",
      target: this,
      oldValues: t
    });
  }
  /**
   * Sets value at specific index.
   *
   * If there's already a value at the index, it is overwritten.
   *
   * @param index  Index
   * @param value  New value
   * @return New value
   */
  setIndex(t, n) {
    UA(t, this._values.length);
    const r = this._values[t];
    return r !== n && (this._values[t] = n, this._onSetIndex(t, r, n)), r;
  }
  /**
   * Adds an item to the list at a specific index, which pushes all the other
   * items further down the list.
   *
   * @param index Index
   * @param item  An item to add
   */
  insertIndex(t, n) {
    return UA(t, this._values.length + 1), YY(this._values, t, n), this._onInsertIndex(t, n), n;
  }
  /**
   * Swaps indexes of two items in the list.
   *
   * @param a  Item 1
   * @param b  Item 2
   */
  swap(t, n) {
    const r = this._values.length;
    if (UA(t, r), UA(n, r), t !== n) {
      const i = this._values[t], o = this._values[n];
      this._values[t] = o, this._onSetIndex(t, i, o), this._values[n] = i, this._onSetIndex(n, o, i);
    }
  }
  /**
   * Removes a value at specific index.
   *
   * @param index  Index of value to remove
   * @return Removed value
   */
  removeIndex(t) {
    UA(t, this._values.length);
    const n = this._values[t];
    return Sfe(this._values, t), this._onRemoveIndex(t, n), n;
  }
  /**
   * Moves an item to a specific index within the list.
   *
   * If the index is not specified it will move the item to the end of the
   * list.
   *
   * @param value  Item to move
   * @param index  Index to place item at
   */
  moveValue(t, n) {
    let r = this.indexOf(t);
    if (r !== -1)
      if (Sfe(this._values, r), n == null) {
        const i = this._values.length;
        this._values.push(t), this._onMoveIndex(r, i, t);
      } else
        YY(this._values, n, t), this._onMoveIndex(r, n, t);
    else
      n == null ? (this._values.push(t), this._onPush(t)) : (YY(this._values, n, t), this._onInsertIndex(n, t));
    return t;
  }
  /**
   * Adds an item to the end of the list.
   *
   * @param item  An item to add
   */
  push(t) {
    return this._values.push(t), this._onPush(t), t;
  }
  /**
   * Adds an item as a first item in the list.
   *
   * @param item  An item to add
   */
  unshift(t) {
    return this.insertIndex(0, t), t;
  }
  /**
   * Adds multiple items to the list.
   *
   * @param items  An Array of items to add
   */
  pushAll(t) {
    ut(t, (n) => {
      this.push(n);
    });
  }
  /**
   * Copies and adds items from abother list.
   *
   * @param source  A list top copy items from
   */
  copyFrom(t) {
    this.pushAll(t._values);
  }
  /**
   * Returns the last item from the list, and removes it.
   *
   * @return Item
   */
  pop() {
    return this._values.length - 1 < 0 ? void 0 : this.removeIndex(this._values.length - 1);
  }
  /**
   * Returns the first item from the list, and removes it.
   *
   * @return Item
   */
  shift() {
    return this._values.length ? this.removeIndex(0) : void 0;
  }
  /**
   * Sets multiple items to the list.
   *
   * All current items are removed.
   *
   * @param newArray  New items
   */
  setAll(t) {
    const n = this._values;
    this._values = [], this._onClear(n), ut(t, (r) => {
      this._values.push(r), this._onPush(r);
    });
  }
  /**
   * Removes all items from the list.
   */
  clear() {
    this.setAll([]);
  }
  /**
   * Returns an ES6 iterator for the list.
   */
  *[Symbol.iterator]() {
    const t = this._values.length;
    for (let n = 0; n < t; ++n)
      yield this._values[n];
  }
  /**
   * Calls `f` for each element in the list.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  each(t) {
    ut(this._values, t);
  }
  /**
   * Calls `f` for each element in the list, from right to left.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  eachReverse(t) {
    TR(this._values, t);
  }
}
class Mtt extends mF {
  constructor() {
    super(...arguments), Object.defineProperty(this, "autoDispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _onSetIndex(t, n, r) {
    this.autoDispose && n.dispose(), super._onSetIndex(t, n, r);
  }
  _onRemoveIndex(t, n) {
    this.autoDispose && n.dispose(), super._onRemoveIndex(t, n);
  }
  _onClear(t) {
    this.autoDispose && ut(t, (n) => {
      n.dispose();
    }), super._onClear(t);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this.autoDispose && ut(this._values, (t) => {
      t.dispose();
    }));
  }
}
class Ttt extends Mtt {
  constructor(t, n) {
    super(), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "make", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.template = t, this.make = n;
  }
}
class Ctt extends mF {
  constructor(t) {
    super(), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._container = t, this._events = this.events.onAll((n) => {
      if (n.type === "clear")
        ut(n.oldValues, (r) => {
          this._onRemoved(r);
        });
      else if (n.type === "push")
        this._onInserted(n.newValue);
      else if (n.type === "setIndex")
        this._onRemoved(n.oldValue), this._onInserted(n.newValue, n.index);
      else if (n.type === "insertIndex")
        this._onInserted(n.newValue, n.index);
      else if (n.type === "removeIndex")
        this._onRemoved(n.oldValue);
      else if (n.type === "moveIndex")
        this._onRemoved(n.value), this._onInserted(n.value, n.newIndex);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _onInserted(t, n) {
    t._setParent(this._container, !0);
    const r = this._container._childrenDisplay;
    n === void 0 ? r.addChild(t._display) : r.addChildAt(t._display, n);
  }
  _onRemoved(t) {
    this._container._childrenDisplay.removeChild(t._display), this._container.markDirtyBounds(), this._container.markDirty();
  }
  /**
   * Returns `true` if obejct is disposed.
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Permanently dispose this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._events.dispose(), ut(this.values, (t) => {
      t.dispose();
    }));
  }
}
class hi {
  /**
   * Constructor.
   *
   * @param percent  Percent value
   */
  constructor(t) {
    Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = t;
  }
  /**
   * Relative value.
   *
   * E.g. 100% is 1, 50% is 0.5, etc.
   *
   * This is useful to apply transformations to other values. E.g.:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * Alternatively, you can use `am5.percent()` helper function:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * @readonly
   * @return Relative value
   */
  get value() {
    return this._value / 100;
  }
  /**
   * Value in percent.
   *
   * @return Percent
   */
  get percent() {
    return this._value;
  }
  toString() {
    return "" + this._value + "%";
  }
  interpolate(t, n) {
    return t + this.value * (n - t);
  }
  static normalize(t, n, r) {
    return t instanceof hi ? t : n === r ? new hi(0) : new hi(Math.min(Math.max((t - n) * (1 / (r - n)), 0), 1) * 100);
  }
}
function ab(e) {
  return new hi(e);
}
ab(0);
const Eo = ab(100), Pa = ab(50);
function Ry(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(a) {
      a(o);
    });
  }
  return new (n || (n = Promise))(function(o, a) {
    function s(f) {
      try {
        l(r.next(f));
      } catch (h) {
        a(h);
      }
    }
    function u(f) {
      try {
        l(r.throw(f));
      } catch (h) {
        a(h);
      }
    }
    function l(f) {
      f.done ? o(f.value) : i(f.value).then(s, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function jl(e) {
  return Object.keys(e);
}
function Ntt(e, t) {
  return jl(e).sort(t);
}
function Dtt(e) {
  return Object.assign({}, e);
}
function ia(e, t) {
  jl(e).forEach((n) => {
    t(n, e[n]);
  });
}
function Att(e, t) {
  for (let n in e)
    if (Ott(e, n) && !t(n, e[n]))
      break;
}
function Ott(e, t) {
  return {}.hasOwnProperty.call(e, t);
}
function Rtt(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function Ja(e, t, n, r) {
  return e.addEventListener(t, n, r || !1), new Bs(() => {
    e.removeEventListener(t, n, r || !1);
  });
}
function Kxe(e) {
  return Ja(window, "resize", (t) => {
    e();
  });
}
function XE(e) {
  switch (e) {
    case "touchevents":
      return window.hasOwnProperty("TouchEvent");
    case "pointerevents":
      return window.hasOwnProperty("PointerEvent");
    case "mouseevents":
      return window.hasOwnProperty("MouseEvent");
    case "wheelevents":
      return window.hasOwnProperty("WheelEvent");
    case "keyboardevents":
      return window.hasOwnProperty("KeyboardEvent");
  }
  return !1;
}
function HY(e) {
  return e.pointerId || 0;
}
function ktt() {
  if (document.activeElement && document.activeElement != document.body)
    if (document.activeElement.blur)
      document.activeElement.blur();
    else {
      let e = document.createElement("button");
      e.style.position = "fixed", e.style.top = "0px", e.style.left = "-10000px", document.body.appendChild(e), e.focus(), e.blur(), document.body.removeChild(e);
    }
}
function $tt(e) {
  e && e.focus();
}
function bq(e) {
  if (XE("pointerevents"))
    return e;
  if (XE("touchevents"))
    switch (e) {
      case "pointerover":
        return "touchstart";
      case "pointerout":
        return "touchend";
      case "pointerleave":
        return "touchend";
      case "pointerdown":
        return "touchstart";
      case "pointermove":
        return "touchmove";
      case "pointerup":
        return "touchend";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  else if (XE("mouseevents"))
    switch (e) {
      case "pointerover":
        return "mouseover";
      case "pointerout":
        return "mouseout";
      case "pointerleave":
        return "mouseleave";
      case "pointerdown":
        return "mousedown";
      case "pointermove":
        return "mousemove";
      case "pointerup":
        return "mouseup";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  return e;
}
function Mfe(e) {
  if (typeof Touch < "u" && e instanceof Touch)
    return !0;
  if (typeof PointerEvent < "u" && e instanceof PointerEvent && e.pointerType != null)
    switch (e.pointerType) {
      case "touch":
      case "pen":
      case 2:
        return !0;
      case "mouse":
      case 4:
        return !1;
      default:
        return !(e instanceof MouseEvent);
    }
  else if (e.type != null && e.type.match(/^mouse/))
    return !1;
  return !0;
}
function VY(e, t, n) {
  e.style[t] = n;
}
function Ptt(e, t) {
  return e.style[t];
}
function Zxe(e) {
  if (e.composedPath) {
    const t = e.composedPath();
    return t.length === 0 ? null : t[0];
  } else
    return e.target;
}
function Itt(e, t) {
  let n = t;
  for (; ; ) {
    if (e === n)
      return !0;
    if (n.parentNode === null) {
      if (n.host == null)
        return !1;
      n = n.host;
    } else
      n = n.parentNode;
  }
}
function jtt(e, t) {
  return e.target && Itt(t.root.dom, e.target);
}
function iT(e, t) {
  t ? e.style.pointerEvents = "auto" : e.style.pointerEvents = "none";
}
function Ltt() {
  return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function ztt() {
  return Ltt() ? 1 : void 0;
}
function vy(e, t) {
  return Cn(e) ? e : e != null && Cn(e.value) && Cn(t) ? t * e.value : 0;
}
function Ka(e, t = 0, n = "0") {
  return typeof e != "string" && (e = e.toString()), t > e.length ? Array(t - e.length + 1).join(n) + e : e;
}
function Ftt(e) {
  return e.replace(/^[\s]*/, "");
}
function Btt(e) {
  return e.replace(/[\s]*$/, "");
}
function tj(e) {
  return Ftt(Btt(e));
}
function Utt(e) {
  if (typeof e > "u")
    return "string";
  e = e.toLowerCase().replace(/^\[[^\]]*\]/, ""), e = e.replace(/\[[^\]]+\]/, ""), e = e.trim();
  let t = e.match(/\/(date|number|duration)$/);
  return t ? t[1] : e === "number" ? "number" : e === "date" ? "date" : e === "duration" ? "duration" : e.match(/[#0]/) ? "number" : e.match(/[ymwdhnsqaxkzgtei]/) ? "date" : "string";
}
function RK(e) {
  return e.replace(/\/(date|number|duration)$/i, "");
}
function Tfe(e) {
  return e && e.replace(/<[^>]*>/g, "");
}
function Cfe(e) {
  return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function Nfe(e, t = !1) {
  const n = new Date(e.getFullYear(), 0, 0), r = e.getTime() - n.getTime() + (n.getTimezoneOffset() - e.getTimezoneOffset()) * 60 * 1e3, i = 1e3 * 60 * 60 * 24;
  return Math.floor(r / i);
}
function Kj(e, t = !1) {
  const n = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())), r = n.getUTCDay() || 7;
  n.setUTCDate(n.getUTCDate() + 4 - r);
  const i = new Date(Date.UTC(n.getUTCFullYear(), 0, 1));
  return Math.ceil(((n.getTime() - i.getTime()) / 864e5 + 1) / 7);
}
function Ytt(e, t = !1) {
  const n = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())), r = n.getUTCDay() || 7;
  return n.setUTCDate(n.getUTCDate() + 4 - r), new Date(Date.UTC(n.getUTCFullYear(), 0, 1)).getFullYear();
}
function Htt(e, t = !1) {
  const n = Kj(new Date(e.getFullYear(), e.getMonth(), 1), t);
  let r = Kj(e, t);
  return r == 1 && (r = 53), r - n + 1;
}
function Vtt(e, t, n = 1, r = !1) {
  let i = new Date(t, 0, 4, 0, 0, 0, 0);
  return r && i.setUTCFullYear(t), e * 7 + n - ((i.getDay() || 7) + 3);
}
function PI(e, t) {
  return e > 12 ? e -= 12 : e === 0 && (e = 12), t != null ? e + (t - 1) : e;
}
function II(e, t = !1, n = !1, r = !1) {
  if (r)
    return t ? "Coordinated Universal Time" : "UTC";
  let i = e.toLocaleString("UTC"), o = e.toLocaleString("UTC", { timeZoneName: t ? "long" : "short" }).substr(i.length);
  return n === !1 && (o = o.replace(/ (standard|daylight|summer|winter) /i, " ")), o;
}
function Wtt(e) {
  const t = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0)), n = new Date(t.toLocaleString("en-US", { timeZone: "UTC" }));
  return (new Date(t.toLocaleString("en-US", { timeZone: e })).getTime() - n.getTime()) / 6e4 * -1;
}
function Jxe(e) {
  let t, n, r, i = e.h, o = e.s, a = e.l;
  if (o == 0)
    t = n = r = a;
  else {
    let s = function(h, p, g) {
      return g < 0 && (g += 1), g > 1 && (g -= 1), g < 0.16666666666666666 ? h + (p - h) * 6 * g : g < 0.5 ? p : g < 0.6666666666666666 ? h + (p - h) * (0.6666666666666666 - g) * 6 : h;
    }, u = a < 0.5 ? a * (1 + o) : a + o - a * o, l = 2 * a - u;
    t = s(l, u, i + 1 / 3), n = s(l, u, i), r = s(l, u, i - 1 / 3);
  }
  return {
    r: Math.round(t * 255),
    g: Math.round(n * 255),
    b: Math.round(r * 255)
  };
}
function ewe(e) {
  let t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.max(t, n, r), o = Math.min(t, n, r), a = 0, s = 0, u = (i + o) / 2;
  if (i === o)
    a = s = 0;
  else {
    let l = i - o;
    switch (s = u > 0.5 ? l / (2 - i - o) : l / (i + o), i) {
      case t:
        a = (n - r) / l + (n < r ? 6 : 0);
        break;
      case n:
        a = (r - t) / l + 2;
        break;
      case r:
        a = (t - n) / l + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s,
    l: u
  };
}
function qtt(e, t) {
  return e && {
    r: Math.max(0, Math.min(255, e.r + nj(e.r, t))),
    g: Math.max(0, Math.min(255, e.g + nj(e.g, t))),
    b: Math.max(0, Math.min(255, e.b + nj(e.b, t))),
    a: e.a
  };
}
function nj(e, t) {
  let n = t > 0 ? 255 - e : e;
  return Math.round(n * t);
}
function Gtt(e, t) {
  if (e) {
    let n = Math.min(Math.max(e.r, e.g, e.b), 230), r = nj(n, t);
    return {
      r: Math.max(0, Math.min(255, Math.round(e.r + r))),
      g: Math.max(0, Math.min(255, Math.round(e.g + r))),
      b: Math.max(0, Math.min(255, Math.round(e.b + r))),
      a: e.a
    };
  } else
    return e;
}
function Dfe(e) {
  return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3 >= 128;
}
function Qtt(e, t) {
  if (e === void 0 || t == 1)
    return e;
  let n = ewe(e);
  return n.s = t, Jxe(n);
}
function Xtt(e, t = { r: 255, g: 255, b: 255 }, n = { r: 255, g: 255, b: 255 }) {
  let r = t, i = n;
  return Dfe(n) && (r = n, i = t), Dfe(e) ? i : r;
}
function twe(e, t) {
  return e || (e = []), [...e, ...t].filter((n, r, i) => i.indexOf(n) === r);
}
function nwe(e) {
  return e[0] === "#" && (e = e.substr(1)), e.length == 3 && (e = e[0].repeat(2) + e[1].repeat(2) + e[2].repeat(2)), parseInt(e, 16);
}
function Ktt(e) {
  e = e.replace(/[ ]/g, "");
  let t = e.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
  if (t)
    t.push("1");
  else if (t = e.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i), !t)
    return 0;
  let n = "";
  for (let r = 1; r <= 3; r++) {
    let i = parseInt(t[r]).toString(16);
    i.length == 1 && (i = "0" + i), n += i;
  }
  return nwe(n);
}
function OE(e) {
  return Mr.fromAny(e);
}
let Mr = class vc {
  constructor(t) {
    Object.defineProperty(this, "_hex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._hex = t | 0;
  }
  /**
   * Color numeric value.
   */
  get hex() {
    return this._hex;
  }
  /**
   * Value of color's R channel.
   * @return R value
   */
  get r() {
    return this._hex >>> 16;
  }
  /**
   * Value of color's G channel.
   * @return G value
   */
  get g() {
    return this._hex >> 8 & 255;
  }
  /**
   * Value of color's B channel.
   * @return B value
   */
  get b() {
    return this._hex & 255;
  }
  /**
   * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
   *
   * @param   alpha  Opacity
   * @return         CSS string
   */
  toCSS(t = 1) {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + t + ")";
  }
  /**
   * Returns color CSS representation in form of `#rgb` string.
   *
   * @return         CSS string
   */
  toCSSHex() {
    return "#" + Ka(this.r.toString(16), 2) + Ka(this.g.toString(16), 2) + Ka(this.b.toString(16), 2);
  }
  /**
   * Returns color's HSL info.
   * @param   alpha Opacity
   * @return        HSL info
   */
  toHSL(t = 1) {
    return ewe({
      r: this.r,
      g: this.g,
      b: this.b,
      a: t
    });
  }
  /**
   * Converts HSL values into a new [[Color]] object.
   *
   * @param   h H value
   * @param   s S value
   * @param   l L value
   * @return    Color object
   */
  static fromHSL(t, n, r) {
    const i = Jxe({
      h: t,
      s: n,
      l: r
    });
    return this.fromRGB(i.r, i.g, i.b);
  }
  toString() {
    return this.toCSSHex();
  }
  /**
   * Converts hex number into a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromHex(0xff0000) // red
   * ```
   * ```JavaScript
   * Color.fromHex(0xff0000) // red
   * ```
   *
   * @param   hex  Hex color
   * @return       Color
   */
  static fromHex(t) {
    return new vc(t);
  }
  /**
   * Converts RGB values to a new [[Color]] object.
   *
   * @param   r  R value
   * @param   g  G value
   * @param   b  B value
   * @return     Color
   */
  static fromRGB(t, n, r) {
    return new vc((r | 0) + (n << 8) + (t << 16));
  }
  /**
   * Converts RGB string to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromString("#ff0000") // red
   * ```
   * ```JavaScript
   * Color.fromString("#ff0000") // red
   * ```
   *
   * @param   s  RGB string
   * @return     Color
   */
  static fromString(t) {
    return new vc(nwe(t));
  }
  /**
   * Converts CSS rgba() syntax to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   * ```JavaScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   *
   * @param  {string} s [description]
   * @return {Color}    [description]
   */
  static fromCSS(t) {
    return new vc(Ktt(t));
  }
  /**
   * Convert to color from virtually anything.
   *
   * Will throw an exception if unable to resolve the color.
   *
   * @param   s  Source
   * @return     Color
   */
  static fromAny(t) {
    if (tC(t)) {
      if (t[0] == "#")
        return vc.fromString(t);
      if (t.substr(0, 3) == "rgb")
        return vc.fromCSS(t);
    } else {
      if (Cn(t))
        return vc.fromHex(t);
      if (t instanceof vc)
        return vc.fromHex(t.hex);
    }
    throw new Error("Unknown color syntax: " + t);
  }
  /**
   * Returns a new [[Color]] object based on either `lightAlternative` or
   * `darkAlternative` depending on which one is more contrasting with
   * the `color`.
   *
   * @param   color             Reference color
   * @param   lightAlternative  Light color
   * @param   darkAlternative   Dark color
   * @return                    Alternative color
   */
  static alternative(t, n, r) {
    const i = Xtt({ r: t.r, g: t.g, b: t.b }, n ? { r: n.r, g: n.g, b: n.b } : void 0, r ? { r: r.r, g: r.g, b: r.b } : void 0);
    return this.fromRGB(i.r, i.g, i.b);
  }
  /**
   * Returns an intermediate Color between two reference colors depending on
   * the progress (`diff`) between the two.
   *
   * @param   diff  Progress
   * @param   from  Source color
   * @param   to    Target color
   * @param   mode  Interpolation mode
   * @return        Color
   */
  static interpolate(t, n, r, i = "rgb") {
    if (i == "hsl") {
      const o = n.toHSL(), a = r.toHSL();
      return vc.fromHSL(lx(t, o.h, a.h), lx(t, o.s, a.s), lx(t, o.l, a.l));
    } else
      return vc.fromRGB(lx(t, n.r, r.r), lx(t, n.g, r.g), lx(t, n.b, r.b));
  }
  /**
   * Returns a new [[Color]] lightened by `percent` value.
   *
   * Use negative value to darken the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static lighten(t, n) {
    const r = qtt({ r: t.r, g: t.g, b: t.b }, n);
    return vc.fromRGB(r.r, r.g, r.b);
  }
  /**
   * Returns a new [[Color]] brightened by `percent` value.
   *
   * Use negative value to dim the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static brighten(t, n) {
    const r = Gtt({ r: t.r, g: t.g, b: t.b }, n);
    return vc.fromRGB(r.r, r.g, r.b);
  }
  /**
   * Returns a new [[Color]] saturated by `percent` value.
   *
   * Value range is between `0` (fully desaturated), to `1` (full color).
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static saturate(t, n) {
    const r = Qtt({ r: t.r, g: t.g, b: t.b }, n);
    return vc.fromRGB(r.r, r.g, r.b);
  }
};
function Afe(e) {
  return Ry(this, void 0, void 0, function* () {
    if (e !== void 0) {
      const t = [];
      ia(e, (n, r) => {
        t.push(r.waitForStop());
      }), yield Promise.all(t);
    }
  });
}
function lx(e, t, n) {
  return t + e * (n - t);
}
function Ztt(e, t, n) {
  return e >= 1 ? n : t;
}
function rwe(e, t, n) {
  return new hi(lx(e, t.percent, n.percent));
}
function Jtt(e, t, n) {
  return Mr.interpolate(e, t, n);
}
function ent(e, t) {
  return typeof e == "number" && typeof t == "number" ? lx : e instanceof hi && t instanceof hi ? rwe : e instanceof Mr && t instanceof Mr ? Jtt : Ztt;
}
const iwe = Math.PI, kK = iwe / 180, KE = 180 / iwe;
function vd(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function xq(e) {
  return Math.sin(kK * e);
}
function wq(e) {
  return Math.cos(kK * e);
}
function tnt(e) {
  return e = e % 360, e < 0 && (e += 360), e;
}
function nnt(e, t, n, r, i) {
  let o = Number.MAX_VALUE, a = Number.MAX_VALUE, s = -Number.MAX_VALUE, u = -Number.MAX_VALUE, l = [];
  l.push(WY(i, n)), l.push(WY(i, r));
  let f = Math.min(Math.floor(n / 90) * 90, Math.floor(r / 90) * 90), h = Math.max(Math.ceil(n / 90) * 90, Math.ceil(r / 90) * 90);
  for (let p = f; p <= h; p += 90)
    p >= n && p <= r && l.push(WY(i, p));
  for (let p = 0; p < l.length; p++) {
    let g = l[p];
    g.x < o && (o = g.x), g.y < a && (a = g.y), g.x > s && (s = g.x), g.y > u && (u = g.y);
  }
  return { left: e + o, top: t + a, right: e + s, bottom: t + u };
}
function WY(e, t) {
  return { x: e * wq(t), y: e * xq(t) };
}
function Ofe(e) {
  return e;
}
function RE(e) {
  return e * e * e;
}
function oT(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}
class rnt {
  constructor(t, n) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_userSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = t, this._settings = n, ia(n, (r) => {
      this._userSettings[r] = !0;
    });
  }
  get(t, n) {
    const r = this._settings[t];
    return r !== void 0 ? r : n;
  }
  /**
   * @ignore
   */
  setRaw(t, n) {
    this._settings[t] = n;
  }
  /**
   * Sets a setting `value` for the specified `key` to be set when the state
   * is applied.
   *
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(t, n) {
    this._userSettings[t] = !0, this.setRaw(t, n);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(t) {
    delete this._userSettings[t], delete this._settings[t];
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(t) {
    jl(t).forEach((n) => {
      this.set(n, t[n]);
    });
  }
  _eachSetting(t) {
    ia(this._settings, t);
  }
  /**
   * Applies the state to the target element.
   *
   * All setting values are set immediately.
   */
  apply() {
    const t = {};
    t.stateAnimationEasing = !0, t.stateAnimationDuration = !0;
    const n = this._entity.states.lookup("default");
    this._eachSetting((r, i) => {
      t[r] || (t[r] = !0, this !== n && (r in n._settings || (n._settings[r] = this._entity.get(r))), this._entity.set(r, i));
    });
  }
  /**
   * Applies the state to the target element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @return           Animations
   */
  applyAnimate(t) {
    t == null && (t = this._settings.stateAnimationDuration), t == null && (t = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0)));
    let n = this._settings.stateAnimationEasing;
    n == null && (n = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", RE)));
    const r = this._entity.states.lookup("default"), i = {};
    i.stateAnimationEasing = !0, i.stateAnimationDuration = !0;
    const o = {};
    return this._eachSetting((a, s) => {
      if (!i[a]) {
        i[a] = !0, this != r && (a in r._settings || (r._settings[a] = this._entity.get(a)));
        const u = this._entity.animate({
          key: a,
          to: s,
          duration: t,
          easing: n
        });
        u && (o[a] = u);
      }
    }), o;
  }
}
class int {
  constructor(t) {
    Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._entity = t;
  }
  /**
   * Checks if a state by `name` exists. Returns it there is one.
   *
   * @param  name  State name
   * @return       State
   */
  lookup(t) {
    return this._states[t];
  }
  /**
   * Sets supplied `settings` on a state by the `name`.
   *
   * If such state does not yet exists, it is created.
   *
   * @param   name      State name
   * @param   settings  Settings
   * @return            New State
   */
  create(t, n) {
    const r = this._states[t];
    if (r)
      return r.setAll(n), r;
    {
      const i = new rnt(this._entity, n);
      return this._states[t] = i, i;
    }
  }
  /**
   * Removes the state called `name`.
   *
   * @param   name      State name
   */
  remove(t) {
    delete this._states[t];
  }
  /**
   * Applies a named state to the target element.
   *
   * @param  newState  State name
   */
  apply(t) {
    const n = this._states[t];
    n && n.apply(), this._entity._applyState(t);
  }
  /**
   * Applies a named state to the element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @param   newState  State name
   * @return            Animations
   */
  applyAnimate(t, n) {
    let r;
    const i = this._states[t];
    return i && (r = i.applyAnimate(n)), this._entity._applyStateAnimated(t, n), r;
  }
}
class ont {
  constructor() {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "5.4.4"
    }), Object.defineProperty(this, "licenses", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "entitiesById", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "rootElements", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
const Cg = new ont();
function ant(e) {
  Cg.licenses.push(e);
}
function ZE(e, t) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function owe(e, t, n) {
  const r = e.length, i = t.length, o = Math.min(r, i);
  for (let a = 0; a < o; ++a) {
    const s = n(e[a], t[a]);
    if (s !== 0)
      return s;
  }
  return ZE(r, i);
}
class snt {
  constructor(t) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = t;
  }
  /**
   * Add a function (`callback`) that will modify value for setting `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
   */
  add(t, n) {
    let r = this._callbacks[t];
    return r === void 0 && (r = this._callbacks[t] = []), r.push(n), this._entity._markDirtyKey(t), new Bs(() => {
      Md(r, n) && this._entity._markDirtyKey(t);
    });
  }
  /**
   * Removes all adapters for the specific key.
   *
   * @since 5.1.0
   */
  remove(t) {
    const n = this._callbacks[t];
    n !== void 0 && (delete this._callbacks[t], n.length !== 0 && this._entity._markDirtyKey(t));
  }
  /**
   * Enables (previously disabled) adapters for specific key.
   *
   * @since 5.1.0
   */
  enable(t) {
    this._disabled[t] && (delete this._disabled[t], this._entity._markDirtyKey(t));
  }
  /**
   * Disables all adapters for specific key.
   *
   * @since 5.1.0
   */
  disable(t) {
    this._disabled[t] || (this._disabled[t] = !0, this._entity._markDirtyKey(t));
  }
  /**
   * @ignore
   */
  fold(t, n) {
    if (!this._disabled[t]) {
      const r = this._callbacks[t];
      if (r !== void 0)
        for (let i = 0, o = r.length; i < o; ++i)
          n = r[i](n, this._entity, t);
    }
    return n;
  }
}
class jI {
  constructor(t, n, r, i, o, a, s) {
    Object.defineProperty(this, "_animation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_from", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_to", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_duration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_easing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_loops", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_interpolate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_oldTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_stopped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_playing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new aN()
    }), this._animation = t, this._from = n, this._to = r, this._duration = i, this._easing = o, this._loops = a, this._interpolate = ent(n, r), this._oldTime = s;
  }
  get to() {
    return this._to;
  }
  get from() {
    return this._from;
  }
  get playing() {
    return this._playing;
  }
  get stopped() {
    return this._stopped;
  }
  stop() {
    this._stopped || (this._stopped = !0, this._playing = !1, this.events.isEnabled("stopped") && this.events.dispatch("stopped", {
      type: "stopped",
      target: this
    }));
  }
  pause() {
    this._playing = !1, this._oldTime = null;
  }
  play() {
    !this._stopped && !this._playing && (this._playing = !0, this._animation._startAnimation());
  }
  get percentage() {
    return this._time / this._duration;
  }
  waitForStop() {
    return new Promise((t, n) => {
      if (this._stopped)
        t();
      else {
        const r = () => {
          i.dispose(), t();
        }, i = this.events.on("stopped", r);
      }
    });
  }
  _checkEnded() {
    return this._loops > 1 ? (--this._loops, !1) : !0;
  }
  _run(t) {
    this._oldTime !== null && (this._time += t - this._oldTime, this._time > this._duration && (this._time = this._duration)), this._oldTime = t;
  }
  _reset(t) {
    this._oldTime = t, this._time = 0;
  }
  _value(t) {
    return this._interpolate(this._easing(t), this._from, this._to);
  }
}
let unt = 0;
class awe {
  constructor(t) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ++unt
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_userProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._settings = t;
  }
  _checkDirty() {
    jl(this._settings).forEach((t) => {
      this._userProperties[t] = !0, this._markDirtyKey(t);
    });
  }
  /**
   * @ignore
   */
  resetUserSettings() {
    this._userProperties = {};
  }
  _runAnimation(t) {
    if (this.isDisposed())
      return !1;
    {
      let n = !1;
      return ia(this._animatingSettings, (r, i) => {
        if (i._stopped)
          this._stopAnimation(r);
        else if (i._playing) {
          i._run(t);
          const o = i.percentage;
          o >= 1 ? i._checkEnded() ? this.set(r, i._value(1)) : (n = !0, i._reset(t), this._set(r, i._value(1))) : (n = !0, this._set(r, i._value(o)));
        }
      }), ia(this._animatingPrivateSettings, (r, i) => {
        if (i._stopped)
          this._stopAnimationPrivate(r);
        else if (i._playing) {
          i._run(t);
          const o = i.percentage;
          o >= 1 ? i._checkEnded() ? this.setPrivate(r, i._value(1)) : (n = !0, i._reset(t), this._setPrivate(r, i._value(1))) : (n = !0, this._setPrivate(r, i._value(o)));
        }
      }), n;
    }
  }
  _markDirtyKey(t) {
    this.markDirty();
  }
  _markDirtyPrivateKey(t) {
    this.markDirty();
  }
  /**
   * Sets a callback function to invoke when specific key of settings changes
   * or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @param   key       Settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  on(t, n) {
    let r = this._settingEvents[t];
    return r === void 0 && (r = this._settingEvents[t] = []), r.push(n), new Bs(() => {
      Md(r, n), r.length === 0 && delete this._settingEvents[t];
    });
  }
  /**
   * Sets a callback function to invoke when specific key of private settings
   * changes or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @ignore
   * @param   key       Private settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  onPrivate(t, n) {
    let r = this._privateSettingEvents[t];
    return r === void 0 && (r = this._privateSettingEvents[t] = []), r.push(n), new Bs(() => {
      Md(r, n), r.length === 0 && delete this._privateSettingEvents[t];
    });
  }
  /**
   * @ignore
   */
  getRaw(t, n) {
    const r = this._settings[t];
    return r !== void 0 ? r : n;
  }
  get(t, n) {
    return this.getRaw(t, n);
  }
  _sendKeyEvent(t, n) {
    const r = this._settingEvents[t];
    r !== void 0 && ut(r, (i) => {
      i(n, this, t);
    });
  }
  _sendPrivateKeyEvent(t, n) {
    const r = this._privateSettingEvents[t];
    r !== void 0 && ut(r, (i) => {
      i(n, this, t);
    });
  }
  /**
   * @ignore
   */
  _setRaw(t, n, r) {
    this._prevSettings[t] = n, this._sendKeyEvent(t, r);
  }
  /**
   * @ignore
   */
  setRaw(t, n) {
    const r = this._settings[t];
    this._settings[t] = n, r !== n && this._setRaw(t, r, n);
  }
  /**
   * @ignore
   */
  _set(t, n) {
    const r = this._settings[t];
    this._settings[t] = n, r !== n && (this._setRaw(t, r, n), this._markDirtyKey(t));
  }
  _stopAnimation(t) {
    const n = this._animatingSettings[t];
    n && (delete this._animatingSettings[t], n.stop());
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(t, n) {
    return this._set(t, n), this._stopAnimation(t), n;
  }
  /**
   * Removes a setting value for the specified `key`;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(t) {
    t in this._settings && (this._prevSettings[t] = this._settings[t], delete this._settings[t], this._sendKeyEvent(t, void 0), this._markDirtyKey(t)), this._stopAnimation(t);
  }
  /**
   * Removes all keys;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   */
  removeAll() {
    ut(jl(this._settings), (t) => {
      this.remove(t);
    });
  }
  /**
   * Returns a value of a private setting.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
   */
  getPrivate(t, n) {
    const r = this._privateSettings[t];
    return r !== void 0 ? r : n;
  }
  /**
   * @ignore
   */
  _setPrivateRaw(t, n, r) {
    this._prevPrivateSettings[t] = n, this._sendPrivateKeyEvent(t, r);
  }
  /**
   * @ignore
   */
  setPrivateRaw(t, n) {
    const r = this._privateSettings[t];
    this._privateSettings[t] = n, r !== n && this._setPrivateRaw(t, r, n);
  }
  /**
   * @ignore
   */
  _setPrivate(t, n) {
    const r = this._privateSettings[t];
    this._privateSettings[t] = n, r !== n && (this._setPrivateRaw(t, r, n), this._markDirtyPrivateKey(t));
  }
  _stopAnimationPrivate(t) {
    const n = this._animatingPrivateSettings[t];
    n && (n.stop(), delete this._animatingPrivateSettings[t]);
  }
  /**
   * @ignore
   */
  setPrivate(t, n) {
    return this._setPrivate(t, n), this._stopAnimationPrivate(t), n;
  }
  /**
   * @ignore
   */
  removePrivate(t) {
    t in this._privateSettings && (this._prevPrivateSettings[t] = this._privateSettings[t], delete this._privateSettings[t], this._markDirtyPrivateKey(t)), this._stopAnimationPrivate(t);
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(t) {
    ia(t, (n, r) => {
      this.set(n, r);
    });
  }
  /**
   * Animates setting values from current/start values to new ones.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
   * @param   options  Animation options
   * @return           Animation object
   */
  animate(t) {
    const n = t.key, r = t.to, i = t.duration || 0, o = t.loops || 1, a = t.from === void 0 ? this.get(n) : t.from, s = t.easing === void 0 ? Ofe : t.easing;
    if (i === 0)
      this.set(n, r);
    else if (a === void 0 || a === r)
      this.set(n, r);
    else {
      this.set(n, a);
      const l = this._animatingSettings[n] = new jI(this, a, r, i, s, o, this._animationTime());
      return this._startAnimation(), l;
    }
    const u = new jI(this, a, r, i, s, o, null);
    return u.stop(), u;
  }
  /**
   * @ignore
   */
  animatePrivate(t) {
    const n = t.key, r = t.to, i = t.duration || 0, o = t.loops || 1, a = t.from === void 0 ? this.getPrivate(n) : t.from, s = t.easing === void 0 ? Ofe : t.easing;
    if (i === 0)
      this.setPrivate(n, r);
    else if (a === void 0 || a === r)
      this.setPrivate(n, r);
    else {
      this.setPrivate(n, a);
      const l = this._animatingPrivateSettings[n] = new jI(this, a, r, i, s, o, this._animationTime());
      return this._startAnimation(), l;
    }
    const u = new jI(this, a, r, i, s, o, null);
    return u.stop(), u;
  }
  _dispose() {
  }
  /**
   * Returns `true` if this element is disposed.
   *
   * @return Disposed
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Lf extends awe {
  /**
   * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
   *
   * Use static method `Class.new()` instead.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @ignore
   */
  constructor(t, n, r, i = []) {
    if (super(n), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_user_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new int(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new snt(this)
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createEvents()
    }), Object.defineProperty(this, "_userPrivateProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPrivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_internalTemplates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_defaultThemes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_templateDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_runSetup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposerProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), !r)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._root = t, this._internalTemplates = i, n.id && this._registerId(n.id);
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(t, n, r) {
    const i = new this(t, n, !0);
    return i._template = r, i._afterNew(), i;
  }
  static _new(t, n, r = []) {
    const i = new this(t, n, !0, r);
    return i._afterNew(), i;
  }
  _afterNew() {
    this._checkDirty();
    let t = !1;
    const n = this._template;
    n && (t = !0, n._setObjectTemplate(this)), ut(this._internalTemplates, (r) => {
      t = !0, r._setObjectTemplate(this);
    }), t && this._applyTemplates(!1), this.states.create("default", {}), this._setDefaults();
  }
  // This is the same as _afterNew, except it also applies the themes.
  // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
  _afterNewApplyThemes() {
    this._checkDirty();
    const t = this._template;
    t && t._setObjectTemplate(this), ut(this._internalTemplates, (n) => {
      n._setObjectTemplate(this);
    }), this.states.create("default", {}), this._setDefaults(), this._applyThemes();
  }
  _createEvents() {
    return new aN();
  }
  /**
   * @ignore
   */
  get classNames() {
    return this.constructor.classNames;
  }
  /**
   * @ignore
   */
  get className() {
    return this.constructor.className;
  }
  _setDefaults() {
  }
  _setDefault(t, n) {
    t in this._settings || super.set(t, n);
  }
  _setRawDefault(t, n) {
    t in this._settings || super.setRaw(t, n);
  }
  _clearDirty() {
    jl(this._dirty).forEach((t) => {
      this._dirty[t] = !1;
    }), jl(this._dirtyPrivate).forEach((t) => {
      this._dirtyPrivate[t] = !1;
    });
  }
  /**
   * @ignore
   */
  isDirty(t) {
    return !!this._dirty[t];
  }
  /**
   * @ignore
   */
  isPrivateDirty(t) {
    return !!this._dirtyPrivate[t];
  }
  _markDirtyKey(t) {
    this._dirty[t] = !0, super._markDirtyKey(t);
  }
  _markDirtyPrivateKey(t) {
    this._dirtyPrivate[t] = !0, super._markDirtyKey(t);
  }
  /**
   * Checks if element is of certain class (or inherits one).
   *
   * @param   type  Class name to check
   * @return {boolean} Is of class?
   */
  isType(t) {
    return this.classNames.indexOf(t) !== -1;
  }
  _pushPropertyDisposer(t, n) {
    let r = this._disposerProperties[t];
    return r === void 0 && (r = this._disposerProperties[t] = []), r.push(n), n;
  }
  _disposeProperty(t) {
    const n = this._disposerProperties[t];
    n !== void 0 && (ut(n, (r) => {
      r.dispose();
    }), delete this._disposerProperties[t]);
  }
  /**
   * @todo needs description
   * @param  value  Template
   */
  set template(t) {
    const n = this._template;
    n !== t && (this._template = t, n && n._removeObjectTemplate(this), t && t._setObjectTemplate(this), this._applyTemplates());
  }
  get template() {
    return this._template;
  }
  /**
   * @ignore
   */
  markDirty() {
    this._root._addDirtyEntity(this);
  }
  _startAnimation() {
    this._root._addAnimation(this);
  }
  _animationTime() {
    return this._root.animationTime;
  }
  _applyState(t) {
  }
  _applyStateAnimated(t, n) {
  }
  get(t, n) {
    const r = this.adapters.fold(t, this._settings[t]);
    return r !== void 0 ? r : n;
  }
  /**
   * @ignore
   */
  isUserSetting(t) {
    return this._userProperties[t] || !1;
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(t, n) {
    return this._userProperties[t] = !0, super.set(t, n);
  }
  /**
   * @ignore
   */
  setRaw(t, n) {
    this._userProperties[t] = !0, super.setRaw(t, n);
  }
  /**
   * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  _setSoft(t, n) {
    return this._userProperties[t] ? n : super.set(t, n);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(t) {
    delete this._userProperties[t], this._removeTemplateProperty(t);
  }
  /**
   * @ignore
   */
  setPrivate(t, n) {
    return this._userPrivateProperties[t] = !0, super.setPrivate(t, n);
  }
  /**
   * @ignore
   */
  setPrivateRaw(t, n) {
    this._userPrivateProperties[t] = !0, super.setPrivateRaw(t, n);
  }
  /**
   * @ignore
   */
  removePrivate(t) {
    delete this._userPrivateProperties[t], this._removeTemplatePrivateProperty(t);
  }
  _setTemplateProperty(t, n, r) {
    if (!this._userProperties[n]) {
      const i = this._findTemplateByKey(n);
      t === i && super.set(n, r);
    }
  }
  _setTemplatePrivateProperty(t, n, r) {
    if (!this._userPrivateProperties[n]) {
      const i = this._findTemplateByPrivateKey(n);
      t === i && super.setPrivate(n, r);
    }
  }
  _removeTemplateProperty(t) {
    if (!this._userProperties[t]) {
      const n = this._findTemplateByKey(t);
      n ? super.set(t, n._settings[t]) : super.remove(t);
    }
  }
  _removeTemplatePrivateProperty(t) {
    if (!this._userPrivateProperties[t]) {
      const n = this._findTemplateByPrivateKey(t);
      n ? super.setPrivate(t, n._privateSettings[t]) : super.removePrivate(t);
    }
  }
  _walkParents(t) {
    t(this._root._rootContainer), t(this);
  }
  // TODO faster version of this method which is specialized to just 1 key
  _applyStateByKey(t) {
    const n = this.states.create(t, {}), r = {};
    this._eachTemplate((i) => {
      const o = i.states.lookup(t);
      o && o._apply(n, r);
    }), ia(n._settings, (i) => {
      !r[i] && !n._userSettings[i] && n.remove(i);
    });
  }
  _applyTemplate(t, n) {
    this._templateDisposers.push(t._apply(this, n)), ia(t._settings, (r, i) => {
      !n.settings[r] && !this._userProperties[r] && (n.settings[r] = !0, super.set(r, i));
    }), ia(t._privateSettings, (r, i) => {
      !n.privateSettings[r] && !this._userPrivateProperties[r] && (n.privateSettings[r] = !0, super.setPrivate(r, i));
    }), this._runSetup && t.setup && (this._runSetup = !1, t.setup(this));
  }
  /**
   * Calls the closure with each template and returns the first template which is true
   */
  _findStaticTemplate(t) {
    if (this._template && t(this._template))
      return this._template;
  }
  _eachTemplate(t) {
    this._findStaticTemplate((n) => (t(n), !1)), TR(this._internalTemplates, t), ut(this._templates, t);
  }
  _applyTemplates(t = !0) {
    t && this._disposeTemplates();
    const n = {
      settings: {},
      privateSettings: {},
      states: {}
    };
    this._eachTemplate((r) => {
      this._applyTemplate(r, n);
    }), t && (ia(this._settings, (r) => {
      !this._userProperties[r] && !n.settings[r] && super.remove(r);
    }), ia(this._privateSettings, (r) => {
      !this._userPrivateProperties[r] && !n.privateSettings[r] && super.removePrivate(r);
    }));
  }
  _findTemplate(t) {
    const n = this._findStaticTemplate(t);
    if (n === void 0) {
      const r = wtt(this._internalTemplates, t);
      return r === void 0 ? Qxe(this._templates, t) : r;
    } else
      return n;
  }
  _findTemplateByKey(t) {
    return this._findTemplate((n) => t in n._settings);
  }
  _findTemplateByPrivateKey(t) {
    return this._findTemplate((n) => t in n._privateSettings);
  }
  _disposeTemplates() {
    ut(this._templateDisposers, (t) => {
      t.dispose();
    }), this._templateDisposers.length = 0;
  }
  _removeTemplates() {
    ut(this._templates, (t) => {
      t._removeObjectTemplate(this);
    }), this._templates.length = 0;
  }
  _applyThemes() {
    let t = !1;
    const n = [];
    let r = [];
    const i = /* @__PURE__ */ new Set(), o = this.get("themeTagsSelf");
    return o && ut(o, (a) => {
      i.add(a);
    }), this._walkParents((a) => {
      a === this._root._rootContainer && (t = !0), a._defaultThemes.length > 0 && n.push(a._defaultThemes);
      const s = a.get("themes");
      s && r.push(s);
      const u = a.get("themeTags");
      u && ut(u, (l) => {
        i.add(l);
      });
    }), r = n.concat(r), this._removeTemplates(), t && TR(this.classNames, (a) => {
      const s = [];
      ut(r, (u) => {
        ut(u, (l) => {
          const f = l._lookupRules(a);
          f && TR(f, (h) => {
            if (h.tags.every((g) => i.has(g))) {
              const g = Ett(s, (y) => {
                const b = ZE(h.tags.length, y.tags.length);
                return b === 0 ? owe(h.tags, y.tags, ZE) : b;
              });
              s.splice(g.index, 0, h);
            }
          });
        });
      }), ut(s, (u) => {
        this._templates.push(u.template), u.template._setObjectTemplate(this);
      });
    }), this._applyTemplates(), t && (this._runSetup = !1), t;
  }
  _changed() {
  }
  _beforeChanged() {
    if (this.isDirty("id")) {
      const t = this.get("id");
      t && this._registerId(t);
      const n = this._prevSettings.id;
      n && delete Cg.entitiesById[n];
    }
  }
  _registerId(t) {
    if (Cg.entitiesById[t] && Cg.entitiesById[t] !== this)
      throw new Error('An entity with id "' + t + '" already exists.');
    Cg.entitiesById[t] = this;
  }
  _afterChanged() {
  }
  /**
   * @ignore
   */
  addDisposer(t) {
    return this._disposers.push(t), t;
  }
  _dispose() {
    super._dispose();
    const t = this._template;
    t && t._removeObjectTemplate(this), ut(this._internalTemplates, (r) => {
      r._removeObjectTemplate(this);
    }), this._removeTemplates(), this._disposeTemplates(), this.events.dispose(), this._disposers.forEach((r) => {
      r.dispose();
    }), ia(this._disposerProperties, (r, i) => {
      ut(i, (o) => {
        o.dispose();
      });
    });
    const n = this.get("id");
    n && delete Cg.entitiesById[n];
  }
  /**
   * Creates and returns a "disposable" timeout.
   *
   * @param   fn     Callback
   * @param   delay  Delay in milliseconds
   * @return         Timeout disposer
   */
  setTimeout(t, n) {
    const r = setTimeout(() => {
      this.removeDispose(i), t();
    }, n), i = new Bs(() => {
      clearTimeout(r);
    });
    return this._disposers.push(i), i;
  }
  /**
   * @ignore
   */
  removeDispose(t) {
    if (!this.isDisposed()) {
      let n = Xj(this._disposers, t);
      n > -1 && this._disposers.splice(n, 1);
    }
    t.dispose();
  }
  /**
   * @ignore
   */
  hasTag(t) {
    return Xj(this.get("themeTags", []), t) !== -1;
  }
  /**
   * @ignore
   */
  addTag(t) {
    if (!this.hasTag(t)) {
      const n = this.get("themeTags", []);
      n.push(t), this.set("themeTags", n);
    }
  }
  /**
   * @ignore
   */
  removeTag(t) {
    if (this.hasTag(t)) {
      const n = this.get("themeTags", []);
      mx(n, t), this.set("themeTags", n);
    }
  }
  _t(t, n, ...r) {
    return this._root.language.translate(t, n, ...r);
  }
  /**
   * An instance of [[Root]] object.
   *
   * @readonly
   * @since 5.0.6
   * @return Root object
   */
  get root() {
    return this._root;
  }
}
Object.defineProperty(Lf, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Entity"
});
Object.defineProperty(Lf, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ["Entity"]
});
class lnt {
  constructor(t, n, r) {
    Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._name = t, this._template = n, this._settings = r;
  }
  get(t, n) {
    const r = this._settings[t];
    return r !== void 0 ? r : n;
  }
  set(t, n) {
    this._settings[t] = n, this._template._stateChanged(this._name);
  }
  remove(t) {
    delete this._settings[t], this._template._stateChanged(this._name);
  }
  setAll(t) {
    jl(t).forEach((n) => {
      this._settings[n] = t[n];
    }), this._template._stateChanged(this._name);
  }
  _apply(t, n) {
    ia(this._settings, (r, i) => {
      !n[r] && !t._userSettings[r] && (n[r] = !0, t.setRaw(r, i));
    });
  }
}
class cnt {
  constructor(t) {
    Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._template = t;
  }
  lookup(t) {
    return this._states[t];
  }
  create(t, n) {
    const r = this._states[t];
    if (r)
      return r.setAll(n), r;
    {
      const i = new lnt(t, this._template, n);
      return this._states[t] = i, this._template._stateChanged(t), i;
    }
  }
  remove(t) {
    delete this._states[t], this._template._stateChanged(t);
  }
  _apply(t, n) {
    ia(this._states, (r, i) => {
      let o = n.states[r];
      o == null && (o = n.states[r] = {});
      const a = t.states.create(r, {});
      i._apply(a, o);
    });
  }
}
class fnt {
  constructor() {
    Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  add(t, n) {
    let r = this._callbacks[t];
    return r === void 0 && (r = this._callbacks[t] = []), r.push(n), new Bs(() => {
      Md(r, n), r.length === 0 && delete this._callbacks[t];
    });
  }
  remove(t) {
    this._callbacks[t] !== void 0 && delete this._callbacks[t];
  }
  _apply(t) {
    const n = [];
    return ia(this._callbacks, (r, i) => {
      ut(i, (o) => {
        n.push(t.adapters.add(r, o));
      });
    }), new wd(n);
  }
}
class nC {
  constructor(t, n) {
    if (Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entities", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new cnt(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new fnt()
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new aN()
    }), Object.defineProperty(this, "setup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !n)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = t;
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(t) {
    return new nC(t, !0);
  }
  /**
   * Array of all entities using this template.
   */
  get entities() {
    return this._entities;
  }
  get(t, n) {
    const r = this._settings[t];
    return r !== void 0 ? r : n;
  }
  setRaw(t, n) {
    this._settings[t] = n;
  }
  set(t, n) {
    this._settings[t] !== n && (this.setRaw(t, n), this._entities.forEach((r) => {
      r._setTemplateProperty(this, t, n);
    }));
  }
  remove(t) {
    t in this._settings && (delete this._settings[t], this._entities.forEach((n) => {
      n._removeTemplateProperty(t);
    }));
  }
  removeAll() {
    ia(this._settings, (t, n) => {
      this.remove(t);
    });
  }
  getPrivate(t, n) {
    const r = this._privateSettings[t];
    return r !== void 0 ? r : n;
  }
  setPrivateRaw(t, n) {
    return this._privateSettings[t] = n, n;
  }
  setPrivate(t, n) {
    return this._privateSettings[t] !== n && (this.setPrivateRaw(t, n), this._entities.forEach((r) => {
      r._setTemplatePrivateProperty(this, t, n);
    })), n;
  }
  removePrivate(t) {
    t in this._privateSettings && (delete this._privateSettings[t], this._entities.forEach((n) => {
      n._removeTemplatePrivateProperty(t);
    }));
  }
  setAll(t) {
    ia(t, (n, r) => {
      this.set(n, r);
    });
  }
  // TODO code duplication with Properties
  on(t, n) {
    let r = this._settingEvents[t];
    return r === void 0 && (r = this._settingEvents[t] = []), r.push(n), new Bs(() => {
      Md(r, n), r.length === 0 && delete this._settingEvents[t];
    });
  }
  // TODO code duplication with Properties
  onPrivate(t, n) {
    let r = this._privateSettingEvents[t];
    return r === void 0 && (r = this._privateSettingEvents[t] = []), r.push(n), new Bs(() => {
      Md(r, n), r.length === 0 && delete this._privateSettingEvents[t];
    });
  }
  _apply(t, n) {
    const r = [];
    return ia(this._settingEvents, (i, o) => {
      ut(o, (a) => {
        r.push(t.on(i, a));
      });
    }), ia(this._privateSettingEvents, (i, o) => {
      ut(o, (a) => {
        r.push(t.onPrivate(i, a));
      });
    }), this.states._apply(t, n), r.push(this.adapters._apply(t)), r.push(t.events.copyFrom(this.events)), new wd(r);
  }
  _setObjectTemplate(t) {
    this._entities.push(t);
  }
  _removeObjectTemplate(t) {
    mx(this._entities, t);
  }
  _stateChanged(t) {
    this._entities.forEach((n) => {
      n._applyStateByKey(t);
    });
  }
}
class yF extends aN {
  constructor(t) {
    super(), Object.defineProperty(this, "_sprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rendererDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dispatchParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this._sprite = t;
  }
  _makePointerEvent(t, n) {
    return {
      type: t,
      originalEvent: n.event,
      point: n.point,
      simulated: n.simulated,
      native: n.native,
      target: this._sprite
    };
  }
  _onRenderer(t, n) {
    this._sprite.set("interactive", !0), this._sprite._display.interactive = !0;
    let r = this._rendererDisposers[t];
    if (r === void 0) {
      const i = this._sprite._display.on(t, (o) => {
        n.call(this, o);
      });
      r = this._rendererDisposers[t] = new Xxe(() => {
        delete this._rendererDisposers[t], i.dispose();
      });
    }
    return r.increment();
  }
  _on(t, n, r, i, o, a) {
    const s = super._on(t, n, r, i, o, a), u = yF.RENDERER_EVENTS[n];
    return u !== void 0 && (s.disposer = new wd([
      s.disposer,
      this._onRenderer(n, u)
    ])), s;
  }
  /**
   * Will stop any bubbling up of the event to element's parents.
   *
   * Should be called in an event handler, e.g.:
   *
   * ```TypeScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   * ```JavaScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   */
  stopParentDispatch() {
    this._dispatchParents = !1;
  }
  /**
   * @ignore
   */
  dispatchParents(t, n) {
    const r = this._dispatchParents;
    this._dispatchParents = !0;
    try {
      this.dispatch(t, n), this._dispatchParents && this._sprite.parent && this._sprite.parent.events.dispatchParents(t, n);
    } finally {
      this._dispatchParents = r;
    }
  }
}
Object.defineProperty(yF, "RENDERER_EVENTS", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    click: function(e) {
      this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", e)) && this.dispatch("click", this._makePointerEvent("click", e));
    },
    rightclick: function(e) {
      this.isEnabled("rightclick") && this.dispatch("rightclick", this._makePointerEvent("rightclick", e));
    },
    middleclick: function(e) {
      this.isEnabled("middleclick") && this.dispatch("middleclick", this._makePointerEvent("middleclick", e));
    },
    dblclick: function(e) {
      this.dispatchParents("dblclick", this._makePointerEvent("dblclick", e));
    },
    pointerover: function(e) {
      this.isEnabled("pointerover") && this.dispatch("pointerover", this._makePointerEvent("pointerover", e));
    },
    pointerout: function(e) {
      this.isEnabled("pointerout") && this.dispatch("pointerout", this._makePointerEvent("pointerout", e));
    },
    pointerdown: function(e) {
      this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", e));
    },
    pointerup: function(e) {
      this.isEnabled("pointerup") && this.dispatch("pointerup", this._makePointerEvent("pointerup", e));
    },
    globalpointerup: function(e) {
      this.isEnabled("globalpointerup") && this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", e));
    },
    globalpointermove: function(e) {
      this.isEnabled("globalpointermove") && this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", e));
    },
    wheel: function(e) {
      this.dispatchParents("wheel", {
        type: "wheel",
        target: this._sprite,
        originalEvent: e.event,
        point: e.point
      });
    }
  }
});
class Yg extends Lf {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_adjustedLocalBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templateField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_sizeDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dragEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHidden", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isShowing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isHiding", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_downPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_toggleDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_hoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipMoveDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipPointerDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_statesHandled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this.setPrivateRaw("visible", !0), super._afterNew();
  }
  _markDirtyKey(t) {
    super._markDirtyKey(t), (t == "x" || t == "y" || t == "dx" || t == "dy") && (this.markDirtyBounds(), this._addPercentagePositionChildren(), this.markDirtyPosition());
  }
  _markDirtyPrivateKey(t) {
    super._markDirtyPrivateKey(t), (t == "x" || t == "y") && this.markDirtyPosition();
  }
  _removeTemplateField() {
    this._templateField && this._templateField._removeObjectTemplate(this);
  }
  _createEvents() {
    return new yF(this);
  }
  _processTemplateField() {
    let t;
    const n = this.get("templateField");
    if (n) {
      const r = this.dataItem;
      if (r) {
        const i = r.dataContext;
        i && (t = i[n], !(t instanceof nC) && t && (t = nC.new(t)));
      }
    }
    this._templateField !== t && (this._removeTemplateField(), this._templateField = t, t && t._setObjectTemplate(this), this._applyTemplates());
  }
  // TODO change this to run before the element is added to the parent, so that way
  //      it doesn't need to apply the themes twice
  _setDataItem(t) {
    const n = this._dataItem;
    this._dataItem = t, this._processTemplateField();
    const r = "dataitemchanged";
    t != n && this.events.isEnabled(r) && this.events.dispatch(r, {
      type: r,
      target: this,
      oldDataItem: n,
      newDataItem: t
    });
  }
  /**
   * A [[DataItem]] used for this element.
   *
   * NOTE: data item is being assigned automatically in most cases where it
   * matters. Use this accessor to set data item only if you know what you're
   * doing.
   *
   * @param  value  Data item
   */
  set dataItem(t) {
    this._setDataItem(t);
  }
  /**
   * @return DataItem
   */
  get dataItem() {
    if (this._dataItem)
      return this._dataItem;
    {
      let t = this._parent;
      for (; t; ) {
        if (t._dataItem)
          return t._dataItem;
        t = t._parent;
      }
    }
  }
  _addPercentageSizeChildren() {
    let t = this.parent;
    t && (this.get("width") instanceof hi || this.get("height") instanceof hi ? mk(t._percentageSizeChildren, this) : Md(t._percentageSizeChildren, this));
  }
  _addPercentagePositionChildren() {
    let t = this.parent;
    t && (this.get("x") instanceof hi || this.get("y") instanceof hi ? mk(t._percentagePositionChildren, this) : Md(t._percentagePositionChildren, this));
  }
  /**
   * @ignore
   */
  markDirtyPosition() {
    this._root._addDirtyPosition(this);
  }
  updatePivotPoint() {
    const t = this._localBounds;
    if (t) {
      const n = this.get("centerX");
      n != null && (this._display.pivot.x = t.left + vy(n, t.right - t.left));
      const r = this.get("centerY");
      r != null && (this._display.pivot.y = t.top + vy(r, t.bottom - t.top));
    }
  }
  _beforeChanged() {
    if (super._beforeChanged(), this._handleStates(), this.isDirty("tooltip")) {
      const t = this._prevSettings.tooltip;
      t && t.dispose();
    }
    if ((this.isDirty("layer") || this.isDirty("layerMargin")) && (this._display.setLayer(this.get("layer"), this.get("layerMargin")), this.markDirtyLayer()), this.isDirty("tooltipPosition")) {
      const t = this._tooltipMoveDp;
      t && (t.dispose(), this._tooltipMoveDp = void 0);
      const n = this._tooltipPointerDp;
      n && (n.dispose(), this._tooltipPointerDp = void 0), this.get("tooltipPosition") == "pointer" && (this.isHover() && (this._tooltipMoveDp = this.events.on("globalpointermove", (r) => {
        this.showTooltip(r.point);
      })), this._tooltipPointerDp = new wd([
        this.events.on("pointerover", () => {
          this._tooltipMoveDp = this.events.on("globalpointermove", (r) => {
            this.showTooltip(r.point);
          });
        }),
        this.events.on("pointerout", () => {
          const r = this._tooltipMoveDp;
          r && (r.dispose(), this._tooltipMoveDp = void 0);
        })
      ]));
    }
  }
  _handleStates() {
    this._statesHandled || (this.isDirty("active") && (this.get("active") ? (this.states.applyAnimate("active"), this.set("ariaChecked", !0)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !1)), this.markDirtyAccessibility()), this.isDirty("disabled") && (this.get("disabled") ? (this.states.applyAnimate("disabled"), this.set("ariaChecked", !1)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !0)), this.markDirtyAccessibility()), this._statesHandled = !0);
  }
  _changed() {
    super._changed();
    const t = this._display, n = this.events;
    if (this.isDirty("draggable")) {
      const r = this.get("draggable");
      r ? (this.set("interactive", !0), this._dragDp = new wd([
        n.on("pointerdown", (i) => {
          this.dragStart(i);
        }),
        n.on("globalpointermove", (i) => {
          this.dragMove(i);
        }),
        n.on("globalpointerup", (i) => {
          this.dragStop(i);
        })
      ])) : this._dragDp && (this._dragDp.dispose(), this._dragDp = void 0), t.cancelTouch = !!r;
    }
    if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
      const r = this.get("tooltipText"), i = this.get("tooltipHTML"), o = this.get("showTooltipOn", "hover");
      this._tooltipDp && (this._tooltipDp.dispose(), this._tooltipDp = void 0), (r || i) && (o == "click" ? (this._tooltipDp = new wd([
        n.on("click", () => {
          this.setTimeout(() => this.showTooltip(), 10);
        }),
        Ja(document, "click", (a) => {
          this.hideTooltip();
        })
      ]), this._disposers.push(this._tooltipDp)) : o == "always" || (this._tooltipDp = new wd([
        n.on("pointerover", () => {
          this.showTooltip();
        }),
        n.on("pointerout", () => {
          this.hideTooltip();
        })
      ]), this._disposers.push(this._tooltipDp)));
    }
    if (this.isDirty("toggleKey")) {
      let r = this.get("toggleKey");
      r && r != "none" ? this._toggleDp = n.on("click", () => {
        this._isDragging || this.set(r, !this.get(r));
      }) : this._toggleDp && (this._toggleDp.dispose(), this._toggleDp = void 0);
    }
    if (this.isDirty("opacity") && (t.alpha = Math.max(0, this.get("opacity", 1))), this.isDirty("rotation") && (this.markDirtyBounds(), t.angle = this.get("rotation", 0)), this.isDirty("scale") && (this.markDirtyBounds(), t.scale = this.get("scale", 0)), (this.isDirty("centerX") || this.isDirty("centerY")) && (this.markDirtyBounds(), this.updatePivotPoint()), (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) && (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (t.visible = !1, this.hideTooltip()) : t.visible = !0, this.markDirtyBounds(), this.get("focusable") && this.markDirtyAccessibility()), this.isDirty("width") || this.isDirty("height")) {
      this.markDirtyBounds(), this._addPercentageSizeChildren();
      const r = this.parent;
      r && (this.isDirty("width") && this.get("width") instanceof hi || this.isDirty("height") && this.get("height") instanceof hi) && (r.markDirty(), r._prevWidth = 0), this._sizeDirty = !0;
    }
    if ((this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && (this.markDirtyBounds(), this._sizeDirty = !0), this._sizeDirty && this._updateSize(), this.isDirty("wheelable")) {
      const r = this.get("wheelable");
      r && this.set("interactive", !0), t.wheelable = !!r;
    }
    if ((this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this)), this.isDirty("filter") && (t.filter = this.get("filter")), this.isDirty("cursorOverStyle") && (t.cursorOverStyle = this.get("cursorOverStyle")), this.isDirty("hoverOnFocus") && (this.get("hoverOnFocus") ? this._focusDp = new wd([
      n.on("focus", () => {
        this.showTooltip();
      }),
      n.on("blur", () => {
        this.hideTooltip();
      })
    ]) : this._focusDp && (this._focusDp.dispose(), this._focusDp = void 0)), this.isDirty("focusable") && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this), this.markDirtyAccessibility()), this.isPrivateDirty("focusable") && this.markDirtyAccessibility(), (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) && this.markDirtyAccessibility(), this.isDirty("exportable") && (t.exportable = this.get("exportable")), this.isDirty("interactive")) {
      const r = this.events;
      this.get("interactive") ? this._hoverDp = new wd([
        r.on("click", (i) => {
          Mfe(i.originalEvent) && (this.getPrivate("touchHovering") || this.setTimeout(() => {
            this._handleOver(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.showTooltip(), this.setPrivateRaw("touchHovering", !0), this.events.dispatch("pointerover", {
              type: "pointerover",
              target: i.target,
              originalEvent: i.originalEvent,
              point: i.point,
              simulated: i.simulated
            });
          }, 10));
        }),
        r.on("globalpointerup", (i) => {
          Mfe(i.originalEvent) && this.getPrivate("touchHovering") && (this._handleOut(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.hideTooltip(), this.setPrivateRaw("touchHovering", !1), this.events.dispatch("pointerout", {
            type: "pointerout",
            target: i.target,
            originalEvent: i.originalEvent,
            point: i.point,
            simulated: i.simulated
          })), this._isDown && this._handleUp(i);
        }),
        r.on("pointerover", () => {
          this._handleOver();
        }),
        r.on("pointerout", () => {
          this._handleOut();
        }),
        r.on("pointerdown", (i) => {
          this._handleDown(i);
        })
      ]) : (this._display.interactive = !1, this._hoverDp && (this._hoverDp.dispose(), this._hoverDp = void 0));
    }
    this.isDirty("forceInactive") && (this._display.inactive = this.get("forceInactive", !1)), this.get("showTooltipOn") == "always" && this._display.visible && this.showTooltip();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStart(t) {
    this._dragEvent = t, this.events.stopParentDispatch();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStop(t) {
    if (this._dragEvent = void 0, this._dragPoint = void 0, this.events.stopParentDispatch(), this._isDragging) {
      this._isDragging = !1;
      const n = "dragstop";
      this.events.isEnabled(n) && this.events.dispatch(n, {
        type: n,
        target: this,
        originalEvent: t.originalEvent,
        point: t.point,
        simulated: t.simulated
      });
    }
  }
  _handleOver() {
    this.isHidden() || (this.get("active") && this.states.lookup("hoverActive") ? this.states.applyAnimate("hoverActive") : this.get("disabled") && this.states.lookup("hoverDisabled") ? this.states.applyAnimate("hoverDisabled") : this.states.applyAnimate("hover"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleOut() {
    this.isHidden() || (this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : (this.states.lookup("hover") || this.states.lookup("hoverActive")) && this.states.applyAnimate("default"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleUp(t) {
    if (!this.isHidden()) {
      this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : this.states.lookup("down") && (this.isHover() ? this.states.applyAnimate("hover") : this.states.applyAnimate("default")), this._downPoint = void 0;
      const n = HY(t.originalEvent);
      delete this._downPoints[n], jl(this._downPoints).length == 0 && (this._isDown = !1);
    }
  }
  _hasMoved(t) {
    const n = HY(t.originalEvent), r = this._downPoints[n];
    if (r) {
      const i = Math.abs(r.x - t.point.x), o = Math.abs(r.y - t.point.y);
      return i > 5 || o > 5;
    }
    return !1;
  }
  _hasDown() {
    return jl(this._downPoints).length > 0;
  }
  _handleDown(t) {
    const n = this.parent;
    if (n && !this.get("draggable") && n._handleDown(t), this.get("interactive") && !this.isHidden()) {
      this.states.lookup("down") && this.states.applyAnimate("down"), this._downPoint = {
        x: t.point.x,
        y: t.point.y
      }, this._isDown = !0;
      const r = HY(t.originalEvent);
      this._downPoints[r] = {
        x: t.point.x,
        y: t.point.y
      };
    }
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragMove(t) {
    let n = this._dragEvent;
    if (n) {
      if (n.simulated && !t.simulated)
        return !0;
      let r = 0, i = this.parent;
      for (; i != null; )
        r += i.get("rotation", 0), i = i.parent;
      let o = t.point.x - n.point.x, a = t.point.y - n.point.y;
      const s = this.events;
      if (n.simulated && !this._isDragging) {
        this._isDragging = !0, this._dragEvent = t, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const u = "dragstart";
        s.isEnabled(u) && s.dispatch(u, {
          type: u,
          target: this,
          originalEvent: t.originalEvent,
          point: t.point,
          simulated: t.simulated
        });
      }
      if (this._isDragging) {
        let u = this._dragPoint;
        this.set("x", u.x + o * wq(r) + a * xq(r)), this.set("y", u.y + a * wq(r) - o * xq(r));
        const l = "dragged";
        s.isEnabled(l) && s.dispatch(l, {
          type: l,
          target: this,
          originalEvent: t.originalEvent,
          point: t.point,
          simulated: t.simulated
        });
      } else if (Math.hypot(o, a) > 5) {
        this._isDragging = !0, this._dragEvent = t, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const u = "dragstart";
        s.isEnabled(u) && s.dispatch(u, {
          type: u,
          target: this,
          originalEvent: t.originalEvent,
          point: t.point,
          simulated: t.simulated
        });
      }
    }
  }
  _updateSize() {
  }
  _getBounds() {
    this._localBounds = this._display.getLocalBounds();
  }
  /**
   * Returns depth (how deep in the hierachy of the content tree) of this
   * element.
   *
   * @return Depth
   */
  depth() {
    let t = this.parent, n = 0;
    for (; ; )
      if (t)
        ++n, t = t.parent;
      else
        return n;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtyBounds() {
    const t = this._display;
    if (this.get("isMeasured")) {
      this._root._addDirtyBounds(this), t.isMeasured = !0, t.invalidateBounds();
      const n = this.parent;
      n && this.get("position") != "absolute" && (n.get("width") == null || n.get("height") == null || n.get("layout")) && n.markDirtyBounds(), this.get("focusable") && this.isFocus() && this.markDirtyAccessibility();
    }
  }
  /**
   * @ignore
   */
  markDirtyAccessibility() {
    this._root._invalidateAccessibility(this);
  }
  /**
   * @ignore
   */
  markDirtyLayer() {
    this._display.markDirtyLayer(!0);
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this.markDirtyLayer();
  }
  _updateBounds() {
    const t = this._adjustedLocalBounds;
    let n;
    if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (n = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this._localBounds = n, this._adjustedLocalBounds = n) : (this._getBounds(), this._fixMinBounds(this._localBounds), this.updatePivotPoint(), this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds), n = this._adjustedLocalBounds), !t || t.left !== n.left || t.top !== n.top || t.right !== n.right || t.bottom !== n.bottom) {
      const r = "boundschanged";
      this.events.isEnabled(r) && this.events.dispatch(r, { type: r, target: this }), this.parent && (this.parent.markDirty(), this.parent.markDirtyBounds());
    }
  }
  _fixMinBounds(t) {
    let n = this.get("minWidth", this.getPrivate("minWidth")), r = this.get("minHeight", this.getPrivate("minHeight"));
    Cn(n) && t.right - t.left < n && (t.right = t.left + n), Cn(r) && t.bottom - t.top < r && (t.bottom = t.top + r);
    let i = this.getPrivate("width"), o = this.getPrivate("height");
    Cn(i) && (i > 0 ? t.right = t.left + i : t.left = t.right + i), Cn(o) && (o > 0 ? t.bottom = t.top + o : t.top = t.bottom + o);
  }
  _removeParent(t) {
    t && (t.children.removeValue(this), Md(t._percentageSizeChildren, this), Md(t._percentagePositionChildren, this));
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._statesHandled = !1;
  }
  /**
   * Simulate hover over element.
   */
  hover() {
    this.showTooltip(), this._handleOver();
  }
  /**
   * Simulate unhover over element.
   */
  unhover() {
    this.hideTooltip(), this._handleOut();
  }
  /**
   * Shows element's [[Tooltip]].
   */
  showTooltip(t) {
    const n = this.getTooltip(), r = this.get("tooltipText"), i = this.get("tooltipHTML");
    if ((r || i) && n) {
      const o = this.get("tooltipPosition"), a = this.getPrivate("tooltipTarget", this);
      (o == "fixed" || !t) && (this._display._setMatrix(), t = this.toGlobal(a._getTooltipPoint())), n.set("pointTo", t), n.set("tooltipTarget", a), n.get("x") || n.set("x", t.x), n.get("y") || n.set("y", t.y), r && n.label.set("text", r), i && n.label.set("html", i);
      const s = this.dataItem;
      if (s && n.label._setDataItem(s), this.get("showTooltipOn") == "always" && (t.x < 0 || t.x > this._root.width() || t.y < 0 || t.y > this._root.height())) {
        this.hideTooltip();
        return;
      }
      n.label.text.markDirtyText();
      const u = n.show();
      return this.setPrivateRaw("showingTooltip", !0), u;
    }
  }
  /**
   * Hides element's [[Tooltip]].
   */
  hideTooltip() {
    const t = this.getTooltip();
    if (t && (t.get("tooltipTarget") == this.getPrivate("tooltipTarget", this) || this.get("tooltip") == t)) {
      let n = t.get("keepTargetHover") && t.get("stateAnimationDuration", 0) == 0 ? 400 : void 0;
      const r = t.hide(n);
      return this.setPrivateRaw("showingTooltip", !1), r;
    }
  }
  _getTooltipPoint() {
    const t = this._localBounds;
    if (t) {
      let n = 0, r = 0;
      return this.get("isMeasured") ? (n = t.left + vy(this.get("tooltipX", 0), t.right - t.left), r = t.top + vy(this.get("tooltipY", 0), t.bottom - t.top)) : (n = vy(this.get("tooltipX", 0), this.width()), r = vy(this.get("tooltipY", 0), this.height())), { x: n, y: r };
    }
    return { x: 0, y: 0 };
  }
  /**
   * Returns [[Tooltip]] used for this element.
   *
   * @return Tooltip
   */
  getTooltip() {
    let t = this.get("tooltip");
    if (t)
      return t;
    {
      let n = this.parent;
      if (n)
        return n.getTooltip();
    }
  }
  _updatePosition() {
    const t = this.parent;
    let n = this.get("dx", 0), r = this.get("dy", 0), i = this.get("x"), o = this.getPrivate("x"), a = 0, s = 0;
    const u = this.get("position");
    i instanceof hi && (t ? i = t.innerWidth() * i.value + t.get("paddingLeft", 0) : i = 0), Cn(i) ? a = i + n : o != null ? a = o : t && u == "relative" && (a = t.get("paddingLeft", 0) + n);
    let l = this.get("y"), f = this.getPrivate("y");
    l instanceof hi && (t ? l = t.innerHeight() * l.value + t.get("paddingTop", 0) : l = 0), Cn(l) ? s = l + r : f != null ? s = f : t && u == "relative" && (s = t.get("paddingTop", 0) + r);
    const h = this._display;
    if (h.x != a || h.y != s) {
      h.invalidateBounds(), h.x = a, h.y = s;
      const p = "positionchanged";
      this.events.isEnabled(p) && this.events.dispatch(p, { type: p, target: this });
    }
    this.getPrivate("showingTooltip") && this.showTooltip();
  }
  /**
   * Returns element's actual X position in pixels.
   *
   * @return X (px)
   */
  x() {
    let t = this.get("x"), n = this.getPrivate("x");
    const r = this.parent;
    return r ? t instanceof hi ? vy(t, r.innerWidth()) + r.get("paddingLeft", 0) : Cn(t) ? t : n ?? r.get("paddingLeft", this._display.x) : this._display.x;
  }
  /**
   * Returns element's actual Y position in pixels.
   *
   * @return Y (px)
   */
  y() {
    let t = this.getPrivate("y");
    if (t != null)
      return t;
    let n = this.get("y");
    const r = this.parent;
    return r ? n instanceof hi ? vy(n, r.innerHeight()) + r.get("paddingTop", 0) : Cn(n) ? n : t ?? r.get("paddingTop", this._display.y) : this._display.y;
  }
  _dispose() {
    super._dispose(), this._display.dispose(), this._removeTemplateField(), this._removeParent(this.parent), this._root._removeFocusElement(this);
    const t = this.get("tooltip");
    t && t.dispose(), this.markDirty();
  }
  /**
   * @ignore
   */
  adjustedLocalBounds() {
    return this._fixMinBounds(this._adjustedLocalBounds), this._adjustedLocalBounds;
  }
  /**
   * Returns local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  localBounds() {
    return this._localBounds;
  }
  /**
   * Returns adjusted local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  bounds() {
    const t = this._adjustedLocalBounds, n = this.x(), r = this.y();
    return { left: t.left + n, right: t.right + n, top: t.top + r, bottom: t.bottom + r };
  }
  /**
   * Returns global coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  globalBounds() {
    const t = this.localBounds(), n = this.toGlobal({ x: t.left, y: t.top }), r = this.toGlobal({ x: t.right, y: t.top }), i = this.toGlobal({ x: t.right, y: t.bottom }), o = this.toGlobal({ x: t.left, y: t.bottom });
    return {
      left: Math.min(n.x, r.x, i.x, o.x),
      top: Math.min(n.y, r.y, i.y, o.y),
      right: Math.max(n.x, r.x, i.x, o.x),
      bottom: Math.max(n.y, r.y, i.y, o.y)
    };
  }
  _onShow(t) {
  }
  _onHide(t) {
  }
  /**
   * Plays initial reveal animation regardless if element is currently hidden
   * or visible.
   *
   * @param   duration  Duration of the animation in milliseconds
   * @param   delay     Delay showing of the element by X milliseconds
   * @return            Promise
   */
  appear(t, n) {
    return Ry(this, void 0, void 0, function* () {
      return yield this.hide(0), n ? new Promise((r, i) => {
        this.setTimeout(() => {
          r(this.show(t));
        }, n);
      }) : this.show(t);
    });
  }
  /**
   * Shows currently hidden element and returns a `Promise` which completes
   * when all showing animations are finished.
   *
   * ```TypeScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   * ```JavaScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   *
   * @return Promise
   */
  show(t) {
    return Ry(this, void 0, void 0, function* () {
      if (!this._isShowing) {
        this._isHidden = !1, this._isShowing = !0, this._isHiding = !1, this.states.lookup("default").get("visible") && this.set("visible", !0), this._onShow(t);
        const n = this.states.applyAnimate("default", t);
        yield Afe(n), this._isShowing = !1;
      }
    });
  }
  /**
   * Hides the element and returns a `Promise` which completes when all hiding
   * animations are finished.
   *
   * ```TypeScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   * ```JavaScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   *
   * @return Promise
   */
  hide(t) {
    return Ry(this, void 0, void 0, function* () {
      if (!this._isHiding && !this._isHidden) {
        this._isHiding = !0, this._isShowing = !1;
        let n = this.states.lookup("hidden");
        n || (n = this.states.create("hidden", {
          opacity: 0,
          visible: !1
        })), this._isHidden = !0, this._onHide(t);
        const r = this.states.applyAnimate("hidden", t);
        yield Afe(r), this._isHiding = !1;
      }
    });
  }
  /**
   * Returns `true` if this element is currently hidden.
   *
   * @return Is hidden?
   */
  isHidden() {
    return this._isHidden;
  }
  /**
   * Returns `true` if this element is currently animating to a default state.
   *
   * @return Is showing?
   */
  isShowing() {
    return this._isShowing;
  }
  /**
   * Returns `true` if this element is currently animating to a hidden state.
   *
   * @return Is hiding?
   */
  isHiding() {
    return this._isHiding;
  }
  /**
   * Returns `true` if this element is currently hovered by a pointer.
   *
   * @return Is hovered?
   */
  isHover() {
    return this._display.hovering();
  }
  /**
   * Returns `true` if this element does currently have focus.
   *
   * @return Is focused?
   */
  isFocus() {
    return this._root.focused(this);
  }
  /**
   * Returns `true` if this element is currently being dragged.
   *
   * @return Is dragged?
   */
  isDragging() {
    return this._isDragging;
  }
  /**
   * Returns `false` if if either public or private setting `visible` is set
   * to `false`, or `forceHidden` is set to `true`.
   *
   * @return Visible?
   */
  isVisible() {
    return !!(this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden"));
  }
  /**
   * Same as `isVisible()`, except it checks all ascendants, too.
   *
   * @since 5.2.7
   * @return Visible?
   */
  isVisibleDeep() {
    return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible();
  }
  /**
   * Returns an actual opacity of the element, taking into account all parents.
   *
   * @return Opacity
   * @since 5.2.11
   */
  compositeOpacity() {
    const t = this.get("opacity", 1);
    return this._parent ? this._parent.compositeOpacity() * t : t;
  }
  /**
   * Returns width of this element in pixels.
   *
   * @return Width (px)
   */
  width() {
    let t = this.get("width"), n = this.get("maxWidth", this.getPrivate("maxWidth")), r = this.get("minWidth", this.getPrivate("minWidth")), i = this.getPrivate("width"), o = 0;
    if (Cn(i))
      o = i;
    else if (t == null)
      this._adjustedLocalBounds && (o = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left);
    else if (t instanceof hi) {
      const a = this.parent;
      a ? o = a.innerWidth() * t.value : o = this._root.width() * t.value;
    } else
      Cn(t) && (o = t);
    return Cn(r) && (o = Math.max(r, o)), Cn(n) && (o = Math.min(n, o)), o;
  }
  /**
   * Returns maximum allowed width of this element in pixels.
   *
   * @return Maximum width (px)
   */
  maxWidth() {
    let t = this.get("maxWidth", this.getPrivate("maxWidth"));
    if (Cn(t))
      return t;
    {
      let r = this.get("width");
      if (Cn(r))
        return r;
    }
    const n = this.parent;
    return n ? n.innerWidth() : this._root.width();
  }
  /**
   * Returns maximum allowed height of this element in pixels.
   *
   * @return Maximum height (px)
   */
  maxHeight() {
    let t = this.get("maxHeight", this.getPrivate("maxHeight"));
    if (Cn(t))
      return t;
    {
      let r = this.get("height");
      if (Cn(r))
        return r;
    }
    const n = this.parent;
    return n ? n.innerHeight() : this._root.height();
  }
  /**
   * Returns height of this element in pixels.
   *
   * @return Height (px)
   */
  height() {
    let t = this.get("height"), n = this.get("maxHeight", this.getPrivate("maxHeight")), r = this.get("minHeight", this.getPrivate("minHeight")), i = this.getPrivate("height"), o = 0;
    if (Cn(i))
      o = i;
    else if (t == null)
      this._adjustedLocalBounds && (o = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top);
    else if (t instanceof hi) {
      const a = this.parent;
      a ? o = a.innerHeight() * t.value : o = this._root.height() * t.value;
    } else
      Cn(t) && (o = t);
    return Cn(r) && (o = Math.max(r, o)), Cn(n) && (o = Math.min(n, o)), o;
  }
  _findStaticTemplate(t) {
    return this._templateField && t(this._templateField) ? this._templateField : super._findStaticTemplate(t);
  }
  _walkParents(t) {
    this._parent && this._walkParent(t);
  }
  _walkParent(t) {
    this._parent && this._parent._walkParent(t), t(this);
  }
  /**
   * Parent [[Container]] of this element.
   *
   * @return Parent container
   */
  get parent() {
    return this._parent;
  }
  _setParent(t, n = !1) {
    const r = this._parent;
    t !== r && (this.markDirtyBounds(), t.markDirty(), this._parent = t, n && (this._removeParent(r), t && (this._addPercentageSizeChildren(), this._addPercentagePositionChildren())), this.markDirtyPosition(), this._applyThemes());
  }
  /**
   * Returns an instance of [[NumberFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return NumberFormatter instace
   */
  getNumberFormatter() {
    return this.get("numberFormatter", this._root.numberFormatter);
  }
  /**
   * Returns an instance of [[DateFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DateFormatter instace
   */
  getDateFormatter() {
    return this.get("dateFormatter", this._root.dateFormatter);
  }
  /**
   * Returns an instance of [[DurationFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DurationFormatter instace
   */
  getDurationFormatter() {
    return this.get("durationFormatter", this._root.durationFormatter);
  }
  /**
   * Converts X/Y coordinate within this element to a global coordinate.
   *
   * @param  point  Local coordinate
   * @return        Global coordinate
   */
  toGlobal(t) {
    return this._display.toGlobal(t);
  }
  /**
   * Converts global X/Y coordinate to a coordinate within this element.
   *
   * @param  point  Global coordinate
   * @return        Local coordinate
   */
  toLocal(t) {
    return this._display.toLocal(t);
  }
  _getDownPoint() {
    const t = this._getDownPointId();
    if (t)
      return this._downPoints[t];
  }
  _getDownPointId() {
    if (this._downPoints)
      return Ntt(this._downPoints, (t, n) => t > n ? 1 : t < n ? -1 : 0)[0];
  }
  /**
   * Moves sprite to the end of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toFront() {
    const t = this.parent;
    t && t.children.moveValue(this, t.children.length - 1);
  }
  /**
   * Moves sprite to the beginning of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toBack() {
    const t = this.parent;
    t && t.children.moveValue(this, 0);
  }
}
Object.defineProperty(Yg, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Sprite"
});
Object.defineProperty(Yg, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Lf.classNames.concat([Yg.className])
});
class yk extends Lf {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_backgroundDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_pattern", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  get pattern() {
    return this._pattern;
  }
  _draw() {
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("color") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fill") || this.isDirty("fillOpacity")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const t = this.get("repetition", ""), n = this.get("width", 100), r = this.get("height", 100), i = this.get("fill"), o = this.get("fillOpacity", 1);
      this._display.clear(), this._backgroundDisplay.clear(), i && o > 0 && (this._backgroundDisplay.beginFill(i, o), this._backgroundDisplay.drawRect(0, 0, n, r), this._backgroundDisplay.endFill()), this._display.angle = this.get("rotation", 0), this._draw(), this._pattern = this._root._renderer.createPattern(this._display, this._backgroundDisplay, t, n, r);
    }
  }
}
Object.defineProperty(yk, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Pattern"
});
Object.defineProperty(yk, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Lf.classNames.concat([yk.className])
});
class vk extends yk {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged(), this._clear = !0, this.isDirty("src") && this._load();
  }
  _draw() {
    super._draw();
    const t = this._image;
    if (t) {
      const n = this.get("width", 100), r = this.get("height", 100), i = this.get("fit", "image");
      let o = 0, a = 0;
      i == "pattern" ? (o = n, a = r) : (o = t.width, a = t.height, i == "image" && (this.set("width", o), this.set("height", a)));
      const s = this.get("centered", !0);
      let u = 0, l = 0;
      s && (u = n / 2 - o / 2, l = r / 2 - a / 2), this._display.image(t, o, a, u, l);
    }
  }
  _load() {
    const t = this.get("src");
    if (t) {
      const n = new Image();
      n.src = t, n.decode().then(() => {
        this._image = n, this._draw(), this.events.isEnabled("loaded") && this.events.dispatch("loaded", { type: "loaded", target: this });
      }).catch((r) => {
      });
    }
  }
}
Object.defineProperty(vk, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PicturePattern"
});
Object.defineProperty(vk, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: yk.classNames.concat([vk.className])
});
var Zj;
(function(e) {
  e.ADD = "lighter", e.COLOR = "color", e.COLOR_BURN = "color-burn", e.COLOR_DODGE = "color-dodge", e.DARKEN = "darken", e.DIFFERENCE = "difference", e.DST_OVER = "destination-over", e.EXCLUSION = "exclusion", e.HARD_LIGHT = "hard-light", e.HUE = "hue", e.LIGHTEN = "lighten", e.LUMINOSITY = "luminosity", e.MULTIPLY = "multiply", e.NORMAL = "source-over", e.OVERLAY = "overlay", e.SATURATION = "saturation", e.SCREEN = "screen", e.SOFT_LIGHT = "soft-light", e.SRC_ATOP = "source-atop", e.XOR = "xor";
})(Zj || (Zj = {}));
class sb extends Yg {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _beforeChanged() {
    if (super._beforeChanged(), (this.isDirty("draw") || this.isDirty("svgPath")) && this.markDirtyBounds(), (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) && (this._clear = !0), this._display.crisp = this.get("crisp", !1), this.isDirty("fillGradient")) {
      const t = this.get("fillGradient");
      if (t) {
        this._display.isMeasured = !0;
        const n = t.get("target");
        n && (this._disposers.push(n.events.on("boundschanged", () => {
          this._markDirtyKey("fill");
        })), this._disposers.push(n.events.on("positionchanged", () => {
          this._markDirtyKey("fill");
        })));
      }
    }
    if (this.isDirty("strokeGradient")) {
      const t = this.get("strokeGradient");
      if (t) {
        this._display.isMeasured = !0;
        const n = t.get("target");
        n && (this._disposers.push(n.events.on("boundschanged", () => {
          this._markDirtyKey("stroke");
        })), this._disposers.push(n.events.on("positionchanged", () => {
          this._markDirtyKey("stroke");
        })));
      }
    }
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds(), this.markDirtyLayer(), this._display.clear();
      let t = this.get("strokeDasharray");
      Cn(t) && (t < 0.5 ? t = [0] : t = [t]), this._display.setLineDash(t);
      const n = this.get("strokeDashoffset");
      n && this._display.setLineDashOffset(n);
      const r = this.get("blendMode", Zj.NORMAL);
      this._display.blendMode = r;
      const i = this.get("draw");
      i && i(this._display, this);
      const o = this.get("svgPath");
      o != null && this._display.svgPath(o);
    }
  }
  _afterChanged() {
    if (super._afterChanged(), this._clear) {
      const t = this.get("fill"), n = this.get("fillGradient"), r = this.get("fillPattern"), i = this.get("fillOpacity"), o = this.get("stroke"), a = this.get("strokeGradient"), s = this.get("strokePattern"), u = this.get("shadowColor"), l = this.get("shadowBlur"), f = this.get("shadowOffsetX"), h = this.get("shadowOffsetY"), p = this.get("shadowOpacity");
      if (u && (l || f || h) && this._display.shadow(u, l, f, h, p), r) {
        let g = !1;
        t && (!r.get("fill") || r.get("fillInherited")) && (r.set("fill", t), r.set("fillInherited", !0), g = !0), o && (!r.get("color") || r.get("colorInherited")) && (r.set("color", o), r.set("colorInherited", !0), g = !0), g && r._changed();
        const y = r.pattern;
        y && (this._display.beginFill(y, i), this._display.endFill(), r instanceof vk && r.events.once("loaded", () => {
          this._clear = !0, this.markDirty();
        }));
      } else if (n) {
        if (t) {
          const y = n.get("stops", []);
          y.length && ut(y, (b) => {
            (!b.color || b.colorInherited) && t && (b.color = t, b.colorInherited = !0), (b.opacity == null || b.opacityInherited) && (b.opacity = i, b.opacityInherited = !0);
          });
        }
        const g = n.getFill(this);
        g && (this._display.beginFill(g, i), this._display.endFill());
      } else
        t && (this._display.beginFill(t, i), this._display.endFill());
      if (o || a || s) {
        const g = this.get("strokeOpacity");
        let y = this.get("strokeWidth", 1);
        this.get("nonScalingStroke") && (y = y / this.get("scale", 1)), this.get("crisp") && (y /= this._root._renderer.resolution);
        const b = this.get("lineJoin");
        if (s) {
          let _ = !1;
          o && (!s.get("color") || s.get("colorInherited")) && (s.set("color", o), s.set("colorInherited", !0), _ = !0), _ && s._changed();
          const S = s.pattern;
          S && (this._display.lineStyle(y, S, g, b), this._display.endStroke(), s instanceof vk && s.events.once("loaded", () => {
            this._clear = !0, this.markDirty();
          }));
        } else if (a) {
          const _ = a.get("stops", []);
          _.length && ut(_, (C) => {
            (!C.color || C.colorInherited) && o && (C.color = o, C.colorInherited = !0), (C.opacity == null || C.opacityInherited) && (C.opacity = g, C.opacityInherited = !0);
          });
          const S = a.getFill(this);
          S && (this._display.lineStyle(y, S, g, b), this._display.endStroke());
        } else
          o && (this._display.lineStyle(y, o, g, b), this._display.endStroke());
      }
      this.getPrivate("showingTooltip") && this.showTooltip();
    }
    this._clear = !1;
  }
}
Object.defineProperty(sb, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Graphics"
});
Object.defineProperty(sb, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Yg.classNames.concat([sb.className])
});
class bS extends sb {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    this._display.drawRect(0, 0, this.width(), this.height());
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(bS, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Rectangle"
});
Object.defineProperty(bS, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: sb.classNames.concat([bS.className])
});
function X0(e, t) {
  e.get("reverseChildren", !1) ? e.children.eachReverse(t) : e.children.each(t);
}
class ub extends Lf {
}
Object.defineProperty(ub, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Layout"
});
Object.defineProperty(ub, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Lf.classNames.concat([ub.className])
});
class rC extends ub {
  /**
   * @ignore
   */
  updateContainer(t) {
    let n = t.get("paddingLeft", 0), r = t.innerWidth(), i = 0;
    X0(t, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let s = a.get("width");
        if (s instanceof hi) {
          i += s.value;
          let u = r * s.value, l = a.get("minWidth", a.getPrivate("minWidth", -1 / 0));
          l > u && (r -= l, i -= s.value);
          let f = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          u > f && (r -= f, i -= s.value);
        } else
          Cn(s) || (s = a.width()), r -= s + a.get("marginLeft", 0) + a.get("marginRight", 0);
      }
    }), (r <= 0 || r == 1 / 0) && (r = 0.1), X0(t, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let s = a.get("width");
        if (s instanceof hi) {
          let u = r * s.value / i - a.get("marginLeft", 0) - a.get("marginRight", 0), l = a.get("minWidth", a.getPrivate("minWidth", -1 / 0)), f = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          u = Math.min(Math.max(l, u), f), a.setPrivate("width", u);
        } else
          a._prevSettings.width instanceof hi && a.setPrivate("width", void 0);
      }
    });
    let o = n;
    X0(t, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let s = a.adjustedLocalBounds(), u = a.get("marginLeft", 0), l = a.get("marginRight", 0), f = a.get("maxWidth"), h = s.left, p = s.right;
          f && p - h > f && (p = h + f);
          let g = o + u - h;
          a.setPrivate("x", g), o = g + p + l;
        } else
          a.setPrivate("x", void 0);
    });
  }
}
Object.defineProperty(rC, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HorizontalLayout"
});
Object.defineProperty(rC, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ub.classNames.concat([rC.className])
});
class iC extends ub {
  /**
   * @ignore
   */
  updateContainer(t) {
    let n = t.get("paddingTop", 0), r = t.innerHeight(), i = 0;
    X0(t, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let s = a.get("height");
        if (s instanceof hi) {
          i += s.value;
          let u = r * s.value, l = a.get("minHeight", a.getPrivate("minHeight", -1 / 0));
          l > u && (r -= l, i -= s.value);
          let f = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          u > f && (r -= f, i -= s.value);
        } else
          Cn(s) || (s = a.height()), r -= s + a.get("marginTop", 0) + a.get("marginBottom", 0);
      }
    }), (r <= 0 || r == 1 / 0) && (r = 0.1), X0(t, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let s = a.get("height");
        if (s instanceof hi) {
          let u = r * s.value / i - a.get("marginTop", 0) - a.get("marginBottom", 0), l = a.get("minHeight", a.getPrivate("minHeight", -1 / 0)), f = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          u = Math.min(Math.max(l, u), f), a.setPrivate("height", u);
        } else
          a._prevSettings.height instanceof hi && a.setPrivate("height", void 0);
      }
    });
    let o = n;
    X0(t, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let s = a.adjustedLocalBounds(), u = a.get("marginTop", 0), l = s.top, f = s.bottom, h = a.get("maxHeight");
          h && f - l > h && (f = l + h);
          let p = a.get("marginBottom", 0), g = o + u - l;
          a.setPrivate("y", g), o = g + f + p;
        } else
          a.setPrivate("y", void 0);
    });
  }
}
Object.defineProperty(iC, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "VerticalLayout"
});
Object.defineProperty(iC, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ub.classNames.concat([iC.className])
});
class xS extends ub {
  _afterNew() {
    this._setRawDefault("maxColumns", Number.MAX_VALUE), super._afterNew();
  }
  /**
   * @ignore
   */
  updateContainer(t) {
    let n = t.get("paddingLeft", 0), r = t.get("paddingRight", 0), i = t.get("paddingTop", 0), o = t.maxWidth() - n - r, a = o, s = 1;
    X0(t, (y) => {
      if (y.get("visible") && y.getPrivate("visible") && !y.get("forceHidden") && y.get("position") != "absolute") {
        let b = y.width();
        b < a && (a = b), b > s && (s = b);
      }
    }), a = vd(a, 1, o), s = vd(s, 1, o);
    let u = 1;
    this.get("fixedWidthGrid") ? u = o / s : u = o / a, u = Math.max(1, Math.floor(u)), u = Math.min(this.get("maxColumns", Number.MAX_VALUE), u);
    let l = this.getColumnWidths(t, u, s, o), f = i, h = 0, p = 0;
    u = l.length;
    let g = n;
    X0(t, (y) => {
      if (y.get("position") == "relative" && y.isVisible()) {
        const b = y.get("marginTop", 0), _ = y.get("marginBottom", 0);
        let S = y.adjustedLocalBounds(), C = y.get("marginLeft", 0), A = y.get("marginRight", 0), O = g + C - S.left, R = f + b - S.top;
        y.setPrivate("x", O), y.setPrivate("y", R), g += l[h] + A, p = Math.max(p, y.height() + b + _), h++, h >= u && (h = 0, g = n, f += p);
      }
    });
  }
  /**
   * @ignore
   */
  getColumnWidths(t, n, r, i) {
    let o = 0, a = [], s = 0;
    return X0(t, (u) => {
      let l = u.adjustedLocalBounds();
      u.get("position") != "absolute" && u.isVisible() && (this.get("fixedWidthGrid") ? a[s] = r : a[s] = Math.max(a[s] | 0, l.right - l.left + u.get("marginLeft", 0) + u.get("marginRight", 0)), s < t.children.length - 1 && (s++, s == n && (s = 0)));
    }), ut(a, (u) => {
      o += u;
    }), o > i ? n > 2 ? (n -= 1, this.getColumnWidths(t, n, r, i)) : [i] : a;
  }
}
Object.defineProperty(xS, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GridLayout"
});
Object.defineProperty(xS, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ub.classNames.concat([xS.className])
});
class Fg {
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  static escape(t) {
    return t.replace(/\[\[/g, this.prefix + "1").replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").replace(/\]\]/g, this.prefix + "2").replace(/\{\{/g, this.prefix + "3").replace(/\}\}/g, this.prefix + "4").replace(/\'\'/g, this.prefix + "5");
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  static unescape(t) {
    return t.replace(new RegExp(this.prefix + "1", "g"), "[[").replace(new RegExp(this.prefix + "2", "g"), "]]").replace(new RegExp(this.prefix + "3", "g"), "{{").replace(new RegExp(this.prefix + "4", "g"), "}}").replace(new RegExp(this.prefix + "5", "g"), "''");
  }
  /**
   * Cleans up the text text for leftover double square brackets.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Cleaned up text
   */
  static cleanUp(t) {
    return t.replace(/\[\[/g, "[").replace(/\]\]/g, "]").replace(/\{\{/g, "{").replace(/\}\}/g, "}").replace(/\'\'/g, "'");
  }
  /**
   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
   *
   * If the second parameter `quotedBlocks` is set to `true` this method will
   * also single out text blocks enclosed within single quotes that no
   * formatting should be applied to, and they should be displayed as is.
   *
   * Default for the above is `false`, so that you can use single quote in text
   * without escaping it.
   *
   * If enabled, single quotes can be escaped by doubling it - adding two
   * single quotes, which will be replaced by a one single quote in the final
   * output.
   *
   * @ignore Exclude from docs
   * @param text          Text to chunk
   * @param quotedBlocks  Use quoted blocks
   * @param noFormatting  Formatting blocks will be treated as regular text
   * @return Array of string chunks
   */
  static chunk(t, n = !1, r = !1) {
    let i = [];
    t = this.escape(t);
    let o = n ? t.split("'") : [t];
    for (let a = 0; a < o.length; a++) {
      let s = o[a];
      if (s !== "")
        if (a % 2 === 0) {
          s = s.replace(/\]\[/g, "]" + Wx + "["), s = s.replace(/\[\]/g, "[ ]");
          let u = s.split(/[\[\]]+/);
          for (let l = 0; l < u.length; l++) {
            let f = this.cleanUp(this.unescape(u[l]));
            f !== Wx && f !== "" && (l % 2 === 0 ? i.push({
              type: "value",
              text: f
            }) : i.push({
              type: r ? "value" : "format",
              text: "[" + f + "]"
            }));
          }
        } else {
          let u = s.split(/[\[\]]+/);
          for (let l = 0; l < u.length; l++) {
            let f = this.cleanUp(this.unescape(u[l]));
            f !== "" && (l % 2 === 0 ? i.push({
              type: "text",
              text: f
            }) : this.isImage(f) ? i.push({
              type: "image",
              text: "[" + f + "]"
            }) : i.push({
              type: "format",
              text: "[" + f + "]"
            }));
          }
        }
    }
    return i;
  }
  /**
   * Checks if supplied format contains image information and should be
   * formatted as such.
   * I.e.: `[img: myImage.png]`
   *
   * @ignore
   * @param  text  Format
   * @return true if it is an image
   */
  static isImage(t) {
    return !!t.match(/img[ ]?:/);
  }
  static getTextStyle(t) {
    let n = {};
    if (t == "" || t == "[ ]")
      return {};
    const r = t.match(/('[^']*')|("[^"]*")/gi);
    if (r)
      for (let o = 0; o < r.length; o++)
        t = t.replace(r[o], r[o].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
    let i = t.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
    if (!i)
      return {};
    for (let o = 0; o < i.length; o++)
      if (i[o].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i))
        n.fontWeight = i[o];
      else if (i[o].match(/^(underline|line-through)$/i))
        n.textDecoration = i[o];
      else if (i[o] != "/")
        if (!i[o].match(/:/))
          n.fill = Mr.fromString(i[o]);
        else {
          const a = i[o].replace("+", " ").split(/:[ ]*/);
          n[a[0]] = a[1];
        }
    return n;
  }
}
Object.defineProperty(Fg, "prefix", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "__amcharts__"
});
function Jj(e, t) {
  if (t != null) {
    t = "" + t, t = Fg.escape(t);
    let n = t.match(/\{([^}]+)\}/g), r;
    if (n)
      for (r = 0; r < n.length; r++) {
        let i = n[r].replace(/\{([^}]+)\}/, "$1"), o = _q(e, i);
        o == null && (o = ""), t = t.split(n[r]).join(o);
      }
    t = Fg.unescape(t);
  } else
    t = "";
  return t;
}
function _q(e, t, n) {
  let r;
  const i = e.dataItem;
  let o = [], a = /(format[a-zA-Z]*)\((.*)\)|([^.]+)/g, s;
  for (; s = a.exec(t), s !== null; )
    if (s[3]) {
      o.push({
        prop: s[3]
      });
      const u = e.getDateFormatter().get("dateFields", []), l = e.getNumberFormatter().get("numericFields", []), f = e.getDurationFormatter().get("durationFields", []);
      u.indexOf(s[3]) !== -1 ? o.push({
        method: "formatDate",
        params: []
      }) : l.indexOf(s[3]) !== -1 ? o.push({
        method: "formatNumber",
        params: []
      }) : f.indexOf(s[3]) !== -1 && o.push({
        method: "formatDuration",
        params: []
      });
    } else {
      let u = [];
      if (tj(s[2]) != "") {
        let l = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g, f;
        for (; f = l.exec(s[2]), f !== null; )
          u.push(f[1] || f[2] || f[3]);
      }
      o.push({
        method: s[1],
        params: u
      });
    }
  if (i) {
    r = EE(e, o, i._settings), (r == null || pF(r)) && (r = EE(e, o, i));
    let u = i.dataContext;
    r == null && u && (r = EE(e, o, u), r == null && (r = EE(e, [{
      prop: t
    }], u)), r == null && u.dataContext && (r = EE(e, o, u.dataContext))), r == null && i.component && i.component.dataItem !== i && (r = _q(i.component, t));
  }
  return r == null && (r = EE(e, o, e)), r == null && e.parent && (r = _q(e.parent, t)), r;
}
function dnt(e, t) {
  const n = e.getPrivate("customData");
  if (pF(n))
    return n[t];
}
function EE(e, t, n, r) {
  let i = n, o = !1;
  for (let a = 0, s = t.length; a < s; a++) {
    let u = t[a];
    if (u.prop) {
      if (i instanceof Yg) {
        let l = i.get(u.prop);
        l == null && (l = i.getPrivate(u.prop)), l == null && (l = dnt(i, u.prop)), l == null && (l = i[u.prop]), i = l;
      } else if (i.get) {
        let l = i.get(u.prop);
        l == null && (l = i[u.prop]), i = l;
      } else
        i = i[u.prop];
      if (i == null)
        return;
    } else
      switch (u.method) {
        case "formatNumber":
          let l = xd(i);
          l != null && (i = e.getNumberFormatter().format(l, r || u.params[0] || void 0), o = !0);
          break;
        case "formatDate":
          let f = mtt(i);
          if (!yq(f) || hF(f.getTime()))
            return;
          f != null && (i = e.getDateFormatter().format(f, r || u.params[0] || void 0), o = !0);
          break;
        case "formatDuration":
          let h = xd(i);
          h != null && (i = e.getDurationFormatter().format(h, r || u.params[0] || void 0, u.params[1] || void 0), o = !0);
          break;
        case "urlEncode":
        case "encodeURIComponent":
          i = encodeURIComponent(i);
          break;
        default:
          i[u.method] && i[u.method].apply(n, u.params);
          break;
      }
  }
  if (!o) {
    let a = [{
      method: "",
      params: r
    }];
    if (r == null)
      Cn(i) ? (a[0].method = "formatNumber", a[0].params = "") : yq(i) && (a[0].method = "formatDate", a[0].params = "");
    else {
      let s = Utt(r);
      s === "number" ? a[0].method = "formatNumber" : s === "date" ? a[0].method = "formatDate" : s === "duration" && (a[0].method = "formatDuration");
    }
    a[0].method && (i = EE(e, a, i));
  }
  return i;
}
class es extends Yg {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "_childrenDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ctt(this)
    }), Object.defineProperty(this, "_percentageSizeChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_percentagePositionChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_prevWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_prevHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNew(), this._display.addChild(this._childrenDisplay);
  }
  _dispose() {
    TR(this.allChildren(), (t) => {
      t.dispose();
    }), this.getPrivate("htmlElement") && this._root._removeHTMLContent(this), super._dispose();
  }
  _changed() {
    if (super._changed(), this.isDirty("interactiveChildren") && (this._display.interactiveChildren = this.get("interactiveChildren", !1)), this.isDirty("layout") && (this._prevWidth = 0, this._prevHeight = 0, this.markDirtyBounds(), this._prevSettings.layout && this.children.each((t) => {
      t.removePrivate("x"), t.removePrivate("y");
    })), (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) && this.children.each((t) => {
      t.markDirtyPosition();
    }), this.isDirty("maskContent")) {
      const t = this._childrenDisplay;
      let n = this._contentMask;
      this.get("maskContent") ? n || (n = bS.new(this._root, {
        x: -0.5,
        y: -0.5,
        width: this.width() + 1,
        height: this.height() + 1
      }), this._contentMask = n, t.addChildAt(n._display, 0), t.mask = n._display) : n && (t.removeChild(n._display), t.mask = null, n.dispose(), this._contentMask = void 0);
    }
  }
  _updateSize() {
    super._updateSize(), ut(this._percentageSizeChildren, (t) => {
      t._updateSize();
    }), ut(this._percentagePositionChildren, (t) => {
      t.markDirtyPosition(), t._updateSize();
    }), this.updateBackground();
  }
  updateBackground() {
    const t = this.get("background");
    let n = this._localBounds;
    if (n && !this.isHidden()) {
      let r = n.left, i = n.top, o = n.right - r, a = n.bottom - i, s = this.get("maxWidth"), u = this.get("maxHeight");
      u && a > u && (a = u), s && o > s && (o = s);
      let l = this.width(), f = this.height();
      t && (t.setAll({ width: o, height: a, x: r, y: i }), this._display.interactive && (t._display.interactive = !0));
      const h = this._contentMask;
      h && h.setAll({ width: l + 1, height: f + 1 });
      const p = this.get("verticalScrollbar");
      if (p) {
        p.set("height", f), p.set("x", l - p.width() - p.get("marginRight", 0)), p.set("end", p.get("start", 0) + f / this._contentHeight);
        const g = p.get("background");
        g && g.setAll({ width: p.width(), height: f });
        let y = !0;
        this._contentHeight <= f && (y = !1), p.setPrivate("visible", y);
      }
    }
  }
  _applyThemes() {
    return super._applyThemes() ? (this.eachChildren((t) => {
      t._applyThemes();
    }), !0) : !1;
  }
  _applyState(t) {
    super._applyState(t), this.get("setStateOnChildren") && this.eachChildren((n) => {
      n.states.apply(t);
    });
  }
  _applyStateAnimated(t, n) {
    super._applyStateAnimated(t, n), this.get("setStateOnChildren") && this.eachChildren((r) => {
      r.states.applyAnimate(t, n);
    });
  }
  /**
   * Returns container's inner width (width without padding) in pixels.
   *
   * @return Inner width (px)
   */
  innerWidth() {
    return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
  }
  /**
   * Returns container's inner height (height without padding) in pixels.
   *
   * @return Inner height (px)
   */
  innerHeight() {
    return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
  }
  _getBounds() {
    let t = this.get("width"), n = this.get("height"), r = this.getPrivate("width"), i = this.getPrivate("height"), o = {
      left: 0,
      top: 0,
      right: this.width(),
      bottom: this.height()
    }, a = this.get("layout"), s = !1, u = !1;
    if ((a instanceof rC || a instanceof xS) && (s = !0), a instanceof iC && (u = !0), !((t != null || r != null) && (n != null || i != null) && !this.get("verticalScrollbar"))) {
      let l = Number.MAX_VALUE, f = l, h = -l, p = l, g = -l;
      const y = this.get("paddingLeft", 0), b = this.get("paddingTop", 0), _ = this.get("paddingRight", 0), S = this.get("paddingBottom", 0);
      this.children.each((C) => {
        if (C.get("position") != "absolute" && C.get("isMeasured")) {
          let A = C.adjustedLocalBounds(), O = C.x(), R = C.y(), j = O + A.left, $ = O + A.right, z = R + A.top, W = R + A.bottom;
          s && (j -= C.get("marginLeft", 0), $ += C.get("marginRight", 0)), u && (z -= C.get("marginTop", 0), W += C.get("marginBottom", 0)), j < f && (f = j), $ > h && (h = $), z < p && (p = z), W > g && (g = W);
        }
      }), f == l && (f = 0), h == -l && (h = 0), p == l && (p = 0), g == -l && (g = 0), o.left = f - y, o.top = p - b, o.right = h + _, o.bottom = g + S;
    }
    this._contentWidth = o.right - o.left, this._contentHeight = o.bottom - o.top, Cn(t) && (o.left = 0, o.right = t), Cn(r) && (o.left = 0, o.right = r), Cn(n) && (o.top = 0, o.bottom = n), Cn(i) && (o.top = 0, o.bottom = i), this._localBounds = o;
  }
  _updateBounds() {
    const t = this.get("layout");
    t && t.updateContainer(this), super._updateBounds(), this.updateBackground();
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this._root._addDirtyParent(this);
  }
  _prepareChildren() {
    const t = this.innerWidth(), n = this.innerHeight();
    if (t != this._prevWidth || n != this._prevHeight) {
      let r = this.get("layout"), i = !1, o = !1;
      r && ((r instanceof rC || r instanceof xS) && (i = !0), r instanceof iC && (o = !0)), ut(this._percentageSizeChildren, (a) => {
        if (!i) {
          let s = a.get("width");
          s instanceof hi && a.setPrivate("width", s.value * t);
        }
        if (!o) {
          let s = a.get("height");
          s instanceof hi && a.setPrivate("height", s.value * n);
        }
      }), ut(this._percentagePositionChildren, (a) => {
        a.markDirtyPosition(), a.markDirtyBounds();
      }), this._prevWidth = t, this._prevHeight = n, this._sizeDirty = !0, this.updateBackground();
    }
    this._handleStates();
  }
  _updateChildren() {
    if (this.isDirty("html")) {
      const t = this.get("html");
      t && t !== "" ? this._root._setHTMLContent(this, Jj(this, this.get("html", ""))) : this._root._removeHTMLContent(this), this._root._positionHTMLElement(this);
    }
    if (this.isDirty("verticalScrollbar")) {
      const t = this.get("verticalScrollbar");
      if (t) {
        t._setParent(this), t.startGrip.setPrivate("visible", !1), t.endGrip.setPrivate("visible", !1), this.set("maskContent", !0), this.set("paddingRight", t.width() + t.get("marginRight", 0) + t.get("marginLeft", 0));
        let n = this.get("background");
        n || (n = this.set("background", bS.new(this._root, {
          themeTags: ["background"],
          fillOpacity: 0,
          fill: this._root.interfaceColors.get("alternativeBackground")
        }))), this._vsbd0 = this.events.on("wheel", (r) => {
          const i = r.originalEvent;
          if (jtt(i, this))
            i.preventDefault();
          else
            return;
          let o = i.deltaY / 5e3;
          const a = t.get("start", 0), s = t.get("end", 1);
          a + o <= 0 && (o = -a), s + o >= 1 && (o = 1 - s), a + o >= 0 && s + o <= 1 && (t.set("start", a + o), t.set("end", s + o));
        }), this._disposers.push(this._vsbd0), this._vsbd1 = t.events.on("rangechanged", () => {
          let r = this._contentHeight;
          const i = this._childrenDisplay, o = this._contentMask;
          i.y = -t.get("start") * r, i.markDirtyLayer(), o && (o._display.y = -i.y, i.mask = o._display);
        }), this._disposers.push(this._vsbd1), this._display.addChild(t._display);
      } else {
        const n = this._prevSettings.verticalScrollbar;
        if (n) {
          this._display.removeChild(n._display), this._vsbd0 && this._vsbd0.dispose(), this._vsbd1 && this._vsbd1.dispose();
          const r = this._childrenDisplay;
          r.y = 0, this.setPrivate("height", void 0), this.set("maskContent", !1), this.set("paddingRight", void 0);
        }
      }
    }
    if (this.isDirty("background")) {
      const t = this._prevSettings.background;
      t && this._display.removeChild(t._display);
      const n = this.get("background");
      n instanceof Yg && (n.set("isMeasured", !1), n._setParent(this), this._display.addChildAt(n._display, 0));
    }
    if (this.isDirty("mask")) {
      const t = this.get("mask"), n = this._prevSettings.mask;
      if (n && (this._display.removeChild(n._display), n != t && n.dispose()), t) {
        const r = t.parent;
        r && r.children.removeValue(t), t._setParent(this), this._display.addChildAt(t._display, 0), this._childrenDisplay.mask = t._display;
      }
    }
  }
  _processTemplateField() {
    super._processTemplateField(), this.children.each((t) => {
      t._processTemplateField();
    });
  }
  /**
   * @ignore
   */
  walkChildren(t) {
    this.children.each((n) => {
      n instanceof es && n.walkChildren(t), t(n);
    });
  }
  eachChildren(t) {
    const n = this.get("background");
    n && t(n);
    const r = this.get("verticalScrollbar");
    r && t(r);
    const i = this.get("mask");
    i && t(i), this.children.values.forEach((o) => {
      t(o);
    });
  }
  allChildren() {
    const t = [];
    return this.eachChildren((n) => {
      t.push(n);
    }), t;
  }
  _setDataItem(t) {
    const n = t !== this._dataItem;
    super._setDataItem(t);
    const r = this.get("html", "");
    r && r !== "" && n && this._root._setHTMLContent(this, Jj(this, r));
  }
}
Object.defineProperty(es, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Container"
});
Object.defineProperty(es, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Yg.classNames.concat([es.className])
});
let bk = class extends Yg {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeTextStyle()
    }), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeText("", this.textStyle)
    }), Object.defineProperty(this, "_textStyles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale"
      ]
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _updateBounds() {
    if (this.get("text"))
      super._updateBounds();
    else {
      let t = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this._adjustedLocalBounds = t;
    }
  }
  _changed() {
    super._changed(), this._display.clear();
    let t = this.textStyle;
    if (this.isDirty("opacity")) {
      let n = this.get("opacity", 1);
      this._display.alpha = n;
    }
    if ((this.isDirty("text") || this.isDirty("populateText")) && (this._display.text = this._getText(), this.markDirtyBounds(), this.get("role") == "tooltip" && this._root.updateTooltip(this)), this.isPrivateDirty("tooltipElement") && this.getPrivate("tooltipElement") && this._disposers.push(new Bs(() => {
      this._root._removeTooltipElement(this);
    })), this.isDirty("width") && (t.wordWrapWidth = this.width(), this.markDirtyBounds()), this.isDirty("oversizedBehavior") && (t.oversizedBehavior = this.get("oversizedBehavior", "none"), this.markDirtyBounds()), this.isDirty("breakWords") && (t.breakWords = this.get("breakWords", !1), this.markDirtyBounds()), this.isDirty("ellipsis") && (t.ellipsis = this.get("ellipsis"), this.markDirtyBounds()), this.isDirty("ignoreFormatting") && (t.ignoreFormatting = this.get("ignoreFormatting", !1), this.markDirtyBounds()), this.isDirty("minScale") && (t.minScale = this.get("minScale", 0), this.markDirtyBounds()), this.isDirty("fill")) {
      let n = this.get("fill");
      n && (t.fill = n);
    }
    if (this.isDirty("fillOpacity")) {
      let n = this.get("fillOpacity", 1);
      n && (t.fillOpacity = n);
    }
    (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) && (t.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth")), this.markDirtyBounds()), (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) && (t.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight")), this.markDirtyBounds()), ut(this._textStyles, (n) => {
      this._dirty[n] && (t[n] = this.get(n), this.markDirtyBounds());
    }), t.fontSize = this.get("fontSize"), t.fontFamily = this.get("fontFamily"), this._display.style = t, this.isDirty("role") && this.get("role") == "tooltip" && this._root.updateTooltip(this);
  }
  _getText() {
    const t = this.get("text", "");
    return this.get("populateText") ? Jj(this, t) : t;
  }
  /**
   * Forces the text to be re-evaluated and re-populated.
   */
  markDirtyText() {
    this._display.text = this._getText(), this.get("role") == "tooltip" && this._root.updateTooltip(this), this.markDirtyBounds(), this.markDirty();
  }
  _setDataItem(t) {
    super._setDataItem(t), this.get("populateText") && this.markDirtyText();
  }
  getNumberFormatter() {
    return this.parent ? this.parent.getNumberFormatter() : super.getNumberFormatter();
  }
  getDateFormatter() {
    return this.parent ? this.parent.getDateFormatter() : super.getDateFormatter();
  }
  getDurationFormatter() {
    return this.parent ? this.parent.getDurationFormatter() : super.getDurationFormatter();
  }
};
Object.defineProperty(bk, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Text"
});
Object.defineProperty(bk, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Yg.classNames.concat([bk.className])
});
class hnt {
  constructor() {
    Object.defineProperty(this, "_observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this._observer = new ResizeObserver((t) => {
      ut(t, (n) => {
        ut(this._targets, (r) => {
          r.target === n.target && r.callback();
        });
      });
    });
  }
  addTarget(t, n) {
    this._observer.observe(t, { box: "border-box" }), this._targets.push({ target: t, callback: n });
  }
  removeTarget(t) {
    this._observer.unobserve(t), gF(this._targets, (n) => n.target !== t);
  }
}
class vF {
  constructor() {
    Object.defineProperty(this, "_timer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  addTarget(t, n) {
    if (this._timer === null) {
      let i = null;
      const o = () => {
        const a = Date.now();
        (i === null || a > i + vF.delay) && (i = a, ut(this._targets, (s) => {
          let u = s.target.getBoundingClientRect();
          (u.width !== s.size.width || u.height !== s.size.height) && (s.size = u, s.callback());
        })), this._targets.length === 0 ? this._timer = null : this._timer = requestAnimationFrame(o);
      };
      this._timer = requestAnimationFrame(o);
    }
    let r = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
    this._targets.push({ target: t, callback: n, size: r });
  }
  removeTarget(t) {
    gF(this._targets, (n) => n.target !== t), this._targets.length === 0 && this._timer !== null && (cancelAnimationFrame(this._timer), this._timer = null);
  }
}
Object.defineProperty(vF, "delay", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 200
});
let LI = null;
function pnt() {
  return LI === null && (typeof ResizeObserver < "u" ? LI = new hnt() : LI = new vF()), LI;
}
class gnt {
  constructor(t, n) {
    Object.defineProperty(this, "_sensor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_listener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this._sensor = pnt(), this._element = t, this._listener = Kxe(n), this._sensor.addTarget(t, n);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._sensor.removeTarget(this._element), this._listener.dispose());
  }
  get sensor() {
    return this._sensor;
  }
}
class eL extends Lf {
}
Object.defineProperty(eL, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "InterfaceColors"
});
Object.defineProperty(eL, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Lf.classNames.concat([eL.className])
});
let wS = class extends es {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_textKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "text",
        "fill",
        "fillOpacity",
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale",
        "populateText",
        "role",
        "ignoreFormatting"
      ]
    });
  }
  /**
   * @ignore Text is not to be used directly
   */
  get text() {
    return this._text;
  }
  _afterNew() {
    super._afterNew(), this._makeText(), ut(this._textKeys, (t) => {
      const n = this.get(t);
      n != null && this._text.set(t, n);
    }), this.get("html", "") !== "" && this._text.set("text", ""), this.onPrivate("maxWidth", () => {
      this._setMaxDimentions();
    }), this.onPrivate("maxHeight", () => {
      this._setMaxDimentions();
    });
  }
  _makeText() {
    this._text = this.children.push(bk.new(this._root, {}));
  }
  _updateChildren() {
    if (super._updateChildren(), ut(this._textKeys, (t) => {
      this._text.set(t, this.get(t));
    }), this.isDirty("maxWidth") && this._setMaxDimentions(), this.isDirty("maxHeight") && this._setMaxDimentions(), this.isDirty("rotation") && this._setMaxDimentions(), this.get("html", "") !== "" ? this._text.set("text", "") : this._text.set("text", this.get("text")), this.isDirty("textAlign") || this.isDirty("width")) {
      const t = this.get("textAlign");
      let n;
      this.get("width") != null ? t == "right" ? n = Eo : t == "center" ? n = Pa : n = 0 : t == "left" || t == "start" ? n = this.get("paddingLeft") : (t == "right" || t == "end") && (n = -this.get("paddingRight")), this.text.set("x", n);
    }
  }
  _setMaxDimentions() {
    const t = this.get("rotation"), n = t == 90 || t == 270 || t == -90, r = this.get("maxWidth", this.getPrivate("maxWidth", 1 / 0));
    Cn(r) ? this.text.set(n ? "maxHeight" : "maxWidth", r - this.get("paddingLeft", 0) - this.get("paddingRight", 0)) : this.text.set(n ? "maxHeight" : "maxWidth", void 0);
    const i = this.get("maxHeight", this.getPrivate("maxHeight", 1 / 0));
    Cn(i) ? this.text.set(n ? "maxWidth" : "maxHeight", i - this.get("paddingTop", 0) - this.get("paddingBottom", 0)) : this.text.set(n ? "maxWidth" : "maxHeight", void 0);
  }
  _setDataItem(t) {
    super._setDataItem(t), this._markDirtyKey("text"), this.text.get("populateText") && this.text.markDirtyText();
  }
  /**
   * Returns text with populated placeholders and formatting if `populateText` is
   * set to `true`.
   *
   * @return Populated text
   */
  getText() {
    return this._text._getText();
  }
};
Object.defineProperty(wS, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Label"
});
Object.defineProperty(wS, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: es.classNames.concat([wS.className])
});
class TT extends sb {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds();
      let t = this.width(), n = this.height();
      if (t > 0 && n > 0) {
        let r = this.get("cornerRadius", 8);
        r = vd(r, 0, Math.min(t / 2, n / 2));
        let i = this.get("pointerX", 0), o = this.get("pointerY", 0), a = this.get("pointerBaseWidth", 15) / 2, s = 0, u = 0, l = t, f = 0, h = t, p = n, g = 0, y = n, b = (i - s) * (p - u) - (o - u) * (h - s), _ = (i - g) * (f - y) - (o - y) * (l - g);
        const S = this._display;
        if (S.moveTo(r, 0), b > 0 && _ > 0) {
          let C = Math.round(vd(i, r + a, t - a - r));
          o = vd(o, -1 / 0, 0), S.lineTo(C - a, 0), S.lineTo(i, o), S.lineTo(C + a, 0);
        }
        if (S.lineTo(t - r, 0), S.arcTo(t, 0, t, r, r), b > 0 && _ < 0) {
          let C = Math.round(vd(o, r + a, n - a - r));
          i = vd(i, t, 1 / 0), S.lineTo(t, r), S.lineTo(t, Math.max(C - a, r)), S.lineTo(i, o), S.lineTo(t, C + a);
        }
        if (S.lineTo(t, n - r), S.arcTo(t, n, t - r, n, r), b < 0 && _ < 0) {
          let C = Math.round(vd(i, r + a, t - a - r));
          o = vd(o, n, 1 / 0), S.lineTo(t - r, n), S.lineTo(C + a, n), S.lineTo(i, o), S.lineTo(C - a, n);
        }
        if (S.lineTo(r, n), S.arcTo(0, n, 0, n - r, r), b < 0 && _ > 0) {
          let C = Math.round(vd(o, r + a, n - r - a));
          i = vd(i, -1 / 0, 0), S.lineTo(0, n - r), S.lineTo(0, C + a), S.lineTo(i, o), S.lineTo(0, Math.max(C - a, r));
        }
        S.lineTo(0, r), S.arcTo(0, 0, r, 0, r), S.closePath();
      }
    }
  }
}
Object.defineProperty(TT, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PointedRectangle"
});
Object.defineProperty(TT, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: sb.classNames.concat([TT.className])
});
class xk extends es {
  constructor(t, n, r, i = []) {
    super(t, n, r, i), Object.defineProperty(this, "_fx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_fy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fillDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_labelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_w", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_h", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_keepHoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_htmlContentHovered", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this._settings.themeTags = twe(this._settings.themeTags, ["tooltip"]), super._afterNew(), this.set("background", TT.new(this._root, {
      themeTags: ["tooltip", "background"]
    })), this._label = this.children.push(wS.new(this._root, {})), this._disposers.push(this._label.events.on("boundschanged", () => {
      this._updateBackground();
    })), this._disposers.push(this.on("bounds", () => {
      this._updateBackground();
    })), this._updateTextColor(), this._root.tooltipContainer.children.push(this), this.hide(0), this._disposers.push(this.label.onPrivate("htmlElement", (t) => {
      t && (Ja(t, "pointerover", (n) => {
        this._htmlContentHovered = !0;
      }), Ja(t, "pointerout", (n) => {
        this._htmlContentHovered = !1;
      }));
    })), this._root._tooltips.push(this);
  }
  /**
   * A [[Label]] element for the tooltip.
   *
   * @readonly
   * @return Label
   */
  get label() {
    return this._label;
  }
  /**
   * Permanently disposes the tooltip.
   */
  dispose() {
    super.dispose(), mx(this._root._tooltips, this);
  }
  _updateChildren() {
    super._updateChildren(), (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && this.get("background")._markDirtyKey("width"), this.get("labelText") != null && this.label.set("text", this.get("labelText")), this.get("labelHTML") != null && this.label.set("html", this.get("labelHTML"));
  }
  _changed() {
    if (super._changed(), (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) && this._updateBackground(), this.isDirty("tooltipTarget") && this.updateBackgroundColor(), this.isDirty("keepTargetHover"))
      if (this.get("keepTargetHover")) {
        const n = this.get("background");
        this._keepHoverDp = new wd([
          n.events.on("pointerover", (r) => {
            let i = this.get("tooltipTarget");
            i && (i.parent && i.parent.getPrivate("tooltipTarget") == i && (i = i.parent), i.hover());
          }),
          n.events.on("pointerout", (r) => {
            let i = this.get("tooltipTarget");
            i && (i.parent && i.parent.getPrivate("tooltipTarget") == i && (i = i.parent), this._htmlContentHovered || i.unhover());
          })
        ]), this.label.onPrivate("htmlElement", (r) => {
          this._keepHoverDp && r && this._keepHoverDp.disposers.push(Ja(r, "pointerleave", (i) => {
            const o = this.root._renderer.getEvent(i);
            n.events.dispatch("pointerout", {
              type: "pointerout",
              originalEvent: o.event,
              point: o.point,
              simulated: !1,
              target: n
            });
          }));
        });
      } else
        this._keepHoverDp && (this._keepHoverDp.dispose(), this._keepHoverDp = void 0);
  }
  _onShow() {
    super._onShow(), this.updateBackgroundColor();
  }
  updateBackgroundColor() {
    let t = this.get("tooltipTarget");
    const n = this.get("background");
    let r, i;
    t && n && (r = t.get("fill"), i = t.get("stroke"), r == null && (r = i), this.get("getFillFromSprite") && (this._fillDp && this._fillDp.dispose(), r != null && n.set("fill", r), this._fillDp = t.on("fill", (o) => {
      o != null && (n.set("fill", o), this._updateTextColor(o));
    }), this._disposers.push(this._fillDp)), this.get("getStrokeFromSprite") && (this._strokeDp && this._strokeDp.dispose(), r != null && n.set("stroke", r), this._strokeDp = t.on("fill", (o) => {
      o != null && n.set("stroke", o);
    }), this._disposers.push(this._strokeDp)), this.get("getLabelFillFromSprite") && (this._labelDp && this._labelDp.dispose(), r != null && this.label.set("fill", r), this._labelDp = t.on("fill", (o) => {
      o != null && this.label.set("fill", o);
    }), this._disposers.push(this._labelDp))), this._updateTextColor(r);
  }
  _updateTextColor(t) {
    this.get("autoTextColor") && (t == null && (t = this.get("background").get("fill")), t == null && (t = this._root.interfaceColors.get("background")), t instanceof Mr && this.label.set("fill", Mr.alternative(t, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text"))));
  }
  _setDataItem(t) {
    super._setDataItem(t), this.label._setDataItem(t);
  }
  _updateBackground() {
    super.updateBackground();
    const t = this._root.container;
    if (t) {
      let n = 0.5, r = 0.5, i = this.get("centerX");
      i instanceof hi && (n = i.value);
      let o = this.get("centerY");
      o instanceof hi && (r = o.value);
      let a = t.width(), s = t.height(), u = this.parent, l = 0, f = 0;
      if (u) {
        l = u.x(), f = u.y();
        const V = u.get("layerMargin");
        V && (l += V.left || 0, f += V.top || 0, a += (V.left || 0) + (V.right || 0), s += (V.top || 0) + (V.bottom || 0));
      }
      const h = this.get("bounds", { left: -l, top: -f, right: a - l, bottom: s - f });
      this._updateBounds();
      let p = this.width(), g = this.height();
      p === 0 && (p = this._w), g === 0 && (g = this._h);
      let y = this.get("pointTo", { x: a / 2, y: s / 2 }), b = y.x, _ = y.y, S = this.get("pointerOrientation"), C = this.get("background"), A = 0, O = 0, R = 0;
      C instanceof TT && (A = C.get("pointerLength", 0), O = C.get("strokeWidth", 0) / 2, R = O, C.set("width", p), C.set("height", g));
      let j = 0, $ = 0, z = h.right - h.left, W = h.bottom - h.top;
      S == "horizontal" || S == "left" || S == "right" ? (O = 0, S == "horizontal" ? b > h.left + z / 2 ? (b -= p * (1 - n) + A, R *= -1) : b += p * n + A : S == "left" ? b += p * (1 - n) + A : (b -= p * n + A, R *= -1)) : (R = 0, S == "vertical" ? _ > h.top + g / 2 + A ? _ -= g * (1 - r) + A : (_ += g * r + A, O *= -1) : S == "down" ? _ -= g * (1 - r) + A : (_ += g * r + A, O *= -1)), b = vd(b, h.left + p * n, h.left + z - p * (1 - n)) + R, _ = vd(_, h.top + g * r, h.top + W - g * (1 - r)) - O, j = y.x - b + p * n + R, $ = y.y - _ + g * r - O, this._fx = b, this._fy = _;
      const Y = this.get("animationDuration", 0);
      if (Y > 0 && this.get("visible") && this.get("opacity") > 0.1) {
        const V = this.get("animationEasing");
        this.animate({ key: "x", to: b, duration: Y, easing: V }), this.animate({ key: "y", to: _, duration: Y, easing: V });
      } else
        this.set("x", b), this.set("y", _);
      C instanceof TT && (C.set("pointerX", j), C.set("pointerY", $)), p > 0 && (this._w = p), g > 0 && (this._h = g);
    }
  }
}
Object.defineProperty(xk, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tooltip"
});
Object.defineProperty(xk, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: es.classNames.concat([xk.className])
});
class mnt extends Lf {
  _setDefaults() {
    this._setDefault("negativeBase", 0), this._setDefault("numberFormat", "#,###.#####"), this._setDefault("smallNumberThreshold", 1);
    const t = "_big_number_suffix_", n = "_small_number_suffix_", r = "_byte_suffix_";
    this._setDefault("bigNumberPrefixes", [
      { number: 1e3, suffix: this._t(t + "3") },
      { number: 1e6, suffix: this._t(t + "6") },
      { number: 1e9, suffix: this._t(t + "9") },
      { number: 1e12, suffix: this._t(t + "12") },
      { number: 1e15, suffix: this._t(t + "15") },
      { number: 1e18, suffix: this._t(t + "18") },
      { number: 1e21, suffix: this._t(t + "21") },
      { number: 1e24, suffix: this._t(t + "24") }
    ]), this._setDefault("smallNumberPrefixes", [
      { number: 1e-24, suffix: this._t(n + "24") },
      { number: 1e-21, suffix: this._t(n + "21") },
      { number: 1e-18, suffix: this._t(n + "18") },
      { number: 1e-15, suffix: this._t(n + "15") },
      { number: 1e-12, suffix: this._t(n + "12") },
      { number: 1e-9, suffix: this._t(n + "9") },
      { number: 1e-6, suffix: this._t(n + "6") },
      { number: 1e-3, suffix: this._t(n + "3") }
    ]), this._setDefault("bytePrefixes", [
      { number: 1, suffix: this._t(r + "B") },
      { number: 1024, suffix: this._t(r + "KB") },
      { number: 1048576, suffix: this._t(r + "MB") },
      { number: 1073741824, suffix: this._t(r + "GB") },
      { number: 1099511627776, suffix: this._t(r + "TB") },
      { number: 1125899906842624, suffix: this._t(r + "PB") }
    ]), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number according to specific format.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @return Formatted number
   */
  format(t, n, r) {
    (n == null || tC(n) && n.toLowerCase() === "number") && (n = this.get("numberFormat", ""));
    let i, o = Number(t);
    if (pF(n))
      try {
        return this.get("intlLocales") ? new Intl.NumberFormat(this.get("intlLocales"), n).format(o) : new Intl.NumberFormat(void 0, n).format(o);
      } catch {
        return "Invalid";
      }
    else {
      n = RK(n);
      let a = this.parseFormat(n, this._root.language), s;
      o > this.get("negativeBase") ? s = a.positive : o < this.get("negativeBase") ? s = a.negative : s = a.zero, r != null && !s.mod && (s = Dtt(s), s.decimals.active = o == 0 ? 0 : r), i = s.template.split(Wx).join(this.applyFormat(o, s));
    }
    return this.get("forceLTR") === !0 && (i = "‎" + i), i;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format Format string, i.e. "#,###.00"
   * @param language Language
   * @ignore
   */
  parseFormat(t, n) {
    const r = n.translateEmpty("_thousandSeparator"), i = n.translateEmpty("_decimalSeparator");
    let o = {
      positive: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: r
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: i
        },
        template: "",
        source: "",
        parsed: !1
      },
      negative: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: r
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: i
        },
        template: "",
        source: "",
        parsed: !1
      },
      zero: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: r
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: i
        },
        template: "",
        source: "",
        parsed: !1
      }
    };
    t = t.replace("||", fT);
    let a = t.split("|");
    return o.positive.source = a[0], typeof a[2] > "u" ? o.zero = o.positive : o.zero.source = a[2], typeof a[1] > "u" ? o.negative = o.positive : o.negative.source = a[1], ia(o, (s, u) => {
      if (u.parsed)
        return;
      let l = u.source;
      l.toLowerCase() === "number" && (l = this.get("numberFormat", "#,###.#####"));
      let f = Fg.chunk(l, !0);
      for (let h = 0; h < f.length; h++) {
        let p = f[h];
        if (p.text = p.text.replace(fT, "|"), p.type === "value") {
          let g = p.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
          if (g)
            if (g === null || g[0] === "")
              u.template += p.text;
            else {
              let y = g[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
              y && (u.mod = y[0].toLowerCase(), u.modSpacing = !!g[0].match(/[ ]{1}[abespABESP%‰!]{1}$/));
              let b = g[0].split(".");
              if (b[0] !== "") {
                u.thousands.active = (b[0].match(/0/g) || []).length, u.thousands.passive = (b[0].match(/\#/g) || []).length + u.thousands.active;
                let _ = b[0].split(",");
                _.length === 1 || (u.thousands.interval = (_.pop() || "").length, u.thousands.interval === 0 && (u.thousands.interval = -1));
              }
              typeof b[1] > "u" || (u.decimals.active = (b[1].match(/0/g) || []).length, u.decimals.passive = (b[1].match(/\#/g) || []).length + u.decimals.active), u.template += p.text.split(g[0]).join(Wx);
            }
        } else
          u.template += p.text;
      }
      u.parsed = !0;
    }), o;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by parseFormat()
   * @return Formatted number
   * @ignore
   */
  applyFormat(t, n) {
    let r = t < 0;
    t = Math.abs(t);
    let i = "", o = "", a = n.mod ? n.mod.split("") : [];
    if (a.indexOf("b") !== -1) {
      let h = this.applyPrefix(t, this.get("bytePrefixes"), a.indexOf("!") !== -1);
      t = h[0], i = h[1], o = h[2], n.modSpacing && (o = " " + o);
    } else if (a.indexOf("a") !== -1) {
      let h = this.applyPrefix(t, t < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), a.indexOf("!") !== -1);
      t = h[0], i = h[1], o = h[2], n.modSpacing && (o = " " + o);
    } else if (a.indexOf("p") !== -1) {
      let h = Math.min(t.toString().length + 2, 21);
      t = parseFloat(t.toPrecision(h)), i = this._root.language.translate("_percentPrefix"), o = this._root.language.translate("_percentSuffix"), i == "" && o == "" && (o = "%");
    } else if (a.indexOf("%") !== -1) {
      let h = Math.min(t.toString().length + 2, 21);
      t *= 100, t = parseFloat(t.toPrecision(h)), o = "%";
    } else if (a.indexOf("‰") !== -1) {
      let h = Math.min(t.toString().length + 3, 21);
      t *= 1e3, t = parseFloat(t.toPrecision(h)), o = "‰";
    }
    if (a.indexOf("e") !== -1) {
      let h;
      n.decimals.passive >= 0 ? h = t.toExponential(n.decimals.passive).split("e") : h = t.toExponential().split("e"), t = Number(h[0]), o = "e" + h[1], n.modSpacing && (o = " " + o);
    } else if (n.decimals.passive === 0)
      t = Math.round(t);
    else if (n.decimals.passive > 0) {
      let h = Math.pow(10, n.decimals.passive);
      t = Math.round(t * h) / h;
    }
    let s = "", u = ytt(t).split("."), l = u[0];
    if (l.length < n.thousands.active && (l = Array(n.thousands.active - l.length + 1).join("0") + l), n.thousands.interval > 0) {
      let h = [], p = l.split("").reverse().join("");
      for (let g = 0, y = l.length; g <= y; g += n.thousands.interval) {
        let b = p.substr(g, n.thousands.interval).split("").reverse().join("");
        b !== "" && h.unshift(b);
      }
      l = h.join(n.thousands.separator);
    }
    s += l, u.length === 1 && u.push("");
    let f = u[1];
    return f.length < n.decimals.active && (f += Array(n.decimals.active - f.length + 1).join("0")), f !== "" && (s += n.decimals.separator + f), s === "" && (s = "0"), t !== 0 && r && a.indexOf("s") === -1 && (s = "-" + s), i && (s = i + s), o && (s += o), s;
  }
  applyPrefix(t, n, r = !1) {
    let i = t, o = "", a = "", s = !1, u = 1;
    for (let l = 0, f = n.length; l < f; l++)
      n[l].number <= t && (n[l].number === 0 ? i = 0 : (i = t / n[l].number, u = n[l].number), o = n[l].prefix, a = n[l].suffix, s = !0);
    return !s && r && n.length && t != 0 && (i = t / n[0].number, o = n[0].prefix, a = n[0].suffix, s = !0), s && (i = parseFloat(i.toPrecision(Math.min(u.toString().length + Math.floor(i).toString().replace(/[^0-9]*/g, "").length, 21)))), [i, o, a];
  }
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  escape(t) {
    return t.replace("||", fT);
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  unescape(t) {
    return t.replace(fT, "|");
  }
}
function swe(e, t) {
  let n = 0, r = 0, i = 1, o = 0, a = 0, s = 0, u = 0, l = 0;
  return e.formatToParts(t).forEach((f) => {
    switch (f.type) {
      case "year":
        n = +f.value;
        break;
      case "month":
        r = +f.value - 1;
        break;
      case "day":
        i = +f.value;
        break;
      case "hour":
        o = +f.value;
        break;
      case "minute":
        a = +f.value;
        break;
      case "second":
        s = +f.value;
        break;
      case "fractionalSecond":
        u = +f.value;
        break;
      case "weekday":
        switch (f.value) {
          case "Sun":
            l = 0;
            break;
          case "Mon":
            l = 1;
            break;
          case "Tue":
            l = 2;
            break;
          case "Wed":
            l = 3;
            break;
          case "Thu":
            l = 4;
            break;
          case "Fri":
            l = 5;
            break;
          case "Sat":
            l = 6;
            break;
        }
    }
  }), o === 24 && (o = 0), { year: n, month: r, day: i, hour: o, minute: a, second: s, millisecond: u, weekday: l };
}
function Rfe(e, t) {
  const { year: n, month: r, day: i, hour: o, minute: a, second: s, millisecond: u } = swe(e, t);
  return Date.UTC(n, r, i, o, a, s, u);
}
class ynt {
  constructor(t, n) {
    if (Object.defineProperty(this, "_utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dtf", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !n)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this.name = t, this._utc = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    }), this._dtf = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: t,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    });
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   timezone  IANA timezone
   * @return            Instantiated object
   */
  static new(t) {
    return new this(t, !0);
  }
  convertLocal(t) {
    const n = this.offsetUTC(t), r = t.getTimezoneOffset(), i = new Date(t);
    i.setUTCMinutes(i.getUTCMinutes() - (n - r));
    const o = i.getTimezoneOffset();
    return r != o && i.setUTCMinutes(i.getUTCMinutes() + o - r), i;
  }
  offsetUTC(t) {
    const n = Rfe(this._utc, t), r = Rfe(this._dtf, t);
    return (n - r) / 6e4;
  }
  parseDate(t) {
    return swe(this._dtf, t);
  }
}
class vnt extends Lf {
  _setDefaults() {
    this._setDefault("capitalize", !0), this._setDefault("dateFormat", "yyyy-MM-dd"), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  format(t, n) {
    (typeof n > "u" || n === "") && (n = this.get("dateFormat", "yyyy-MM-dd"));
    let r, i = t;
    if (pF(n))
      try {
        const s = this.get("intlLocales");
        return s ? new Intl.DateTimeFormat(s, n).format(i) : new Intl.DateTimeFormat(void 0, n).format(i);
      } catch {
        return "Invalid";
      }
    let o = this.parseFormat(n);
    const a = this._root.timezone;
    return a && !this._root.utc && (i = a.convertLocal(i)), Cn(i.getTime()) ? (r = this.applyFormat(i, o), this.get("capitalize") && (r = r.replace(/^.{1}/, r.substr(0, 1).toUpperCase())), r) : "Invalid date";
  }
  /**
   * Applies format to Date.
   *
   * @param date      Date object
   * @param info      Parsed format information
   * @return Formatted date string
   */
  applyFormat(t, n) {
    let r = n.template, i, o, a, s, u, l, f, h, p = t.getTime();
    this._root.utc ? (i = t.getUTCFullYear(), o = t.getUTCMonth(), a = t.getUTCDay(), s = t.getUTCDate(), u = t.getUTCHours(), l = t.getUTCMinutes(), f = t.getUTCSeconds(), h = t.getUTCMilliseconds()) : (i = t.getFullYear(), o = t.getMonth(), a = t.getDay(), s = t.getDate(), u = t.getHours(), l = t.getMinutes(), f = t.getSeconds(), h = t.getMilliseconds());
    for (let g = 0, y = n.parts.length; g < y; g++) {
      let b = "";
      switch (n.parts[g]) {
        case "G":
          b = this._t(i < 0 ? "_era_bc" : "_era_ad");
          break;
        case "yyyy":
          b = Math.abs(i).toString(), i < 0 && (b += this._t("_era_bc"));
          break;
        case "yyy":
        case "yy":
        case "y":
          b = Math.abs(i).toString().substr(-n.parts[g].length), i < 0 && (b += this._t("_era_bc"));
          break;
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
          let _ = Ytt(t, this._root.utc);
          n.parts[g] == "YYYY" ? b = Math.abs(_).toString() : b = Math.abs(_).toString().substr(-n.parts[g].length), _ < 0 && (b += this._t("_era_bc"));
          break;
        case "u":
          break;
        case "q":
          b = "" + Math.ceil((t.getMonth() + 1) / 3);
          break;
        case "MMMMM":
          b = this._t(this._getMonth(o)).substr(0, 1);
          break;
        case "MMMM":
          b = this._t(this._getMonth(o));
          break;
        case "MMM":
          b = this._t(this._getShortMonth(o));
          break;
        case "MM":
          b = Ka(o + 1, 2, "0");
          break;
        case "M":
          b = (o + 1).toString();
          break;
        case "ww":
          b = Ka(Kj(t, this._root.utc), 2, "0");
          break;
        case "w":
          b = Kj(t, this._root.utc).toString();
          break;
        case "W":
          b = Htt(t, this._root.utc).toString();
          break;
        case "dd":
          b = Ka(s, 2, "0");
          break;
        case "d":
          b = s.toString();
          break;
        case "DD":
        case "DDD":
          b = Ka(Nfe(t, this._root.utc).toString(), n.parts[g].length, "0");
          break;
        case "D":
          b = Nfe(t, this._root.utc).toString();
          break;
        case "F":
          break;
        case "g":
          break;
        case "t":
          b = this._root.language.translateFunc("_dateOrd").call(this, s);
          break;
        case "E":
          b = (a || 7).toString();
          break;
        case "EE":
          b = Ka((a || 7).toString(), 2, "0");
          break;
        case "EEE":
        case "eee":
          b = this._t(this._getShortWeekday(a));
          break;
        case "EEEE":
        case "eeee":
          b = this._t(this._getWeekday(a));
          break;
        case "EEEEE":
        case "eeeee":
          b = this._t(this._getShortWeekday(a)).substr(0, 1);
          break;
        case "e":
        case "ee":
          b = (a - (this._root.locale.firstDayOfWeek || 1) + 1).toString(), n.parts[g] == "ee" && (b = Ka(b, 2, "0"));
          break;
        case "a":
          u >= 12 ? b = this._t("PM") : b = this._t("AM");
          break;
        case "aa":
          u >= 12 ? b = this._t("P.M.") : b = this._t("A.M.");
          break;
        case "aaa":
          u >= 12 ? b = this._t("P") : b = this._t("A");
          break;
        case "h":
          b = PI(u).toString();
          break;
        case "hh":
          b = Ka(PI(u), 2, "0");
          break;
        case "H":
          b = u.toString();
          break;
        case "HH":
          b = Ka(u, 2, "0");
          break;
        case "K":
          b = PI(u, 0).toString();
          break;
        case "KK":
          b = Ka(PI(u, 0), 2, "0");
          break;
        case "k":
          b = (u + 1).toString();
          break;
        case "kk":
          b = Ka(u + 1, 2, "0");
          break;
        case "m":
          b = l.toString();
          break;
        case "mm":
          b = Ka(l, 2, "0");
          break;
        case "s":
          b = f.toString();
          break;
        case "ss":
          b = Ka(f, 2, "0");
          break;
        case "S":
        case "SS":
        case "SSS":
          b = Math.round(h / 1e3 * Math.pow(10, n.parts[g].length)).toString();
          break;
        case "x":
          b = p.toString();
          break;
        case "n":
        case "nn":
        case "nnn":
          b = Ka(h, n.parts[g].length, "0");
          break;
        case "z":
          b = II(t, !1, !1, this._root.utc);
          break;
        case "zz":
          b = II(t, !0, !1, this._root.utc);
          break;
        case "zzz":
          b = II(t, !1, !0, this._root.utc);
          break;
        case "zzzz":
          b = II(t, !0, !0, this._root.utc);
          break;
        case "Z":
        case "ZZ":
          let S = this._root.utc ? "UTC" : this._root.timezone;
          S instanceof ynt && (S = S.name);
          const C = S ? Wtt(S) : t.getTimezoneOffset();
          let A = Math.abs(C) / 60, O = Math.floor(A), R = A * 60 - O * 60;
          this._root.utc && (O = 0, R = 0), n.parts[g] == "Z" ? (b = "GMT", b += C > 0 ? "-" : "+", b += Ka(O, 2) + ":" + Ka(R, 2)) : (b = C > 0 ? "-" : "+", b += Ka(O, 2) + Ka(R, 2));
          break;
        case "i":
          b = t.toISOString();
          break;
        case "I":
          b = t.toUTCString();
          break;
      }
      r = r.replace(Wx, b);
    }
    return r;
  }
  /**
   * Parses format into structured infromation.
   *
   * @param format Format template
   */
  parseFormat(t) {
    let n = {
      template: "",
      parts: []
    }, r = Fg.chunk(t, !0);
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      if (o.type === "value") {
        if (o.text.match(/^date$/i)) {
          let s = this.get("dateFormat", "yyyy-MM-dd");
          tC(s) || (s = "yyyy-MM-dd"), o.text = s;
        }
        let a = o.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
        if (a)
          for (let s = 0; s < a.length; s++)
            n.parts.push(a[s]), o.text = o.text.replace(a[s], Wx);
      }
      n.template += o.text;
    }
    return n;
  }
  _months() {
    return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  }
  _getMonth(t) {
    return this._months()[t];
  }
  _shortMonths() {
    return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  }
  _getShortMonth(t) {
    return this._shortMonths()[t];
  }
  _weekdays() {
    return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  _getWeekday(t) {
    return this._weekdays()[t];
  }
  _shortWeekdays() {
    return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  }
  _getShortWeekday(t) {
    return this._shortWeekdays()[t];
  }
  parse(t, n) {
    if (t instanceof Date)
      return t;
    if (Cn(t))
      return new Date(t);
    tC(t) || (t = t.toString());
    let r, i = "";
    n = RK(n), n = n.substr(0, t.length);
    let o = this.parseFormat(n), a = {
      year: -1,
      year3: -1,
      year2: -1,
      year1: -1,
      month: -1,
      monthShort: -1,
      monthLong: -1,
      weekdayShort: -1,
      weekdayLong: -1,
      day: -1,
      yearDay: -1,
      week: -1,
      hourBase0: -1,
      hour12Base0: -1,
      hourBase1: -1,
      hour12Base1: -1,
      minute: -1,
      second: -1,
      millisecond: -1,
      millisecondDigits: -1,
      am: -1,
      zone: -1,
      timestamp: -1,
      iso: -1
    }, s = {
      year: 1970,
      month: 0,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
      timestamp: null,
      offset: 0,
      utc: this._root.utc
    }, u = 0, l = 0;
    for (let p = 0; p < o.parts.length; p++) {
      switch (l = p + u + 1, o.parts[p]) {
        case "yyyy":
        case "YYYY":
          i += "([0-9]{4})", a.year = l;
          break;
        case "yyy":
        case "YYY":
          i += "([0-9]{3})", a.year3 = l;
          break;
        case "yy":
        case "YY":
          i += "([0-9]{2})", a.year2 = l;
          break;
        case "y":
        case "Y":
          i += "([0-9]{1})", a.year1 = l;
          break;
        case "MMMM":
          i += "(" + this.getStringList(this._months()).join("|") + ")", a.monthLong = l;
          break;
        case "MMM":
          i += "(" + this.getStringList(this._shortMonths()).join("|") + ")", a.monthShort = l;
          break;
        case "MM":
        case "M":
          i += "([0-9]{2}|[0-9]{1})", a.month = l;
          break;
        case "ww":
        case "w":
          i += "([0-9]{2}|[0-9]{1})", a.week = l;
          break;
        case "dd":
        case "d":
          i += "([0-9]{2}|[0-9]{1})", a.day = l;
          break;
        case "DDD":
        case "DD":
        case "D":
          i += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.yearDay = l;
          break;
        case "dddd":
          i += "(" + this.getStringList(this._weekdays()).join("|") + ")", a.weekdayLong = l;
          break;
        case "ddd":
          i += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")", a.weekdayShort = l;
          break;
        case "aaa":
        case "aa":
        case "a":
          i += "(" + this.getStringList(["AM", "PM", "A.M.", "P.M.", "A", "P"]).join("|") + ")", a.am = l;
          break;
        case "hh":
        case "h":
          i += "([0-9]{2}|[0-9]{1})", a.hour12Base1 = l;
          break;
        case "HH":
        case "H":
          i += "([0-9]{2}|[0-9]{1})", a.hourBase0 = l;
          break;
        case "KK":
        case "K":
          i += "([0-9]{2}|[0-9]{1})", a.hour12Base0 = l;
          break;
        case "kk":
        case "k":
          i += "([0-9]{2}|[0-9]{1})", a.hourBase1 = l;
          break;
        case "mm":
        case "m":
          i += "([0-9]{2}|[0-9]{1})", a.minute = l;
          break;
        case "ss":
        case "s":
          i += "([0-9]{2}|[0-9]{1})", a.second = l;
          break;
        case "SSS":
        case "SS":
        case "S":
          i += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = l, a.millisecondDigits = o.parts[p].length;
          break;
        case "nnn":
        case "nn":
        case "n":
          i += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = l;
          break;
        case "x":
          i += "([0-9]{1,})", a.timestamp = l;
          break;
        case "Z":
          i += "GMT([-+]+[0-9]{2}:[0-9]{2})", a.zone = l;
          break;
        case "ZZ":
          i += "([\\-+]+[0-9]{2}[0-9]{2})", a.zone = l;
          break;
        case "i":
          i += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)", a.iso = l, u += 7;
          break;
        case "G":
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
        case "MMMMM":
        case "W":
        case "EEEEE":
        case "EEEE":
        case "EEE":
        case "EE":
        case "E":
        case "eeeee":
        case "eeee":
        case "eee":
        case "ee":
        case "e":
        case "zzzz":
        case "zzz":
        case "zz":
        case "z":
        case "t":
          u--;
          break;
      }
      i += "[^0-9]*";
    }
    let f = new RegExp(i), h = t.match(f);
    if (h) {
      if (a.year > -1 && (s.year = parseInt(h[a.year])), a.year3 > -1) {
        let p = parseInt(h[a.year3]);
        p += 1e3, s.year = p;
      }
      if (a.year2 > -1) {
        let p = parseInt(h[a.year2]);
        p > 50 ? p += 1e3 : p += 2e3, s.year = p;
      }
      if (a.year1 > -1) {
        let p = parseInt(h[a.year1]);
        p = Math.floor((/* @__PURE__ */ new Date()).getFullYear() / 10) * 10 + p, s.year = p;
      }
      if (a.monthLong > -1 && (s.month = this.resolveMonth(h[a.monthLong])), a.monthShort > -1 && (s.month = this.resolveShortMonth(h[a.monthShort])), a.month > -1 && (s.month = parseInt(h[a.month]) - 1), a.week > -1 && a.day === -1 && (s.month = 0, s.day = Vtt(parseInt(h[a.week]), s.year, 1, this._root.utc)), a.day > -1 && (s.day = parseInt(h[a.day])), a.yearDay > -1 && (s.month = 0, s.day = parseInt(h[a.yearDay])), a.hourBase0 > -1 && (s.hour = parseInt(h[a.hourBase0])), a.hourBase1 > -1 && (s.hour = parseInt(h[a.hourBase1]) - 1), a.hour12Base0 > -1) {
        let p = parseInt(h[a.hour12Base0]);
        p == 11 && (p = 0), a.am > -1 && !this.isAm(h[a.am]) && (p += 12), s.hour = p;
      }
      if (a.hour12Base1 > -1) {
        let p = parseInt(h[a.hour12Base1]);
        p == 12 && (p = 0), a.am > -1 && !this.isAm(h[a.am]) && (p += 12), s.hour = p;
      }
      if (a.minute > -1 && (s.minute = parseInt(h[a.minute])), a.second > -1 && (s.second = parseInt(h[a.second])), a.millisecond > -1) {
        let p = parseInt(h[a.millisecond]);
        a.millisecondDigits == 2 ? p *= 10 : a.millisecondDigits == 1 && (p *= 100), s.millisecond = p;
      }
      if (a.timestamp > -1) {
        s.timestamp = parseInt(h[a.timestamp]);
        const p = new Date(s.timestamp);
        s.year = p.getUTCFullYear(), s.month = p.getUTCMonth(), s.day = p.getUTCDate(), s.hour = p.getUTCHours(), s.minute = p.getUTCMinutes(), s.second = p.getUTCSeconds(), s.millisecond = p.getUTCMilliseconds();
      }
      a.zone > -1 && (s.offset = this.resolveTimezoneOffset(new Date(s.year, s.month, s.day), h[a.zone])), a.iso > -1 && (s.year = xd(h[a.iso + 0]), s.month = xd(h[a.iso + 1]) - 1, s.day = xd(h[a.iso + 2]), s.hour = xd(h[a.iso + 3]), s.minute = xd(h[a.iso + 4]), s.second = xd(h[a.iso + 5]), s.millisecond = xd(h[a.iso + 6]), h[a.iso + 7] == "Z" || h[a.iso + 7] == "z" ? s.utc = !0 : h[a.iso + 7] != "" && (s.offset = this.resolveTimezoneOffset(new Date(s.year, s.month, s.day), h[a.iso + 7]))), s.utc ? r = new Date(Date.UTC(s.year, s.month, s.day, s.hour, s.minute, s.second, s.millisecond)) : r = new Date(s.year, s.month, s.day, s.hour, s.minute + s.offset, s.second, s.millisecond);
    } else
      r = new Date(t);
    return r;
  }
  resolveTimezoneOffset(t, n) {
    if (n.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/)) {
      let i = n.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/), o = i[1], a = i[2], s = i[3], u = parseInt(a) * 60 + parseInt(s);
      o == "+" && (u *= -1);
      let l = (t || /* @__PURE__ */ new Date()).getTimezoneOffset();
      return u - l;
    }
    return 0;
  }
  /**
   * Resolves month name (i.e. "December") into a month number (11).
   *
   * @param value  Month name
   * @return Month number
   */
  resolveMonth(t) {
    let n = this._months().indexOf(t);
    return n > -1 || !this._root.language.isDefault() && (n = this._root.language.translateAll(this._months()).indexOf(t), n > -1) ? n : 0;
  }
  /**
   * Resolves short month name (i.e. "Dec") into a month number.
   *
   * @param value  Short month name
   * @return Month number
   */
  resolveShortMonth(t) {
    let n = this._shortMonths().indexOf(t);
    return n > -1 || (n = this._months().indexOf(t), n > -1) || this._root.language && !this._root.language.isDefault() && (n = this._root.language.translateAll(this._shortMonths()).indexOf(t), n > -1) ? n : 0;
  }
  /**
   * Checks if passed in string represents AM/PM notation in many of its
   * versions.
   *
   * @param value  Source string
   * @return Is it AM/PM?
   */
  isAm(t) {
    return this.getStringList(["AM", "A.M.", "A"]).indexOf(t.toUpperCase()) > -1;
  }
  /**
   * Translates list of strings.
   *
   * @param list  Source strings
   * @return Translated strings
   */
  getStringList(t) {
    let n = [];
    for (let r = 0; r < t.length; r++)
      this._root.language ? n.push(Cfe(this._t(t[r]))) : n.push(Cfe(t[r]));
    return n;
  }
}
class bnt extends Lf {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_unitAliases", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        Y: "y",
        D: "d",
        H: "h",
        K: "h",
        k: "h",
        n: "S"
      }
    });
  }
  _setDefaults() {
    const t = "_duration_millisecond", n = "_duration_second", r = "_duration_minute", i = "_duration_hour", o = "_duration_day", a = "_duration_week", s = "_duration_month", u = "_duration_year", l = "_second", f = "_minute", h = "_hour", p = "_day", g = "_week", y = "_week", b = "_year";
    this._setDefault("negativeBase", 0), this._setDefault("baseUnit", "second"), this._setDefault("durationFormats", {
      millisecond: {
        millisecond: this._t(t),
        second: this._t(t + l),
        minute: this._t(t + f),
        hour: this._t(t + h),
        day: this._t(t + p),
        week: this._t(t + g),
        month: this._t(t + y),
        year: this._t(t + b)
      },
      second: {
        second: this._t(n),
        minute: this._t(n + f),
        hour: this._t(n + h),
        day: this._t(n + p),
        week: this._t(n + g),
        month: this._t(n + y),
        year: this._t(n + b)
      },
      minute: {
        minute: this._t(r),
        hour: this._t(r + h),
        day: this._t(r + p),
        week: this._t(r + g),
        month: this._t(r + y),
        year: this._t(r + b)
      },
      hour: {
        hour: this._t(i),
        day: this._t(i + p),
        week: this._t(i + g),
        month: this._t(i + y),
        year: this._t(i + b)
      },
      day: {
        day: this._t(o),
        week: this._t(o + g),
        month: this._t(o + y),
        year: this._t(o + b)
      },
      week: {
        week: this._t(a),
        month: this._t(a + y),
        year: this._t(a + b)
      },
      month: {
        month: this._t(s),
        year: this._t(s + b)
      },
      year: {
        year: this._t(u)
      }
    }), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number as duration.
   *
   * For example `1000` (base unit seconds) would be converted to `16:40` as in
   * 16 minutes and 40 seconds.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @param base    Override base unit
   * @return Formatted number
   */
  format(t, n, r) {
    let i = r || this.get("baseUnit");
    (typeof n > "u" || n === "") && (this.get("durationFormat") != null ? n = this.get("durationFormat") : n = this.getFormat(xd(t), void 0, i)), n = RK(n);
    let o = this.parseFormat(n, i), a = Number(t), s;
    a > this.get("negativeBase") ? s = o.positive : a < this.get("negativeBase") ? s = o.negative : s = o.zero;
    let u = this.applyFormat(a, s);
    return s.color !== "" && (u = "[" + s.color + "]" + u + "[/]"), u;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format  Format string, i.e. "#,###.00"
   * @param base    Override base unit
   * @return Parsed information
   */
  parseFormat(t, n) {
    let r = n || this.get("baseUnit"), i = {
      positive: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: r,
        parsed: !1,
        absolute: !1
      },
      negative: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: r,
        parsed: !1,
        absolute: !1
      },
      zero: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: r,
        parsed: !1,
        absolute: !1
      }
    };
    t = t.replace("||", fT);
    let o = t.split("|");
    return i.positive.source = o[0], typeof o[2] > "u" ? i.zero = i.positive : i.zero.source = o[2], typeof o[1] > "u" ? i.negative = i.positive : i.negative.source = o[1], ia(i, (a, s) => {
      if (s.parsed)
        return;
      let u = s.source, l = [];
      l = s.source.match(/^\[([^\]]*)\]/), l && l.length && l[0] !== "" && (u = s.source.substr(l[0].length), s.color = l[1]);
      let f = Fg.chunk(u, !0);
      for (let h = 0; h < f.length; h++) {
        let p = f[h];
        if (p.text = p.text.replace(fT, "|"), p.type === "value") {
          p.text.match(/[yYMdDwhHKkmsSn]+a/) && (s.absolute = !0, p.text = p.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1"));
          let g = p.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
          if (g)
            for (let y = 0; y < g.length; y++)
              g[y] == null && (g[y] = this._unitAliases[g[y]]), s.parts.push(g[y]), p.text = p.text.replace(g[y], Wx);
        }
        s.template += p.text;
      }
      s.parsed = !0;
    }), i;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by {parseFormat}
   * @return Formatted duration
   */
  applyFormat(t, n) {
    let r = !n.absolute && t < this.get("negativeBase");
    t = Math.abs(t);
    let i = this.toTimeStamp(t, n.baseUnit), o = n.template;
    for (let a = 0, s = n.parts.length; a < s; a++) {
      let u = n.parts[a], l = this._toTimeUnit(u.substr(0, 1)), f = u.length, h = Math.floor(i / this._getUnitValue(l));
      o = o.replace(Wx, Ka(h, f, "0")), i -= h * this._getUnitValue(l);
    }
    return r && (o = "-" + o), o;
  }
  /**
   * Converts numeric value to timestamp in milliseconds.
   *
   * @param value     A source value
   * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
   * @return Value representation as a timestamp in milliseconds
   */
  toTimeStamp(t, n) {
    return t * this._getUnitValue(n);
  }
  _toTimeUnit(t) {
    switch (t) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
        return "hour";
      case "d":
        return "day";
      case "w":
        return "week";
      case "M":
        return "month";
      case "y":
        return "year";
    }
  }
  /**
   * Returns appropriate default format for the value.
   *
   * If `maxValue` is sepcified, it will use that value to determine the time
   * unit for the format.
   *
   * For example if your `baseUnit` is `"second"` and you pass in `10`, you
   * will get `"10"`.
   *
   * However, you might want it to be formatted in the context of bigger scale,
   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
   * values, including small ones will use format with minutes, e.g.:
   * `00:10`, `00:50`, `12: 30`, etc.
   *
   * @param value     Value to format
   * @param maxValue  Maximum value to be used to determine format
   * @param baseUnit  Base unit of the value
   * @return Format
   */
  getFormat(t, n, r) {
    if (this.get("durationFormat") != null)
      return this.get("durationFormat");
    if (r || (r = this.get("baseUnit")), n != null && t != n) {
      t = Math.abs(t), n = Math.abs(n);
      let i = this.getValueUnit(Math.max(t, n), r);
      return this.get("durationFormats")[r][i];
    } else {
      let i = this.getValueUnit(t, r);
      return this.get("durationFormats")[r][i];
    }
  }
  /**
   * Returns value's closest denominator time unit, e.g 100 seconds is
   * `"minute"`, while 59 seconds would still be `second`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Denominator
   */
  getValueUnit(t, n) {
    n || (n = this.get("baseUnit"));
    let r, i = this.getMilliseconds(t, n);
    return Att(this._getUnitValues(), (o, a) => {
      if (o == n || r) {
        if (i / a <= 1)
          return r || (r = o), !1;
        r = o;
      }
      return !0;
    }), r;
  }
  /**
   * Converts value to milliseconds according to `baseUnit`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Value in milliseconds
   */
  getMilliseconds(t, n) {
    return n || (n = this.get("baseUnit")), t * this._getUnitValue(n);
  }
  _getUnitValue(t) {
    return this._getUnitValues()[t];
  }
  _getUnitValues() {
    return {
      millisecond: 1,
      second: 1e3,
      minute: 6e4,
      hour: 36e5,
      day: 864e5,
      week: 6048e5,
      month: 2592e6,
      year: 31536e6
    };
  }
}
const uwe = {
  firstDayOfWeek: 1,
  // Number formatting options.
  // 
  // Please check with the local standards which separator is accepted to be
  // used for separating decimals, and which for thousands.
  _decimalSeparator: ".",
  _thousandSeparator: ",",
  // Position of the percent sign in numbers
  _percentPrefix: null,
  _percentSuffix: "%",
  // Suffixes for numbers
  // When formatting numbers, big or small numers might be reformatted to
  // shorter version, by applying a suffix.
  // 
  // For example, 1000000 might become "1m".
  // Or 1024 might become "1KB" if we're formatting byte numbers.
  // 
  // This section defines such suffixes for all such cases.
  _big_number_suffix_3: "k",
  _big_number_suffix_6: "M",
  _big_number_suffix_9: "G",
  _big_number_suffix_12: "T",
  _big_number_suffix_15: "P",
  _big_number_suffix_18: "E",
  _big_number_suffix_21: "Z",
  _big_number_suffix_24: "Y",
  _small_number_suffix_3: "m",
  _small_number_suffix_6: "μ",
  _small_number_suffix_9: "n",
  _small_number_suffix_12: "p",
  _small_number_suffix_15: "f",
  _small_number_suffix_18: "a",
  _small_number_suffix_21: "z",
  _small_number_suffix_24: "y",
  _byte_suffix_B: "B",
  _byte_suffix_KB: "KB",
  _byte_suffix_MB: "MB",
  _byte_suffix_GB: "GB",
  _byte_suffix_TB: "TB",
  _byte_suffix_PB: "PB",
  // Default date formats for various periods.
  // 
  // This should reflect official or de facto formatting universally accepted
  // in the country translation is being made for
  // Available format codes here:
  // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
  // 
  // This will be used when formatting date/time for particular granularity,
  // e.g. "_date_hour" will be shown whenever we need to show time as hours.
  // 
  // "date" is used as in default date format when showing standalone dates.
  _date: "yyyy-MM-dd",
  _date_millisecond: "mm:ss SSS",
  _date_millisecond_full: "HH:mm:ss SSS",
  _date_second: "HH:mm:ss",
  _date_second_full: "HH:mm:ss",
  _date_minute: "HH:mm",
  _date_minute_full: "HH:mm - MMM dd, yyyy",
  _date_hour: "HH:mm",
  _date_hour_full: "HH:mm - MMM dd, yyyy",
  _date_day: "MMM dd",
  _date_day_full: "MMM dd, yyyy",
  _date_week: "ww",
  _date_week_full: "MMM dd, yyyy",
  _date_month: "MMM",
  _date_month_full: "MMM, yyyy",
  _date_year: "yyyy",
  // Default duration formats for various base units.
  // 
  // This will be used by DurationFormatter to format numeric values into
  // duration.
  // 
  // Notice how each duration unit comes in several versions. This is to ensure
  // that each base unit is shown correctly.
  // 
  // For example, if we have baseUnit set to "second", meaning our duration is
  // in seconds.
  // 
  // If we pass in `50` to formatter, it will know that we have just 50 seconds
  // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
  // and the formatted result will be in like `"50"`.
  // 
  // If we pass in `70`, which is more than a minute, the formatter will switch
  // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
  // text.
  // 
  // Available codes here:
  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
  _duration_millisecond: "SSS",
  _duration_millisecond_second: "ss.SSS",
  _duration_millisecond_minute: "mm:ss SSS",
  _duration_millisecond_hour: "hh:mm:ss SSS",
  _duration_millisecond_day: "d'd' mm:ss SSS",
  _duration_millisecond_week: "d'd' mm:ss SSS",
  _duration_millisecond_month: "M'm' dd'd' mm:ss SSS",
  _duration_millisecond_year: "y'y' MM'm' dd'd' mm:ss SSS",
  _duration_second: "ss",
  _duration_second_minute: "mm:ss",
  _duration_second_hour: "hh:mm:ss",
  _duration_second_day: "d'd' hh:mm:ss",
  _duration_second_week: "d'd' hh:mm:ss",
  _duration_second_month: "M'm' dd'd' hh:mm:ss",
  _duration_second_year: "y'y' MM'm' dd'd' hh:mm:ss",
  _duration_minute: "mm",
  _duration_minute_hour: "hh:mm",
  _duration_minute_day: "d'd' hh:mm",
  _duration_minute_week: "d'd' hh:mm",
  _duration_minute_month: "M'm' dd'd' hh:mm",
  _duration_minute_year: "y'y' MM'm' dd'd' hh:mm",
  _duration_hour: "hh'h'",
  _duration_hour_day: "d'd' hh'h'",
  _duration_hour_week: "d'd' hh'h'",
  _duration_hour_month: "M'm' dd'd' hh'h'",
  _duration_hour_year: "y'y' MM'm' dd'd' hh'h'",
  _duration_day: "d'd'",
  _duration_day_week: "d'd'",
  _duration_day_month: "M'm' dd'd'",
  _duration_day_year: "y'y' MM'm' dd'd'",
  _duration_week: "w'w'",
  _duration_week_month: "w'w'",
  _duration_week_year: "w'w'",
  _duration_month: "M'm'",
  _duration_month_year: "y'y' MM'm'",
  _duration_year: "y'y'",
  // Era translations
  _era_ad: "AD",
  _era_bc: "BC",
  // Day part, used in 12-hour formats, e.g. 5 P.M.
  // Please note that these come in 3 variants:
  // * one letter (e.g. "A")
  // * two letters (e.g. "AM")
  // * two letters with dots (e.g. "A.M.")
  // 
  // All three need to to be translated even if they are all the same. Some
  // users might use one, some the other.
  A: "",
  P: "",
  AM: "",
  PM: "",
  "A.M.": "",
  "P.M.": "",
  // Date-related stuff.
  // 
  // When translating months, if there's a difference, use the form which is
  // best for a full date, e.g. as you would use it in "2018 January 1".
  // 
  // Note that May is listed twice. This is because in English May is the same
  // in both long and short forms, while in other languages it may not be the
  // case. Translate "May" to full word, while "May(short)" to shortened
  // version.
  // 
  // Should month names and weekdays be capitalized or not?
  // 
  // Rule of thumb is this: if the names should always be capitalized,
  // regardless of name position within date ("January", "21st January 2018",
  // etc.) use capitalized names. Otherwise enter all lowercase.
  // 
  // The date formatter will automatically capitalize names if they are the
  // first (or only) word in resulting date.
  January: "",
  February: "",
  March: "",
  April: "",
  May: "",
  June: "",
  July: "",
  August: "",
  September: "",
  October: "",
  November: "",
  December: "",
  Jan: "",
  Feb: "",
  Mar: "",
  Apr: "",
  "May(short)": "May",
  Jun: "",
  Jul: "",
  Aug: "",
  Sep: "",
  Oct: "",
  Nov: "",
  Dec: "",
  // Weekdays.
  Sunday: "",
  Monday: "",
  Tuesday: "",
  Wednesday: "",
  Thursday: "",
  Friday: "",
  Saturday: "",
  Sun: "",
  Mon: "",
  Tue: "",
  Wed: "",
  Thu: "",
  Fri: "",
  Sat: "",
  // Date ordinal function.
  // 
  // This is used when adding number ordinal when formatting days in dates.
  // 
  // E.g. "January 1st", "February 2nd".
  // 
  // The function accepts day number, and returns a string to be added to the
  // day, like in default English translation, if we pass in 2, we will receive
  // "nd" back.
  _dateOrd: function(e) {
    let t = "th";
    if (e < 11 || e > 13)
      switch (e % 10) {
        case 1:
          t = "st";
          break;
        case 2:
          t = "nd";
          break;
        case 3:
          t = "rd";
          break;
      }
    return t;
  },
  // Various chart controls.
  // Shown as a tooltip on zoom out button.
  "Zoom Out": "",
  // Timeline buttons
  Play: "",
  Stop: "",
  // Chart's Legend screen reader title.
  Legend: "",
  // Legend's item screen reader indicator.
  "Press ENTER to toggle": "",
  // Shown when the chart is busy loading something.
  Loading: "",
  // Shown as the first button in the breadcrumb navigation, e.g.:
  // Home > First level > ...
  Home: "",
  // Chart types.
  // Those are used as default screen reader titles for the main chart element
  // unless developer has set some more descriptive title.
  Chart: "",
  "Serial chart": "",
  "X/Y chart": "",
  "Pie chart": "",
  "Gauge chart": "",
  "Radar chart": "",
  "Sankey diagram": "",
  "Flow diagram": "",
  "Chord diagram": "",
  "TreeMap chart": "",
  "Force directed tree": "",
  "Sliced chart": "",
  // Series types.
  // Used to name series by type for screen readers if they do not have their
  // name set.
  Series: "",
  "Candlestick Series": "",
  "OHLC Series": "",
  "Column Series": "",
  "Line Series": "",
  "Pie Slice Series": "",
  "Funnel Series": "",
  "Pyramid Series": "",
  "X/Y Series": "",
  // Map-related stuff.
  Map: "",
  "Press ENTER to zoom in": "",
  "Press ENTER to zoom out": "",
  "Use arrow keys to zoom in and out": "",
  "Use plus and minus keys on your keyboard to zoom in and out": "",
  // Export-related stuff.
  // These prompts are used in Export menu labels.
  // 
  // "Export" is the top-level menu item.
  // 
  // "Image", "Data", "Print" as second-level indicating type of export
  // operation.
  // 
  // Leave actual format untranslated, unless you absolutely know that they
  // would convey more meaning in some other way.
  Export: "",
  Image: "",
  Data: "",
  Print: "",
  "Press ENTER or use arrow keys to navigate": "",
  "Press ENTER to open": "",
  "Press ENTER to print.": "",
  "Press ENTER to export as %1.": "",
  "(Press ESC to close this message)": "",
  "Image Export Complete": "",
  "Export operation took longer than expected. Something might have gone wrong.": "",
  "Saved from": "",
  PNG: "",
  JPG: "",
  GIF: "",
  SVG: "",
  PDF: "",
  JSON: "",
  CSV: "",
  XLSX: "",
  HTML: "",
  // Scrollbar-related stuff.
  // 
  // Scrollbar is a control which can zoom and pan the axes on the chart.
  // 
  // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
  // upper and lower (for vertical one).
  // 
  // Prompts change in relation to whether Scrollbar is vertical or horizontal.
  // 
  // The final section is used to indicate the current range of selection.
  "Use TAB to select grip buttons or left and right arrows to change selection": "",
  "Use left and right arrows to move selection": "",
  "Use left and right arrows to move left selection": "",
  "Use left and right arrows to move right selection": "",
  "Use TAB select grip buttons or up and down arrows to change selection": "",
  "Use up and down arrows to move selection": "",
  "Use up and down arrows to move lower selection": "",
  "Use up and down arrows to move upper selection": "",
  "From %1 to %2": "",
  "From %1": "",
  "To %1": "",
  // Data loader-related.
  "No parser available for file: %1": "",
  "Error parsing file: %1": "",
  "Unable to load file: %1": "",
  "Invalid date": "",
  // Common actions
  Close: "",
  Minimize: ""
};
class xnt extends Lf {
  _setDefaults() {
    this.setPrivate("defaultLocale", uwe), super._setDefaults();
  }
  /**
   * Returns a prompt translation.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translate(t, n, ...r) {
    n || (n = this._root.locale || this.getPrivate("defaultLocale"));
    let i = t, o = n[t];
    if (o === null)
      i = "";
    else if (o != null)
      o && (i = o);
    else if (n !== this.getPrivate("defaultLocale"))
      return this.translate(t, this.getPrivate("defaultLocale"), ...r);
    if (r.length)
      for (let a = r.length, s = 0; s < a; ++s)
        i = i.split("%" + (s + 1)).join(r[s]);
    return i;
  }
  /**
   * Returns a prompt translation, including custom prompts.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translateAny(t, n, ...r) {
    return this.translate(t, n, ...r);
  }
  /**
   * Add a custom prompt to locale.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  prompt       Source prompt
   * @param  translation  Tanslation
   * @param  locale       Target locale
   */
  setTranslationAny(t, n, r) {
    const i = r || this._root.locale;
    i[t] = n;
  }
  /**
   * Add a batch of custom prompts.
   *
   * @since 5.3.3
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  translations  Translations
   * @param  locale        Target locale
   */
  setTranslationsAny(t, n) {
    ia(t, (r, i) => {
      this.setTranslationAny(r, i, n);
    });
  }
  translateEmpty(t, n, ...r) {
    let i = this.translate(t, n, ...r);
    return i == t ? "" : i;
  }
  translateFunc(t, n) {
    return this._root.locale[t] ? this._root.locale[t] : n !== this.getPrivate("defaultLocale") ? this.translateFunc(t, this.getPrivate("defaultLocale")) : () => "";
  }
  /**
   * Translates a btach of prompts.
   *
   * @param  list    Array of prompts to translate
   * @param  locale  Target locale
   * @return         Array of translations
   */
  translateAll(t, n) {
    return this.isDefault() ? t : vq(t, (r) => this.translate(r, n));
  }
  /**
   * Returns `true` if the currently selected locale is a default locale.
   *
   * @return `true` if locale is default; `false` if it is not.
   */
  isDefault() {
    return this.getPrivate("defaultLocale") === this._root.locale;
  }
}
class $K {
  constructor(t, n) {
    if (Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rules", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._root = t, !n)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(t) {
    const n = new this(t, !0);
    return n.setupDefaultRules(), n;
  }
  setupDefaultRules() {
  }
  /**
   * Looks up the rules for a specific theme class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @return             Array<IRule<A>>
   */
  _lookupRules(t) {
    return this._rules[t];
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
   * type checks.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  ruleRaw(t, n = []) {
    let r = this._rules[t];
    r || (r = this._rules[t] = []), n.sort(ZE);
    const { index: i, found: o } = _tt(r, (a) => {
      const s = ZE(a.tags.length, n.length);
      return s === 0 ? owe(a.tags, n, ZE) : s;
    });
    if (o)
      return r[i].template;
    {
      const a = nC.new({});
      return r.splice(i, 0, {
        tags: n,
        template: a
      }), a;
    }
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  rule(t, n = []) {
    return this.ruleRaw(t, n);
  }
}
function Vr(e, t, n, r) {
  e.set(t, n.get(r)), n.on(r, (i) => {
    e.set(t, i);
  });
}
class wnt extends $K {
  setupDefaultRules() {
    super.setupDefaultRules();
    const t = this._root.language, n = this._root.interfaceColors, r = this._root.horizontalLayout, i = this._root.verticalLayout, o = this.rule.bind(this);
    o("InterfaceColors").setAll({
      stroke: Mr.fromHex(15066597),
      fill: Mr.fromHex(15987699),
      primaryButton: Mr.fromHex(6788316),
      primaryButtonHover: Mr.fromHex(6779356),
      primaryButtonDown: Mr.fromHex(6872182),
      primaryButtonActive: Mr.fromHex(6872182),
      primaryButtonText: Mr.fromHex(16777215),
      primaryButtonStroke: Mr.fromHex(16777215),
      secondaryButton: Mr.fromHex(14277081),
      secondaryButtonHover: Mr.fromHex(10724259),
      secondaryButtonDown: Mr.fromHex(9276813),
      secondaryButtonActive: Mr.fromHex(15132390),
      secondaryButtonText: Mr.fromHex(0),
      secondaryButtonStroke: Mr.fromHex(16777215),
      grid: Mr.fromHex(0),
      background: Mr.fromHex(16777215),
      alternativeBackground: Mr.fromHex(0),
      text: Mr.fromHex(0),
      alternativeText: Mr.fromHex(16777215),
      disabled: Mr.fromHex(11382189),
      positive: Mr.fromHex(5288704),
      negative: Mr.fromHex(11730944)
    });
    {
      const a = o("ColorSet");
      a.setAll({
        passOptions: {
          hue: 0.05,
          saturation: 0,
          lightness: 0
        },
        colors: [
          Mr.fromHex(6797276)
        ],
        step: 1,
        //baseColor: Color.fromRGB(103, 183, 220),
        //count: 20,
        reuse: !1,
        startIndex: 0
      }), a.setPrivate("currentStep", 0), a.setPrivate("currentPass", 0);
    }
    o("Entity").setAll({
      stateAnimationDuration: 0,
      stateAnimationEasing: oT(RE)
    }), o("Component").setAll({
      interpolationDuration: 0,
      interpolationEasing: oT(RE)
    }), o("Sprite").setAll({
      visible: !0,
      scale: 1,
      opacity: 1,
      rotation: 0,
      position: "relative",
      tooltipX: Pa,
      tooltipY: Pa,
      tooltipPosition: "fixed",
      isMeasured: !0
    }), o("Sprite").states.create("default", { visible: !0, opacity: 1 }), o("Container").setAll({
      interactiveChildren: !0,
      setStateOnChildren: !1
    }), o("Graphics").setAll({
      strokeWidth: 1
    }), o("Chart").setAll({
      width: Eo,
      height: Eo,
      interactiveChildren: !1
    }), o("Sprite", ["horizontal", "center"]).setAll({
      centerX: Pa,
      x: Pa
    }), o("Sprite", ["vertical", "center"]).setAll({
      centerY: Pa,
      y: Pa
    }), o("Container", ["horizontal", "layout"]).setAll({
      layout: r
    }), o("Container", ["vertical", "layout"]).setAll({
      layout: i
    }), o("Pattern").setAll({
      repetition: "repeat",
      width: 50,
      height: 50,
      rotation: 0,
      fillOpacity: 1
    }), o("LinePattern").setAll({
      gap: 6,
      colorOpacity: 1,
      width: 49,
      height: 49
    }), o("RectanglePattern").setAll({
      gap: 6,
      checkered: !1,
      centered: !0,
      maxWidth: 5,
      maxHeight: 5,
      width: 48,
      height: 48,
      strokeWidth: 0
    }), o("CirclePattern").setAll({
      gap: 5,
      checkered: !1,
      centered: !1,
      radius: 3,
      strokeWidth: 0,
      width: 45,
      height: 45
    }), o("LinearGradient").setAll({
      rotation: 90
    }), o("Legend").setAll({
      fillField: "fill",
      strokeField: "stroke",
      nameField: "name",
      layout: xS.new(this._root, {}),
      layer: 30,
      clickTarget: "itemContainer"
    }), o("Container", ["legend", "item", "itemcontainer"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingBottom: 5,
      paddingTop: 5,
      layout: r,
      setStateOnChildren: !0,
      interactiveChildren: !1,
      ariaChecked: !0,
      focusable: !0,
      ariaLabel: t.translate("Press ENTER to toggle"),
      role: "checkbox"
    });
    {
      const a = o("Rectangle", ["legend", "item", "background"]);
      a.setAll({
        fillOpacity: 0
      }), Vr(a, "fill", n, "background");
    }
    o("Container", ["legend", "marker"]).setAll({
      setStateOnChildren: !0,
      centerY: Pa,
      paddingLeft: 0,
      paddingRight: 0,
      paddingBottom: 0,
      paddingTop: 0,
      width: 18,
      height: 18
    }), o("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
      width: Eo,
      height: Eo,
      cornerRadiusBL: 3,
      cornerRadiusTL: 3,
      cornerRadiusBR: 3,
      cornerRadiusTR: 3
    });
    {
      const a = o("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
      Vr(a, "fill", n, "disabled"), Vr(a, "stroke", n, "disabled");
    }
    o("Label", ["legend", "label"]).setAll({
      centerY: Pa,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      populateText: !0
    });
    {
      const a = o("Label", ["legend", "label"]).states.create("disabled", {});
      Vr(a, "fill", n, "disabled");
    }
    o("Label", ["legend", "value", "label"]).setAll({
      centerY: Pa,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      width: 50,
      centerX: Eo,
      populateText: !0
    });
    {
      const a = o("Label", ["legend", "value", "label"]).states.create("disabled", {});
      Vr(a, "fill", n, "disabled");
    }
    o("HeatLegend").setAll({
      stepCount: 1
    }), o("RoundedRectangle", ["heatlegend", "marker"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBL: 0
    }), o("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
      height: Eo,
      width: 15
    }), o("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
      width: Eo,
      height: 15
    }), o("HeatLegend", ["vertical"]).setAll({
      height: Eo
    }), o("HeatLegend", ["horizontal"]).setAll({
      width: Eo
    }), o("Label", ["heatlegend", "start"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    }), o("Label", ["heatlegend", "end"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    });
    {
      const a = o("Label");
      a.setAll({
        paddingTop: 8,
        paddingBottom: 8,
        paddingLeft: 10,
        paddingRight: 10,
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
        fontSize: "1em",
        populateText: !1
      }), Vr(a, "fill", n, "text");
    }
    o("RadialLabel").setAll({
      textType: "regular",
      centerY: Pa,
      centerX: Pa,
      inside: !1,
      radius: 0,
      baseRadius: Eo,
      orientation: "auto",
      textAlign: "center"
    }), o("RoundedRectangle").setAll({
      cornerRadiusTL: 8,
      cornerRadiusBL: 8,
      cornerRadiusTR: 8,
      cornerRadiusBR: 8
    }), o("PointedRectangle").setAll({
      pointerBaseWidth: 15,
      pointerLength: 10,
      cornerRadius: 8
    }), o("Slice").setAll({
      shiftRadius: 0,
      dRadius: 0,
      dInnerRadius: 0
    });
    {
      const a = o("Tick");
      a.setAll({
        strokeOpacity: 0.15,
        isMeasured: !1,
        length: 4.5,
        position: "absolute",
        crisp: !0
      }), Vr(a, "stroke", n, "grid");
    }
    o("Bullet").setAll({
      locationX: 0.5,
      locationY: 0.5
    }), o("Tooltip").setAll({
      position: "absolute",
      getFillFromSprite: !0,
      getStrokeFromSprite: !1,
      autoTextColor: !0,
      paddingTop: 9,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      marginBottom: 5,
      pointerOrientation: "vertical",
      centerX: Pa,
      centerY: Pa,
      animationEasing: oT(RE),
      exportable: !1
      //layer: 100
    }), o("Polygon").setAll({
      animationEasing: oT(RE)
    }), o("PointedRectangle", ["tooltip", "background"]).setAll({
      strokeOpacity: 0.9,
      cornerRadius: 4,
      pointerLength: 4,
      pointerBaseWidth: 8,
      fillOpacity: 0.9,
      stroke: Mr.fromHex(16777215)
    });
    {
      const a = o("Label", ["tooltip"]);
      a.setAll({
        role: "tooltip",
        populateText: !0,
        paddingRight: 0,
        paddingTop: 0,
        paddingLeft: 0,
        paddingBottom: 0
      }), Vr(a, "fill", n, "alternativeText");
    }
    o("Button").setAll({
      paddingTop: 8,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      interactive: !0,
      layout: r,
      interactiveChildren: !1,
      setStateOnChildren: !0,
      focusable: !0
    }), o("Button").states.create("hover", {}), o("Button").states.create("down", { stateAnimationDuration: 0 }), o("Button").states.create("active", {});
    {
      const a = o("RoundedRectangle", ["button", "background"]);
      Vr(a, "fill", n, "primaryButton"), Vr(a, "stroke", n, "primaryButtonStroke");
    }
    {
      const a = o("RoundedRectangle", ["button", "background"]).states.create("hover", {});
      Vr(a, "fill", n, "primaryButtonHover");
    }
    {
      const a = o("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
      Vr(a, "fill", n, "primaryButtonDown");
    }
    {
      const a = o("RoundedRectangle", ["button", "background"]).states.create("active", {});
      Vr(a, "fill", n, "primaryButtonActive");
    }
    {
      const a = o("Graphics", ["button", "icon"]);
      Vr(a, "stroke", n, "primaryButtonText");
    }
    {
      const a = o("Label", ["button"]);
      Vr(a, "fill", n, "primaryButtonText");
    }
    o("Button", ["zoom"]).setAll({
      paddingTop: 18,
      paddingBottom: 18,
      paddingLeft: 12,
      paddingRight: 12,
      centerX: 46,
      centerY: -10,
      y: 0,
      x: Eo,
      role: "button",
      ariaLabel: t.translate("Zoom Out"),
      layer: 30
    });
    {
      const a = o("RoundedRectangle", ["background", "button", "zoom"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), Vr(a, "fill", n, "primaryButton");
    }
    {
      const a = o("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
      Vr(a, "fill", n, "primaryButtonHover");
    }
    {
      const a = o("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
      Vr(a, "fill", n, "primaryButtonDown");
    }
    {
      const a = o("Graphics", ["icon", "button", "zoom"]);
      a.setAll({
        crisp: !0,
        strokeOpacity: 0.7,
        draw: (s) => {
          s.moveTo(0, 0), s.lineTo(12, 0);
        }
      }), Vr(a, "stroke", n, "primaryButtonText");
    }
    o("Button", ["resize"]).setAll({
      paddingTop: 9,
      paddingBottom: 9,
      paddingLeft: 13,
      paddingRight: 13,
      draggable: !0,
      centerX: Pa,
      centerY: Pa,
      position: "absolute",
      role: "slider",
      ariaValueMin: "0",
      ariaValueMax: "100",
      ariaLabel: t.translate("Use up and down arrows to move selection")
    });
    {
      const a = o("RoundedRectangle", ["background", "resize", "button"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), Vr(a, "fill", n, "secondaryButton"), Vr(a, "stroke", n, "secondaryButtonStroke");
    }
    {
      const a = o("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
      Vr(a, "fill", n, "secondaryButtonHover");
    }
    {
      const a = o("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
      Vr(a, "fill", n, "secondaryButtonDown");
    }
    {
      const a = o("Graphics", ["resize", "button", "icon"]);
      a.setAll({
        interactive: !1,
        crisp: !0,
        strokeOpacity: 0.5,
        draw: (s) => {
          s.moveTo(0, 0.5), s.lineTo(0, 12.5), s.moveTo(4, 0.5), s.lineTo(4, 12.5);
        }
      }), Vr(a, "stroke", n, "secondaryButtonText");
    }
    o("Button", ["resize", "vertical"]).setAll({
      rotation: 90,
      cursorOverStyle: "ns-resize"
    }), o("Button", ["resize", "horizontal"]).setAll({
      cursorOverStyle: "ew-resize"
    }), o("Button", ["play"]).setAll({
      paddingTop: 13,
      paddingBottom: 13,
      paddingLeft: 14,
      paddingRight: 14,
      ariaLabel: t.translate("Play"),
      toggleKey: "active"
    });
    {
      const a = o("RoundedRectangle", ["play", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), Vr(a, "fill", n, "primaryButton");
    }
    {
      const a = o("Graphics", ["play", "icon"]);
      a.setAll({
        stateAnimationDuration: 0,
        dx: 1,
        draw: (s) => {
          s.moveTo(0, -5), s.lineTo(8, 0), s.lineTo(0, 5), s.lineTo(0, -5);
        }
      }), Vr(a, "fill", n, "primaryButtonText");
    }
    o("Graphics", ["play", "icon"]).states.create("default", {
      stateAnimationDuration: 0
    }), o("Graphics", ["play", "icon"]).states.create("active", {
      stateAnimationDuration: 0,
      draw: (a) => {
        a.moveTo(-4, -5), a.lineTo(-1, -5), a.lineTo(-1, 5), a.lineTo(-4, 5), a.lineTo(-4, -5), a.moveTo(4, -5), a.lineTo(1, -5), a.lineTo(1, 5), a.lineTo(4, 5), a.lineTo(4, -5);
      }
    }), o("Button", ["switch"]).setAll({
      paddingTop: 4,
      paddingBottom: 4,
      paddingLeft: 4,
      paddingRight: 4,
      ariaLabel: t.translate("Press ENTER to toggle"),
      toggleKey: "active",
      width: 40,
      height: 24,
      layout: null
    });
    {
      const a = o("RoundedRectangle", ["switch", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), Vr(a, "fill", n, "primaryButton");
    }
    {
      const a = o("Circle", ["switch", "icon"]);
      a.setAll({
        radius: 8,
        centerY: 0,
        centerX: 0,
        dx: 0
      }), Vr(a, "fill", n, "primaryButtonText");
    }
    o("Graphics", ["switch", "icon"]).states.create("active", {
      dx: 16
    }), o("Scrollbar").setAll({
      start: 0,
      end: 1,
      layer: 30,
      animationEasing: oT(RE)
    }), o("Scrollbar", ["vertical"]).setAll({
      marginRight: 13,
      marginLeft: 13,
      minWidth: 12,
      height: Eo
    }), o("Scrollbar", ["horizontal"]).setAll({
      marginTop: 13,
      marginBottom: 13,
      minHeight: 12,
      width: Eo
    }), this.rule("Button", ["scrollbar"]).setAll({
      exportable: !1
    });
    {
      const a = o("RoundedRectangle", ["scrollbar", "main", "background"]);
      a.setAll({
        cornerRadiusTL: 8,
        cornerRadiusBL: 8,
        cornerRadiusTR: 8,
        cornerRadiusBR: 8,
        fillOpacity: 0.8
      }), Vr(a, "fill", n, "fill");
    }
    {
      const a = o("RoundedRectangle", ["scrollbar", "thumb"]);
      a.setAll({
        role: "slider",
        ariaLive: "polite",
        position: "absolute",
        draggable: !0
      }), Vr(a, "fill", n, "secondaryButton");
    }
    {
      const a = o("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
      Vr(a, "fill", n, "secondaryButtonHover");
    }
    {
      const a = o("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
      Vr(a, "fill", n, "secondaryButtonDown");
    }
    o("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
      x: Pa,
      width: Eo,
      centerX: Pa,
      ariaLabel: t.translate("Use up and down arrows to move selection")
    }), o("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
      y: Pa,
      centerY: Pa,
      height: Eo,
      ariaLabel: t.translate("Use left and right arrows to move selection")
    });
    {
      const a = o("PointedRectangle", ["axis", "tooltip", "background"]);
      a.setAll({
        cornerRadius: 0
      }), Vr(a, "fill", n, "alternativeBackground");
    }
    o("Label", ["axis", "tooltip"]).setAll({
      role: void 0
    }), o("Label", ["axis", "tooltip", "y"]).setAll({
      textAlign: "right"
    }), o("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
      textAlign: "left"
    }), o("Label", ["axis", "tooltip", "x"]).setAll({
      textAlign: "center"
    }), o("Tooltip", ["categoryaxis"]).setAll({
      labelText: "{category}"
    }), o("Star").setAll({
      spikes: 5,
      innerRadius: 5,
      radius: 10
    }), o("Tooltip", ["stock"]).setAll({
      paddingTop: 6,
      paddingBottom: 5,
      paddingLeft: 7,
      paddingRight: 7
    }), o("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
      pointerLength: 0,
      pointerBaseWidth: 0,
      cornerRadius: 3
    }), o("Label", ["tooltip", "stock"]).setAll({
      fontSize: "0.8em"
    }), o("SpriteResizer").setAll({
      rotationStep: 10
    }), o("Container", ["resizer", "grip"]).states.create("hover", {});
    {
      const a = o("RoundedRectangle", ["resizer", "grip"]);
      a.setAll({
        strokeOpacity: 0.7,
        strokeWidth: 1,
        fillOpacity: 1,
        width: 12,
        height: 12
      }), Vr(a, "fill", n, "background"), Vr(a, "stroke", n, "alternativeBackground");
    }
    {
      const a = o("RoundedRectangle", ["resizer", "grip", "outline"]);
      a.setAll({
        strokeOpacity: 0,
        fillOpacity: 0,
        width: 20,
        height: 20
      }), a.states.create("hover", {
        fillOpacity: 0.3
      }), Vr(a, "fill", n, "alternativeBackground");
    }
    o("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    }), o("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    });
    {
      const a = o("Rectangle", ["resizer", "rectangle"]);
      a.setAll({
        strokeDasharray: [2, 2],
        strokeOpacity: 0.5,
        strokeWidth: 1
      }), Vr(a, "stroke", n, "alternativeBackground");
    }
  }
}
class qY {
  constructor(t = 1, n = 0, r = 0, i = 1, o = 0, a = 0) {
    Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "b", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "c", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "d", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.a = t, this.b = n, this.c = r, this.d = i, this.tx = o, this.ty = a;
  }
  /**
   * Sets the matrix based on all the available properties
   */
  setTransform(t, n, r, i, o, a = 1) {
    this.a = Math.cos(o) * a, this.b = Math.sin(o) * a, this.c = -Math.sin(o) * a, this.d = Math.cos(o) * a, this.tx = t - (r * this.a + i * this.c), this.ty = n - (r * this.b + i * this.d);
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   */
  apply(t) {
    return {
      x: this.a * t.x + this.c * t.y + this.tx,
      y: this.b * t.x + this.d * t.y + this.ty
    };
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   */
  applyInverse(t) {
    const n = 1 / (this.a * this.d + this.c * -this.b);
    return {
      x: this.d * n * t.x + -this.c * n * t.y + (this.ty * this.c - this.tx * this.d) * n,
      y: this.a * n * t.y + -this.b * n * t.x + (-this.ty * this.a + this.tx * this.b) * n
    };
  }
  /**
   * Appends the given Matrix to this Matrix.
   */
  append(t) {
    const n = this.a, r = this.b, i = this.c, o = this.d;
    this.a = t.a * n + t.b * i, this.b = t.a * r + t.b * o, this.c = t.c * n + t.d * i, this.d = t.c * r + t.d * o, this.tx = t.tx * n + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * o + this.ty;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   */
  prepend(t) {
    const n = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      const r = this.a, i = this.c;
      this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d;
    }
    this.tx = n * t.a + this.ty * t.c + t.tx, this.ty = n * t.b + this.ty * t.d + t.ty;
  }
  /**
   * Copies the other matrix's properties into this matrix
   */
  copyFrom(t) {
    this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty;
  }
}
var _nt = function() {
  function e(t, n) {
    var r = [], i = !0, o = !1, a = void 0;
    try {
      for (var s = t[Symbol.iterator](), u; !(i = (u = s.next()).done) && (r.push(u.value), !(n && r.length === n)); i = !0)
        ;
    } catch (l) {
      o = !0, a = l;
    } finally {
      try {
        !i && s.return && s.return();
      } finally {
        if (o)
          throw a;
      }
    }
    return r;
  }
  return function(t, n) {
    if (Array.isArray(t))
      return t;
    if (Symbol.iterator in Object(t))
      return e(t, n);
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
}(), CR = Math.PI * 2, GY = function(t, n, r, i, o, a, s) {
  var u = t.x, l = t.y;
  u *= n, l *= r;
  var f = i * u - o * l, h = o * u + i * l;
  return {
    x: f + a,
    y: h + s
  };
}, Ent = function(t, n) {
  var r = n === 1.5707963267948966 ? 0.551915024494 : n === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(n / 4), i = Math.cos(t), o = Math.sin(t), a = Math.cos(t + n), s = Math.sin(t + n);
  return [{
    x: i - o * r,
    y: o + i * r
  }, {
    x: a + s * r,
    y: s - a * r
  }, {
    x: a,
    y: s
  }];
}, kfe = function(t, n, r, i) {
  var o = t * i - n * r < 0 ? -1 : 1, a = t * r + n * i;
  return a > 1 && (a = 1), a < -1 && (a = -1), o * Math.acos(a);
}, Snt = function(t, n, r, i, o, a, s, u, l, f, h, p) {
  var g = Math.pow(o, 2), y = Math.pow(a, 2), b = Math.pow(h, 2), _ = Math.pow(p, 2), S = g * y - g * _ - y * b;
  S < 0 && (S = 0), S /= g * _ + y * b, S = Math.sqrt(S) * (s === u ? -1 : 1);
  var C = S * o / a * p, A = S * -a / o * h, O = f * C - l * A + (t + r) / 2, R = l * C + f * A + (n + i) / 2, j = (h - C) / o, $ = (p - A) / a, z = (-h - C) / o, W = (-p - A) / a, Y = kfe(1, 0, j, $), V = kfe(j, $, z, W);
  return u === 0 && V > 0 && (V -= CR), u === 1 && V < 0 && (V += CR), [O, R, Y, V];
}, Mnt = function(t) {
  var n = t.px, r = t.py, i = t.cx, o = t.cy, a = t.rx, s = t.ry, u = t.xAxisRotation, l = u === void 0 ? 0 : u, f = t.largeArcFlag, h = f === void 0 ? 0 : f, p = t.sweepFlag, g = p === void 0 ? 0 : p, y = [];
  if (a === 0 || s === 0)
    return [];
  var b = Math.sin(l * CR / 360), _ = Math.cos(l * CR / 360), S = _ * (n - i) / 2 + b * (r - o) / 2, C = -b * (n - i) / 2 + _ * (r - o) / 2;
  if (S === 0 && C === 0)
    return [];
  a = Math.abs(a), s = Math.abs(s);
  var A = Math.pow(S, 2) / Math.pow(a, 2) + Math.pow(C, 2) / Math.pow(s, 2);
  A > 1 && (a *= Math.sqrt(A), s *= Math.sqrt(A));
  var O = Snt(n, r, i, o, a, s, h, g, b, _, S, C), R = _nt(O, 4), j = R[0], $ = R[1], z = R[2], W = R[3], Y = Math.abs(W) / (CR / 4);
  Math.abs(1 - Y) < 1e-7 && (Y = 1);
  var V = Math.max(Math.ceil(Y), 1);
  W /= V;
  for (var ee = 0; ee < V; ee++)
    y.push(Ent(z, W)), z += W;
  return y.map(function(K) {
    var Q = GY(K[0], a, s, _, b, j, $), q = Q.x, te = Q.y, X = GY(K[1], a, s, _, b, j, $), Z = X.x, se = X.y, H = GY(K[2], a, s, _, b, j, $), ie = H.x, he = H.y;
    return { x1: q, y1: te, x2: Z, y2: se, x: ie, y: he };
  });
};
function Tnt(e, t, n) {
  if (t !== n)
    throw new Error("Required " + n + " arguments for " + e + " but got " + t);
}
function CO(e, t, n) {
  if (t < n)
    throw new Error("Required at least " + n + " arguments for " + e + " but got " + t);
}
function md(e, t, n) {
  if (CO(e, t, n), t % n !== 0)
    throw new Error("Arguments for " + e + " must be in pairs of " + n);
}
function Cnt(e) {
  for (let t = 0; t < e.length; t += 7) {
    let n = t + 3, r = e[n];
    if (r.length > 1) {
      const i = /^([01])([01])(.*)$/.exec(r);
      i !== null && (e.splice(n, 0, i[1]), ++n, e.splice(n, 0, i[2]), ++n, i[3].length > 0 ? e[n] = i[3] : e.splice(n, 1));
    }
    if (++n, r = e[n], r.length > 1) {
      const i = /^([01])(.+)$/.exec(r);
      i !== null && (e.splice(n, 0, i[1]), ++n, e[n] = i[2]);
    }
  }
}
function $fe(e) {
  if (e === 0 || e === 1)
    return e;
  throw new Error("Flag must be 0 or 1");
}
function Nnt(e) {
  const t = [0, 0, 0];
  for (let n = 0; n < 24; n++)
    t[n % 3] <<= 1, t[n % 3] |= e & 1, e >>= 1;
  return (t[2] | 0) + (t[1] << 8) + (t[0] << 16);
}
function zI(e, t) {
  for (; !(e.interactive && !t(e)); )
    if (e._parent)
      e = e._parent;
    else
      break;
}
function Dnt(e, t, n) {
  return Ja(e, bq(t), (r) => {
    const i = Zxe(r);
    let o = r.touches;
    o ? (o.length == 0 && (o = r.changedTouches), n(btt(o), i)) : n([r], i);
  });
}
function Pfe(e) {
  const t = document.createElement("canvas");
  t.width = 1, t.height = 1;
  const n = t.getContext("2d", { willReadFrequently: !0 });
  n.drawImage(e, 0, 0, 1, 1);
  try {
    return n.getImageData(0, 0, 1, 1), !1;
  } catch {
    return console.warn('Image "' + e.src + '" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors'), !0;
  }
}
function NO(e) {
  e.width = 0, e.height = 0, e.style.width = "0px", e.style.height = "0px";
}
class Ant {
  constructor() {
    Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(t) {
    this._x = t;
  }
  set y(t) {
    this._y = t;
  }
}
class bF extends OK {
  constructor(t) {
    super(), Object.defineProperty(this, "_layer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "interactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "wheelable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "cancelTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isMeasured", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "buttonMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "alpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "compoundAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "angle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "crisp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "pivot", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ant()
    }), Object.defineProperty(this, "filter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursorOverStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_replacedCursorStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new qY()
    }), Object.defineProperty(this, "_matrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new qY()
    }), Object.defineProperty(this, "_uMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new qY()
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_bounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._renderer = t;
  }
  _dispose() {
    this._renderer._removeObject(this), this.getLayer().dirty = !0;
  }
  getCanvas() {
    return this.getLayer().view;
  }
  getLayer() {
    let t = this;
    for (; ; ) {
      if (t._layer)
        return t._layer;
      if (t._parent)
        t = t._parent;
      else
        return this._renderer.defaultLayer;
    }
  }
  setLayer(t, n) {
    t == null ? this._layer = void 0 : (this._layer = this._renderer.getLayer(t, !0), this._layer.visible = !0, this._layer.margin = n, n && iT(this._layer.view, !1), this._renderer._ghostLayer.setMargin(this._renderer.layers), this._parent && this._parent.registerChildLayer(this._layer), this._layer.dirty = !0, this._renderer.resizeLayer(this._layer), this._renderer.resizeGhost());
  }
  markDirtyLayer() {
    this.getLayer().dirty = !0;
  }
  clear() {
    this.invalidateBounds();
  }
  invalidateBounds() {
    this._localBounds = void 0;
  }
  _addBounds(t) {
  }
  _getColorId() {
    return this._colorId === void 0 && (this._colorId = this._renderer.paintId(this)), this._colorId;
  }
  _isInteractive() {
    return this.inactive == !1 && (this.interactive || this._renderer._forceInteractive > 0);
  }
  _isInteractiveMask() {
    return this._isInteractive();
  }
  contains(t) {
    for (; ; ) {
      if (t === this)
        return !0;
      if (t._parent)
        t = t._parent;
      else
        return !1;
    }
  }
  toGlobal(t) {
    return this._matrix.apply(t);
  }
  toLocal(t) {
    return this._matrix.applyInverse(t);
  }
  getLocalMatrix() {
    return this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale), this._uMatrix;
  }
  getLocalBounds() {
    return this._localBounds || (this._localBounds = {
      left: 1e7,
      top: 1e7,
      right: -1e7,
      bottom: -1e7
    }, this._addBounds(this._localBounds)), this._localBounds;
  }
  getAdjustedBounds(t) {
    this._setMatrix();
    const n = this.getLocalMatrix(), r = n.apply({ x: t.left, y: t.top }), i = n.apply({ x: t.right, y: t.top }), o = n.apply({ x: t.right, y: t.bottom }), a = n.apply({ x: t.left, y: t.bottom });
    return {
      left: Math.min(r.x, i.x, o.x, a.x),
      top: Math.min(r.y, i.y, o.y, a.y),
      right: Math.max(r.x, i.x, o.x, a.x),
      bottom: Math.max(r.y, i.y, o.y, a.y)
    };
  }
  on(t, n, r) {
    return this.interactive ? this._renderer._addEvent(this, t, n, r) : new Bs(() => {
    });
  }
  _setMatrix() {
    this._localMatrix.setTransform(
      this.x,
      this.y,
      this.pivot.x,
      this.pivot.y,
      // Converts degrees to radians
      this.angle * Math.PI / 180,
      this.scale
    ), this._matrix.copyFrom(this._localMatrix), this._parent && this._matrix.prepend(this._parent._matrix);
  }
  _transform(t, n) {
    const r = this._matrix;
    let i = r.tx * n, o = r.ty * n;
    this.crisp && (i = Math.floor(i) + 0.5, o = Math.floor(o) + 0.5), t.setTransform(r.a * n, r.b * n, r.c * n, r.d * n, i, o);
  }
  _transformMargin(t, n, r) {
    const i = this._matrix;
    t.setTransform(i.a * n, i.b * n, i.c * n, i.d * n, (i.tx + r.left) * n, (i.ty + r.top) * n);
  }
  _transformLayer(t, n, r) {
    r.margin ? this._transformMargin(t, r.scale || n, r.margin) : this._transform(t, r.scale || n);
  }
  render(t) {
    if (this.visible && (this.exportable !== !1 || !this._renderer._omitTainted)) {
      this._setMatrix();
      const n = this._renderer.resolution, r = this._renderer.layers, i = this._renderer._ghostLayer, o = i.context, a = this.mask;
      a && a._setMatrix(), ut(r, (s) => {
        if (s) {
          const u = s.context;
          u.save(), a && (a._transformLayer(u, n, s), a._runPath(u), u.clip()), u.globalAlpha = this.compoundAlpha * this.alpha, this._transformLayer(u, n, s), this.filter && (u.filter = this.filter);
        }
      }), o.save(), a && this._isInteractiveMask() && (a._transformMargin(o, n, i.margin), a._runPath(o), o.clip()), this._transformMargin(o, n, i.margin), this._render(t), o.restore(), ut(r, (s) => {
        s && s.context.restore();
      });
    }
  }
  _render(t) {
    if (this.exportable === !1) {
      const n = this._layer || t;
      n.tainted = !0;
    }
  }
  hovering() {
    return this._renderer._hovering.has(this);
  }
  dragging() {
    return this._renderer._dragging.some((t) => t.value === this);
  }
  shouldCancelTouch() {
    const t = this._renderer;
    return t.tapToActivate && !t._touchActive ? !1 : this.cancelTouch ? !0 : this._parent ? this._parent.shouldCancelTouch() : !1;
  }
}
class Ont extends bF {
  constructor() {
    super(...arguments), Object.defineProperty(this, "interactiveChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_childLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _isInteractiveMask() {
    return this.interactiveChildren || super._isInteractiveMask();
  }
  addChild(t) {
    t._parent = this, this._children.push(t), t._layer && this.registerChildLayer(t._layer);
  }
  addChildAt(t, n) {
    t._parent = this, this._children.splice(n, 0, t), t._layer && this.registerChildLayer(t._layer);
  }
  removeChild(t) {
    t._parent = void 0, Md(this._children, t);
  }
  _render(t) {
    super._render(t);
    const n = this._renderer;
    this.interactive && this.interactiveChildren && ++n._forceInteractive;
    const r = this._layer || t;
    ut(this._children, (i) => {
      i.compoundAlpha = this.compoundAlpha * this.alpha, i.render(r);
    }), this.interactive && this.interactiveChildren && --n._forceInteractive;
  }
  registerChildLayer(t) {
    this._childLayers || (this._childLayers = []), mk(this._childLayers, t), this._parent && this._parent.registerChildLayer(t);
  }
  markDirtyLayer(t = !1) {
    super.markDirtyLayer(), t && this._childLayers && ut(this._childLayers, (n) => n.dirty = !0);
  }
  _dispose() {
    super._dispose(), this._childLayers && ut(this._childLayers, (t) => {
      t.dirty = !0;
    });
  }
}
function ts(e, t) {
  e.left = Math.min(e.left, t.x), e.top = Math.min(e.top, t.y), e.right = Math.max(e.right, t.x), e.bottom = Math.max(e.bottom, t.y);
}
class qs {
  colorize(t, n) {
  }
  path(t) {
  }
  addBounds(t) {
  }
}
class Rnt extends qs {
  colorize(t, n) {
    t.beginPath();
  }
}
class QY extends qs {
  constructor(t) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  colorize(t, n) {
    n !== void 0 ? t.fillStyle = n : t.fillStyle = this.color;
  }
}
class knt extends qs {
  constructor(t) {
    super(), Object.defineProperty(this, "clearShadow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  colorize(t, n) {
    t.fill(), this.clearShadow && (t.shadowColor = "", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);
  }
}
class $nt extends qs {
  colorize(t, n) {
    t.stroke();
  }
}
class XY extends qs {
  constructor(t, n, r) {
    super(), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "lineJoin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  colorize(t, n) {
    n !== void 0 ? t.strokeStyle = n : t.strokeStyle = this.color, t.lineWidth = this.width, this.lineJoin && (t.lineJoin = this.lineJoin);
  }
}
class Pnt extends qs {
  constructor(t) {
    super(), Object.defineProperty(this, "dash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  colorize(t, n) {
    t.setLineDash(this.dash);
  }
}
class Int extends qs {
  constructor(t) {
    super(), Object.defineProperty(this, "dashOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  colorize(t, n) {
    t.lineDashOffset = this.dashOffset;
  }
}
class jnt extends qs {
  constructor(t, n, r, i) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    });
  }
  path(t) {
    t.rect(this.x, this.y, this.width, this.height);
  }
  addBounds(t) {
    const n = this.x, r = this.y, i = n + this.width, o = r + this.height;
    ts(t, { x: n, y: r }), ts(t, { x: i, y: r }), ts(t, { x: n, y: o }), ts(t, { x: i, y: o });
  }
}
class Lnt extends qs {
  constructor(t, n, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(t) {
    t.moveTo(this.x + this.radius, this.y), t.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
  }
  // TODO handle skewing and rotation
  addBounds(t) {
    ts(t, { x: this.x - this.radius, y: this.y - this.radius }), ts(t, { x: this.x + this.radius, y: this.y + this.radius });
  }
}
class znt extends qs {
  constructor(t, n, r, i) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "radiusX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "radiusY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    });
  }
  path(t) {
    t.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
  }
  // TODO handle skewing and rotation
  addBounds(t) {
    ts(t, { x: this.x - this.radiusX, y: this.y - this.radiusY }), ts(t, { x: this.x + this.radiusX, y: this.y + this.radiusY });
  }
}
class Fnt extends qs {
  constructor(t, n, r, i, o, a) {
    super(), Object.defineProperty(this, "cx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "cy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "endAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    }), Object.defineProperty(this, "anticlockwise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(t) {
    this.radius > 0 && t.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
  }
  addBounds(t) {
    let n = nnt(this.cx, this.cy, this.startAngle * KE, this.endAngle * KE, this.radius);
    ts(t, { x: n.left, y: n.top }), ts(t, { x: n.right, y: n.bottom });
  }
}
class Bnt extends qs {
  constructor(t, n, r, i, o) {
    super(), Object.defineProperty(this, "x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "x2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "y2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    });
  }
  path(t) {
    this.radius > 0 && t.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
  }
  // TODO: add points
  addBounds(t) {
  }
}
class Unt extends qs {
  constructor(t, n) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(t) {
    t.lineTo(this.x, this.y);
  }
  addBounds(t) {
    ts(t, { x: this.x, y: this.y });
  }
}
class Ynt extends qs {
  constructor(t, n) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(t) {
    t.moveTo(this.x, this.y);
  }
  addBounds(t) {
    ts(t, { x: this.x, y: this.y });
  }
}
class Hnt extends qs {
  path(t) {
    t.closePath();
  }
}
class Vnt extends qs {
  constructor(t, n, r, i, o, a) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "cpX2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "cpY2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(t) {
    t.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(t) {
    ts(t, { x: this.cpX, y: this.cpY }), ts(t, { x: this.cpX2, y: this.cpY2 }), ts(t, { x: this.toX, y: this.toY });
  }
}
class Wnt extends qs {
  constructor(t, n, r, i) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    });
  }
  path(t) {
    t.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(t) {
    ts(t, { x: this.cpX, y: this.cpY }), ts(t, { x: this.toX, y: this.toY });
  }
}
class qnt extends qs {
  constructor(t, n, r, i, o) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "blur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "offsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "offsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "opacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    });
  }
  colorize(t, n) {
    this.opacity && (t.fillStyle = this.color), t.shadowColor = this.color, t.shadowBlur = this.blur, t.shadowOffsetX = this.offsetX, t.shadowOffsetY = this.offsetY;
  }
}
class Gnt extends qs {
  constructor(t, n, r, i, o) {
    super(), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
    });
  }
  path(t) {
    t.drawImage(this.image, this.x, this.y, this.width, this.height);
  }
  // TODO: OK?
  addBounds(t) {
    ts(t, { x: this.x, y: this.y }), ts(t, { x: this.width, y: this.height });
  }
}
class Qnt extends bF {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_operations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blendMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Zj.NORMAL
    }), Object.defineProperty(this, "_hasShadows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_fillAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  clear() {
    super.clear(), this._operations.length = 0;
  }
  _pushOp(t) {
    this._operations.push(t);
  }
  beginFill(t, n = 1) {
    this._fillAlpha = n, t ? t instanceof Mr ? this._pushOp(new QY(t.toCSS(n))) : (this.isMeasured = !0, this._pushOp(new QY(t))) : this._pushOp(new QY("rgba(0, 0, 0, " + n + ")"));
  }
  endFill() {
    this._pushOp(new knt(this._hasShadows));
  }
  endStroke() {
    this._pushOp(new $nt());
  }
  beginPath() {
    this._pushOp(new Rnt());
  }
  lineStyle(t = 0, n, r = 1, i) {
    this._strokeAlpha = r, n ? n instanceof Mr ? this._pushOp(new XY(t, n.toCSS(r), i)) : this._pushOp(new XY(t, n, i)) : this._pushOp(new XY(t, "rgba(0, 0, 0, " + r + ")", i));
  }
  setLineDash(t) {
    this._pushOp(new Pnt(t || []));
  }
  setLineDashOffset(t = 0) {
    this._pushOp(new Int(t));
  }
  drawRect(t, n, r, i) {
    this._pushOp(new jnt(t, n, r, i));
  }
  drawCircle(t, n, r) {
    this._pushOp(new Lnt(t, n, r));
  }
  drawEllipse(t, n, r, i) {
    this._pushOp(new znt(t, n, r, i));
  }
  arc(t, n, r, i, o, a = !1) {
    this._pushOp(new Fnt(t, n, r, i, o, a));
  }
  arcTo(t, n, r, i, o) {
    this._pushOp(new Bnt(t, n, r, i, o));
  }
  lineTo(t, n) {
    this._pushOp(new Unt(t, n));
  }
  moveTo(t, n) {
    this._pushOp(new Ynt(t, n));
  }
  bezierCurveTo(t, n, r, i, o, a) {
    this._pushOp(new Vnt(t, n, r, i, o, a));
  }
  quadraticCurveTo(t, n, r, i) {
    this._pushOp(new Wnt(t, n, r, i));
  }
  closePath() {
    this._pushOp(new Hnt());
  }
  shadow(t, n = 0, r = 0, i = 0, o) {
    this._hasShadows = !0, this._pushOp(new qnt(o ? t.toCSS(o) : t.toCSS(this._fillAlpha || this._strokeAlpha), n, r, i));
  }
  image(t, n, r, i, o) {
    this._pushOp(new Gnt(t, n, r, i, o));
  }
  // https://svgwg.org/svg2-draft/paths.html#DProperty
  // TODO better error checking
  svgPath(t) {
    let n = 0, r = 0, i = null, o = null, a = null, s = null;
    const u = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g, l = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
    let f;
    for (; (f = u.exec(t)) !== null; ) {
      const h = f[1], p = f[2], g = [];
      for (; (f = l.exec(p)) !== null; )
        g.push(f[1]);
      switch (h !== "S" && h !== "s" && h !== "C" && h !== "c" && (i = null, o = null), h !== "Q" && h !== "q" && h !== "T" && h !== "t" && (a = null, s = null), h) {
        case "M":
          md(h, g.length, 2), n = +g[0], r = +g[1], this.moveTo(n, r);
          for (let b = 2; b < g.length; b += 2)
            n = +g[b], r = +g[b + 1], this.lineTo(n, r);
          break;
        case "m":
          md(h, g.length, 2), n += +g[0], r += +g[1], this.moveTo(n, r);
          for (let b = 2; b < g.length; b += 2)
            n += +g[b], r += +g[b + 1], this.lineTo(n, r);
          break;
        case "L":
          md(h, g.length, 2);
          for (let b = 0; b < g.length; b += 2)
            n = +g[b], r = +g[b + 1], this.lineTo(n, r);
          break;
        case "l":
          md(h, g.length, 2);
          for (let b = 0; b < g.length; b += 2)
            n += +g[b], r += +g[b + 1], this.lineTo(n, r);
          break;
        case "H":
          CO(h, g.length, 1);
          for (let b = 0; b < g.length; ++b)
            n = +g[b], this.lineTo(n, r);
          break;
        case "h":
          CO(h, g.length, 1);
          for (let b = 0; b < g.length; ++b)
            n += +g[b], this.lineTo(n, r);
          break;
        case "V":
          CO(h, g.length, 1);
          for (let b = 0; b < g.length; ++b)
            r = +g[b], this.lineTo(n, r);
          break;
        case "v":
          CO(h, g.length, 1);
          for (let b = 0; b < g.length; ++b)
            r += +g[b], this.lineTo(n, r);
          break;
        case "C":
          md(h, g.length, 6);
          for (let b = 0; b < g.length; b += 6) {
            const _ = +g[b], S = +g[b + 1];
            i = +g[b + 2], o = +g[b + 3], n = +g[b + 4], r = +g[b + 5], this.bezierCurveTo(_, S, i, o, n, r);
          }
          break;
        case "c":
          md(h, g.length, 6);
          for (let b = 0; b < g.length; b += 6) {
            const _ = +g[b] + n, S = +g[b + 1] + r;
            i = +g[b + 2] + n, o = +g[b + 3] + r, n += +g[b + 4], r += +g[b + 5], this.bezierCurveTo(_, S, i, o, n, r);
          }
          break;
        case "S":
          md(h, g.length, 4), (i === null || o === null) && (i = n, o = r);
          for (let b = 0; b < g.length; b += 4) {
            const _ = 2 * n - i, S = 2 * r - o;
            i = +g[b], o = +g[b + 1], n = +g[b + 2], r = +g[b + 3], this.bezierCurveTo(_, S, i, o, n, r);
          }
          break;
        case "s":
          md(h, g.length, 4), (i === null || o === null) && (i = n, o = r);
          for (let b = 0; b < g.length; b += 4) {
            const _ = 2 * n - i, S = 2 * r - o;
            i = +g[b] + n, o = +g[b + 1] + r, n += +g[b + 2], r += +g[b + 3], this.bezierCurveTo(_, S, i, o, n, r);
          }
          break;
        case "Q":
          md(h, g.length, 4);
          for (let b = 0; b < g.length; b += 4)
            a = +g[b], s = +g[b + 1], n = +g[b + 2], r = +g[b + 3], this.quadraticCurveTo(a, s, n, r);
          break;
        case "q":
          md(h, g.length, 4);
          for (let b = 0; b < g.length; b += 4)
            a = +g[b] + n, s = +g[b + 1] + r, n += +g[b + 2], r += +g[b + 3], this.quadraticCurveTo(a, s, n, r);
          break;
        case "T":
          md(h, g.length, 2), (a === null || s === null) && (a = n, s = r);
          for (let b = 0; b < g.length; b += 2)
            a = 2 * n - a, s = 2 * r - s, n = +g[b], r = +g[b + 1], this.quadraticCurveTo(a, s, n, r);
          break;
        case "t":
          md(h, g.length, 2), (a === null || s === null) && (a = n, s = r);
          for (let b = 0; b < g.length; b += 2)
            a = 2 * n - a, s = 2 * r - s, n += +g[b], r += +g[b + 1], this.quadraticCurveTo(a, s, n, r);
          break;
        case "A":
        case "a":
          const y = h === "a";
          Cnt(g), md(h, g.length, 7);
          for (let b = 0; b < g.length; b += 7) {
            let _ = +g[b + 5], S = +g[b + 6];
            y && (_ += n, S += r);
            const C = Mnt({
              px: n,
              py: r,
              rx: +g[b],
              ry: +g[b + 1],
              xAxisRotation: +g[b + 2],
              largeArcFlag: $fe(+g[b + 3]),
              sweepFlag: $fe(+g[b + 4]),
              cx: _,
              cy: S
            });
            ut(C, (A) => {
              this.bezierCurveTo(A.x1, A.y1, A.x2, A.y2, A.x, A.y), n = A.x, r = A.y;
            });
          }
          break;
        case "Z":
        case "z":
          Tnt(h, g.length, 0), this.closePath();
          break;
      }
    }
  }
  _runPath(t) {
    t.beginPath(), ut(this._operations, (n) => {
      n.path(t);
    });
  }
  _render(t) {
    super._render(t);
    const n = this._layer || t, r = n.dirty, i = this._isInteractive();
    if (r || i) {
      const o = n.context, a = this._renderer._ghostLayer.context;
      r && (o.globalCompositeOperation = this.blendMode, o.beginPath());
      let s;
      i && (a.beginPath(), s = this._getColorId()), ut(this._operations, (u) => {
        r && (u.path(o), u.colorize(o, void 0)), i && (u.path(a), u.colorize(a, s));
      });
    }
  }
  renderDetached(t) {
    if (this.visible) {
      this._setMatrix(), t.save();
      const n = this.mask;
      n && (n._setMatrix(), n._transform(t, 1), n._runPath(t), t.clip()), t.globalAlpha = this.compoundAlpha * this.alpha, this._transform(t, 1), this.filter && (t.filter = this.filter), t.globalCompositeOperation = this.blendMode, t.beginPath(), ut(this._operations, (r) => {
        r.path(t), r.colorize(t, void 0);
      }), t.restore();
    }
  }
  _addBounds(t) {
    this.visible && this.isMeasured && ut(this._operations, (n) => {
      n.addBounds(t);
    });
  }
}
class lwe extends bF {
  constructor(t, n, r) {
    super(t), Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "style", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "textVisible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_textInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), this.text = n, this.style = r;
  }
  invalidateBounds() {
    super.invalidateBounds(), this._textInfo = void 0;
  }
  _shared(t) {
    this.style.textAlign && (t.textAlign = this.style.textAlign), this.style.direction && (t.direction = this.style.direction), this.style.textBaseline && (t.textBaseline = this.style.textBaseline);
  }
  _prerender(t, n = !1, r = !1) {
    super._render(t);
    const i = t.context, o = this._renderer._ghostLayer.context, a = this.style;
    let s = this._getFontStyle(void 0, r);
    i.font = s, this._isInteractive() && !n && (o.font = s), a.fill && (a.fill instanceof Mr ? i.fillStyle = a.fill.toCSS(a.fillOpacity != null ? a.fillOpacity : 1) : i.fillStyle = a.fill), a.shadowColor && (t.context.shadowColor = a.shadowColor.toCSS(a.shadowOpacity || 1)), a.shadowBlur && (t.context.shadowBlur = a.shadowBlur), a.shadowOffsetX && (t.context.shadowOffsetX = a.shadowOffsetX), a.shadowOffsetY && (t.context.shadowOffsetY = a.shadowOffsetY), this._shared(i), this._isInteractive() && !n && (o.fillStyle = this._getColorId(), this._shared(o));
  }
  _getFontStyle(t, n = !1) {
    const r = this.style;
    let i = [];
    return t && t.fontVariant ? i.push(t.fontVariant) : r.fontVariant && i.push(r.fontVariant), n || (t && t.fontWeight ? i.push(t.fontWeight) : r.fontWeight && i.push(r.fontWeight)), t && t.fontStyle ? i.push(t.fontStyle) : r.fontStyle && i.push(r.fontStyle), t && t.fontSize ? (Cn(t.fontSize) && (t.fontSize = t.fontSize + "px"), i.push(t.fontSize)) : r.fontSize && (Cn(r.fontSize) && (r.fontSize = r.fontSize + "px"), i.push(r.fontSize)), t && t.fontFamily ? i.push(t.fontFamily) : r.fontFamily ? i.push(r.fontFamily) : i.length && i.push("Arial"), i.join(" ");
  }
  _render(t) {
    const n = this._layer || t;
    if (this._textInfo || this._measure(n), this.textVisible) {
      const r = this._isInteractive(), i = n.context, o = n.dirty, a = this._renderer._ghostLayer.context;
      i.save(), a.save(), this._prerender(n), ut(this._textInfo, (s, u) => {
        ut(s.textChunks, (l, f) => {
          if (l.style && (i.save(), a.save(), i.font = l.style, this._isInteractive() && (a.font = l.style)), l.fill && (i.save(), i.fillStyle = l.fill.toCSS()), o && i.fillText(l.text, l.offsetX, s.offsetY + l.offsetY), l.textDecoration == "underline" || l.textDecoration == "line-through") {
            let h = 1, p = 1, g = l.height, y = l.offsetX;
            switch (this.style.textAlign) {
              case "right":
              case "end":
                y -= l.width;
                break;
              case "center":
                y -= l.width / 2;
                break;
            }
            if (l.style)
              switch (Fg.getTextStyle(l.style).fontWeight) {
                case "bolder":
                case "bold":
                case "700":
                case "800":
                case "900":
                  h = 2;
                  break;
              }
            g && (p = g / 20);
            let b;
            l.textDecoration == "line-through" ? b = h + s.offsetY + l.offsetY - l.height / 2 : b = h + p * 1.5 + s.offsetY + l.offsetY, i.save(), i.beginPath(), l.fill ? i.strokeStyle = l.fill.toCSS() : this.style.fill && this.style.fill instanceof Mr && (i.strokeStyle = this.style.fill.toCSS()), i.lineWidth = h * p, i.moveTo(y, b), i.lineTo(y + l.width, b), i.stroke(), i.restore();
          }
          r && this.interactive && a.fillText(l.text, l.offsetX, s.offsetY + l.offsetY), l.fill && i.restore(), l.style && (i.restore(), a.restore());
        });
      }), i.restore(), a.restore();
    }
  }
  _addBounds(t) {
    if (this.visible && this.isMeasured) {
      const n = this._measure(this.getLayer());
      ts(t, { x: n.left, y: n.top }), ts(t, { x: n.right, y: n.bottom });
    }
  }
  _ignoreFontWeight() {
    return /apple/i.test(navigator.vendor);
  }
  _measure(t) {
    const n = t.context, r = this._renderer._ghostLayer.context, i = this.style.direction == "rtl";
    this._textInfo = [];
    const o = this.style.oversizedBehavior, a = this.style.maxWidth, s = Cn(a) && o == "truncate", u = Cn(a) && (o == "wrap" || o == "wrap-no-break");
    n.save(), r.save(), this._prerender(t, !0, this._ignoreFontWeight());
    const l = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", f = this.text.toString().replace(/\r/g, "").split(/\n/);
    let h = !0, p = 0, g = 0, y = 0, b;
    ut(f, (S, C) => {
      let A;
      for (S == "" ? A = [{
        type: "value",
        text: ""
      }] : A = Fg.chunk(S, !1, this.style.ignoreFormatting); A.length > 0; ) {
        let O = {
          offsetY: y,
          ascent: 0,
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          textChunks: []
        };
        const R = this._measureText(l, n), j = R.actualBoundingBoxAscent + R.actualBoundingBoxDescent;
        O.height = j, O.ascent = R.actualBoundingBoxAscent;
        let $, z = this.style.textDecoration, W, Y, V = !1, ee = !0, K = [], Q;
        qxe(A, (q, te) => {
          if (q.type == "format")
            if (q.text == "[/]")
              h || (n.restore(), r.restore(), h = !0), W = void 0, b = void 0, Y = void 0, z = this.style.textDecoration, Q = void 0, $ = q.text;
            else {
              h || (n.restore(), r.restore());
              let X = Fg.getTextStyle(q.text);
              const Z = this._getFontStyle(X);
              n.save(), r.save(), n.font = Z, b = Z, $ = q.text, X.textDecoration && (z = X.textDecoration), X.fill && (W = X.fill), X.width && (Y = xd(X.width)), X.verticalAlign && (Q = X.verticalAlign), h = !1;
              const se = this._measureText(l, n), H = se.actualBoundingBoxAscent + se.actualBoundingBoxDescent;
              H > O.height && (O.height = H), se.actualBoundingBoxAscent > O.ascent && (O.ascent = se.actualBoundingBoxAscent);
            }
          else if (q.type == "value" && !V) {
            const X = this._measureText(q.text, n);
            let Z = X.actualBoundingBoxLeft + X.actualBoundingBoxRight;
            if (s) {
              let he = ee || this.style.breakWords || !1;
              const ye = this.style.ellipsis || "", _e = this._measureText(ye, n), Ne = _e.actualBoundingBoxLeft + _e.actualBoundingBoxRight;
              if (O.width + Z > a) {
                const Oe = a - O.width - Ne;
                q.text = this._truncateText(n, q.text, Oe, he), q.text += ye, V = !0;
              }
            } else if (u && O.width + Z > a) {
              const he = a - O.width, ye = this._truncateText(n, q.text, he, !1, ee && this.style.oversizedBehavior != "wrap-no-break");
              if (ye == "")
                return this.textVisible = !0, !1;
              K = A.slice(te + 1), tj(ye) != tj(q.text) && (K.unshift({
                type: "value",
                text: q.text.substr(ye.length)
              }), $ && K.unshift({
                type: "format",
                text: $
              })), q.text = tj(ye), A = [], V = !0;
            }
            let se = 1, H = 1;
            if (b && Y && Y > Z) {
              const he = Z / Y;
              switch (this.style.textAlign) {
                case "right":
                case "end":
                  se = he;
                  break;
                case "center":
                  se = he, H = he;
                  break;
                default:
                  H = he;
              }
              Z = Y;
            }
            const ie = X.actualBoundingBoxAscent + X.actualBoundingBoxDescent;
            ie > O.height && (O.height = ie), X.actualBoundingBoxAscent > O.ascent && (O.ascent = X.actualBoundingBoxAscent), O.width += Z, O.left += X.actualBoundingBoxLeft / se, O.right += X.actualBoundingBoxRight / H, O.textChunks.push({
              style: b,
              fill: W,
              text: q.text,
              width: Z,
              height: ie,
              left: X.actualBoundingBoxLeft,
              right: X.actualBoundingBoxRight,
              ascent: X.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: 0,
              textDecoration: z,
              verticalAlign: Q
            }), ee = !1;
          }
          return !0;
        }), this.style.lineHeight instanceof hi ? (O.height *= this.style.lineHeight.value, O.ascent *= this.style.lineHeight.value) : (O.height *= this.style.lineHeight || 1.2, O.ascent *= this.style.lineHeight || 1.2), p < O.left && (p = O.left), g < O.right && (g = O.right), this._textInfo.push(O), y += O.height, A = K || [];
      }
    }), h || (n.restore(), r.restore()), ut(this._textInfo, (S, C) => {
      let A = 0;
      ut(S.textChunks, (O) => {
        if (O.offsetX = A + O.left - S.left, O.offsetY += S.height - S.height * (this.style.baselineRatio || 0.19), A += O.width, O.verticalAlign)
          switch (O.verticalAlign) {
            case "super":
              O.offsetY -= S.height / 2 - O.height / 2;
              break;
            case "sub":
              O.offsetY += O.height / 2;
              break;
          }
      });
    });
    const _ = {
      left: i ? -g : -p,
      top: 0,
      right: i ? p : g,
      bottom: y
    };
    if (o !== "none") {
      const S = this._fitRatio(_);
      if (S < 1)
        if (o == "fit")
          Cn(this.style.minScale) && S < this.style.minScale ? (this.textVisible = !1, _.left = 0, _.top = 0, _.right = 0, _.bottom = 0) : ((!this._originalScale || this._originalScale == 1) && (this._originalScale = this.scale), this.scale = S, this.textVisible = !0);
        else if (o == "hide")
          this.textVisible = !1, _.left = 0, _.top = 0, _.right = 0, _.bottom = 0;
        else {
          switch (this.style.textAlign) {
            case "right":
            case "end":
              _.left = -a, _.right = 0;
              break;
            case "center":
              _.left = -a / 2, _.right = a / 2;
              break;
            default:
              _.left = 0, _.right = a;
          }
          this.scale = this._originalScale || 1, this._originalScale = void 0, this.textVisible = !0;
        }
      else
        this.scale = this._originalScale || 1, this._originalScale = void 0, this.textVisible = !0;
    }
    return n.restore(), r.restore(), _;
  }
  _fitRatio(t) {
    const n = this.style.maxWidth, r = this.style.maxHeight;
    if (!Cn(n) && !Cn(r))
      return 1;
    const i = t.right - t.left, o = t.bottom - t.top;
    return Math.min(n / i || 1, r / o || 1);
  }
  _truncateText(t, n, r, i = !1, o = !0) {
    let a;
    do {
      if (i)
        n = n.slice(0, -1);
      else {
        let u = n.replace(/[^,;:!?\\\/\s​]+[,;:!?\\\/\s​]*$/g, "");
        if ((u == "" || u === n) && o)
          i = !0;
        else {
          if (u == "")
            return n;
          n = u;
        }
      }
      const s = this._measureText(n, t);
      a = s.actualBoundingBoxLeft + s.actualBoundingBoxRight;
    } while (a > r && n != "");
    return n;
  }
  _measureText(t, n) {
    let r = n.measureText(t), i = {};
    if (r.actualBoundingBoxAscent == null) {
      const a = document.createElement("div");
      a.innerText = t, a.style.visibility = "hidden", a.style.position = "absolute", a.style.top = "-1000000px;", a.style.fontFamily = this.style.fontFamily || "", a.style.fontSize = this.style.fontSize + "", document.body.appendChild(a);
      const s = a.getBoundingClientRect();
      document.body.removeChild(a);
      const u = s.height, l = r.width;
      i = {
        actualBoundingBoxAscent: u,
        actualBoundingBoxDescent: 0,
        actualBoundingBoxLeft: 0,
        actualBoundingBoxRight: l,
        fontBoundingBoxAscent: u,
        fontBoundingBoxDescent: 0,
        width: l
      };
    } else
      i = {
        actualBoundingBoxAscent: r.actualBoundingBoxAscent,
        actualBoundingBoxDescent: r.actualBoundingBoxDescent,
        actualBoundingBoxLeft: r.actualBoundingBoxLeft,
        actualBoundingBoxRight: r.actualBoundingBoxRight,
        fontBoundingBoxAscent: r.actualBoundingBoxAscent,
        fontBoundingBoxDescent: r.actualBoundingBoxDescent,
        width: r.width
      };
    const o = r.width;
    switch (this.style.textAlign) {
      case "right":
      case "end":
        i.actualBoundingBoxLeft = o, i.actualBoundingBoxRight = 0;
        break;
      case "center":
        i.actualBoundingBoxLeft = o / 2, i.actualBoundingBoxRight = o / 2;
        break;
      default:
        i.actualBoundingBoxLeft = 0, i.actualBoundingBoxRight = o;
    }
    return i;
  }
}
class Xnt {
  constructor() {
    Object.defineProperty(this, "fill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fillOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textAlign", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontFamily", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontWeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontVariant", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lineHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ab(120)
    }), Object.defineProperty(this, "baselineRatio", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.19
    }), Object.defineProperty(this, "direction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textBaseline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oversizedBehavior", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "none"
    }), Object.defineProperty(this, "breakWords", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ellipsis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "…"
    }), Object.defineProperty(this, "maxWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "minScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ignoreFormatting", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
}
class Knt extends lwe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "circular"
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inside", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "orientation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "auto"
    }), Object.defineProperty(this, "kerning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_textReversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _render(t) {
    switch (this.textType) {
      case "circular":
        this._renderCircular(t);
        break;
      default:
        super._render(t);
        break;
    }
  }
  _renderCircular(t) {
    if (this.textVisible) {
      const n = this._layer || t;
      this._prerender(n);
      const r = this._isInteractive(), i = n.context, o = n.dirty, a = this._renderer._ghostLayer.context;
      i.save(), r && a.save(), this._textInfo || this._measure(n);
      let s = this.radius || 0, u = this.startAngle || 0, l = 0, f = this.orientation, h = f == "auto" ? "auto" : f == "inward";
      const p = this.inside, g = this.style.textAlign || "left", y = this.kerning || 0;
      let b = g == "left" ? 1 : -1;
      const _ = !this._textReversed;
      if (h == "auto") {
        let S = 0, C = 0;
        ut(this._textInfo, (A, O) => {
          const R = u + A.width / (s - A.height) / 2 * -b;
          R > S && (S = R);
        }), g == "left" ? C = (S + l / 2) * KE : g == "right" ? C = (S - l / 2) * KE : C = u * KE, C = tnt(C), h = C >= 270 || C <= 90;
      }
      h == !0 && _ && (this._textInfo.reverse(), this._textReversed = !0), ut(this._textInfo, (S, C) => {
        const A = S.height;
        p || (s += A), (b == -1 && h || b == 1 && !h) && _ && S.textChunks.reverse();
        let O = u;
        l = 0, g == "center" && (O += S.width / (s - A) / 2 * -b, l = O - u), O += Math.PI * (h ? 0 : 1), i.save(), r && a.save(), i.rotate(O), r && a.rotate(O);
        let R = 0;
        ut(S.textChunks, (j, $) => {
          const z = j.text, W = j.width;
          R = W / 2 / (s - A) * b, i.rotate(R), r && a.rotate(R), j.style && (i.save(), a.save(), i.font = j.style, r && (a.font = j.style)), j.fill && (i.save(), i.fillStyle = j.fill.toCSS()), i.textBaseline = "middle", i.textAlign = "center", r && (a.textBaseline = "middle", a.textAlign = "center"), o && i.fillText(z, 0, (h ? 1 : -1) * (0 - s + A / 2)), r && a.fillText(z, 0, (h ? 1 : -1) * (0 - s + A / 2)), j.fill && i.restore(), j.style && (i.restore(), a.restore()), R = (W / 2 + y) / (s - A) * b, i.rotate(R), r && a.rotate(R);
        }), i.restore(), r && a.restore(), p && (s -= A);
      }), i.restore(), r && a.restore();
    }
  }
  _measure(t) {
    switch (this.textType) {
      case "circular":
        return this._measureCircular(t);
      default:
        return super._measure(t);
    }
  }
  _measureCircular(t) {
    const n = t.context, r = this._renderer._ghostLayer.context, i = this.style.direction == "rtl", o = this.style.oversizedBehavior, a = this.style.maxWidth, s = Cn(a) && o == "truncate", u = this.style.ellipsis || "";
    let l;
    this.textVisible = !0, this._textInfo = [], this._textReversed = !1, n.save(), r.save(), this._prerender(t, !0);
    const f = this.text.toString().replace(/\r/g, "").split(/\n/);
    let h = !0, p = 0, g = 0;
    return ut(f, (y, b) => {
      let _ = Fg.chunk(y, !1, this.style.ignoreFormatting), S = {
        offsetY: g,
        ascent: 0,
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        textChunks: []
      }, C, A, O;
      ut(_, (R, j) => {
        if (R.type == "format") {
          if (R.text == "[/]")
            h || (n.restore(), r.restore(), h = !0), A = void 0, C = void 0, O = void 0;
          else {
            let $ = Fg.getTextStyle(R.text);
            const z = this._getFontStyle($);
            n.save(), r.save(), n.font = z, C = z, $.fill && (A = $.fill), $.width && (O = xd($.width)), h = !1;
          }
          s && (l = this._measureText(u, n));
        } else if (R.type == "value") {
          const $ = R.text.match(/./ug) || [];
          i && $.reverse();
          for (let z = 0; z < $.length; z++) {
            const W = $[z], Y = this._measureText(W, n);
            let V = Y.width;
            C && O && O > V && (V = O);
            const ee = Y.actualBoundingBoxAscent + Y.actualBoundingBoxDescent;
            if (ee > S.height && (S.height = ee), Y.actualBoundingBoxAscent > S.ascent && (S.ascent = Y.actualBoundingBoxAscent), S.width += V, S.left += Y.actualBoundingBoxLeft, S.right += Y.actualBoundingBoxRight, S.textChunks.push({
              style: C,
              fill: A,
              text: W,
              width: V,
              height: ee + Y.actualBoundingBoxDescent,
              left: Y.actualBoundingBoxLeft,
              right: Y.actualBoundingBoxRight,
              ascent: Y.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: ee,
              textDecoration: void 0
            }), p += V, s) {
              l || (l = this._measureText(u, n));
              const K = l.actualBoundingBoxLeft + l.actualBoundingBoxRight;
              if (p += K, p + K > a) {
                S.textChunks.length == 1 ? this.textVisible = !1 : (S.width += K, S.left += l.actualBoundingBoxLeft, S.right += l.actualBoundingBoxRight, S.textChunks.push({
                  style: C,
                  fill: A,
                  text: u,
                  width: K,
                  height: ee + l.actualBoundingBoxDescent,
                  left: l.actualBoundingBoxLeft,
                  right: l.actualBoundingBoxRight,
                  ascent: l.actualBoundingBoxAscent,
                  offsetX: 0,
                  offsetY: ee,
                  textDecoration: void 0
                }));
                break;
              }
            }
            if (i)
              break;
          }
        }
      }), this.style.lineHeight instanceof hi ? S.height *= this.style.lineHeight.value : S.height *= this.style.lineHeight || 1.2, this._textInfo.push(S), g += S.height;
    }), h || (n.restore(), r.restore()), o == "hide" && p > a && (this.textVisible = !1), ut(this._textInfo, (y) => {
      ut(y.textChunks, (b) => {
        b.offsetY += Math.round((y.height - b.height + (y.ascent - b.ascent)) / 2);
      });
    }), n.restore(), r.restore(), {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
}
class Znt extends bF {
  constructor(t, n) {
    super(t), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_imageMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.image = n;
  }
  _dispose() {
    super._dispose(), this._imageMask && NO(this._imageMask);
  }
  getLocalBounds() {
    if (!this._localBounds) {
      let t = 0, n = 0;
      this.width && (t = this.width), this.height && (n = this.height), this._localBounds = {
        left: 0,
        top: 0,
        right: t,
        bottom: n
      }, this._addBounds(this._localBounds);
    }
    return this._localBounds;
  }
  _render(t) {
    if (super._render(t), this.image) {
      const n = this._layer || t;
      if (this.tainted === void 0 && (this.tainted = Pfe(this.image), n.tainted = !0), this.tainted && this._renderer._omitTainted)
        return;
      if (n.dirty) {
        this.shadowColor && (n.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1)), this.shadowBlur && (n.context.shadowBlur = this.shadowBlur), this.shadowOffsetX && (n.context.shadowOffsetX = this.shadowOffsetX), this.shadowOffsetY && (n.context.shadowOffsetY = this.shadowOffsetY);
        const r = this.width || this.image.naturalWidth, i = this.height || this.image.naturalHeight;
        n.context.drawImage(this.image, 0, 0, r, i);
      }
      if (this.interactive && this._isInteractive()) {
        const r = this._getMask(this.image);
        this._renderer._ghostLayer.context.drawImage(r, 0, 0);
      }
    }
  }
  clear() {
    super.clear(), this.image = void 0, this._imageMask = void 0;
  }
  _getMask(t) {
    if (this._imageMask === void 0) {
      const n = this.width || t.naturalWidth, r = this.height || t.naturalHeight, i = document.createElement("canvas");
      i.width = n, i.height = r;
      const o = i.getContext("2d");
      o.imageSmoothingEnabled = !1, o.fillStyle = this._getColorId(), o.fillRect(0, 0, n, r), Pfe(t) || (o.globalCompositeOperation = "destination-in", o.drawImage(t, 0, 0, n, r)), this._imageMask = i;
    }
    return this._imageMask;
  }
}
class Jnt {
  constructor(t, n, r, i) {
    Object.defineProperty(this, "event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "bbox", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "simulated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "native", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), XE("touchevents") && t instanceof Touch ? this.id = t.identifier : this.id = null;
  }
}
let ert = class extends Stt {
  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
  });
  */
  constructor(t) {
    if (super(), Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "_layerDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "layers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_dirtyLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "defaultLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.getLayer(0)
    }), Object.defineProperty(this, "_ghostLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new trt()
    }), Object.defineProperty(this, "_patternCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("canvas")
    }), Object.defineProperty(this, "_patternContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._patternCanvas.getContext("2d")
    }), Object.defineProperty(this, "_realWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_realHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_calculatedWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_calculatedHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interactionsEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_colorMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_forceInteractive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_omitTainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_hovering", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "_dragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_lastPointerMoveEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tapToActivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "tapToActivateTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3e3
    }), Object.defineProperty(this, "_touchActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_touchActiveTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), t == null ? this.resolution = window.devicePixelRatio : this.resolution = t, this.view.style.position = "absolute", this.view.setAttribute("aria-hidden", "true"), this.view.appendChild(this._layerDom), this._disposers.push(new Bs(() => {
      ia(this._events, (n, r) => {
        r.disposer.dispose();
      }), ut(this.layers, (n) => {
        NO(n.view), n.exportableView && NO(n.exportableView);
      }), NO(this._ghostLayer.view), NO(this._patternCanvas);
    })), this._disposers.push(Kxe(() => {
      t == null && (this.resolution = window.devicePixelRatio);
    })), XE("touchevents")) {
      const n = (r) => {
        this._dragging.length !== 0 && qxe(this._dragging, (i) => i.value.shouldCancelTouch() ? (r.preventDefault(), !1) : !0), this._touchActiveTimeout && this._delayTouchDeactivate();
      };
      this._disposers.push(Ja(window, "touchstart", n, { passive: !1 })), this._disposers.push(Ja(this.view, "touchstart", n, { passive: !1 })), this._disposers.push(Ja(this.view, "touchmove", () => {
        this._touchActiveTimeout && this._delayTouchDeactivate();
      }, { passive: !0 })), this._disposers.push(Ja(window, "click", (r) => {
        this._touchActive = !1;
      }, { passive: !0 })), this._disposers.push(Ja(this.view, "click", (r) => {
        window.setTimeout(() => {
          this._touchActive = !0, this._delayTouchDeactivate();
        }, 100);
      }, { passive: !0 }));
    }
    XE("wheelevents") && this._disposers.push(Ja(this.view, "wheel", (n) => {
      let r = !1;
      this._hovering.forEach((i) => {
        if (i.wheelable)
          return r = !0, !1;
      }), r && n.preventDefault();
    }, { passive: !1 }));
  }
  _delayTouchDeactivate() {
    this._touchActiveTimeout && clearTimeout(this._touchActiveTimeout), this.tapToActivateTimeout > 0 && (this._touchActiveTimeout = window.setTimeout(() => {
      this._touchActive = !1;
    }, this.tapToActivateTimeout));
  }
  get debugGhostView() {
    return !!this._ghostLayer.view.parentNode;
  }
  set debugGhostView(t) {
    t ? this._ghostLayer.view.parentNode || this.view.appendChild(this._ghostLayer.view) : this._ghostLayer.view.parentNode && this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
  }
  createLinearGradient(t, n, r, i) {
    return this.defaultLayer.context.createLinearGradient(t, n, r, i);
  }
  createRadialGradient(t, n, r, i, o, a) {
    return this.defaultLayer.context.createRadialGradient(t, n, r, i, o, a);
  }
  createPattern(t, n, r, i, o) {
    return this._patternCanvas.width = i, this._patternCanvas.height = o, this._patternContext.clearRect(0, 0, i, o), n.renderDetached(this._patternContext), t.renderDetached(this._patternContext), this._patternContext.createPattern(this._patternCanvas, r);
  }
  makeContainer() {
    return new Ont(this);
  }
  makeGraphics() {
    return new Qnt(this);
  }
  makeText(t, n) {
    return new lwe(this, t, n);
  }
  makeTextStyle() {
    return new Xnt();
  }
  makeRadialText(t, n) {
    return new Knt(this, t, n);
  }
  makePicture(t) {
    return new Znt(this, t);
  }
  resizeLayer(t) {
    t.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);
  }
  resizeGhost() {
    this._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);
  }
  resize(t, n, r, i) {
    this._realWidth = t, this._realHeight = n, this._calculatedWidth = r, this._calculatedHeight = i, ut(this.layers, (o) => {
      o && (o.dirty = !0, this.resizeLayer(o));
    }), this.resizeGhost(), this.view.style.width = r + "px", this.view.style.height = i + "px";
  }
  createDetachedLayer(t = !1) {
    const n = document.createElement("canvas"), r = n.getContext("2d", { willReadFrequently: t }), i = new nrt(n, r);
    return n.style.position = "absolute", n.style.top = "0px", n.style.left = "0px", i;
  }
  getLayerByOrder(t) {
    const n = this.layers, r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      if (o.order == t)
        return o;
    }
  }
  getLayer(t, n = !0) {
    let r = this.getLayerByOrder(t);
    if (r)
      return r;
    const i = this.createDetachedLayer(t == 99);
    i.order = t, i.visible = n, i.visible && this.resizeLayer(i);
    const o = this.layers;
    o.push(i), o.sort((l, f) => l.order > f.order ? 1 : l.order < f.order ? -1 : 0);
    const a = o.length, s = Xj(o, i);
    let u;
    for (let l = s + 1; l < a; l++)
      if (o[l].visible) {
        u = o[l];
        break;
      }
    return i.visible && (u === void 0 ? this._layerDom.appendChild(i.view) : this._layerDom.insertBefore(i.view, u.view)), i;
  }
  render(t) {
    if (this._dirtyLayers.length = 0, ut(this.layers, (n) => {
      n && n.dirty && n.visible && (this._dirtyLayers.push(n), n.clear());
    }), this._ghostLayer.clear(), t.render(this.defaultLayer), this._ghostLayer.context.restore(), ut(this.layers, (n) => {
      if (n) {
        const r = n.context;
        r.beginPath(), r.moveTo(0, 0), r.stroke();
      }
    }), ut(this._dirtyLayers, (n) => {
      n.context.restore(), n.dirty = !1;
    }), this._hovering.size && this._lastPointerMoveEvent) {
      const { events: n, target: r, native: i } = this._lastPointerMoveEvent;
      ut(n, (o) => {
        this._dispatchGlobalMousemove(o, r, i);
      });
    }
  }
  paintId(t) {
    const n = Nnt(++this._colorId), r = Mr.fromHex(n).toCSS();
    return this._colorMap[r] = t, r;
  }
  _removeObject(t) {
    t._colorId !== void 0 && delete this._colorMap[t._colorId];
  }
  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
  // 	return this._colorMap[colorId];
  // }
  _adjustBoundingBox(t) {
    const n = this._ghostLayer.margin;
    return new DOMRect(-n.left, -n.top, t.width + n.left + n.right, t.height + n.top + n.bottom);
  }
  getEvent(t, n = !0) {
    const r = this.view.getBoundingClientRect(), i = t.clientX || 0, o = t.clientY || 0, a = this._calculatedWidth / this._realWidth, s = this._calculatedHeight / this._realHeight, u = {
      x: i - r.left,
      y: o - r.top
    }, l = {
      x: (i - (n ? r.left : 0)) * a,
      y: (o - (n ? r.top : 0)) * s
    };
    return new Jnt(t, u, l, this._adjustBoundingBox(r));
  }
  _getHitTarget(t, n, r) {
    if (n.width === 0 || n.height === 0 || t.x < n.left || t.x > n.right || t.y < n.top || t.y > n.bottom || !r || !this._layerDom.contains(r))
      return;
    const i = this._ghostLayer.getImageData(t, n);
    if (i.data[0] === 0 && i.data[1] === 0 && i.data[2] === 0)
      return !1;
    const o = Mr.fromRGB(i.data[0], i.data[1], i.data[2]).toCSS();
    return this._colorMap[o];
  }
  _withEvents(t, n) {
    const r = this._events[t];
    if (r !== void 0) {
      r.dispatching = !0;
      try {
        n(r);
      } finally {
        r.dispatching = !1, r.cleanup && (r.cleanup = !1, gF(r.callbacks, (i) => !i.disposed), r.callbacks.length === 0 && (r.disposer.dispose(), delete this._events[t]));
      }
    }
  }
  _dispatchEventAll(t, n) {
    this.interactionsEnabled && this._withEvents(t, (r) => {
      ut(r.callbacks, (i) => {
        i.disposed || i.callback.call(i.context, n);
      });
    });
  }
  _dispatchEvent(t, n, r) {
    if (!this.interactionsEnabled)
      return !1;
    let i = !1;
    return this._withEvents(t, (o) => {
      ut(o.callbacks, (a) => {
        !a.disposed && a.object === n && (a.callback.call(a.context, r), i = !0);
      });
    }), i;
  }
  _dispatchMousedown(t, n) {
    const r = t.button;
    if (r != 0 && r != 2 && r != 1 && r !== void 0)
      return;
    const i = this.getEvent(t), o = this._getHitTarget(i.originalPoint, i.bbox, n);
    if (o) {
      const a = i.id;
      let s = !1;
      zI(o, (u) => {
        const l = { id: a, value: u };
        return this._mousedown.push(l), !s && this._dispatchEvent("pointerdown", u, i) && (s = !0, this._dragging.some((h) => h.value === u && h.id === a) || this._dragging.push(l)), !0;
      });
    }
  }
  _dispatchGlobalMousemove(t, n, r) {
    const i = this.getEvent(t), o = this._getHitTarget(i.originalPoint, i.bbox, n);
    i.native = r, o ? (this._hovering.forEach((a) => {
      a.contains(o) || (this._hovering.delete(a), a.cursorOverStyle && VY(document.body, "cursor", a._replacedCursorStyle), this._dispatchEvent("pointerout", a, i));
    }), i.native && zI(o, (a) => (this._hovering.has(a) || (this._hovering.add(a), a.cursorOverStyle && (a._replacedCursorStyle = Ptt(document.body, "cursor"), VY(document.body, "cursor", a.cursorOverStyle)), this._dispatchEvent("pointerover", a, i)), !0))) : (this._hovering.forEach((a) => {
      a.cursorOverStyle && VY(document.body, "cursor", a._replacedCursorStyle), this._dispatchEvent("pointerout", a, i);
    }), this._hovering.clear()), this._dispatchEventAll("globalpointermove", i);
  }
  _dispatchGlobalMouseup(t, n) {
    const r = this.getEvent(t);
    r.native = n, this._dispatchEventAll("globalpointerup", r);
  }
  _dispatchDragMove(t) {
    if (this._dragging.length !== 0) {
      const n = this.getEvent(t), r = n.id;
      this._dragging.forEach((i) => {
        i.id === r && this._dispatchEvent("pointermove", i.value, n);
      });
    }
  }
  _dispatchDragEnd(t, n) {
    const r = t.button;
    let i;
    if (r == 0 || r === void 0)
      i = "click";
    else if (r == 2)
      i = "rightclick";
    else if (r == 1)
      i = "middleclick";
    else
      return;
    const o = this.getEvent(t), a = o.id;
    if (this._mousedown.length !== 0) {
      const s = this._getHitTarget(o.originalPoint, o.bbox, n);
      s && this._mousedown.forEach((u) => {
        u.id === a && u.value.contains(s) && this._dispatchEvent(i, u.value, o);
      }), this._mousedown.length = 0;
    }
    this._dragging.length !== 0 && (this._dragging.forEach((s) => {
      s.id === a && this._dispatchEvent("pointerup", s.value, o);
    }), this._dragging.length = 0);
  }
  _dispatchDoubleClick(t, n) {
    const r = this.getEvent(t), i = this._getHitTarget(r.originalPoint, r.bbox, n);
    i && zI(i, (o) => !this._dispatchEvent("dblclick", o, r));
  }
  _dispatchWheel(t, n) {
    const r = this.getEvent(t), i = this._getHitTarget(r.originalPoint, r.bbox, n);
    i && zI(i, (o) => !this._dispatchEvent("wheel", o, r));
  }
  _makeSharedEvent(t, n) {
    if (this._listeners[t] === void 0) {
      const r = n();
      this._listeners[t] = new Xxe(() => {
        delete this._listeners[t], r.dispose();
      });
    }
    return this._listeners[t].increment();
  }
  _onPointerEvent(t, n) {
    let r = !1, i = null;
    function o() {
      i = null, r = !1;
    }
    return new wd([
      new Bs(() => {
        i !== null && clearTimeout(i), o();
      }),
      Ja(this.view, bq(t), (a) => {
        r = !0, i !== null && clearTimeout(i), i = window.setTimeout(o, 0);
      }),
      Dnt(window, t, (a, s) => {
        i !== null && (clearTimeout(i), i = null), n(a, s, r), r = !1;
      })
    ]);
  }
  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
  _initEvent(t) {
    switch (t) {
      case "globalpointermove":
      case "pointerover":
      case "pointerout":
        return this._makeSharedEvent("pointermove", () => {
          const n = (r, i, o) => {
            this._lastPointerMoveEvent = { events: r, target: i, native: o }, ut(r, (a) => {
              this._dispatchGlobalMousemove(a, i, o);
            });
          };
          return new wd([
            this._onPointerEvent("pointerdown", n),
            this._onPointerEvent("pointermove", n)
          ]);
        });
      case "globalpointerup":
        return this._makeSharedEvent("pointerup", () => {
          const n = this._onPointerEvent("pointerup", (i, o, a) => {
            ut(i, (s) => {
              this._dispatchGlobalMouseup(s, a);
            }), this._lastPointerMoveEvent = { events: i, target: o, native: a };
          }), r = this._onPointerEvent("pointercancel", (i, o, a) => {
            ut(i, (s) => {
              this._dispatchGlobalMouseup(s, a);
            }), this._lastPointerMoveEvent = { events: i, target: o, native: a };
          });
          return new Bs(() => {
            n.dispose(), r.dispose();
          });
        });
      case "click":
      case "rightclick":
      case "middleclick":
      case "pointerdown":
      case "pointermove":
      case "pointerup":
        return this._makeSharedEvent("pointerdown", () => {
          const n = this._onPointerEvent("pointerdown", (a, s) => {
            ut(a, (u) => {
              this._dispatchMousedown(u, s);
            });
          }), r = this._onPointerEvent("pointermove", (a) => {
            ut(a, (s) => {
              this._dispatchDragMove(s);
            });
          }), i = this._onPointerEvent("pointerup", (a, s) => {
            ut(a, (u) => {
              this._dispatchDragEnd(u, s);
            });
          }), o = this._onPointerEvent("pointercancel", (a, s) => {
            ut(a, (u) => {
              this._dispatchDragEnd(u, s);
            });
          });
          return new Bs(() => {
            n.dispose(), r.dispose(), i.dispose(), o.dispose();
          });
        });
      case "dblclick":
        return this._makeSharedEvent("dblclick", () => this._onPointerEvent("dblclick", (n, r) => {
          ut(n, (i) => {
            this._dispatchDoubleClick(i, r);
          });
        }));
      case "wheel":
        return this._makeSharedEvent("wheel", () => Ja(window, bq("wheel"), (n) => {
          this._dispatchWheel(n, Zxe(n));
        }, { passive: !1 }));
    }
  }
  _addEvent(t, n, r, i) {
    let o = this._events[n];
    o === void 0 && (o = this._events[n] = {
      disposer: this._initEvent(n),
      callbacks: [],
      dispatching: !1,
      cleanup: !1
    });
    const a = { object: t, context: i, callback: r, disposed: !1 };
    return o.callbacks.push(a), new Bs(() => {
      a.disposed = !0, o.dispatching ? o.cleanup = !0 : (Md(o.callbacks, a), o.callbacks.length === 0 && (o.disposer.dispose(), delete this._events[n]));
    });
  }
  getCanvas(t, n) {
    this.render(t), n || (n = {});
    let r = this.resolution, i = Math.floor(this._calculatedWidth * this.resolution), o = Math.floor(this._calculatedHeight * this.resolution);
    if (n.minWidth && n.minWidth > i) {
      let g = n.minWidth / i;
      g > r && (r = g * this.resolution);
    }
    if (n.minHeight && n.minHeight > o) {
      let g = n.minHeight / o;
      g > r && (r = g * this.resolution);
    }
    if (n.maxWidth && n.maxWidth < i) {
      let g = n.maxWidth / i;
      g < r && (r = g * this.resolution);
    }
    if (n.maxHeight && n.maxHeight > o) {
      let g = n.maxHeight / o;
      g < r && (r = g * this.resolution);
    }
    n.maintainPixelRatio && (r /= this.resolution);
    const a = [];
    let s = !1;
    const u = document.createElement("canvas");
    r != this.resolution && (s = !0, i = i * r / this.resolution, o = o * r / this.resolution), u.width = i, u.height = o, u.style.position = "fixed", u.style.top = "-10000px", this.view.appendChild(u), a.push(u);
    const l = u.getContext("2d");
    let f = 0, h = 0, p = !1;
    return ut(this.layers, (g) => {
      if (g && g.visible && (g.tainted || s)) {
        p = !0, g.exportableView = g.view, g.exportableContext = g.context, g.view = document.createElement("canvas"), g.view.style.position = "fixed", g.view.style.top = "-10000px", this.view.appendChild(g.view), a.push(g.view);
        let y = 0, b = 0;
        g.margin && (y += g.margin.left || 0 + g.margin.right || 0, b += g.margin.top || 0 + g.margin.bottom || 0), g.view.width = i + y, g.view.height = o + b, g.context = g.view.getContext("2d"), g.dirty = !0, g.scale = r;
      }
    }), p && (this._omitTainted = !0, this.render(t), this._omitTainted = !1), ut(this.layers, (g) => {
      if (g && g.visible) {
        let y = 0, b = 0;
        g.margin && (y = -(g.margin.left || 0) * this.resolution, b = -(g.margin.top || 0) * this.resolution), l.drawImage(g.view, y, b), g.exportableView && (g.view = g.exportableView, g.exportableView = void 0), g.exportableContext && (g.context = g.exportableContext, g.exportableContext = void 0), f < g.view.clientWidth && (f = g.view.clientWidth), h < g.view.clientHeight && (h = g.view.clientHeight), g.scale = void 0;
      }
    }), u.style.width = f + "px", u.style.height = h + "px", ut(a, (g) => {
      g.style.position = "", g.style.top = "", this.view.removeChild(g);
    }), u;
  }
};
class trt {
  constructor() {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = document.createElement("canvas"), this.context = this.view.getContext("2d", { alpha: !1, willReadFrequently: !0 }), this.context.imageSmoothingEnabled = !1, this.view.style.position = "absolute", this.view.style.top = "0px", this.view.style.left = "0px";
  }
  resize(t, n, r, i, o) {
    t += this.margin.left + this.margin.right, n += this.margin.top + this.margin.bottom, r += this.margin.left + this.margin.right, i += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px", this._width = Math.floor(t * o), this._height = Math.floor(n * o), this.view.width = this._width, this.view.style.width = r + "px", this.view.height = this._height, this.view.style.height = i + "px";
  }
  getImageData(t, n) {
    return this.context.getImageData(
      // TODO should this round ?
      Math.round((t.x - n.left) / n.width * this._width),
      Math.round((t.y - n.top) / n.height * this._height),
      1,
      1
    );
  }
  setMargin(t) {
    this.margin.left = 0, this.margin.right = 0, this.margin.top = 0, this.margin.bottom = 0, ut(t, (n) => {
      n.margin && (this.margin.left = Math.max(this.margin.left, n.margin.left), this.margin.right = Math.max(this.margin.right, n.margin.right), this.margin.top = Math.max(this.margin.top, n.margin.top), this.margin.bottom = Math.max(this.margin.bottom, n.margin.bottom));
    });
  }
  clear() {
    this.context.save(), this.context.fillStyle = "#000", this.context.fillRect(0, 0, this._width, this._height);
  }
}
class nrt {
  constructor(t, n) {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportableView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exportableContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = t, this.context = n;
  }
  resize(t, n, r, i, o) {
    this.width != null && (t = this.width, r = this.width), this.height != null && (n = this.height, i = this.height), this.margin ? (t += this.margin.left + this.margin.right, n += this.margin.top + this.margin.bottom, r += this.margin.left + this.margin.right, i += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px") : (this.view.style.left = "0px", this.view.style.top = "0px"), this._width = Math.floor(t * o), this._height = Math.floor(n * o), this.view.width = this._width, this.view.style.width = r + "px", this.view.height = this._height, this.view.style.height = i + "px";
  }
  clear() {
    this.context.save(), this.context.clearRect(0, 0, this._width, this._height);
  }
}
function Ife(e, t) {
  e == null ? requestAnimationFrame(t) : setTimeout(() => {
    requestAnimationFrame(t);
  }, 1e3 / e);
}
class PK {
  constructor(t, n = {}, r) {
    if (Object.defineProperty(this, "dom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inner", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPositions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_ticker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_tickers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_updateTick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new aN()
    }), Object.defineProperty(this, "animationTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_animations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rootContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tooltipContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipContainerSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "language", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: xnt.new(this, {})
    }), Object.defineProperty(this, "locale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: uwe
    }), Object.defineProperty(this, "utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "timezone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numberFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: mnt.new(this, {})
    }), Object.defineProperty(this, "dateFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: vnt.new(this, {})
    }), Object.defineProperty(this, "durationFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bnt.new(this, {})
    }), Object.defineProperty(this, "tabindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tabindexes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_a11yD", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusedSprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isShift", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_keyboardDragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_readerAlertElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_logo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDiv", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nonce", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interfaceColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verticalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: iC.new(this, {})
    }), Object.defineProperty(this, "horizontalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: rC.new(this, {})
    }), Object.defineProperty(this, "gridLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: xS.new(this, {})
    }), Object.defineProperty(this, "_paused", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "autoResize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_fontHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "_isDisposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_resizeSensorDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltips", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_htmlElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_htmlEnabledContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), !r)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = n, n.accessible == !1 && (this._a11yD = !0), n.useSafeResolution == null && (n.useSafeResolution = !0);
    let i;
    n.useSafeResolution && (i = ztt()), this._renderer = new ert(i);
    let o;
    if (t instanceof HTMLElement ? o = t : o = document.getElementById(t), ut(Cg.rootElements, (u) => {
      if (u.dom === o)
        throw new Error("You cannot have multiple Roots on the same DOM node");
    }), this.interfaceColors = eL.new(this, {}), o === null)
      throw new Error("Could not find HTML element with id `" + t + "`");
    this.dom = o;
    let a = document.createElement("div");
    a.style.position = "relative", a.style.width = "100%", a.style.height = "100%", o.appendChild(a);
    const s = n.tooltipContainerBounds;
    s && (this._tooltipContainerSettings = s), this._inner = a, this._updateComputedStyles(), Cg.rootElements.push(this);
  }
  static new(t, n) {
    const r = new PK(t, n, !0);
    return r._init(), r;
  }
  moveDOM(t) {
    let n;
    if (t instanceof HTMLElement ? n = t : n = document.getElementById(t), n) {
      for (; this.dom.childNodes.length > 0; )
        n.appendChild(this.dom.childNodes[0]);
      this.dom = n, this._initResizeSensor(), this.resize();
    }
  }
  _handleLogo() {
    if (this._logo) {
      const t = this.dom.offsetWidth, n = this.dom.offsetHeight;
      t <= 150 || n <= 60 ? this._logo.hide() : this._logo.show();
    }
  }
  _showBranding() {
    if (!this._logo) {
      const t = this.tooltipContainer.children.push(es.new(this, {
        interactive: !0,
        interactiveChildren: !1,
        position: "absolute",
        setStateOnChildren: !0,
        paddingTop: 9,
        paddingRight: 9,
        paddingBottom: 9,
        paddingLeft: 9,
        scale: 0.6,
        y: ab(100),
        centerY: Eo,
        tooltipText: "Created using amCharts 5",
        tooltipX: Eo,
        cursorOverStyle: "pointer",
        background: bS.new(this, {
          fill: OE(4671320),
          fillOpacity: 0,
          tooltipY: 5
        })
      })), n = xk.new(this, {
        pointerOrientation: "horizontal",
        paddingTop: 4,
        paddingRight: 7,
        paddingBottom: 4,
        paddingLeft: 7
      });
      n.label.setAll({
        fontSize: 12
      }), n.get("background").setAll({
        fill: this.interfaceColors.get("background"),
        stroke: this.interfaceColors.get("grid"),
        strokeOpacity: 0.3
      }), t.set("tooltip", n), t.events.on("click", () => {
        window.open("https://www.amcharts.com/", "_blank");
      }), t.states.create("hover", {}), t.children.push(sb.new(this, {
        stroke: OE(13421772),
        strokeWidth: 3,
        svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
      })).states.create("hover", { stroke: OE(3976191) }), t.children.push(sb.new(this, {
        stroke: OE(8947848),
        strokeWidth: 3,
        svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
      })).states.create("hover", { stroke: OE(4671320) }), this._logo = t, this._handleLogo();
    }
  }
  _getRealSize() {
    return this.dom.getBoundingClientRect();
  }
  _getCalculatedSize(t) {
    return this._settings.calculateSize ? this._settings.calculateSize(t) : {
      width: t.width,
      height: t.height
    };
  }
  _init() {
    const t = this._settings;
    t.accessible !== !1 && (t.focusable && (this._inner.setAttribute("focusable", "true"), this._inner.setAttribute("tabindex", this.tabindex + "")), t.ariaLabel && this._inner.setAttribute("aria-label", t.ariaLabel));
    const n = this._renderer, r = this._getRealSize(), i = this._getCalculatedSize(r), o = Math.floor(i.width), a = Math.floor(i.height), s = Math.floor(r.width), u = Math.floor(r.height), l = es.new(this, {
      visible: !0,
      width: o,
      height: a
    });
    this._rootContainer = l, this._rootContainer._defaultThemes.push(wnt.new(this));
    const f = l.children.push(es.new(this, { visible: !0, width: Eo, height: Eo }));
    this.container = f, n.resize(s, u, o, a), this._inner.appendChild(n.view), this._initResizeSensor();
    const h = document.createElement("div");
    if (this._htmlElementContainer = h, h.className = "am5-html-container", h.style.position = "absolute", h.style.pointerEvents = "none", this._tooltipContainerSettings || (h.style.overflow = "hidden"), this._inner.appendChild(h), this._a11yD !== !0) {
      const p = document.createElement("div");
      p.className = "am5-reader-container", p.setAttribute("role", "alert"), p.style.position = "absolute", p.style.width = "1px", p.style.height = "1px", p.style.overflow = "hidden", p.style.clip = "rect(1px, 1px, 1px, 1px)", this._readerAlertElement = p, this._inner.appendChild(this._readerAlertElement);
      const g = document.createElement("div");
      g.className = "am5-focus-container", g.style.position = "absolute", g.style.pointerEvents = "none", g.style.top = "0px", g.style.left = "0px", g.style.overflow = "hidden", g.style.width = o + "px", g.style.height = a + "px", g.setAttribute("role", "graphics-document"), iT(g, !1), this._focusElementContainer = g, this._inner.appendChild(this._focusElementContainer);
      const y = document.createElement("div");
      this._tooltipElementContainer = y, y.className = "am5-tooltip-container", this._inner.appendChild(y), XE("keyboardevents") && (this._disposers.push(Ja(window, "keydown", (b) => {
        b.keyCode == 16 ? this._isShift = !0 : b.keyCode == 9 && (this._isShift = b.shiftKey);
      })), this._disposers.push(Ja(window, "keyup", (b) => {
        b.keyCode == 16 && (this._isShift = !1);
      })), this._disposers.push(Ja(g, "keydown", (b) => {
        const _ = this._focusedSprite;
        if (_) {
          b.keyCode == 27 && (ktt(), this._focusedSprite = void 0);
          let S = 0, C = 0;
          switch (b.keyCode) {
            case 13:
              b.preventDefault();
              const A = n.getEvent(new MouseEvent("click"));
              _.events.dispatch("click", {
                type: "click",
                originalEvent: A.event,
                point: A.point,
                simulated: !0,
                target: _
              });
              return;
            case 37:
              S = -6;
              break;
            case 39:
              S = 6;
              break;
            case 38:
              C = -6;
              break;
            case 40:
              C = 6;
              break;
            default:
              return;
          }
          if (S != 0 || C != 0) {
            if (b.preventDefault(), !_.isDragging()) {
              this._keyboardDragPoint = {
                x: 0,
                y: 0
              };
              const R = n.getEvent(new MouseEvent("mousedown", {
                clientX: 0,
                clientY: 0
              }));
              _.events.isEnabled("pointerdown") && _.events.dispatch("pointerdown", {
                type: "pointerdown",
                originalEvent: R.event,
                point: R.point,
                simulated: !0,
                target: _
              });
            }
            const A = this._keyboardDragPoint;
            A.x += S, A.y += C;
            const O = n.getEvent(new MouseEvent("mousemove", {
              clientX: A.x,
              clientY: A.y
            }), !1);
            _.events.isEnabled("globalpointermove") && _.events.dispatch("globalpointermove", {
              type: "globalpointermove",
              originalEvent: O.event,
              point: O.point,
              simulated: !0,
              target: _
            });
          }
        }
      })), this._disposers.push(Ja(g, "keyup", (b) => {
        if (this._focusedSprite) {
          const _ = this._focusedSprite, S = b.keyCode;
          switch (S) {
            case 37:
            case 39:
            case 38:
            case 40:
              if (_.isDragging()) {
                const C = this._keyboardDragPoint, A = n.getEvent(new MouseEvent("mouseup", {
                  clientX: C.x,
                  clientY: C.y
                }));
                _.events.isEnabled("globalpointerup") && _.events.dispatch("globalpointerup", {
                  type: "globalpointerup",
                  originalEvent: A.event,
                  point: A.point,
                  simulated: !0,
                  target: _
                }), this._keyboardDragPoint = void 0;
                return;
              } else if (_.get("focusableGroup")) {
                const C = _.get("focusableGroup"), A = this._tabindexes.filter((j) => j.get("focusableGroup") == C && j.getPrivate("focusable") !== !1);
                let O = A.indexOf(_);
                const R = A.length - 1;
                O += S == 39 || S == 40 ? 1 : -1, O < 0 ? O = R : O > R && (O = 0), $tt(A[O].getPrivate("focusElement").dom);
              }
              break;
          }
        }
      })));
    }
    this._startTicker(), this.setThemes([]), this._addTooltip(), this._hasLicense() || this._showBranding();
  }
  _initResizeSensor() {
    this._resizeSensorDisposer && this._resizeSensorDisposer.dispose(), this._resizeSensorDisposer = new gnt(this.dom, () => {
      this.autoResize && this.resize();
    }), this._disposers.push(this._resizeSensorDisposer);
  }
  /**
   * If automatic resizing of char is disabled (`root.autoResize = false`), it
   * can be resized manually by calling this method.
   */
  resize() {
    const t = this._getRealSize(), n = this._getCalculatedSize(t), r = Math.floor(n.width), i = Math.floor(n.height);
    if (r > 0 && i > 0) {
      const o = Math.floor(t.width), a = Math.floor(t.height), s = this._htmlElementContainer;
      if (s.style.width = r + "px", s.style.height = i + "px", this._a11yD !== !0) {
        const l = this._focusElementContainer;
        l.style.width = r + "px", l.style.height = i + "px";
      }
      this._renderer.resize(o, a, r, i);
      const u = this._rootContainer;
      u.setPrivate("width", r), u.setPrivate("height", i), this._render(), this._handleLogo();
    }
  }
  _render() {
    this._renderer.render(this._rootContainer._display), this._focusElementDirty && (this._updateCurrentFocus(), this._focusElementDirty = !1);
  }
  _runTickers(t) {
    ut(this._tickers, (n) => {
      n(t);
    });
  }
  _runAnimations(t) {
    gF(this._animations, (n) => n._runAnimation(t));
  }
  _runDirties() {
    let t = {};
    for (; this._isDirtyParents; )
      this._isDirtyParents = !1, jl(this._dirtyParents).forEach((a) => {
        const s = this._dirtyParents[a];
        delete this._dirtyParents[a], s.isDisposed() || (t[s.uid] = s, s._prepareChildren());
      });
    jl(t).forEach((a) => {
      t[a]._updateChildren();
    });
    const n = [];
    jl(this._dirty).forEach((a) => {
      const s = this._dirty[a];
      s.isDisposed() ? delete this._dirty[s.uid] : (n.push(s), s._beforeChanged());
    }), n.forEach((a) => {
      a._changed(), delete this._dirty[a.uid], a._clearDirty();
    }), this._isDirty = !1;
    const r = {}, i = [];
    jl(this._dirtyBounds).forEach((a) => {
      const s = this._dirtyBounds[a];
      delete this._dirtyBounds[a], s.isDisposed() || (r[s.uid] = s.depth(), i.push(s));
    }), this._positionHTMLElements(), i.sort((a, s) => ZE(r[s.uid], r[a.uid])), i.forEach((a) => {
      a._updateBounds();
    });
    const o = this._dirtyPositions;
    jl(o).forEach((a) => {
      const s = o[a];
      delete o[a], s.isDisposed() || s._updatePosition();
    }), n.forEach((a) => {
      a._afterChanged();
    });
  }
  _renderFrame(t) {
    return this._updateTick ? (this.events.isEnabled("framestarted") && this.events.dispatch("framestarted", {
      type: "framestarted",
      target: this,
      timestamp: t
    }), this._checkComputedStyles(), this._runTickers(t), this._runAnimations(t), this._runDirties(), this._render(), this._positionHTMLElements(), this.events.isEnabled("frameended") && this.events.dispatch("frameended", {
      type: "frameended",
      target: this,
      timestamp: t
    }), this._tickers.length === 0 && this._animations.length === 0 && !this._isDirty) : !0;
  }
  _runTicker(t, n) {
    this.isDisposed() || (this.animationTime = t, this._renderFrame(t) ? (this._ticker = null, this.animationTime = null) : this._paused || (n ? this._ticker : Ife(this.fps, this._ticker)));
  }
  _runTickerNow(t = 1e4) {
    if (!this.isDisposed()) {
      const n = performance.now() + t;
      for (; ; ) {
        const r = performance.now();
        if (r >= n) {
          this.animationTime = null;
          break;
        }
        if (this.animationTime = r, this._renderFrame(r)) {
          this.animationTime = null;
          break;
        }
      }
    }
  }
  _startTicker() {
    this._ticker === null && (this.animationTime = null, this._ticker = (t) => {
      this._runTicker(t);
    }, Ife(this.fps, this._ticker));
  }
  /**
   * Returns whether the root is updating or not.
   */
  get updateTick() {
    return this._updateTick;
  }
  /**
   * Enables or disables the root updating.
   */
  set updateTick(t) {
    this._updateTick = t, t && this._startTicker();
  }
  _addDirtyEntity(t) {
    this._dirty[t.uid] === void 0 && (this._isDirty = !0, this._dirty[t.uid] = t, this._startTicker());
  }
  _addDirtyParent(t) {
    this._dirtyParents[t.uid] === void 0 && (this._isDirty = !0, this._isDirtyParents = !0, this._dirtyParents[t.uid] = t, this._startTicker());
  }
  _addDirtyBounds(t) {
    this._dirtyBounds[t.uid] === void 0 && (this._isDirty = !0, this._dirtyBounds[t.uid] = t, this._startTicker());
  }
  _addDirtyPosition(t) {
    this._dirtyPositions[t.uid] === void 0 && (this._isDirty = !0, this._dirtyPositions[t.uid] = t, this._startTicker());
  }
  _addAnimation(t) {
    this._animations.indexOf(t) === -1 && (this._animations.push(t), this._startTicker());
  }
  _markDirty() {
    this._isDirty = !0;
  }
  _markDirtyRedraw() {
    this.events.once("frameended", () => {
      this._isDirty = !0, this._startTicker();
    });
  }
  eachFrame(t) {
    return this._tickers.push(t), this._startTicker(), new Bs(() => {
      Md(this._tickers, t);
    });
  }
  markDirtyGlobal(t) {
    t || (t = this.container), t.walkChildren((n) => {
      n instanceof es && this.markDirtyGlobal(n), n.markDirty(), n.markDirtyBounds();
    });
  }
  /**
   * Returns width of the target container, in pixels.
   *
   * @return Width
   */
  width() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
  }
  /**
   * Returns height of the target container, in pixels.
   *
   * @return Height
   */
  height() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
  }
  /**
   * Disposes root and all the content in it.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._rootContainer.dispose(), this._renderer.dispose(), this.horizontalLayout.dispose(), this.verticalLayout.dispose(), this.interfaceColors.dispose(), ut(this._disposers, (t) => {
      t.dispose();
    }), this._inner && Rtt(this._inner), mx(Cg.rootElements, this));
  }
  /**
   * Returns `true` if root element is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._isDisposed;
  }
  /**
   * Triggers screen reader read out a message.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
   * @param  text  Alert text
   */
  readerAlert(t) {
    this._a11yD !== !0 && (this._readerAlertElement.innerHTML = Tfe(t));
  }
  /**
   * Sets themes to be used for the chart.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
   * @param  themes  A list of themes
   */
  setThemes(t) {
    this._rootContainer.set("themes", t);
    const n = this.tooltipContainer;
    n && n._applyThemes();
    const r = this.interfaceColors;
    r && r._applyThemes();
  }
  _addTooltip() {
    if (!this.tooltipContainer) {
      const t = this._tooltipContainerSettings, n = this._rootContainer.children.push(es.new(this, {
        position: "absolute",
        isMeasured: !1,
        width: Eo,
        height: Eo,
        layer: t ? 35 : 30,
        layerMargin: t || void 0
      }));
      this.tooltipContainer = n;
      const r = xk.new(this, {});
      this.container.set("tooltip", r), r.hide(0), this._tooltip = r;
    }
  }
  /**
   * Accesibility
   */
  _registerTabindexOrder(t) {
    this._a11yD != !0 && (t.get("focusable") ? mk(this._tabindexes, t) : mx(this._tabindexes, t), this._invalidateTabindexes());
  }
  _unregisterTabindexOrder(t) {
    this._a11yD != !0 && (mx(this._tabindexes, t), this._invalidateTabindexes());
  }
  _invalidateTabindexes() {
    if (this._a11yD == !0)
      return;
    this._tabindexes.sort((n, r) => {
      const i = n.get("tabindexOrder", 0), o = r.get("tabindexOrder", 0);
      return i == o ? 0 : i > o ? 1 : -1;
    });
    const t = [];
    ut(this._tabindexes, (n, r) => {
      n.getPrivate("focusElement") ? this._moveFocusElement(r, n) : this._makeFocusElement(r, n);
      const i = n.get("focusableGroup");
      i && n.getPrivate("focusable") !== !1 && (t.indexOf(i) !== -1 ? n.getPrivate("focusElement").dom.setAttribute("tabindex", "-1") : t.push(i));
    });
  }
  _updateCurrentFocus() {
    this._a11yD != !0 && this._focusedSprite && (this._decorateFocusElement(this._focusedSprite), this._positionFocusElement(this._focusedSprite));
  }
  _decorateFocusElement(t, n) {
    if (this._a11yD == !0 || (n || (n = t.getPrivate("focusElement").dom), !n))
      return;
    const r = t.get("role");
    r ? n.setAttribute("role", r) : n.removeAttribute("role");
    const i = t.get("ariaLabel");
    if (i) {
      const g = Jj(t, i);
      n.setAttribute("aria-label", g);
    } else
      n.removeAttribute("aria-label");
    const o = t.get("ariaLive");
    o ? n.setAttribute("aria-live", o) : n.removeAttribute("aria-live");
    const a = t.get("ariaChecked");
    a != null ? n.setAttribute("aria-checked", a ? "true" : "false") : n.removeAttribute("aria-checked"), t.get("ariaHidden") ? n.setAttribute("aria-hidden", "hidden") : n.removeAttribute("aria-hidden");
    const s = t.get("ariaOrientation");
    s ? n.setAttribute("aria-orientation", s) : n.removeAttribute("aria-orientation");
    const u = t.get("ariaValueNow");
    u ? n.setAttribute("aria-valuenow", u) : n.removeAttribute("aria-valuenow");
    const l = t.get("ariaValueMin");
    l ? n.setAttribute("aria-valuemin", l) : n.removeAttribute("aria-valuemin");
    const f = t.get("ariaValueMax");
    f ? n.setAttribute("aria-valuemax", f) : n.removeAttribute("aria-valuemax");
    const h = t.get("ariaValueText");
    h ? n.setAttribute("aria-valuetext", h) : n.removeAttribute("aria-valuetext");
    const p = t.get("ariaControls");
    p ? n.setAttribute("aria-controls", p) : n.removeAttribute("aria-controls"), t.get("visible") && t.get("opacity") !== 0 && t.get("role") != "tooltip" && !t.isHidden() && t.getPrivate("focusable") !== !1 ? (n.getAttribute("tabindex") != "-1" && n.setAttribute("tabindex", "" + this.tabindex), n.removeAttribute("aria-hidden")) : (n.removeAttribute("tabindex"), n.setAttribute("aria-hidden", "hidden"));
  }
  _makeFocusElement(t, n) {
    if (n.getPrivate("focusElement") || this._a11yD == !0)
      return;
    const r = document.createElement("div");
    n.get("role") != "tooltip" && (r.tabIndex = this.tabindex), r.style.position = "absolute", iT(r, !1);
    const i = [];
    n.setPrivate("focusElement", {
      dom: r,
      disposers: i
    }), this._decorateFocusElement(n), i.push(Ja(r, "focus", (o) => {
      this._handleFocus(o, t);
    })), i.push(Ja(r, "blur", (o) => {
      this._handleBlur(o, t);
    })), this._moveFocusElement(t, n);
  }
  _removeFocusElement(t) {
    if (this._a11yD == !0)
      return;
    mx(this._tabindexes, t);
    const n = t.getPrivate("focusElement");
    n && (this._focusElementContainer.removeChild(n.dom), ut(n.disposers, (i) => {
      i.dispose();
    }));
  }
  _hideFocusElement(t) {
    if (this._a11yD == !0)
      return;
    const n = t.getPrivate("focusElement");
    n.dom.style.display = "none";
  }
  _moveFocusElement(t, n) {
    if (this._a11yD == !0)
      return;
    const r = this._focusElementContainer, i = n.getPrivate("focusElement").dom;
    if (i === this._focusElementContainer.children[t])
      return;
    const o = this._focusElementContainer.children[t + 1];
    o ? r.insertBefore(i, o) : r.append(i);
  }
  _positionFocusElement(t) {
    if (this._a11yD == !0 || t == null)
      return;
    const n = t.globalBounds();
    let r = n.right == n.left ? t.width() : n.right - n.left, i = n.top == n.bottom ? t.height() : n.bottom - n.top, o = n.left - 2, a = n.top - 2;
    r < 0 && (o += r, r = Math.abs(r)), i < 0 && (a += i, i = Math.abs(i));
    const s = t.getPrivate("focusElement").dom;
    s.style.top = a + "px", s.style.left = o + "px", s.style.width = r + 4 + "px", s.style.height = i + 4 + "px";
  }
  _handleFocus(t, n) {
    if (this._a11yD == !0)
      return;
    const r = this._tabindexes[n];
    if (!r.isVisibleDeep()) {
      this._focusNext(t.target, this._isShift ? -1 : 1);
      return;
    }
    this._positionFocusElement(r), this._focusedSprite = r, r.events.isEnabled("focus") && r.events.dispatch("focus", {
      type: "focus",
      originalEvent: t,
      target: r
    });
  }
  _focusNext(t, n) {
    if (this._a11yD == !0)
      return;
    const r = Array.from(document.querySelectorAll([
      "a[href]",
      "area[href]",
      "button:not([disabled])",
      "details",
      "input:not([disabled])",
      "iframe:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      '[contentEditable=""]',
      '[contentEditable="true"]',
      '[contentEditable="TRUE"]',
      '[tabindex]:not([tabindex^="-"])'
      //':not([disabled])'
    ].join(",")));
    let i = r.indexOf(t) + n;
    i < 0 ? i = r.length - 1 : i >= r.length && (i = 0), r[i].focus();
  }
  _handleBlur(t, n) {
    if (this._a11yD == !0)
      return;
    const r = this._focusedSprite;
    r && r.events.isEnabled("blur") && r.events.dispatch("blur", {
      type: "blur",
      originalEvent: t,
      target: r
    }), this._focusedSprite = void 0;
  }
  /**
   * @ignore
   */
  updateTooltip(t) {
    if (this._a11yD == !0)
      return;
    const n = Tfe(t._getText());
    let r = t.getPrivate("tooltipElement");
    t.get("role") == "tooltip" && n != "" ? (r || (r = this._makeTooltipElement(t)), r.innerHTML != n && (r.innerHTML = n)) : r && (r.remove(), t.removePrivate("tooltipElement"));
  }
  _makeTooltipElement(t) {
    const n = this._tooltipElementContainer, r = document.createElement("div");
    return r.style.position = "absolute", r.style.width = "1px", r.style.height = "1px", r.style.overflow = "hidden", r.style.clip = "rect(1px, 1px, 1px, 1px)", iT(r, !1), this._decorateFocusElement(t, r), n.append(r), t.setPrivate("tooltipElement", r), r;
  }
  _removeTooltipElement(t) {
    if (this._a11yD == !0)
      return;
    const n = t.getPrivate("tooltipElement");
    if (n) {
      const r = n.parentElement;
      r && r.removeChild(n);
    }
  }
  _invalidateAccessibility(t) {
    if (this._a11yD == !0)
      return;
    this._focusElementDirty = !0;
    const n = t.getPrivate("focusElement");
    t.get("focusable") ? n && (this._decorateFocusElement(t), this._positionFocusElement(t)) : n && this._removeFocusElement(t);
  }
  /**
   * Returns `true` if `target` is currently focused.
   *
   * @param   target  Target
   * @return          Focused?
   */
  focused(t) {
    return this._focusedSprite === t;
  }
  /**
   * Converts document coordinates to coordinates withing root element.
   *
   * @param   point  Document point
   * @return         Root point
   */
  documentPointToRoot(t) {
    const n = this._getRealSize(), r = this._getCalculatedSize(n), i = r.width / n.width, o = r.height / n.height;
    return {
      x: (t.x - n.left) * i,
      y: (t.y - n.top) * o
    };
  }
  /**
   * Converts root coordinates to document
   *
   * @param   point  Document point
   * @return         Root point
   */
  rootPointToDocument(t) {
    const n = this._getRealSize(), r = this._getCalculatedSize(n), i = r.width / n.width, o = r.height / n.height;
    return {
      x: t.x / i + n.left,
      y: t.y / o + n.top
    };
  }
  /**
   * @ignore
   */
  addDisposer(t) {
    return this._disposers.push(t), t;
  }
  _updateComputedStyles() {
    const t = window.getComputedStyle(this.dom);
    let n = "";
    ia(t, (i, o) => {
      tC(i) && i.match(/^font/) && (n += o);
    });
    const r = n != this._fontHash;
    return r && (this._fontHash = n), r;
  }
  _checkComputedStyles() {
    this._updateComputedStyles() && this._invalidateLabelBounds(this.container);
  }
  _invalidateLabelBounds(t) {
    t instanceof es ? t.children.each((n) => {
      this._invalidateLabelBounds(n);
    }) : t instanceof bk && t.markDirtyBounds();
  }
  /**
   * To all the clever heads out there. Yes, we did not make any attempts to
   * scramble this.
   *
   * This is a part of a tool meant for our users to manage their commercial
   * licenses for removal of amCharts branding from charts.
   *
   * The only legit way to do so is to purchase a commercial license for amCharts:
   * https://www.amcharts.com/online-store/
   *
   * Removing or altering this code, or disabling amCharts branding in any other
   * way is against the license and thus illegal.
   */
  _hasLicense() {
    for (let t = 0; t < Cg.licenses.length; t++)
      if (Cg.licenses[t].match(/^AM5C.{5,}/i))
        return !0;
    return !1;
  }
  _licenseApplied() {
    this._logo && this._logo.set("forceHidden", !0);
  }
  /**
   * @ignore
   */
  get debugGhostView() {
    return this._renderer.debugGhostView;
  }
  /**
   * @ignore
   */
  set debugGhostView(t) {
    this._renderer.debugGhostView = t;
  }
  /**
   * Set this to `true` if you need chart to require first a tap onto it before
   * touch gesture related functionality like zoom/pan is turned on.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default false
   * @since 5.2.9
   * @param  value  Needs a tap to activate touch functions
   */
  set tapToActivate(t) {
    this._renderer.tapToActivate = t;
  }
  /**
   * @return Needs a tap to activate touch functions
   */
  get tapToActivate() {
    return this._renderer.tapToActivate;
  }
  /**
   * If `tapToActivate` is set to `true`, this setting will determine number
   * of milliseconds the chart will stay "active", before releasing the
   * controls back to the page.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default 3000
   * @since 5.2.9
   * @param  value  Timeout
   */
  set tapToActivateTimeout(t) {
    this._renderer.tapToActivateTimeout = t;
  }
  /**
   * @return Timeout
   */
  get tapToActivateTimeout() {
    return this._renderer.tapToActivateTimeout;
  }
  _makeHTMLElement(t) {
    const n = this._htmlElementContainer, r = document.createElement("div");
    return t.setPrivate("htmlElement", r), r.style.position = "absolute", r.style.overflow = "auto", r.style.boxSizing = "border-box", iT(r, t.get("interactive", !1)), t.events.isEnabled("click") && (iT(r, !0), this._disposers.push(Ja(r, "click", (i) => {
      const o = this._renderer.getEvent(i);
      t.events.dispatch("click", {
        type: "click",
        originalEvent: o.event,
        point: o.point,
        simulated: !1,
        target: t
      });
    }))), this._positionHTMLElement(t), n.append(r), mk(this._htmlEnabledContainers, t), r;
  }
  _positionHTMLElements() {
    ut(this._htmlEnabledContainers, (t) => {
      this._positionHTMLElement(t);
    });
  }
  _positionHTMLElement(t) {
    const n = t.getPrivate("htmlElement");
    if (n) {
      ut(["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"], (h) => {
        const p = t.get(h);
        p ? n.style[h] = p + "px" : n.style[h] = "";
      });
      const i = t.compositeOpacity();
      setTimeout(() => {
        n.style.opacity = i + "";
      }, 10);
      const o = t.isVisibleDeep();
      o && (n.style.display = "block");
      const a = t.globalBounds();
      n.style.top = a.top + "px", n.style.left = a.left + "px";
      const s = t.get("width"), u = t.get("height");
      let l = 0, f = 0;
      if (s && (l = t.width()), u && (f = t.height()), !s || !u) {
        n.style.position = "fixed", n.style.width = "", n.style.height = "";
        const h = n.getBoundingClientRect();
        n.style.position = "absolute", l = h.width, f = h.height, t._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 }, t.setPrivate("minWidth", l), t.setPrivate("minHeight", f);
      } else
        t.removePrivate("minWidth"), t.removePrivate("minHeight");
      l > 0 && (n.style.minWidth = l + "px"), f > 0 && (n.style.minHeight = f + "px"), (!o || i == 0) && (n.style.display = "none");
    }
  }
  _setHTMLContent(t, n) {
    let r = t.getPrivate("htmlElement");
    r || (r = this._makeHTMLElement(t)), r.innerHTML != n && (r.innerHTML = n);
  }
  _removeHTMLContent(t) {
    let n = t.getPrivate("htmlElement");
    n && this._htmlElementContainer.removeChild(n), mx(this._htmlEnabledContainers, t);
  }
}
class rrt extends mF {
  constructor() {
    super(...arguments), Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  incrementRef() {
  }
  /**
   * @ignore
   */
  decrementRef() {
  }
  _onPush(t) {
    this.processor && this.processor.processRow(t), super._onPush(t);
  }
  _onInsertIndex(t, n) {
    this.processor && this.processor.processRow(n), super._onInsertIndex(t, n);
  }
  _onSetIndex(t, n, r) {
    this.processor && this.processor.processRow(r), super._onSetIndex(t, n, r);
  }
}
class KY extends awe {
  constructor(t, n, r) {
    super(r), Object.defineProperty(this, "component", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dataContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "open", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "close", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.dataContext = n, this.component = t, this._settings.visible = !0, this._checkDirty();
  }
  /**
   * @ignore
   */
  markDirty() {
    this.component.markDirtyValues(this);
  }
  _startAnimation() {
    this.component._root._addAnimation(this);
  }
  _animationTime() {
    return this.component._root.animationTime;
  }
  _dispose() {
    this.component && this.component.disposeDataItem(this), super._dispose();
  }
  /**
   * Shows a data item that's currently hidden.
   */
  show(t) {
    this.setRaw("visible", !0), this.component && this.component.showDataItem(this, t);
  }
  /**
   * Hides a data item that's currently visible.
   */
  hide(t) {
    this.setRaw("visible", !1), this.component && this.component.hideDataItem(this, t);
  }
  isHidden() {
    return !this.get("visible");
  }
}
class wk extends es {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new rrt()
    }), Object.defineProperty(this, "_dataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mainDataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._dataItems
    }), Object.defineProperty(this, "valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["id"]
    }), Object.defineProperty(this, "_valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueFieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inited", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  /**
   * Component's data.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
   */
  set data(t) {
    t.incrementRef(), this._data.decrementRef(), this._data = t;
  }
  /**
   * @return  Data
   */
  get data() {
    return this._data;
  }
  _dispose() {
    super._dispose(), this._data.decrementRef();
  }
  _onDataClear() {
  }
  _afterNew() {
    super._afterNew(), this._data.incrementRef(), this._updateFields(), this._disposers.push(this.data.events.onAll((t) => {
      const n = this._mainDataItems;
      if (this.markDirtyValues(), this._markDirtyGroup(), this._dataChanged = !0, t.type === "clear")
        ut(n, (r) => {
          r.dispose();
        }), n.length = 0, this._onDataClear();
      else if (t.type === "push") {
        const r = new KY(this, t.newValue, this._makeDataItem(t.newValue));
        n.push(r), this.processDataItem(r);
      } else if (t.type === "setIndex") {
        const r = n[t.index], i = this._makeDataItem(t.newValue);
        r.bullets && r.bullets.length == 0 && (r.bullets = void 0), jl(i).forEach((o) => {
          r.animate({
            key: o,
            to: i[o],
            duration: this.get("interpolationDuration", 0),
            easing: this.get("interpolationEasing")
          });
        }), r.dataContext = t.newValue;
      } else if (t.type === "insertIndex") {
        const r = new KY(this, t.newValue, this._makeDataItem(t.newValue));
        n.splice(t.index, 0, r), this.processDataItem(r);
      } else if (t.type === "removeIndex")
        n[t.index].dispose(), n.splice(t.index, 1);
      else if (t.type === "moveIndex") {
        const r = n[t.oldIndex];
        n.splice(t.oldIndex, 1), n.splice(t.newIndex, 0, r);
      } else
        throw new Error("Unknown IStreamEvent type");
      this._afterDataChange();
    }));
  }
  _updateFields() {
    this.valueFields && (this._valueFields = [], this._valueFieldsF = {}, ut(this.valueFields, (t) => {
      this.get(t + "Field") && (this._valueFields.push(t), this._valueFieldsF[t] = { fieldKey: t + "Field", workingKey: t + "Working" });
    })), this.fields && (this._fields = [], this._fieldsF = {}, ut(this.fields, (t) => {
      this.get(t + "Field") && (this._fields.push(t), this._fieldsF[t] = t + "Field");
    }));
  }
  /**
   * A list of component's data items.
   *
   * @return  Data items
   */
  get dataItems() {
    return this._dataItems;
  }
  processDataItem(t) {
  }
  _makeDataItem(t) {
    const n = {};
    return this._valueFields && ut(this._valueFields, (r) => {
      const i = this.get(this._valueFieldsF[r].fieldKey);
      n[r] = t[i], n[this._valueFieldsF[r].workingKey] = n[r];
    }), this._fields && ut(this._fields, (r) => {
      const i = this.get(this._fieldsF[r]);
      n[r] = t[i];
    }), n;
  }
  /**
   * @ignore
   */
  makeDataItem(t) {
    let n = new KY(this, void 0, t);
    return this.processDataItem(n), n;
  }
  /**
   * @ignore
   */
  pushDataItem(t) {
    const n = this.makeDataItem(t);
    return this._mainDataItems.push(n), n;
  }
  /**
   * @ignore
   */
  disposeDataItem(t) {
  }
  /**
   * Shows component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  showDataItem(t, n) {
    return Ry(this, void 0, void 0, function* () {
      t.set("visible", !0);
    });
  }
  /**
   * Hides component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  hideDataItem(t, n) {
    return Ry(this, void 0, void 0, function* () {
      t.set("visible", !1);
    });
  }
  _clearDirty() {
    super._clearDirty(), this._valuesDirty = !1;
  }
  _afterDataChange() {
  }
  _afterChanged() {
    if (super._afterChanged(), this._dataChanged) {
      const t = "datavalidated";
      this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this }), this._dataChanged = !1;
    }
    this.inited = !0;
  }
  /**
   * Forces a repaint of the element which relies on data.
   *
   * @since 5.0.21
   */
  markDirtyValues(t) {
    this.markDirty(), this._valuesDirty = !0;
  }
  _markDirtyGroup() {
    this._dataGrouped = !1;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
}
Object.defineProperty(wk, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Component"
});
Object.defineProperty(wk, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: es.classNames.concat([wk.className])
});
function irt(e) {
  return new Promise((t, n) => {
    setTimeout(t, e);
  });
}
class _k extends wk {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_aggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionAggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_psi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_pei", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new mF()
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: es.new(this._root, { width: Eo, height: Eo, position: "absolute" })
    });
  }
  _afterNew() {
    this.valueFields.push("value"), super._afterNew(), this.setPrivate("customData", {}), this._disposers.push(this.bullets.events.onAll((t) => {
      if (t.type === "clear")
        this._handleBullets(this.dataItems);
      else if (t.type === "push")
        this._handleBullets(this.dataItems);
      else if (t.type === "setIndex")
        this._handleBullets(this.dataItems);
      else if (t.type === "insertIndex")
        this._handleBullets(this.dataItems);
      else if (t.type === "removeIndex")
        this._handleBullets(this.dataItems);
      else if (t.type === "moveIndex")
        this._handleBullets(this.dataItems);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _dispose() {
    this.bulletsContainer.dispose(), super._dispose();
  }
  startIndex() {
    let t = this.dataItems.length;
    return Math.min(this.getPrivate("startIndex", 0), t);
  }
  endIndex() {
    let t = this.dataItems.length;
    return Math.min(this.getPrivate("endIndex", t), t);
  }
  _handleBullets(t) {
    ut(t, (n) => {
      const r = n.bullets;
      r && (ut(r, (i) => {
        i.dispose();
      }), n.bullets = void 0);
    }), this.markDirtyValues();
  }
  /**
   * Looks up and returns a data item by its ID.
   *
   * @param   id  ID
   * @return      Data item
   */
  getDataItemById(t) {
    return Qxe(this.dataItems, (n) => n.get("id") == t);
  }
  _makeBullets(t) {
    this._shouldMakeBullet(t) && (t.bullets = [], this.bullets.each((n) => {
      this._makeBullet(t, n);
    }));
  }
  _shouldMakeBullet(t) {
    return !0;
  }
  _makeBullet(t, n, r) {
    const i = n(this._root, this, t);
    if (i) {
      let o = i.get("sprite");
      o && (o._setDataItem(t), o.setRaw("position", "absolute"), this.bulletsContainer.children.push(o)), i._index = r, i.series = this, t.bullets.push(i);
    }
    return i;
  }
  _clearDirty() {
    super._clearDirty(), this._aggregatesCalculated = !1, this._selectionAggregatesCalculated = !1;
  }
  _prepareChildren() {
    super._prepareChildren();
    let t = this.startIndex(), n = this.endIndex();
    if (this.isDirty("heatRules") && (this._valuesDirty = !0), this.isPrivateDirty("baseValueSeries")) {
      const i = this.getPrivate("baseValueSeries");
      i && this._disposers.push(i.onPrivate("startIndex", () => {
        this.markDirtyValues();
      }));
    }
    if (this.get("calculateAggregates") && (this._valuesDirty && !this._dataProcessed && (this._aggregatesCalculated || (this._calculateAggregates(0, this.dataItems.length), this._aggregatesCalculated = !0)), (this._psi != t || this._pei != n) && !this._selectionAggregatesCalculated && (t === 0 && n === this.dataItems.length && this._aggregatesCalculated || this._calculateAggregates(t, n), this._selectionAggregatesCalculated = !0)), this.isDirty("tooltip")) {
      let i = this.get("tooltip");
      i && (i.hide(0), i.set("tooltipTarget", this));
    }
    if (this.isDirty("fill") || this.isDirty("stroke")) {
      let i;
      const o = this.get("legendDataItem");
      if (o && (i = o.get("markerRectangle"), i && this.isVisible())) {
        if (this.isDirty("stroke")) {
          let a = this.get("stroke");
          i.set("stroke", a);
        }
        if (this.isDirty("fill")) {
          let a = this.get("fill");
          i.set("fill", a);
        }
      }
      this.updateLegendMarker(void 0);
    }
    if (this.bullets.length > 0) {
      let i = this.startIndex(), o = this.endIndex();
      o < this.dataItems.length && o++;
      for (let a = i; a < o; a++) {
        let s = this.dataItems[a];
        s.bullets || this._makeBullets(s);
      }
    }
  }
  _calculateAggregates(t, n) {
    let r = this._valueFields;
    if (!r)
      throw new Error("No value fields are set for the series.");
    const i = {}, o = {}, a = {}, s = {}, u = {}, l = {}, f = {}, h = {}, p = {};
    ut(r, (g) => {
      i[g] = 0, o[g] = 0, a[g] = 0;
    }), ut(r, (g) => {
      let y = g + "Change", b = g + "ChangePercent", _ = g + "ChangePrevious", S = g + "ChangePreviousPercent", C = g + "ChangeSelection", A = g + "ChangeSelectionPercent", O = "valueY";
      (g == "valueX" || g == "openValueX" || g == "lowValueX" || g == "highValueX") && (O = "valueX");
      const R = this.getPrivate("baseValueSeries");
      for (let j = t; j < n; j++) {
        const $ = this.dataItems[j];
        let z = $.get(g);
        z != null && (a[g]++, i[g] += z, o[g] += Math.abs(z), h[g] = i[g] / a[g], (s[g] > z || s[g] == null) && (s[g] = z), (u[g] < z || u[g] == null) && (u[g] = z), f[g] = z, l[g] == null && (l[g] = z, p[g] = z, R && (l[O] = R._getBase(O))), t === 0 && ($.setRaw(y, z - l[O]), $.setRaw(b, (z - l[O]) / l[O] * 100)), $.setRaw(_, z - p[O]), $.setRaw(S, (z - p[O]) / p[O] * 100), $.setRaw(C, z - l[O]), $.setRaw(A, (z - l[O]) / l[O] * 100), p[g] = z);
      }
    }), ut(r, (g) => {
      this.setPrivate(g + "AverageSelection", h[g]), this.setPrivate(g + "CountSelection", a[g]), this.setPrivate(g + "SumSelection", i[g]), this.setPrivate(g + "AbsoluteSumSelection", o[g]), this.setPrivate(g + "LowSelection", s[g]), this.setPrivate(g + "HighSelection", u[g]), this.setPrivate(g + "OpenSelection", l[g]), this.setPrivate(g + "CloseSelection", f[g]);
    }), t === 0 && n === this.dataItems.length && ut(r, (g) => {
      this.setPrivate(g + "Average", h[g]), this.setPrivate(g + "Count", a[g]), this.setPrivate(g + "Sum", i[g]), this.setPrivate(g + "AbsoluteSum", o[g]), this.setPrivate(g + "Low", s[g]), this.setPrivate(g + "High", u[g]), this.setPrivate(g + "Open", l[g]), this.setPrivate(g + "Close", f[g]);
    });
  }
  _updateChildren() {
    super._updateChildren(), this._psi = this.startIndex(), this._pei = this.endIndex(), this.isDirty("visible") && this.bulletsContainer.set("visible", this.get("visible"));
    const t = this.get("heatRules");
    if (this._valuesDirty && t && t.length > 0 && ut(t, (n) => {
      const r = n.minValue || this.getPrivate(n.dataField + "Low") || 0, i = n.maxValue || this.getPrivate(n.dataField + "High") || 0;
      ut(n.target._entities, (o) => {
        const a = o.dataItem.get(n.dataField);
        if (!Cn(a)) {
          n.neutral && o.set(n.key, n.neutral);
          return;
        }
        if (n.customFunction)
          n.customFunction.call(this, o, r, i, a);
        else {
          let s;
          n.logarithmic ? s = (Math.log(a) * Math.LOG10E - Math.log(r) * Math.LOG10E) / (Math.log(i) * Math.LOG10E - Math.log(r) * Math.LOG10E) : s = (a - r) / (i - r), Cn(a) && (!Cn(s) || Math.abs(s) == 1 / 0) && (s = 0.5);
          let u;
          Cn(n.min) ? u = n.min + (n.max - n.min) * s : n.min instanceof Mr ? u = Mr.interpolate(s, n.min, n.max) : n.min instanceof hi && (u = rwe(s, n.min, n.max)), o.set(n.key, u);
        }
      });
    }), this.get("visible") && this.bullets.length > 0) {
      let n = this.dataItems.length, r = this.startIndex(), i = this.endIndex();
      i < n && i++, r > 0 && r--;
      for (let o = 0; o < r; o++)
        this._hideBullets(this.dataItems[o]);
      for (let o = r; o < i; o++)
        this._positionBullets(this.dataItems[o]);
      for (let o = i; o < n; o++)
        this._hideBullets(this.dataItems[o]);
    }
  }
  _positionBullets(t) {
    t.bullets && ut(t.bullets, (n) => {
      this._positionBullet(n);
      const r = n.get("sprite");
      n.get("dynamic") && (r && (r._markDirtyKey("fill"), r.markDirtySize()), r instanceof es && r.walkChildren((i) => {
        i._markDirtyKey("fill"), i.markDirtySize(), i instanceof wS && i.text.markDirtyText();
      })), r instanceof wS && r.get("populateText") && r.text.markDirtyText();
    });
  }
  _hideBullets(t) {
    t.bullets && ut(t.bullets, (n) => {
      let r = n.get("sprite");
      r && r.setPrivate("visible", !1);
    });
  }
  _positionBullet(t) {
  }
  _placeBulletsContainer(t) {
    t.bulletsContainer.children.moveValue(this.bulletsContainer);
  }
  _removeBulletsContainer() {
    const t = this.bulletsContainer;
    t.parent && t.parent.children.removeValue(t);
  }
  /**
   * @ignore
   */
  disposeDataItem(t) {
    const n = t.bullets;
    n && ut(n, (r) => {
      r.dispose();
    });
  }
  _getItemReaderLabel() {
    return "";
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(t, n) {
    const r = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ry(this, void 0, void 0, function* () {
      const i = [r.showDataItem.call(this, t, n)], o = t.bullets;
      o && ut(o, (a) => {
        i.push(a.get("sprite").show(n));
      }), yield Promise.all(i);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(t, n) {
    const r = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ry(this, void 0, void 0, function* () {
      const i = [r.hideDataItem.call(this, t, n)], o = t.bullets;
      o && ut(o, (a) => {
        i.push(a.get("sprite").hide(n));
      }), yield Promise.all(i);
    });
  }
  _sequencedShowHide(t, n) {
    return Ry(this, void 0, void 0, function* () {
      if (this.get("sequencedInterpolation"))
        if (Cn(n) || (n = this.get("interpolationDuration", 0)), n > 0) {
          const r = this.startIndex(), i = this.endIndex();
          yield Promise.all(vq(this.dataItems, (o, a) => Ry(this, void 0, void 0, function* () {
            let s = n || 0;
            (a < r - 10 || a > i + 10) && (s = 0);
            let u = this.get("sequencedDelay", 0) + s / (i - r);
            yield irt(u * (a - r)), t ? yield this.showDataItem(o, s) : yield this.hideDataItem(o, s);
          })));
        } else
          yield Promise.all(vq(this.dataItems, (r) => t ? this.showDataItem(r, 0) : this.hideDataItem(r, 0)));
    });
  }
  /**
   * @ignore
   */
  updateLegendValue(t) {
    if (t) {
      const n = t.get("legendDataItem");
      if (n) {
        const r = n.get("valueLabel");
        if (r) {
          const o = r.text;
          let a = "";
          r._setDataItem(t), a = this.get("legendValueText", o.get("text", "")), r.set("text", a), o.markDirtyText();
        }
        const i = n.get("label");
        if (i) {
          const o = i.text;
          let a = "";
          i._setDataItem(t), a = this.get("legendLabelText", o.get("text", "")), i.set("text", a), o.markDirtyText();
        }
      }
    }
  }
  /**
   * @ignore
   */
  updateLegendMarker(t) {
  }
  _onHide() {
    super._onHide();
    const t = this.getTooltip();
    t && t.hide();
  }
  /**
   * @ignore
   */
  hoverDataItem(t) {
  }
  /**
   * @ignore
   */
  unhoverDataItem(t) {
  }
  /**
   * @ignore
   */
  _getBase(t) {
    const n = this.dataItems[this.startIndex()];
    return n ? n.get(t) : 0;
  }
}
Object.defineProperty(_k, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Series"
});
Object.defineProperty(_k, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: wk.classNames.concat([_k.className])
});
function eo(e) {
  return function() {
    return e;
  };
}
const jfe = Math.abs, Ol = Math.atan2, I0 = Math.cos, ort = Math.max, CT = Math.min, hf = Math.sin, Wo = Math.sqrt, $l = 1e-12, qx = Math.PI, tL = qx / 2, S$ = 2 * qx;
function art(e) {
  return e > 1 ? 0 : e < -1 ? qx : Math.acos(e);
}
function Lfe(e) {
  return e >= 1 ? tL : e <= -1 ? -tL : Math.asin(e);
}
const Eq = Math.PI, Sq = 2 * Eq, SE = 1e-6, srt = Sq - SE;
function cwe(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function urt(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return cwe;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, o = r.length; i < o; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
let xF = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? cwe : urt(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, o, a) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +o},${this._y1 = +a}`;
  }
  arcTo(t, n, r, i, o) {
    if (t = +t, n = +n, r = +r, i = +i, o = +o, o < 0)
      throw new Error(`negative radius: ${o}`);
    let a = this._x1, s = this._y1, u = r - t, l = i - n, f = a - t, h = s - n, p = f * f + h * h;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > SE)
      if (!(Math.abs(h * u - l * f) > SE) || !o)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let g = r - a, y = i - s, b = u * u + l * l, _ = g * g + y * y, S = Math.sqrt(b), C = Math.sqrt(p), A = o * Math.tan((Eq - Math.acos((b + p - _) / (2 * S * C))) / 2), O = A / C, R = A / S;
        Math.abs(O - 1) > SE && this._append`L${t + O * f},${n + O * h}`, this._append`A${o},${o},0,0,${+(h * g > f * y)},${this._x1 = t + R * u},${this._y1 = n + R * l}`;
      }
  }
  arc(t, n, r, i, o, a) {
    if (t = +t, n = +n, r = +r, a = !!a, r < 0)
      throw new Error(`negative radius: ${r}`);
    let s = r * Math.cos(i), u = r * Math.sin(i), l = t + s, f = n + u, h = 1 ^ a, p = a ? i - o : o - i;
    this._x1 === null ? this._append`M${l},${f}` : (Math.abs(this._x1 - l) > SE || Math.abs(this._y1 - f) > SE) && this._append`L${l},${f}`, r && (p < 0 && (p = p % Sq + Sq), p > srt ? this._append`A${r},${r},0,1,${h},${t - s},${n - u}A${r},${r},0,1,${h},${this._x1 = l},${this._y1 = f}` : p > SE && this._append`A${r},${r},0,${+(p >= Eq)},${h},${this._x1 = t + r * Math.cos(o)},${this._y1 = n + r * Math.sin(o)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
};
function wF() {
  return new xF();
}
wF.prototype = xF.prototype;
function H0(e = 3) {
  return new xF(+e);
}
function _F(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new xF(t);
}
function lrt(e) {
  return e.innerRadius;
}
function crt(e) {
  return e.outerRadius;
}
function frt(e) {
  return e.startAngle;
}
function drt(e) {
  return e.endAngle;
}
function hrt(e) {
  return e && e.padAngle;
}
function prt(e, t, n, r, i, o, a, s) {
  var u = n - e, l = r - t, f = a - i, h = s - o, p = h * u - f * l;
  if (!(p * p < $l))
    return p = (f * (t - o) - h * (e - i)) / p, [e + p * u, t + p * l];
}
function FI(e, t, n, r, i, o, a) {
  var s = e - n, u = t - r, l = (a ? o : -o) / Wo(s * s + u * u), f = l * u, h = -l * s, p = e + f, g = t + h, y = n + f, b = r + h, _ = (p + y) / 2, S = (g + b) / 2, C = y - p, A = b - g, O = C * C + A * A, R = i - o, j = p * b - y * g, $ = (A < 0 ? -1 : 1) * Wo(ort(0, R * R * O - j * j)), z = (j * A - C * $) / O, W = (-j * C - A * $) / O, Y = (j * A + C * $) / O, V = (-j * C + A * $) / O, ee = z - _, K = W - S, Q = Y - _, q = V - S;
  return ee * ee + K * K > Q * Q + q * q && (z = Y, W = V), {
    cx: z,
    cy: W,
    x01: -f,
    y01: -h,
    x11: z * (i / R - 1),
    y11: W * (i / R - 1)
  };
}
function grt() {
  var e = lrt, t = crt, n = eo(0), r = null, i = frt, o = drt, a = hrt, s = null, u = _F(l);
  function l() {
    var f, h, p = +e.apply(this, arguments), g = +t.apply(this, arguments), y = i.apply(this, arguments) - tL, b = o.apply(this, arguments) - tL, _ = jfe(b - y), S = b > y;
    if (s || (s = f = u()), g < p && (h = g, g = p, p = h), !(g > $l))
      s.moveTo(0, 0);
    else if (_ > S$ - $l)
      s.moveTo(g * I0(y), g * hf(y)), s.arc(0, 0, g, y, b, !S), p > $l && (s.moveTo(p * I0(b), p * hf(b)), s.arc(0, 0, p, b, y, S));
    else {
      var C = y, A = b, O = y, R = b, j = _, $ = _, z = a.apply(this, arguments) / 2, W = z > $l && (r ? +r.apply(this, arguments) : Wo(p * p + g * g)), Y = CT(jfe(g - p) / 2, +n.apply(this, arguments)), V = Y, ee = Y, K, Q;
      if (W > $l) {
        var q = Lfe(W / p * hf(z)), te = Lfe(W / g * hf(z));
        (j -= q * 2) > $l ? (q *= S ? 1 : -1, O += q, R -= q) : (j = 0, O = R = (y + b) / 2), ($ -= te * 2) > $l ? (te *= S ? 1 : -1, C += te, A -= te) : ($ = 0, C = A = (y + b) / 2);
      }
      var X = g * I0(C), Z = g * hf(C), se = p * I0(R), H = p * hf(R);
      if (Y > $l) {
        var ie = g * I0(A), he = g * hf(A), ye = p * I0(O), _e = p * hf(O), Ne;
        if (_ < qx)
          if (Ne = prt(X, Z, ye, _e, ie, he, se, H)) {
            var Oe = X - Ne[0], ke = Z - Ne[1], Me = ie - Ne[0], we = he - Ne[1], Ye = 1 / hf(art((Oe * Me + ke * we) / (Wo(Oe * Oe + ke * ke) * Wo(Me * Me + we * we))) / 2), ze = Wo(Ne[0] * Ne[0] + Ne[1] * Ne[1]);
            V = CT(Y, (p - ze) / (Ye - 1)), ee = CT(Y, (g - ze) / (Ye + 1));
          } else
            V = ee = 0;
      }
      $ > $l ? ee > $l ? (K = FI(ye, _e, X, Z, g, ee, S), Q = FI(ie, he, se, H, g, ee, S), s.moveTo(K.cx + K.x01, K.cy + K.y01), ee < Y ? s.arc(K.cx, K.cy, ee, Ol(K.y01, K.x01), Ol(Q.y01, Q.x01), !S) : (s.arc(K.cx, K.cy, ee, Ol(K.y01, K.x01), Ol(K.y11, K.x11), !S), s.arc(0, 0, g, Ol(K.cy + K.y11, K.cx + K.x11), Ol(Q.cy + Q.y11, Q.cx + Q.x11), !S), s.arc(Q.cx, Q.cy, ee, Ol(Q.y11, Q.x11), Ol(Q.y01, Q.x01), !S))) : (s.moveTo(X, Z), s.arc(0, 0, g, C, A, !S)) : s.moveTo(X, Z), !(p > $l) || !(j > $l) ? s.lineTo(se, H) : V > $l ? (K = FI(se, H, ie, he, p, -V, S), Q = FI(X, Z, ye, _e, p, -V, S), s.lineTo(K.cx + K.x01, K.cy + K.y01), V < Y ? s.arc(K.cx, K.cy, V, Ol(K.y01, K.x01), Ol(Q.y01, Q.x01), !S) : (s.arc(K.cx, K.cy, V, Ol(K.y01, K.x01), Ol(K.y11, K.x11), !S), s.arc(0, 0, p, Ol(K.cy + K.y11, K.cx + K.x11), Ol(Q.cy + Q.y11, Q.cx + Q.x11), S), s.arc(Q.cx, Q.cy, V, Ol(Q.y11, Q.x11), Ol(Q.y01, Q.x01), !S))) : s.arc(0, 0, p, R, O, S);
    }
    if (s.closePath(), f)
      return s = null, f + "" || null;
  }
  return l.centroid = function() {
    var f = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, h = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - qx / 2;
    return [I0(h) * f, hf(h) * f];
  }, l.innerRadius = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : eo(+f), l) : e;
  }, l.outerRadius = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : eo(+f), l) : t;
  }, l.cornerRadius = function(f) {
    return arguments.length ? (n = typeof f == "function" ? f : eo(+f), l) : n;
  }, l.padRadius = function(f) {
    return arguments.length ? (r = f == null ? null : typeof f == "function" ? f : eo(+f), l) : r;
  }, l.startAngle = function(f) {
    return arguments.length ? (i = typeof f == "function" ? f : eo(+f), l) : i;
  }, l.endAngle = function(f) {
    return arguments.length ? (o = typeof f == "function" ? f : eo(+f), l) : o;
  }, l.padAngle = function(f) {
    return arguments.length ? (a = typeof f == "function" ? f : eo(+f), l) : a;
  }, l.context = function(f) {
    return arguments.length ? (s = f ?? null, l) : s;
  }, l;
}
function fwe(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function dwe(e) {
  this._context = e;
}
dwe.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function sN(e) {
  return new dwe(e);
}
function hwe(e) {
  return e[0];
}
function pwe(e) {
  return e[1];
}
function IK(e, t) {
  var n = eo(!0), r = null, i = sN, o = null, a = _F(s);
  e = typeof e == "function" ? e : e === void 0 ? hwe : eo(e), t = typeof t == "function" ? t : t === void 0 ? pwe : eo(t);
  function s(u) {
    var l, f = (u = fwe(u)).length, h, p = !1, g;
    for (r == null && (o = i(g = a())), l = 0; l <= f; ++l)
      !(l < f && n(h = u[l], l, u)) === p && ((p = !p) ? o.lineStart() : o.lineEnd()), p && o.point(+e(h, l, u), +t(h, l, u));
    if (g)
      return o = null, g + "" || null;
  }
  return s.x = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : eo(+u), s) : e;
  }, s.y = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : eo(+u), s) : t;
  }, s.defined = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : eo(!!u), s) : n;
  }, s.curve = function(u) {
    return arguments.length ? (i = u, r != null && (o = i(r)), s) : i;
  }, s.context = function(u) {
    return arguments.length ? (u == null ? r = o = null : o = i(r = u), s) : r;
  }, s;
}
function M$(e, t, n) {
  var r = null, i = eo(!0), o = null, a = sN, s = null, u = _F(l);
  e = typeof e == "function" ? e : e === void 0 ? hwe : eo(+e), t = typeof t == "function" ? t : eo(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? pwe : eo(+n);
  function l(h) {
    var p, g, y, b = (h = fwe(h)).length, _, S = !1, C, A = new Array(b), O = new Array(b);
    for (o == null && (s = a(C = u())), p = 0; p <= b; ++p) {
      if (!(p < b && i(_ = h[p], p, h)) === S)
        if (S = !S)
          g = p, s.areaStart(), s.lineStart();
        else {
          for (s.lineEnd(), s.lineStart(), y = p - 1; y >= g; --y)
            s.point(A[y], O[y]);
          s.lineEnd(), s.areaEnd();
        }
      S && (A[p] = +e(_, p, h), O[p] = +t(_, p, h), s.point(r ? +r(_, p, h) : A[p], n ? +n(_, p, h) : O[p]));
    }
    if (C)
      return s = null, C + "" || null;
  }
  function f() {
    return IK().defined(i).curve(a).context(o);
  }
  return l.x = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : eo(+h), r = null, l) : e;
  }, l.x0 = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : eo(+h), l) : e;
  }, l.x1 = function(h) {
    return arguments.length ? (r = h == null ? null : typeof h == "function" ? h : eo(+h), l) : r;
  }, l.y = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : eo(+h), n = null, l) : t;
  }, l.y0 = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : eo(+h), l) : t;
  }, l.y1 = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : eo(+h), l) : n;
  }, l.lineX0 = l.lineY0 = function() {
    return f().x(e).y(t);
  }, l.lineY1 = function() {
    return f().x(e).y(n);
  }, l.lineX1 = function() {
    return f().x(r).y(t);
  }, l.defined = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : eo(!!h), l) : i;
  }, l.curve = function(h) {
    return arguments.length ? (a = h, o != null && (s = a(o)), l) : a;
  }, l.context = function(h) {
    return arguments.length ? (h == null ? o = s = null : s = a(o = h), l) : o;
  }, l;
}
class gwe {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function mrt(e) {
  return new gwe(e, !0);
}
function yrt(e) {
  return new gwe(e, !1);
}
const vrt = Wo(3), mwe = {
  draw(e, t) {
    const n = Wo(t + CT(t / 28, 0.75)) * 0.59436, r = n / 2, i = r * vrt;
    e.moveTo(0, n), e.lineTo(0, -n), e.moveTo(-i, -r), e.lineTo(i, r), e.moveTo(-i, r), e.lineTo(i, -r);
  }
}, oC = {
  draw(e, t) {
    const n = Wo(t / qx);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, S$);
  }
}, ywe = {
  draw(e, t) {
    const n = Wo(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, vwe = Wo(1 / 3), brt = vwe * 2, bwe = {
  draw(e, t) {
    const n = Wo(t / brt), r = n * vwe;
    e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath();
  }
}, xwe = {
  draw(e, t) {
    const n = Wo(t) * 0.62625;
    e.moveTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.lineTo(-n, 0), e.closePath();
  }
}, wwe = {
  draw(e, t) {
    const n = Wo(t - CT(t / 7, 2)) * 0.87559;
    e.moveTo(-n, 0), e.lineTo(n, 0), e.moveTo(0, n), e.lineTo(0, -n);
  }
}, _we = {
  draw(e, t) {
    const n = Wo(t), r = -n / 2;
    e.rect(r, r, n, n);
  }
}, Ewe = {
  draw(e, t) {
    const n = Wo(t) * 0.4431;
    e.moveTo(n, n), e.lineTo(n, -n), e.lineTo(-n, -n), e.lineTo(-n, n), e.closePath();
  }
}, xrt = 0.8908130915292852, Swe = hf(qx / 10) / hf(7 * qx / 10), wrt = hf(S$ / 10) * Swe, _rt = -I0(S$ / 10) * Swe, Mwe = {
  draw(e, t) {
    const n = Wo(t * xrt), r = wrt * n, i = _rt * n;
    e.moveTo(0, -n), e.lineTo(r, i);
    for (let o = 1; o < 5; ++o) {
      const a = S$ * o / 5, s = I0(a), u = hf(a);
      e.lineTo(u * n, -s * n), e.lineTo(s * r - u * i, u * r + s * i);
    }
    e.closePath();
  }
}, ZY = Wo(3), Twe = {
  draw(e, t) {
    const n = -Wo(t / (ZY * 3));
    e.moveTo(0, n * 2), e.lineTo(-ZY * n, -n), e.lineTo(ZY * n, -n), e.closePath();
  }
}, Ert = Wo(3), Cwe = {
  draw(e, t) {
    const n = Wo(t) * 0.6824, r = n / 2, i = n * Ert / 2;
    e.moveTo(0, -n), e.lineTo(i, r), e.lineTo(-i, r), e.closePath();
  }
}, Wh = -0.5, qh = Wo(3) / 2, Mq = 1 / Wo(12), Srt = (Mq / 2 + 1) * 3, Nwe = {
  draw(e, t) {
    const n = Wo(t / Srt), r = n / 2, i = n * Mq, o = r, a = n * Mq + n, s = -o, u = a;
    e.moveTo(r, i), e.lineTo(o, a), e.lineTo(s, u), e.lineTo(Wh * r - qh * i, qh * r + Wh * i), e.lineTo(Wh * o - qh * a, qh * o + Wh * a), e.lineTo(Wh * s - qh * u, qh * s + Wh * u), e.lineTo(Wh * r + qh * i, Wh * i - qh * r), e.lineTo(Wh * o + qh * a, Wh * a - qh * o), e.lineTo(Wh * s + qh * u, Wh * u - qh * s), e.closePath();
  }
}, Dwe = {
  draw(e, t) {
    const n = Wo(t - CT(t / 6, 1.7)) * 0.6189;
    e.moveTo(-n, -n), e.lineTo(n, n), e.moveTo(-n, n), e.lineTo(n, -n);
  }
}, Mrt = [
  oC,
  ywe,
  bwe,
  _we,
  Mwe,
  Twe,
  Nwe
], Trt = [
  oC,
  wwe,
  Dwe,
  Cwe,
  mwe,
  Ewe,
  xwe
];
function Crt(e, t) {
  let n = null, r = _F(i);
  e = typeof e == "function" ? e : eo(e || oC), t = typeof t == "function" ? t : eo(t === void 0 ? 64 : +t);
  function i() {
    let o;
    if (n || (n = o = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o)
      return n = null, o + "" || null;
  }
  return i.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : eo(o), i) : e;
  }, i.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : eo(+o), i) : t;
  }, i.context = function(o) {
    return arguments.length ? (n = o ?? null, i) : n;
  }, i;
}
function Gx() {
}
function nL(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function EF(e) {
  this._context = e;
}
EF.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        nL(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        nL(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Awe(e) {
  return new EF(e);
}
function Owe(e) {
  this._context = e;
}
Owe.prototype = {
  areaStart: Gx,
  areaEnd: Gx,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        nL(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Rwe(e) {
  return new Owe(e);
}
function kwe(e) {
  this._context = e;
}
kwe.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        nL(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function $we(e) {
  return new kwe(e);
}
function Pwe(e, t) {
  this._basis = new EF(e), this._beta = t;
}
Pwe.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], o = e[n] - r, a = t[n] - i, s = -1, u; ++s <= n; )
        u = s / n, this._basis.point(
          this._beta * e[s] + (1 - this._beta) * (r + u * o),
          this._beta * t[s] + (1 - this._beta) * (i + u * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const Iwe = function e(t) {
  function n(r) {
    return t === 1 ? new EF(r) : new Pwe(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function rL(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function jK(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
jK.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        rL(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        rL(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const jwe = function e(t) {
  function n(r) {
    return new jK(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function LK(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
LK.prototype = {
  areaStart: Gx,
  areaEnd: Gx,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        rL(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Lwe = function e(t) {
  function n(r) {
    return new LK(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function zK(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
zK.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        rL(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const zwe = function e(t) {
  function n(r) {
    return new zK(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function FK(e, t, n) {
  var r = e._x1, i = e._y1, o = e._x2, a = e._y2;
  if (e._l01_a > $l) {
    var s = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, u = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * s - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u, i = (i * s - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u;
  }
  if (e._l23_a > $l) {
    var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, f = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * l + e._x1 * e._l23_2a - t * e._l12_2a) / f, a = (a * l + e._y1 * e._l23_2a - n * e._l12_2a) / f;
  }
  e._context.bezierCurveTo(r, i, o, a, e._x2, e._y2);
}
function Fwe(e, t) {
  this._context = e, this._alpha = t;
}
Fwe.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        FK(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Bwe = function e(t) {
  function n(r) {
    return t ? new Fwe(r, t) : new jK(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Uwe(e, t) {
  this._context = e, this._alpha = t;
}
Uwe.prototype = {
  areaStart: Gx,
  areaEnd: Gx,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        FK(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Ywe = function e(t) {
  function n(r) {
    return t ? new Uwe(r, t) : new LK(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Hwe(e, t) {
  this._context = e, this._alpha = t;
}
Hwe.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        FK(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Vwe = function e(t) {
  function n(r) {
    return t ? new Hwe(r, t) : new zK(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Wwe(e) {
  this._context = e;
}
Wwe.prototype = {
  areaStart: Gx,
  areaEnd: Gx,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function qwe(e) {
  return new Wwe(e);
}
function zfe(e) {
  return e < 0 ? -1 : 1;
}
function Ffe(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), s = (o * i + a * r) / (r + i);
  return (zfe(o) + zfe(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0;
}
function Bfe(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function JY(e, t, n) {
  var r = e._x0, i = e._y0, o = e._x1, a = e._y1, s = (o - r) / 3;
  e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a);
}
function iL(e) {
  this._context = e;
}
iL.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        JY(this, this._t0, Bfe(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, JY(this, Bfe(this, n = Ffe(this, e, t)), n);
          break;
        default:
          JY(this, this._t0, n = Ffe(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Gwe(e) {
  this._context = new Qwe(e);
}
(Gwe.prototype = Object.create(iL.prototype)).point = function(e, t) {
  iL.prototype.point.call(this, t, e);
};
function Qwe(e) {
  this._context = e;
}
Qwe.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i);
  }
};
function Xwe(e) {
  return new iL(e);
}
function Kwe(e) {
  return new Gwe(e);
}
function Zwe(e) {
  this._context = e;
}
Zwe.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Ufe(e), i = Ufe(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Ufe(e) {
  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), a = new Array(n);
  for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, o[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / o[t - 1], o[t] -= r, a[t] -= r * a[t - 1];
  for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (a[t] - i[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function Jwe(e) {
  return new Zwe(e);
}
function SF(e, t) {
  this._context = e, this._t = t;
}
SF.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function e_e(e) {
  return new SF(e, 0.5);
}
function t_e(e) {
  return new SF(e, 0);
}
function n_e(e) {
  return new SF(e, 1);
}
class Nrt extends $K {
  setupDefaultRules() {
    super.setupDefaultRules();
    const t = this._root.interfaceColors, n = this.rule.bind(this);
    n("WordCloud").setAll({
      width: Eo,
      height: Eo,
      minFontSize: ab(2),
      maxFontSize: ab(15),
      excludeWords: [],
      angles: [0, -90],
      minWordLength: 1,
      step: 15,
      randomness: 0,
      autoFit: !0,
      animationEasing: oT(RE)
    });
    {
      const r = n("Label", ["wordcloud"]);
      r.setAll({
        text: "{category}",
        centerX: Pa,
        centerY: Pa,
        position: "absolute",
        lineHeight: Eo,
        populateText: !0
      }), r.setup = (i) => {
        i.set("background", bS.new(this._root, {
          fill: t.get("background"),
          fillOpacity: 0
        }));
      };
    }
  }
}
let oL = class extends _k {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_currentIndex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_timeoutDP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_ghostContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(es.new(this._root, { layer: 99, opacity: 0.01 }))
    }), Object.defineProperty(this, "_pointSets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_sets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "_process", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_buffer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_boundsToAdd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeLabels()
    });
  }
  _afterNew() {
    this._defaultThemes.push(Nrt.new(this._root)), this.fields.push("category", "fill"), this._setDefault("valueField", "value"), this._setDefault("categoryField", "category"), this._setDefault("fillField", "fill"), super._afterNew(), this._root.events.on("frameended", () => {
      this.set("progress", this._currentIndex / this.dataItems.length);
    });
  }
  /**
   * @ignore
   */
  makeLabel(t) {
    const n = this.children.push(this.labels.make());
    n._setDataItem(t);
    const r = t.get("fill");
    r != null && n.set("fill", r), n.set("x", -999999), t.set("label", n), this.labels.push(n);
    const i = this._ghostContainer.children.push(this.labels.make());
    return i._setDataItem(t), i.setAll({ fill: Mr.fromHex(0), fontWeight: "900" }), t.set("ghostLabel", i), this.labels.push(i), n;
  }
  _makeLabels() {
    return new Ttt(nC.new({}), () => wS._new(this._root, {
      themeTags: twe(this.labels.template.get("themeTags", []), ["wordcloud", "series"])
    }, [this.labels.template]));
  }
  processDataItem(t) {
    if (super.processDataItem(t), t.get("fill") == null) {
      let n = this.get("colors");
      n && t.setRaw("fill", n.next());
    }
    this.makeLabel(t);
  }
  _prepareChildren() {
    super._prepareChildren(), this.isDirty("text") && (this.data.setAll(this._getWords(this.get("text"))), this._dirty.text = !1);
  }
  _updateChildren() {
    super._updateChildren();
    const t = this._root._renderer.resolution, n = Math.round(this._root.width() * t);
    let r = this.get("step", 1) * 2;
    if (this._valuesDirty || this._sizeDirty || this.isPrivateDirty("adjustedFontSize")) {
      const o = this.getPrivate("adjustedFontSize", 1), a = this.innerWidth(), s = this.innerHeight(), u = Math.min(a, s), l = Math.max(a, s);
      this._buffer = Array(Math.ceil(this._root.width() * this._root.height() * t * t)).fill(0), u < 800 && (r = r / 2), this._ghostContainer._display.clear(), this._pointSets = [];
      for (let A = 0; A < this._sets; A++) {
        const O = r * (this._sets - A), R = this._spiralPoints(a / 2, s / 2, a, s, 0, O * s / l, O * a / l, 0, 0);
        for (let j = R.length - 1; j >= 0; j--) {
          let $ = R[j];
          if ($.x < 0 || $.x > a || $.y < 0 || $.y > s) {
            R.splice(j, 1);
            continue;
          }
        }
        this._pointSets.push(R);
      }
      let f = 0, h = 0, p = 0, g = 1 / 0, y = 0;
      ut(this._dataItems, (A) => {
        const O = A.get("valueWorking", 0);
        f += O, h += Math.abs(O);
      }), this._dataItems.sort((A, O) => {
        let R = A.get("value"), j = O.get("value");
        return R > j ? -1 : R < j ? 1 : 0;
      }), ut(this._dataItems, (A) => {
        const O = A.get("valueWorking", 0);
        O >= h && (f = A.get("value", 0)), O > p && (p = O), O < g && (g = O), y++;
      }), this.setPrivateRaw("valueLow", g), this.setPrivateRaw("valueHigh", p), this.setPrivateRaw("valueSum", f), this.setPrivateRaw("valueAverage", f / y), this.setPrivateRaw("valueAbsoluteSum", h);
      const b = Math.min(a, s), _ = vy(this.get("minFontSize", 10), b) * o, S = vy(this.get("maxFontSize", 100), b) * o, C = this.get("angles", [0]);
      ut(this._dataItems, (A) => {
        const O = A.get("valueWorking", 0), R = A.get("ghostLabel");
        let j = _ + (S - _) * (O - g) / (p - g);
        hF(j) && (j = S);
        const $ = this._sets - 1 - Math.floor((j - _) / (S - _) * (this._sets - 1));
        A.setRaw("set", $), A.setRaw("fontSize", j);
        let z = C[Math.floor(Math.random() * C.length)];
        A.setRaw("angle", z), R.setAll({ fontSize: j, rotation: z, x: -1e4 });
      }), this._process = !1, this._currentIndex = 0, this._root.events.once("frameended", () => {
        this.setTimeout(() => {
          this._process = !0, this._markDirtyKey("progress");
        }, 50);
      });
    }
    const i = this._boundsToAdd;
    if (i) {
      const o = this._ghostContainer._display.getLayer().context, a = Math.round(i.top), s = Math.round(i.left), u = Math.round(i.right - i.left), l = Math.round(i.bottom - i.top), f = o.getImageData(s, a, u, l).data, h = this._buffer;
      let p = 3;
      for (let g = a; g < a + l; g++)
        for (let y = s; y < s + u; y++) {
          let b = (g + 1) * n - (n - y);
          f[p] != 0 && (h[b] = 1), p += 4;
        }
      this._boundsToAdd = void 0;
    }
    this._process && this.isDirty("progress") && this._processItem();
  }
  _processItem() {
    if (this._boundsToAdd = void 0, this._currentIndex < this.dataItems.length) {
      const t = this.dataItems[this._currentIndex], n = t.get("label"), r = t.get("ghostLabel"), i = this._root._renderer.resolution;
      let o = r.width(), a = r.height();
      const s = r._display.getLayer().context, u = t.get("set"), l = this._pointSets[u], f = this.innerWidth(), h = this.innerHeight(), p = Math.round(this._root.width() * i), g = this.x(), y = this.y(), b = this.get("angles", [0]);
      f > h && o >= f / 2 && ut(b, (C) => {
        C == 0 && t.get("angle") != 0 && (t.setRaw("angle", 0), r.set("rotation", 0), [o, a] = [a, o]);
      }), h > f && o >= f / 2 && ut(b, (C) => {
        Math.abs(C) == 90 && t.get("angle") == 0 && (t.setRaw("angle", C), r.set("rotation", C), [o, a] = [a, o]);
      });
      const _ = Math.ceil(o * i), S = Math.ceil(a * i);
      if (s && o > 0 && a > 0) {
        let C = Math.round(Math.random() * l.length * this.get("randomness", 0)), A = !0;
        for (; A; ) {
          let O = l[C];
          if (O) {
            if (A = !1, this._currentIndex > 0) {
              let R = Math.round((O.x + g) * i - _ / 2), j = Math.round((O.y + y) * i - S / 2);
              A = this._hasColor(R, j, _, S, p);
            }
            if (O.x - o / 2 < 0 || O.x + o / 2 > f || O.y - a / 2 < 0 || O.y + a / 2 > h)
              C++, A = !0;
            else if (A)
              C += 2;
            else {
              const R = t.get("angle", 0), j = t.get("fontSize", 0);
              n.get("x") != -999999 ? (n.animate({ key: "x", to: O.x, duration: this.get("animationDuration", 0), easing: this.get("animationEasing") }), n.animate({ key: "y", to: O.y, duration: this.get("animationDuration", 0), easing: this.get("animationEasing") }), n.animate({ key: "rotation", to: R, duration: this.get("animationDuration", 0), easing: this.get("animationEasing") }), n.animate({ key: "fontSize", to: j, duration: this.get("animationDuration", 0), easing: this.get("animationEasing") })) : (n.setAll({ x: O.x, y: O.y, rotation: R, fontSize: j }), n.appear()), r.setAll({ x: O.x, y: O.y });
              for (let $ = l.length - 1; $ >= 0; $--) {
                let z = l[$];
                z.x >= O.x - o / 2 && z.x <= O.x + o / 2 && z.y >= O.y - a / 2 && z.y <= O.y + a / 2 && l.splice($, 1);
              }
              this._boundsToAdd = { left: (O.x + g - o / 2) * i, right: (O.x + g + o / 2) * i, top: (O.y + y - a / 2) * i, bottom: (O.y + y + a / 2) * i };
            }
          } else {
            if (this.get("autoFit")) {
              this.setTimeout(() => {
                this.setPrivate("adjustedFontSize", this.getPrivate("adjustedFontSize", 1) * 0.9);
              }, 50);
              return;
            }
            n.set("x", -999999), A = !1;
          }
        }
      }
      this._currentIndex++;
    }
  }
  /**
  * @ignore
  */
  disposeDataItem(t) {
    super.disposeDataItem(t);
    const n = t.get("label");
    n && (this.labels.removeValue(n), n.dispose());
    const r = t.get("ghostLabel");
    r && (this.labels.removeValue(r), r.dispose());
  }
  /**
  * Extracts words and number of their appearances from a text.
  *
  * @ignore
  * @param  input  Source text
  */
  _getWords(t) {
    let n = [];
    if (t) {
      const r = "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶ-ͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԣԱ-Ֆՙա-ևא-תװ-ײء-يٮ-ٯٱ-ۓەۥ-ۦۮ-ۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴ-ߵߺऄ-हऽॐक़-ॡॱ-ॲॻ-ॿঅ-ঌএ-ঐও-নপ-রলশ-হঽৎড়-ঢ়য়-ৡৰ-ৱਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલ-ળવ-હઽૐૠ-ૡଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଵ-ହଽଡ଼-ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘ-ౙౠ-ౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠ-ೡഅ-ഌഎ-ഐഒ-നപ-ഹഽൠ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะา-ำเ-ๆກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-ະາ-ຳຽເ-ໄໆໜ-ໝༀཀ-ཇཉ-ཬྈ-ྋက-ဪဿၐ-ၕၚ-ၝၡၥ-ၦၮ-ၰၵ-ႁႎႠ-Ⴥა-ჺჼᄀ-ᅙᅟ-ᆢᆨ-ᇹሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙶᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦩᧁ-ᧇᨀ-ᨖᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮ-ᮯᰀ-ᰣᱍ-ᱏᱚ-ᱽᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₔℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-Ɐⱱ-ⱽⲀ-ⳤⴀ-ⴥⴰ-ⵥⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆷㇰ-ㇿ㐀䶵一鿃ꀀ-ꒌꔀ-ꘌꘐ-ꘟꘪ-ꘫꙀ-ꙟꙢ-ꙮꙿ-ꚗꜗ-ꜟꜢ-ꞈꞋ-ꞌꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꤊ-ꤥꤰ-ꥆꨀ-ꨨꩀ-ꩂꩄ-ꩋ가-힣豈-鶴侮-頻並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ0-9@+", i = new RegExp("([" + r + "]+[-" + r + "]*[" + r + "]+)|([" + r + "]+)", "ig");
      let o = t.match(i);
      if (!o)
        return [];
      let a;
      for (; a = o.pop(), !!a; ) {
        let h;
        for (let p = 0; p < n.length; p++)
          if (n[p].category.toLowerCase() == a.toLowerCase()) {
            h = n[p];
            break;
          }
        h ? (h.value++, this.isCapitalized(a) || (h.category = a)) : n.push({
          category: a,
          value: 1
        });
      }
      let s = this.get("excludeWords");
      const u = this.get("minValue", 1), l = this.get("minWordLength", 1);
      if (u > 1 || l > 1 || s && s.length > 0)
        for (let h = n.length - 1; h >= 0; h--) {
          let p = n[h], g = p.category;
          p.value < u && n.splice(h, 1), g.length < l && n.splice(h, 1), s && s.indexOf(g) !== -1 && n.splice(h, 1);
        }
      n.sort(function(h, p) {
        return h.value == p.value ? 0 : h.value > p.value ? -1 : 1;
      });
      const f = this.get("maxCount", 1 / 0);
      n.length > f && (n = n.slice(0, f));
    }
    return n;
  }
  /**
  * Checks if word is capitalized (starts with an uppercase) or not.
  *
  * @ignore
  * @param   word  Word
  * @return        Capitalized?
  */
  isCapitalized(t) {
    let n = t.toLowerCase();
    return t[0] != n[0] && t.substr(1) == n.substr(1) && t != n;
  }
  _spiralPoints(t, n, r, i, o, a, s, u, l) {
    let f = o + 0.01, h = u * kK, p = [];
    for (; f < r + s; ) {
      let g = a;
      if (g / 2 > f && (g = 2 * f), h += 2 * Math.asin(g / 2 / f), h * KE > l + (r - o) / s * 360)
        break;
      let y = h * KE, b = { x: t + f * Math.cos(h), y: n + f * i / r * Math.sin(h) };
      p.push(b), f = o + y / 360 * s;
    }
    return p.shift(), p;
  }
  _hasColor(t, n, r, i, o) {
    const a = this._buffer;
    if (a)
      for (let s = n; s < n + i; s += 4)
        for (let u = t; u < t + r; u += 4) {
          let l = (s + 1) * o - (o - u);
          if (a[l] != 0)
            return !0;
        }
    return !1;
  }
};
Object.defineProperty(oL, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "WordCloud"
});
Object.defineProperty(oL, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _k.classNames.concat([oL.className])
});
class Drt extends $K {
  setupDefaultRules() {
    super.setupDefaultRules(), this.rule("Component").setAll({
      interpolationDuration: 600
    }), this.rule("Hierarchy").set("animationDuration", 600), this.rule("Scrollbar").set("animationDuration", 600), this.rule("Tooltip").set("animationDuration", 300), this.rule("MapChart").set("animationDuration", 1e3), this.rule("MapChart").set("wheelDuration", 300), this.rule("Entity").setAll({
      stateAnimationDuration: 600
    }), this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 }), this.rule("Tooltip", ["axis"]).setAll({
      animationDuration: 200
    }), this.rule("WordCloud").set("animationDuration", 500), this.rule("Polygon").set("animationDuration", 600), this.rule("ArcDiagram").set("animationDuration", 600);
  }
}
const Art = "_chartDiv_jlpec_1", Ort = "_bannerLabel_jlpec_5", Rrt = {
  chartDiv: Art,
  bannerLabel: Ort
};
ant("AM5C196223670");
const krt = ({ id: e, style: t = {}, content: n }) => {
  const r = ae.useContext(tv), i = ar.get(n, "category.namespace", ""), o = ar.get(r, `${i}.records`, []);
  return ae.useLayoutEffect(() => {
    var l, f;
    let a = PK.new(`wc-chartdiv-${e}`);
    a.setThemes([Drt.new(a)]);
    var s = a.container.children.push(
      es.new(a, {
        width: ab(100),
        height: ab(100),
        layout: a.verticalLayout
      })
    );
    let u = s.children.push(
      oL.new(a, {
        categoryField: "SEARCH_TERM",
        valueField: "NUMBER_OF_SEARCHES",
        randomness: 0,
        angles: [0],
        minFontSize: 10,
        maxFontSize: 60
      })
    );
    return o && o.length ? u.data.setAll(o) : u.data.setAll([
      { SEARCH_TERM: e0e, NUMBER_OF_SEARCHES: 1 }
    ]), u.labels.template.setAll({
      paddingTop: 5,
      paddingBottom: 5,
      paddingLeft: 5,
      paddingRight: 5,
      fontFamily: "Nunito",
      //am5.color() does not support string type colors (ex. 'white'), must be HEX code or rgb identifier
      fill: (l = t == null ? void 0 : t.textColor) != null && l.includes("#") || (f = t == null ? void 0 : t.textColor) != null && f.includes("rgb") ? OE(`${t == null ? void 0 : t.textColor}`) : OE("#00000"),
      tooltipText: "{category}: [bold]{NUMBER_OF_SEARCHES}[/]"
    }), s.appear(1e3), () => {
      a.dispose();
    };
  }, [e, t, n, o]), /* @__PURE__ */ pe.jsxs("div", { id: "wordCloudWrapper", children: [
    /* @__PURE__ */ pe.jsx(JS, { contentTitle: n.title, style: t }),
    /* @__PURE__ */ pe.jsx(
      "div",
      {
        id: `wc-chartdiv-${e}`,
        className: Rrt.chartDiv,
        style: {
          backgroundColor: `${t == null ? void 0 : t.bgColor}`
        }
      }
    )
  ] });
};
function Go(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function _S(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Qx(e) {
  let t, n, r;
  e.length !== 2 ? (t = Go, n = (s, u) => Go(e(s), u), r = (s, u) => e(s) - u) : (t = e === Go || e === _S ? e : $rt, n = e, r = e);
  function i(s, u, l = 0, f = s.length) {
    if (l < f) {
      if (t(u, u) !== 0)
        return f;
      do {
        const h = l + f >>> 1;
        n(s[h], u) < 0 ? l = h + 1 : f = h;
      } while (l < f);
    }
    return l;
  }
  function o(s, u, l = 0, f = s.length) {
    if (l < f) {
      if (t(u, u) !== 0)
        return f;
      do {
        const h = l + f >>> 1;
        n(s[h], u) <= 0 ? l = h + 1 : f = h;
      } while (l < f);
    }
    return l;
  }
  function a(s, u, l = 0, f = s.length) {
    const h = i(s, u, l, f - 1);
    return h > l && r(s[h - 1], u) > -r(s[h], u) ? h - 1 : h;
  }
  return { left: i, center: a, right: o };
}
function $rt() {
  return 0;
}
function r_e(e) {
  return e === null ? NaN : +e;
}
function* Prt(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let r of e)
      (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r);
  }
}
const i_e = Qx(Go), aL = i_e.right, Irt = i_e.left;
Qx(r_e).center;
const uN = aL, o_e = a_e(s_e), jrt = a_e(Lrt);
function a_e(e) {
  return function(t, n, r = n) {
    if (!((n = +n) >= 0))
      throw new RangeError("invalid rx");
    if (!((r = +r) >= 0))
      throw new RangeError("invalid ry");
    let { data: i, width: o, height: a } = t;
    if (!((o = Math.floor(o)) >= 0))
      throw new RangeError("invalid width");
    if (!((a = Math.floor(a !== void 0 ? a : i.length / o)) >= 0))
      throw new RangeError("invalid height");
    if (!o || !a || !n && !r)
      return t;
    const s = n && e(n), u = r && e(r), l = i.slice();
    return s && u ? (jM(s, l, i, o, a), jM(s, i, l, o, a), jM(s, l, i, o, a), LM(u, i, l, o, a), LM(u, l, i, o, a), LM(u, i, l, o, a)) : s ? (jM(s, i, l, o, a), jM(s, l, i, o, a), jM(s, i, l, o, a)) : u && (LM(u, i, l, o, a), LM(u, l, i, o, a), LM(u, i, l, o, a)), t;
  };
}
function jM(e, t, n, r, i) {
  for (let o = 0, a = r * i; o < a; )
    e(t, n, o, o += r, 1);
}
function LM(e, t, n, r, i) {
  for (let o = 0, a = r * i; o < r; ++o)
    e(t, n, o, o + a, r);
}
function Lrt(e) {
  const t = s_e(e);
  return (n, r, i, o, a) => {
    i <<= 2, o <<= 2, a <<= 2, t(n, r, i + 0, o + 0, a), t(n, r, i + 1, o + 1, a), t(n, r, i + 2, o + 2, a), t(n, r, i + 3, o + 3, a);
  };
}
function s_e(e) {
  const t = Math.floor(e);
  if (t === e)
    return zrt(e);
  const n = e - t, r = 2 * e + 1;
  return (i, o, a, s, u) => {
    if (!((s -= u) >= a))
      return;
    let l = t * o[a];
    const f = u * t, h = f + u;
    for (let p = a, g = a + f; p < g; p += u)
      l += o[Math.min(s, p)];
    for (let p = a, g = s; p <= g; p += u)
      l += o[Math.min(s, p + f)], i[p] = (l + n * (o[Math.max(a, p - h)] + o[Math.min(s, p + h)])) / r, l -= o[Math.max(a, p - f)];
  };
}
function zrt(e) {
  const t = 2 * e + 1;
  return (n, r, i, o, a) => {
    if (!((o -= a) >= i))
      return;
    let s = e * r[i];
    const u = a * e;
    for (let l = i, f = i + u; l < f; l += a)
      s += r[Math.min(o, l)];
    for (let l = i, f = o; l <= f; l += a)
      s += r[Math.min(o, l + u)], n[l] = s / t, s -= r[Math.max(i, l - u)];
  };
}
function MF(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && ++n;
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (i = +i) >= i && ++n;
  }
  return n;
}
function Frt(e) {
  return e.length | 0;
}
function Brt(e) {
  return !(e > 0);
}
function Urt(e) {
  return typeof e != "object" || "length" in e ? e : Array.from(e);
}
function Yrt(e) {
  return (t) => e(...t);
}
function Hrt(...e) {
  const t = typeof e[e.length - 1] == "function" && Yrt(e.pop());
  e = e.map(Urt);
  const n = e.map(Frt), r = e.length - 1, i = new Array(r + 1).fill(0), o = [];
  if (r < 0 || n.some(Brt))
    return o;
  for (; ; ) {
    o.push(i.map((s, u) => e[u][s]));
    let a = r;
    for (; ++i[a] === n[a]; ) {
      if (a === 0)
        return t ? o.map(t) : o;
      i[a--] = 0;
    }
  }
}
function Vrt(e, t) {
  var n = 0, r = 0;
  return Float64Array.from(e, t === void 0 ? (i) => n += +i || 0 : (i) => n += +t(i, r++, e) || 0);
}
function BK(e, t) {
  let n = 0, r, i = 0, o = 0;
  if (t === void 0)
    for (let a of e)
      a != null && (a = +a) >= a && (r = a - i, i += r / ++n, o += r * (a - i));
  else {
    let a = -1;
    for (let s of e)
      (s = t(s, ++a, e)) != null && (s = +s) >= s && (r = s - i, i += r / ++n, o += r * (s - i));
  }
  if (n > 1)
    return o / (n - 1);
}
function lN(e, t) {
  const n = BK(e, t);
  return n && Math.sqrt(n);
}
function Zu(e, t) {
  let n, r;
  if (t === void 0)
    for (const i of e)
      i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (n === void 0 ? o >= o && (n = r = o) : (n > o && (n = o), r < o && (r = o)));
  }
  return [n, r];
}
class Qo {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let r = 0;
    for (let i = 0; i < this._n && i < 32; i++) {
      const o = n[i], a = t + o, s = Math.abs(t) < Math.abs(o) ? t - (a - o) : o - (a - t);
      s && (n[r++] = s), t = a;
    }
    return n[r] = t, this._n = r + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, r, i, o, a = 0;
    if (n > 0) {
      for (a = t[--n]; n > 0 && (r = a, i = t[--n], a = r + i, o = i - (a - r), !o); )
        ;
      n > 0 && (o < 0 && t[n - 1] < 0 || o > 0 && t[n - 1] > 0) && (i = o * 2, r = a + i, i == r - a && (a = r));
    }
    return a;
  }
}
class ES extends Map {
  constructor(t, n = c_e) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(Tq(this, t));
  }
  has(t) {
    return super.has(Tq(this, t));
  }
  set(t, n) {
    return super.set(u_e(this, t), n);
  }
  delete(t) {
    return super.delete(l_e(this, t));
  }
}
class Xx extends Set {
  constructor(t, n = c_e) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const r of t)
        this.add(r);
  }
  has(t) {
    return super.has(Tq(this, t));
  }
  add(t) {
    return super.add(u_e(this, t));
  }
  delete(t) {
    return super.delete(l_e(this, t));
  }
}
function Tq({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function u_e({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function l_e({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function c_e(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function Cq(e) {
  return e;
}
function xb(e, ...t) {
  return UK(e, Cq, Cq, t);
}
function NT(e, t, ...n) {
  return UK(e, Cq, t, n);
}
function Wrt(e, t, ...n) {
  return UK(e, Array.from, t, n);
}
function UK(e, t, n, r) {
  return function i(o, a) {
    if (a >= r.length)
      return n(o);
    const s = new ES(), u = r[a++];
    let l = -1;
    for (const f of o) {
      const h = u(f, ++l, o), p = s.get(h);
      p ? p.push(f) : s.set(h, [f]);
    }
    for (const [f, h] of s)
      s.set(f, i(h, a));
    return t(s);
  }(e, 0);
}
function f_e(e, t) {
  return Array.from(t, (n) => e[n]);
}
function Ek(e, ...t) {
  if (typeof e[Symbol.iterator] != "function")
    throw new TypeError("values is not iterable");
  e = Array.from(e);
  let [n] = t;
  if (n && n.length !== 2 || t.length > 1) {
    const r = Uint32Array.from(e, (i, o) => o);
    return t.length > 1 ? (t = t.map((i) => e.map(i)), r.sort((i, o) => {
      for (const a of t) {
        const s = Sk(a[i], a[o]);
        if (s)
          return s;
      }
    })) : (n = e.map(n), r.sort((i, o) => Sk(n[i], n[o]))), f_e(e, r);
  }
  return e.sort(YK(n));
}
function YK(e = Go) {
  if (e === Go)
    return Sk;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const r = e(t, n);
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function Sk(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
function HK(e, t, n) {
  return (t.length !== 2 ? Ek(NT(e, t, n), ([r, i], [o, a]) => Go(i, a) || Go(r, o)) : Ek(xb(e, n), ([r, i], [o, a]) => t(i, a) || Go(r, o))).map(([r]) => r);
}
const qrt = Math.sqrt(50), Grt = Math.sqrt(10), Qrt = Math.sqrt(2);
function sL(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), o = r / Math.pow(10, i), a = o >= qrt ? 10 : o >= Grt ? 5 : o >= Qrt ? 2 : 1;
  let s, u, l;
  return i < 0 ? (l = Math.pow(10, -i) / a, s = Math.round(e * l), u = Math.round(t * l), s / l < e && ++s, u / l > t && --u, l = -l) : (l = Math.pow(10, i) * a, s = Math.round(e / l), u = Math.round(t / l), s * l < e && ++s, u * l > t && --u), u < s && 0.5 <= n && n < 2 ? sL(e, t, n * 2) : [s, u, l];
}
function Kx(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const r = t < e, [i, o, a] = r ? sL(t, e, n) : sL(e, t, n);
  if (!(o >= i))
    return [];
  const s = o - i + 1, u = new Array(s);
  if (r)
    if (a < 0)
      for (let l = 0; l < s; ++l)
        u[l] = (o - l) / -a;
    else
      for (let l = 0; l < s; ++l)
        u[l] = (o - l) * a;
  else if (a < 0)
    for (let l = 0; l < s; ++l)
      u[l] = (i + l) / -a;
  else
    for (let l = 0; l < s; ++l)
      u[l] = (i + l) * a;
  return u;
}
function Mk(e, t, n) {
  return t = +t, e = +e, n = +n, sL(e, t, n)[2];
}
function Zx(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? Mk(t, e, n) : Mk(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function d_e(e, t, n) {
  let r;
  for (; ; ) {
    const i = Mk(e, t, n);
    if (i === r || i === 0 || !isFinite(i))
      return [e, t];
    i > 0 ? (e = Math.floor(e / i) * i, t = Math.ceil(t / i) * i) : i < 0 && (e = Math.ceil(e * i) / i, t = Math.floor(t * i) / i), r = i;
  }
}
function VK(e) {
  return Math.max(1, Math.ceil(Math.log(MF(e)) / Math.LN2) + 1);
}
function Ha(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Xrt(e, t) {
  let n, r = -1, i = -1;
  if (t === void 0)
    for (const o of e)
      ++i, o != null && (n < o || n === void 0 && o >= o) && (n = o, r = i);
  else
    for (let o of e)
      (o = t(o, ++i, e)) != null && (n < o || n === void 0 && o >= o) && (n = o, r = i);
  return r;
}
function Oc(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Krt(e, t) {
  let n, r = -1, i = -1;
  if (t === void 0)
    for (const o of e)
      ++i, o != null && (n > o || n === void 0 && o >= o) && (n = o, r = i);
  else
    for (let o of e)
      (o = t(o, ++i, e)) != null && (n > o || n === void 0 && o >= o) && (n = o, r = i);
  return r;
}
function h_e(e, t, n = 0, r = 1 / 0, i) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r))
    return e;
  for (i = i === void 0 ? Sk : YK(i); r > n; ) {
    if (r - n > 600) {
      const u = r - n + 1, l = t - n + 1, f = Math.log(u), h = 0.5 * Math.exp(2 * f / 3), p = 0.5 * Math.sqrt(f * h * (u - h) / u) * (l - u / 2 < 0 ? -1 : 1), g = Math.max(n, Math.floor(t - l * h / u + p)), y = Math.min(r, Math.floor(t + (u - l) * h / u + p));
      h_e(e, t, g, y, i);
    }
    const o = e[t];
    let a = n, s = r;
    for (YA(e, n, t), i(e[r], o) > 0 && YA(e, n, r); a < s; ) {
      for (YA(e, a, s), ++a, --s; i(e[a], o) < 0; )
        ++a;
      for (; i(e[s], o) > 0; )
        --s;
    }
    i(e[n], o) === 0 ? YA(e, n, s) : (++s, YA(e, s, r)), s <= t && (n = s + 1), t <= s && (r = s - 1);
  }
  return e;
}
function YA(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function WK(e, t = Go) {
  let n, r = !1;
  if (t.length === 1) {
    let i;
    for (const o of e) {
      const a = t(o);
      (r ? Go(a, i) > 0 : Go(a, a) === 0) && (n = o, i = a, r = !0);
    }
  } else
    for (const i of e)
      (r ? t(i, n) > 0 : t(i, i) === 0) && (n = i, r = !0);
  return n;
}
function Wy(e, t, n) {
  if (e = Float64Array.from(Prt(e, n)), !(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2)
      return Oc(e);
    if (t >= 1)
      return Ha(e);
    var r, i = (r - 1) * t, o = Math.floor(i), a = Ha(h_e(e, o).subarray(0, o + 1)), s = Oc(e.subarray(o + 1));
    return a + (s - a) * (i - o);
  }
}
function p_e(e, t, n = r_e) {
  if (!(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2)
      return +n(e[0], 0, e);
    if (t >= 1)
      return +n(e[r - 1], r - 1, e);
    var r, i = (r - 1) * t, o = Math.floor(i), a = +n(e[o], o, e), s = +n(e[o + 1], o + 1, e);
    return a + (s - a) * (i - o);
  }
}
function Zrt(e, t, n) {
  const r = MF(e), i = Wy(e, 0.75) - Wy(e, 0.25);
  return r && i ? Math.ceil((n - t) / (2 * i * Math.pow(r, -1 / 3))) : 1;
}
function g_e(e, t, n) {
  const r = MF(e), i = lN(e);
  return r && i ? Math.ceil((n - t) * Math.cbrt(r) / (3.49 * i)) : 1;
}
function T$(e, t) {
  let n = 0, r = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++n, r += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++n, r += o);
  }
  if (n)
    return r / n;
}
function Jx(e, t) {
  return Wy(e, 0.5, t);
}
function* Jrt(e) {
  for (const t of e)
    yield* t;
}
function TF(e) {
  return Array.from(Jrt(e));
}
function m_e(e, t) {
  const n = new ES();
  if (t === void 0)
    for (let o of e)
      o != null && o >= o && n.set(o, (n.get(o) || 0) + 1);
  else {
    let o = -1;
    for (let a of e)
      (a = t(a, ++o, e)) != null && a >= a && n.set(a, (n.get(a) || 0) + 1);
  }
  let r, i = 0;
  for (const [o, a] of n)
    a > i && (i = a, r = o);
  return r;
}
function eit(e, t = tit) {
  const n = [];
  let r, i = !1;
  for (const o of e)
    i && n.push(t(r, o)), r = o, i = !0;
  return n;
}
function tit(e, t) {
  return [e, t];
}
function qo(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n;
  return o;
}
function y_e(e, t = Go) {
  if (typeof e[Symbol.iterator] != "function")
    throw new TypeError("values is not iterable");
  let n = Array.from(e);
  const r = new Float64Array(n.length);
  t.length !== 2 && (n = n.map(t), t = Go);
  const i = (s, u) => t(n[s], n[u]);
  let o, a;
  return e = Uint32Array.from(n, (s, u) => u), e.sort(t === Go ? (s, u) => Sk(n[s], n[u]) : YK(i)), e.forEach((s, u) => {
    const l = i(s, o === void 0 ? s : o);
    l >= 0 ? ((o === void 0 || l > 0) && (o = s, a = u), r[s] = a) : r[s] = NaN;
  }), r;
}
function nit(e, t = Go) {
  let n, r = !1;
  if (t.length === 1) {
    let i;
    for (const o of e) {
      const a = t(o);
      (r ? Go(a, i) < 0 : Go(a, a) === 0) && (n = o, i = a, r = !0);
    }
  } else
    for (const i of e)
      (r ? t(i, n) < 0 : t(i, i) === 0) && (n = i, r = !0);
  return n;
}
function fp(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function uL(e) {
  if (typeof e[Symbol.iterator] != "function")
    throw new TypeError("values is not iterable");
  return Array.from(e).reverse();
}
function rit(e, ...t) {
  e = new Xx(e), t = t.map(iit);
  e:
    for (const n of e)
      for (const r of t)
        if (!r.has(n)) {
          e.delete(n);
          continue e;
        }
  return e;
}
function iit(e) {
  return e instanceof Xx ? e : new Xx(e);
}
function oit(...e) {
  const t = new Xx();
  for (const n of e)
    for (const r of n)
      t.add(r);
  return t;
}
function ait(e) {
  return e;
}
var eH = 1, tH = 2, Nq = 3, BI = 4, Yfe = 1e-6;
function sit(e) {
  return "translate(" + e + ",0)";
}
function uit(e) {
  return "translate(0," + e + ")";
}
function lit(e) {
  return (t) => +e(t);
}
function cit(e, t) {
  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
}
function fit() {
  return !this.__axis;
}
function dit(e, t) {
  var n = [], r = null, i = null, o = 6, a = 6, s = 3, u = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, l = e === eH || e === BI ? -1 : 1, f = e === BI || e === tH ? "x" : "y", h = e === eH || e === Nq ? sit : uit;
  function p(g) {
    var y = r ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()), b = i ?? (t.tickFormat ? t.tickFormat.apply(t, n) : ait), _ = Math.max(o, 0) + s, S = t.range(), C = +S[0] + u, A = +S[S.length - 1] + u, O = (t.bandwidth ? cit : lit)(t.copy(), u), R = g.selection ? g.selection() : g, j = R.selectAll(".domain").data([null]), $ = R.selectAll(".tick").data(y, t).order(), z = $.exit(), W = $.enter().append("g").attr("class", "tick"), Y = $.select("line"), V = $.select("text");
    j = j.merge(j.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), $ = $.merge(W), Y = Y.merge(W.append("line").attr("stroke", "currentColor").attr(f + "2", l * o)), V = V.merge(W.append("text").attr("fill", "currentColor").attr(f, l * _).attr("dy", e === eH ? "0em" : e === Nq ? "0.71em" : "0.32em")), g !== R && (j = j.transition(g), $ = $.transition(g), Y = Y.transition(g), V = V.transition(g), z = z.transition(g).attr("opacity", Yfe).attr("transform", function(ee) {
      return isFinite(ee = O(ee)) ? h(ee + u) : this.getAttribute("transform");
    }), W.attr("opacity", Yfe).attr("transform", function(ee) {
      var K = this.parentNode.__axis;
      return h((K && isFinite(K = K(ee)) ? K : O(ee)) + u);
    })), z.remove(), j.attr("d", e === BI || e === tH ? a ? "M" + l * a + "," + C + "H" + u + "V" + A + "H" + l * a : "M" + u + "," + C + "V" + A : a ? "M" + C + "," + l * a + "V" + u + "H" + A + "V" + l * a : "M" + C + "," + u + "H" + A), $.attr("opacity", 1).attr("transform", function(ee) {
      return h(O(ee) + u);
    }), Y.attr(f + "2", l * o), V.attr(f, l * _).text(b), R.filter(fit).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === tH ? "start" : e === BI ? "end" : "middle"), R.each(function() {
      this.__axis = O;
    });
  }
  return p.scale = function(g) {
    return arguments.length ? (t = g, p) : t;
  }, p.ticks = function() {
    return n = Array.from(arguments), p;
  }, p.tickArguments = function(g) {
    return arguments.length ? (n = g == null ? [] : Array.from(g), p) : n.slice();
  }, p.tickValues = function(g) {
    return arguments.length ? (r = g == null ? null : Array.from(g), p) : r && r.slice();
  }, p.tickFormat = function(g) {
    return arguments.length ? (i = g, p) : i;
  }, p.tickSize = function(g) {
    return arguments.length ? (o = a = +g, p) : o;
  }, p.tickSizeInner = function(g) {
    return arguments.length ? (o = +g, p) : o;
  }, p.tickSizeOuter = function(g) {
    return arguments.length ? (a = +g, p) : a;
  }, p.tickPadding = function(g) {
    return arguments.length ? (s = +g, p) : s;
  }, p.offset = function(g) {
    return arguments.length ? (u = +g, p) : u;
  }, p;
}
function hit(e) {
  return dit(Nq, e);
}
var pit = { value: () => {
} };
function qK() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new rj(n);
}
function rj(e) {
  this._ = e;
}
function git(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
rj.prototype = qK.prototype = {
  constructor: rj,
  on: function(e, t) {
    var n = this._, r = git(e + "", n), i, o = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++o < a; )
        if ((i = (e = r[o]).type) && (i = mit(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++o < a; )
      if (i = (e = r[o]).type)
        n[i] = Hfe(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Hfe(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new rj(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, o; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (o = this._[e], r = 0, i = o.length; r < i; ++r)
      o[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, o = r.length; i < o; ++i)
      r[i].value.apply(t, n);
  }
};
function mit(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Hfe(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = pit, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Dq = "http://www.w3.org/1999/xhtml";
const SS = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Dq,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function CF(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), SS.hasOwnProperty(t) ? { space: SS[t], local: e } : e;
}
function yit(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Dq && t.documentElement.namespaceURI === Dq ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function vit(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function NF(e) {
  var t = CF(e);
  return (t.local ? vit : yit)(t);
}
function bit() {
}
function GK(e) {
  return e == null ? bit : function() {
    return this.querySelector(e);
  };
}
function xit(e) {
  typeof e != "function" && (e = GK(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], a = o.length, s = r[i] = new Array(a), u, l, f = 0; f < a; ++f)
      (u = o[f]) && (l = e.call(u, u.__data__, f, o)) && ("__data__" in u && (l.__data__ = u.__data__), s[f] = l);
  return new zd(r, this._parents);
}
function wit(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function _it() {
  return [];
}
function v_e(e) {
  return e == null ? _it : function() {
    return this.querySelectorAll(e);
  };
}
function Eit(e) {
  return function() {
    return wit(e.apply(this, arguments));
  };
}
function Sit(e) {
  typeof e == "function" ? e = Eit(e) : e = v_e(e);
  for (var t = this._groups, n = t.length, r = [], i = [], o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u, l = 0; l < s; ++l)
      (u = a[l]) && (r.push(e.call(u, u.__data__, l, a)), i.push(u));
  return new zd(r, i);
}
function b_e(e) {
  return function() {
    return this.matches(e);
  };
}
function x_e(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Mit = Array.prototype.find;
function Tit(e) {
  return function() {
    return Mit.call(this.children, e);
  };
}
function Cit() {
  return this.firstElementChild;
}
function Nit(e) {
  return this.select(e == null ? Cit : Tit(typeof e == "function" ? e : x_e(e)));
}
var Dit = Array.prototype.filter;
function Ait() {
  return Array.from(this.children);
}
function Oit(e) {
  return function() {
    return Dit.call(this.children, e);
  };
}
function Rit(e) {
  return this.selectAll(e == null ? Ait : Oit(typeof e == "function" ? e : x_e(e)));
}
function kit(e) {
  typeof e != "function" && (e = b_e(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], a = o.length, s = r[i] = [], u, l = 0; l < a; ++l)
      (u = o[l]) && e.call(u, u.__data__, l, o) && s.push(u);
  return new zd(r, this._parents);
}
function w_e(e) {
  return new Array(e.length);
}
function $it() {
  return new zd(this._enter || this._groups.map(w_e), this._parents);
}
function lL(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
lL.prototype = {
  constructor: lL,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Pit(e) {
  return function() {
    return e;
  };
}
function Iit(e, t, n, r, i, o) {
  for (var a = 0, s, u = t.length, l = o.length; a < l; ++a)
    (s = t[a]) ? (s.__data__ = o[a], r[a] = s) : n[a] = new lL(e, o[a]);
  for (; a < u; ++a)
    (s = t[a]) && (i[a] = s);
}
function jit(e, t, n, r, i, o, a) {
  var s, u, l = /* @__PURE__ */ new Map(), f = t.length, h = o.length, p = new Array(f), g;
  for (s = 0; s < f; ++s)
    (u = t[s]) && (p[s] = g = a.call(u, u.__data__, s, t) + "", l.has(g) ? i[s] = u : l.set(g, u));
  for (s = 0; s < h; ++s)
    g = a.call(e, o[s], s, o) + "", (u = l.get(g)) ? (r[s] = u, u.__data__ = o[s], l.delete(g)) : n[s] = new lL(e, o[s]);
  for (s = 0; s < f; ++s)
    (u = t[s]) && l.get(p[s]) === u && (i[s] = u);
}
function Lit(e) {
  return e.__data__;
}
function zit(e, t) {
  if (!arguments.length)
    return Array.from(this, Lit);
  var n = t ? jit : Iit, r = this._parents, i = this._groups;
  typeof e != "function" && (e = Pit(e));
  for (var o = i.length, a = new Array(o), s = new Array(o), u = new Array(o), l = 0; l < o; ++l) {
    var f = r[l], h = i[l], p = h.length, g = Fit(e.call(f, f && f.__data__, l, r)), y = g.length, b = s[l] = new Array(y), _ = a[l] = new Array(y), S = u[l] = new Array(p);
    n(f, h, b, _, S, g, t);
    for (var C = 0, A = 0, O, R; C < y; ++C)
      if (O = b[C]) {
        for (C >= A && (A = C + 1); !(R = _[A]) && ++A < y; )
          ;
        O._next = R || null;
      }
  }
  return a = new zd(a, r), a._enter = s, a._exit = u, a;
}
function Fit(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Bit() {
  return new zd(this._exit || this._groups.map(w_e), this._parents);
}
function Uit(e, t, n) {
  var r = this.enter(), i = this, o = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? o.remove() : n(o), r && i ? r.merge(i).order() : i;
}
function Yit(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, o = r.length, a = Math.min(i, o), s = new Array(i), u = 0; u < a; ++u)
    for (var l = n[u], f = r[u], h = l.length, p = s[u] = new Array(h), g, y = 0; y < h; ++y)
      (g = l[y] || f[y]) && (p[y] = g);
  for (; u < i; ++u)
    s[u] = n[u];
  return new zd(s, this._parents);
}
function Hit() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, o = r[i], a; --i >= 0; )
      (a = r[i]) && (o && a.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(a, o), o = a);
  return this;
}
function Vit(e) {
  e || (e = Wit);
  function t(h, p) {
    return h && p ? e(h.__data__, p.__data__) : !h - !p;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), o = 0; o < r; ++o) {
    for (var a = n[o], s = a.length, u = i[o] = new Array(s), l, f = 0; f < s; ++f)
      (l = a[f]) && (u[f] = l);
    u.sort(t);
  }
  return new zd(i, this._parents).order();
}
function Wit(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function qit() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function Git() {
  return Array.from(this);
}
function Qit() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length; i < o; ++i) {
      var a = r[i];
      if (a)
        return a;
    }
  return null;
}
function Xit() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function Kit() {
  return !this.node();
}
function Zit(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], o = 0, a = i.length, s; o < a; ++o)
      (s = i[o]) && e.call(s, s.__data__, o, i);
  return this;
}
function Jit(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function eot(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function tot(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function not(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function rot(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function iot(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function oot(e, t) {
  var n = CF(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? eot : Jit : typeof t == "function" ? n.local ? iot : rot : n.local ? not : tot)(n, t));
}
function __e(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function aot(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function sot(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function uot(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function lot(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? aot : typeof t == "function" ? uot : sot)(e, t, n ?? "")) : aC(this.node(), e);
}
function aC(e, t) {
  return e.style.getPropertyValue(t) || __e(e).getComputedStyle(e, null).getPropertyValue(t);
}
function cot(e) {
  return function() {
    delete this[e];
  };
}
function fot(e, t) {
  return function() {
    this[e] = t;
  };
}
function dot(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function hot(e, t) {
  return arguments.length > 1 ? this.each((t == null ? cot : typeof t == "function" ? dot : fot)(e, t)) : this.node()[e];
}
function E_e(e) {
  return e.trim().split(/^|\s+/);
}
function QK(e) {
  return e.classList || new S_e(e);
}
function S_e(e) {
  this._node = e, this._names = E_e(e.getAttribute("class") || "");
}
S_e.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function M_e(e, t) {
  for (var n = QK(e), r = -1, i = t.length; ++r < i; )
    n.add(t[r]);
}
function T_e(e, t) {
  for (var n = QK(e), r = -1, i = t.length; ++r < i; )
    n.remove(t[r]);
}
function pot(e) {
  return function() {
    M_e(this, e);
  };
}
function got(e) {
  return function() {
    T_e(this, e);
  };
}
function mot(e, t) {
  return function() {
    (t.apply(this, arguments) ? M_e : T_e)(this, e);
  };
}
function yot(e, t) {
  var n = E_e(e + "");
  if (arguments.length < 2) {
    for (var r = QK(this.node()), i = -1, o = n.length; ++i < o; )
      if (!r.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? mot : t ? pot : got)(n, t));
}
function vot() {
  this.textContent = "";
}
function bot(e) {
  return function() {
    this.textContent = e;
  };
}
function xot(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function wot(e) {
  return arguments.length ? this.each(e == null ? vot : (typeof e == "function" ? xot : bot)(e)) : this.node().textContent;
}
function _ot() {
  this.innerHTML = "";
}
function Eot(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Sot(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Mot(e) {
  return arguments.length ? this.each(e == null ? _ot : (typeof e == "function" ? Sot : Eot)(e)) : this.node().innerHTML;
}
function Tot() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Cot() {
  return this.each(Tot);
}
function Not() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Dot() {
  return this.each(Not);
}
function Aot(e) {
  var t = typeof e == "function" ? e : NF(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Oot() {
  return null;
}
function Rot(e, t) {
  var n = typeof e == "function" ? e : NF(e), r = t == null ? Oot : typeof t == "function" ? t : GK(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function kot() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function $ot() {
  return this.each(kot);
}
function Pot() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Iot() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function jot(e) {
  return this.select(e ? Iot : Pot);
}
function Lot(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function zot(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function Fot(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function Bot(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, o; n < i; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++r] = o;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function Uot(e, t, n) {
  return function() {
    var r = this.__on, i, o = zot(t);
    if (r) {
      for (var a = 0, s = r.length; a < s; ++a)
        if ((i = r[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = o, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), i = { type: e.type, name: e.name, value: t, listener: o, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function Yot(e, t, n) {
  var r = Fot(e + ""), i, o = r.length, a;
  if (arguments.length < 2) {
    var s = this.node().__on;
    if (s) {
      for (var u = 0, l = s.length, f; u < l; ++u)
        for (i = 0, f = s[u]; i < o; ++i)
          if ((a = r[i]).type === f.type && a.name === f.name)
            return f.value;
    }
    return;
  }
  for (s = t ? Uot : Bot, i = 0; i < o; ++i)
    this.each(s(r[i], t, n));
  return this;
}
function C_e(e, t, n) {
  var r = __e(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function Hot(e, t) {
  return function() {
    return C_e(this, e, t);
  };
}
function Vot(e, t) {
  return function() {
    return C_e(this, e, t.apply(this, arguments));
  };
}
function Wot(e, t) {
  return this.each((typeof t == "function" ? Vot : Hot)(e, t));
}
function* qot() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length, a; i < o; ++i)
      (a = r[i]) && (yield a);
}
var N_e = [null];
function zd(e, t) {
  this._groups = e, this._parents = t;
}
function C$() {
  return new zd([[document.documentElement]], N_e);
}
function Got() {
  return this;
}
zd.prototype = C$.prototype = {
  constructor: zd,
  select: xit,
  selectAll: Sit,
  selectChild: Nit,
  selectChildren: Rit,
  filter: kit,
  data: zit,
  enter: $it,
  exit: Bit,
  join: Uit,
  merge: Yit,
  selection: Got,
  order: Hit,
  sort: Vit,
  call: qit,
  nodes: Git,
  node: Qit,
  size: Xit,
  empty: Kit,
  each: Zit,
  attr: oot,
  style: lot,
  property: hot,
  classed: yot,
  text: wot,
  html: Mot,
  raise: Cot,
  lower: Dot,
  append: Aot,
  insert: Rot,
  remove: $ot,
  clone: jot,
  datum: Lot,
  on: Yot,
  dispatch: Wot,
  [Symbol.iterator]: qot
};
function Ix(e) {
  return typeof e == "string" ? new zd([[document.querySelector(e)]], [document.documentElement]) : new zd([[e]], N_e);
}
function Qot(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Xot(e, t) {
  if (e = Qot(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
function cN(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function N$(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t)
    n[r] = t[r];
  return n;
}
function Mw() {
}
var MS = 0.7, sC = 1 / MS, DT = "\\s*([+-]?\\d+)\\s*", Tk = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ly = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Kot = /^#([0-9a-f]{3,8})$/, Zot = new RegExp(`^rgb\\(${DT},${DT},${DT}\\)$`), Jot = new RegExp(`^rgb\\(${Ly},${Ly},${Ly}\\)$`), eat = new RegExp(`^rgba\\(${DT},${DT},${DT},${Tk}\\)$`), tat = new RegExp(`^rgba\\(${Ly},${Ly},${Ly},${Tk}\\)$`), nat = new RegExp(`^hsl\\(${Tk},${Ly},${Ly}\\)$`), rat = new RegExp(`^hsla\\(${Tk},${Ly},${Ly},${Tk}\\)$`), Vfe = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
cN(Mw, ew, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Wfe,
  // Deprecated! Use color.formatHex.
  formatHex: Wfe,
  formatHex8: iat,
  formatHsl: oat,
  formatRgb: qfe,
  toString: qfe
});
function Wfe() {
  return this.rgb().formatHex();
}
function iat() {
  return this.rgb().formatHex8();
}
function oat() {
  return D_e(this).formatHsl();
}
function qfe() {
  return this.rgb().formatRgb();
}
function ew(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Kot.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Gfe(t) : n === 3 ? new pu(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? UI(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? UI(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Zot.exec(e)) ? new pu(t[1], t[2], t[3], 1) : (t = Jot.exec(e)) ? new pu(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = eat.exec(e)) ? UI(t[1], t[2], t[3], t[4]) : (t = tat.exec(e)) ? UI(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = nat.exec(e)) ? Kfe(t[1], t[2] / 100, t[3] / 100, 1) : (t = rat.exec(e)) ? Kfe(t[1], t[2] / 100, t[3] / 100, t[4]) : Vfe.hasOwnProperty(e) ? Gfe(Vfe[e]) : e === "transparent" ? new pu(NaN, NaN, NaN, 0) : null;
}
function Gfe(e) {
  return new pu(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function UI(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new pu(e, t, n, r);
}
function XK(e) {
  return e instanceof Mw || (e = ew(e)), e ? (e = e.rgb(), new pu(e.r, e.g, e.b, e.opacity)) : new pu();
}
function Cf(e, t, n, r) {
  return arguments.length === 1 ? XK(e) : new pu(e, t, n, r ?? 1);
}
function pu(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
cN(pu, Cf, N$(Mw, {
  brighter(e) {
    return e = e == null ? sC : Math.pow(sC, e), new pu(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? MS : Math.pow(MS, e), new pu(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new pu(JE(this.r), JE(this.g), JE(this.b), cL(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Qfe,
  // Deprecated! Use color.formatHex.
  formatHex: Qfe,
  formatHex8: aat,
  formatRgb: Xfe,
  toString: Xfe
}));
function Qfe() {
  return `#${BE(this.r)}${BE(this.g)}${BE(this.b)}`;
}
function aat() {
  return `#${BE(this.r)}${BE(this.g)}${BE(this.b)}${BE((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Xfe() {
  const e = cL(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${JE(this.r)}, ${JE(this.g)}, ${JE(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function cL(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function JE(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function BE(e) {
  return e = JE(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Kfe(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Ng(e, t, n, r);
}
function D_e(e) {
  if (e instanceof Ng)
    return new Ng(e.h, e.s, e.l, e.opacity);
  if (e instanceof Mw || (e = ew(e)), !e)
    return new Ng();
  if (e instanceof Ng)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), a = NaN, s = o - i, u = (o + i) / 2;
  return s ? (t === o ? a = (n - r) / s + (n < r) * 6 : n === o ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= u < 0.5 ? o + i : 2 - o - i, a *= 60) : s = u > 0 && u < 1 ? 0 : a, new Ng(a, s, u, e.opacity);
}
function fL(e, t, n, r) {
  return arguments.length === 1 ? D_e(e) : new Ng(e, t, n, r ?? 1);
}
function Ng(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
cN(Ng, fL, N$(Mw, {
  brighter(e) {
    return e = e == null ? sC : Math.pow(sC, e), new Ng(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? MS : Math.pow(MS, e), new Ng(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new pu(
      nH(e >= 240 ? e - 240 : e + 120, i, r),
      nH(e, i, r),
      nH(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new Ng(Zfe(this.h), YI(this.s), YI(this.l), cL(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = cL(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Zfe(this.h)}, ${YI(this.s) * 100}%, ${YI(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Zfe(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function YI(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function nH(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const A_e = Math.PI / 180, O_e = 180 / Math.PI, dL = 18, R_e = 0.96422, k_e = 1, $_e = 0.82521, P_e = 4 / 29, AT = 6 / 29, I_e = 3 * AT * AT, sat = AT * AT * AT;
function j_e(e) {
  if (e instanceof zy)
    return new zy(e.l, e.a, e.b, e.opacity);
  if (e instanceof V0)
    return L_e(e);
  e instanceof pu || (e = XK(e));
  var t = aH(e.r), n = aH(e.g), r = aH(e.b), i = rH((0.2225045 * t + 0.7168786 * n + 0.0606169 * r) / k_e), o, a;
  return t === n && n === r ? o = a = i : (o = rH((0.4360747 * t + 0.3850649 * n + 0.1430804 * r) / R_e), a = rH((0.0139322 * t + 0.0971045 * n + 0.7141733 * r) / $_e)), new zy(116 * i - 16, 500 * (o - i), 200 * (i - a), e.opacity);
}
function hL(e, t, n, r) {
  return arguments.length === 1 ? j_e(e) : new zy(e, t, n, r ?? 1);
}
function zy(e, t, n, r) {
  this.l = +e, this.a = +t, this.b = +n, this.opacity = +r;
}
cN(zy, hL, N$(Mw, {
  brighter(e) {
    return new zy(this.l + dL * (e ?? 1), this.a, this.b, this.opacity);
  },
  darker(e) {
    return new zy(this.l - dL * (e ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, n = isNaN(this.b) ? e : e - this.b / 200;
    return t = R_e * iH(t), e = k_e * iH(e), n = $_e * iH(n), new pu(
      oH(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
      oH(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
      oH(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
      this.opacity
    );
  }
}));
function rH(e) {
  return e > sat ? Math.pow(e, 1 / 3) : e / I_e + P_e;
}
function iH(e) {
  return e > AT ? e * e * e : I_e * (e - P_e);
}
function oH(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function aH(e) {
  return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function uat(e) {
  if (e instanceof V0)
    return new V0(e.h, e.c, e.l, e.opacity);
  if (e instanceof zy || (e = j_e(e)), e.a === 0 && e.b === 0)
    return new V0(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
  var t = Math.atan2(e.b, e.a) * O_e;
  return new V0(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
}
function pL(e, t, n, r) {
  return arguments.length === 1 ? uat(e) : new V0(e, t, n, r ?? 1);
}
function V0(e, t, n, r) {
  this.h = +e, this.c = +t, this.l = +n, this.opacity = +r;
}
function L_e(e) {
  if (isNaN(e.h))
    return new zy(e.l, 0, 0, e.opacity);
  var t = e.h * A_e;
  return new zy(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
}
cN(V0, pL, N$(Mw, {
  brighter(e) {
    return new V0(this.h, this.c, this.l + dL * (e ?? 1), this.opacity);
  },
  darker(e) {
    return new V0(this.h, this.c, this.l - dL * (e ?? 1), this.opacity);
  },
  rgb() {
    return L_e(this).rgb();
  }
}));
var z_e = -0.14861, KK = 1.78277, ZK = -0.29227, DF = -0.90649, Ck = 1.97294, Jfe = Ck * DF, ede = Ck * KK, tde = KK * ZK - DF * z_e;
function lat(e) {
  if (e instanceof eS)
    return new eS(e.h, e.s, e.l, e.opacity);
  e instanceof pu || (e = XK(e));
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = (tde * r + Jfe * t - ede * n) / (tde + Jfe - ede), o = r - i, a = (Ck * (n - i) - ZK * o) / DF, s = Math.sqrt(a * a + o * o) / (Ck * i * (1 - i)), u = s ? Math.atan2(a, o) * O_e - 120 : NaN;
  return new eS(u < 0 ? u + 360 : u, s, i, e.opacity);
}
function qy(e, t, n, r) {
  return arguments.length === 1 ? lat(e) : new eS(e, t, n, r ?? 1);
}
function eS(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
cN(eS, qy, N$(Mw, {
  brighter(e) {
    return e = e == null ? sC : Math.pow(sC, e), new eS(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? MS : Math.pow(MS, e), new eS(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = isNaN(this.h) ? 0 : (this.h + 120) * A_e, t = +this.l, n = isNaN(this.s) ? 0 : this.s * t * (1 - t), r = Math.cos(e), i = Math.sin(e);
    return new pu(
      255 * (t + n * (z_e * r + KK * i)),
      255 * (t + n * (ZK * r + DF * i)),
      255 * (t + n * (Ck * r)),
      this.opacity
    );
  }
}));
function F_e(e, t, n, r, i) {
  var o = e * e, a = o * e;
  return ((1 - 3 * e + 3 * o - a) * t + (4 - 6 * o + 3 * a) * n + (1 + 3 * e + 3 * o - 3 * a) * r + a * i) / 6;
}
function B_e(e) {
  var t = e.length - 1;
  return function(n) {
    var r = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), i = e[r], o = e[r + 1], a = r > 0 ? e[r - 1] : 2 * i - o, s = r < t - 1 ? e[r + 2] : 2 * o - i;
    return F_e((n - r / t) * t, a, i, o, s);
  };
}
function U_e(e) {
  var t = e.length;
  return function(n) {
    var r = Math.floor(((n %= 1) < 0 ? ++n : n) * t), i = e[(r + t - 1) % t], o = e[r % t], a = e[(r + 1) % t], s = e[(r + 2) % t];
    return F_e((n - r / t) * t, i, o, a, s);
  };
}
const AF = (e) => () => e;
function Y_e(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function cat(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function OF(e, t) {
  var n = t - e;
  return n ? Y_e(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : AF(isNaN(e) ? t : e);
}
function fat(e) {
  return (e = +e) == 1 ? gu : function(t, n) {
    return n - t ? cat(t, n, e) : AF(isNaN(t) ? n : t);
  };
}
function gu(e, t) {
  var n = t - e;
  return n ? Y_e(e, n) : AF(isNaN(e) ? t : e);
}
const tw = function e(t) {
  var n = fat(t);
  function r(i, o) {
    var a = n((i = Cf(i)).r, (o = Cf(o)).r), s = n(i.g, o.g), u = n(i.b, o.b), l = gu(i.opacity, o.opacity);
    return function(f) {
      return i.r = a(f), i.g = s(f), i.b = u(f), i.opacity = l(f), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function H_e(e) {
  return function(t) {
    var n = t.length, r = new Array(n), i = new Array(n), o = new Array(n), a, s;
    for (a = 0; a < n; ++a)
      s = Cf(t[a]), r[a] = s.r || 0, i[a] = s.g || 0, o[a] = s.b || 0;
    return r = e(r), i = e(i), o = e(o), s.opacity = 1, function(u) {
      return s.r = r(u), s.g = i(u), s.b = o(u), s + "";
    };
  };
}
var V_e = H_e(B_e), dat = H_e(U_e);
function JK(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(o) {
    for (i = 0; i < n; ++i)
      r[i] = e[i] * (1 - o) + t[i] * o;
    return r;
  };
}
function W_e(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function hat(e, t) {
  return (W_e(t) ? JK : q_e)(e, t);
}
function q_e(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), o = new Array(n), a;
  for (a = 0; a < r; ++a)
    i[a] = Tw(e[a], t[a]);
  for (; a < n; ++a)
    o[a] = t[a];
  return function(s) {
    for (a = 0; a < r; ++a)
      o[a] = i[a](s);
    return o;
  };
}
function G_e(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function Ku(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function Q_e(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = Tw(e[i], t[i]) : r[i] = t[i];
  return function(o) {
    for (i in n)
      r[i] = n[i](o);
    return r;
  };
}
var Aq = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, sH = new RegExp(Aq.source, "g");
function pat(e) {
  return function() {
    return e;
  };
}
function gat(e) {
  return function(t) {
    return e(t) + "";
  };
}
function eZ(e, t) {
  var n = Aq.lastIndex = sH.lastIndex = 0, r, i, o, a = -1, s = [], u = [];
  for (e = e + "", t = t + ""; (r = Aq.exec(e)) && (i = sH.exec(t)); )
    (o = i.index) > n && (o = t.slice(n, o), s[a] ? s[a] += o : s[++a] = o), (r = r[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, u.push({ i: a, x: Ku(r, i) })), n = sH.lastIndex;
  return n < t.length && (o = t.slice(n), s[a] ? s[a] += o : s[++a] = o), s.length < 2 ? u[0] ? gat(u[0].x) : pat(t) : (t = u.length, function(l) {
    for (var f = 0, h; f < t; ++f)
      s[(h = u[f]).i] = h.x(l);
    return s.join("");
  });
}
function Tw(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? AF(t) : (n === "number" ? Ku : n === "string" ? (r = ew(t)) ? (t = r, tw) : eZ : t instanceof ew ? tw : t instanceof Date ? G_e : W_e(t) ? JK : Array.isArray(t) ? q_e : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Q_e : Ku)(e, t);
}
function mat(e) {
  var t = e.length;
  return function(n) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
  };
}
function yat(e, t) {
  var n = OF(+e, +t);
  return function(r) {
    var i = n(r);
    return i - 360 * Math.floor(i / 360);
  };
}
function fN(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var nde = 180 / Math.PI, Oq = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function X_e(e, t, n, r, i, o) {
  var a, s, u;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (u = e * n + t * r) && (n -= e * u, r -= t * u), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, u /= s), e * r < t * n && (e = -e, t = -t, u = -u, a = -a), {
    translateX: i,
    translateY: o,
    rotate: Math.atan2(t, e) * nde,
    skewX: Math.atan(u) * nde,
    scaleX: a,
    scaleY: s
  };
}
var HI;
function vat(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Oq : X_e(t.a, t.b, t.c, t.d, t.e, t.f);
}
function bat(e) {
  return e == null || (HI || (HI = document.createElementNS("http://www.w3.org/2000/svg", "g")), HI.setAttribute("transform", e), !(e = HI.transform.baseVal.consolidate())) ? Oq : (e = e.matrix, X_e(e.a, e.b, e.c, e.d, e.e, e.f));
}
function K_e(e, t, n, r) {
  function i(l) {
    return l.length ? l.pop() + " " : "";
  }
  function o(l, f, h, p, g, y) {
    if (l !== h || f !== p) {
      var b = g.push("translate(", null, t, null, n);
      y.push({ i: b - 4, x: Ku(l, h) }, { i: b - 2, x: Ku(f, p) });
    } else
      (h || p) && g.push("translate(" + h + t + p + n);
  }
  function a(l, f, h, p) {
    l !== f ? (l - f > 180 ? f += 360 : f - l > 180 && (l += 360), p.push({ i: h.push(i(h) + "rotate(", null, r) - 2, x: Ku(l, f) })) : f && h.push(i(h) + "rotate(" + f + r);
  }
  function s(l, f, h, p) {
    l !== f ? p.push({ i: h.push(i(h) + "skewX(", null, r) - 2, x: Ku(l, f) }) : f && h.push(i(h) + "skewX(" + f + r);
  }
  function u(l, f, h, p, g, y) {
    if (l !== h || f !== p) {
      var b = g.push(i(g) + "scale(", null, ",", null, ")");
      y.push({ i: b - 4, x: Ku(l, h) }, { i: b - 2, x: Ku(f, p) });
    } else
      (h !== 1 || p !== 1) && g.push(i(g) + "scale(" + h + "," + p + ")");
  }
  return function(l, f) {
    var h = [], p = [];
    return l = e(l), f = e(f), o(l.translateX, l.translateY, f.translateX, f.translateY, h, p), a(l.rotate, f.rotate, h, p), s(l.skewX, f.skewX, h, p), u(l.scaleX, l.scaleY, f.scaleX, f.scaleY, h, p), l = f = null, function(g) {
      for (var y = -1, b = p.length, _; ++y < b; )
        h[(_ = p[y]).i] = _.x(g);
      return h.join("");
    };
  };
}
var Z_e = K_e(vat, "px, ", "px)", "deg)"), J_e = K_e(bat, ", ", ")", ")"), xat = 1e-12;
function rde(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function wat(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function _at(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Eat = function e(t, n, r) {
  function i(o, a) {
    var s = o[0], u = o[1], l = o[2], f = a[0], h = a[1], p = a[2], g = f - s, y = h - u, b = g * g + y * y, _, S;
    if (b < xat)
      S = Math.log(p / l) / t, _ = function($) {
        return [
          s + $ * g,
          u + $ * y,
          l * Math.exp(t * $ * S)
        ];
      };
    else {
      var C = Math.sqrt(b), A = (p * p - l * l + r * b) / (2 * l * n * C), O = (p * p - l * l - r * b) / (2 * p * n * C), R = Math.log(Math.sqrt(A * A + 1) - A), j = Math.log(Math.sqrt(O * O + 1) - O);
      S = (j - R) / t, _ = function($) {
        var z = $ * S, W = rde(R), Y = l / (n * C) * (W * _at(t * z + R) - wat(R));
        return [
          s + Y * g,
          u + Y * y,
          l * W / rde(t * z + R)
        ];
      };
    }
    return _.duration = S * 1e3 * t / Math.SQRT2, _;
  }
  return i.rho = function(o) {
    var a = Math.max(1e-3, +o), s = a * a, u = s * s;
    return e(a, s, u);
  }, i;
}(Math.SQRT2, 2, 4);
function eEe(e) {
  return function(t, n) {
    var r = e((t = fL(t)).h, (n = fL(n)).h), i = gu(t.s, n.s), o = gu(t.l, n.l), a = gu(t.opacity, n.opacity);
    return function(s) {
      return t.h = r(s), t.s = i(s), t.l = o(s), t.opacity = a(s), t + "";
    };
  };
}
const tEe = eEe(OF);
var Sat = eEe(gu);
function nEe(e, t) {
  var n = gu((e = hL(e)).l, (t = hL(t)).l), r = gu(e.a, t.a), i = gu(e.b, t.b), o = gu(e.opacity, t.opacity);
  return function(a) {
    return e.l = n(a), e.a = r(a), e.b = i(a), e.opacity = o(a), e + "";
  };
}
function rEe(e) {
  return function(t, n) {
    var r = e((t = pL(t)).h, (n = pL(n)).h), i = gu(t.c, n.c), o = gu(t.l, n.l), a = gu(t.opacity, n.opacity);
    return function(s) {
      return t.h = r(s), t.c = i(s), t.l = o(s), t.opacity = a(s), t + "";
    };
  };
}
const iEe = rEe(OF);
var Mat = rEe(gu);
function oEe(e) {
  return function t(n) {
    n = +n;
    function r(i, o) {
      var a = e((i = qy(i)).h, (o = qy(o)).h), s = gu(i.s, o.s), u = gu(i.l, o.l), l = gu(i.opacity, o.opacity);
      return function(f) {
        return i.h = a(f), i.s = s(f), i.l = u(Math.pow(f, n)), i.opacity = l(f), i + "";
      };
    }
    return r.gamma = t, r;
  }(1);
}
const Tat = oEe(OF);
var RF = oEe(gu);
function dN(e, t) {
  t === void 0 && (t = e, e = Tw);
  for (var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); n < r; )
    o[n] = e(i, i = t[++n]);
  return function(a) {
    var s = Math.max(0, Math.min(r - 1, Math.floor(a *= r)));
    return o[s](a - s);
  };
}
function dp(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r)
    n[r] = e(r / (t - 1));
  return n;
}
const Cat = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolate: Tw,
  interpolateArray: hat,
  interpolateBasis: B_e,
  interpolateBasisClosed: U_e,
  interpolateCubehelix: Tat,
  interpolateCubehelixLong: RF,
  interpolateDate: G_e,
  interpolateDiscrete: mat,
  interpolateHcl: iEe,
  interpolateHclLong: Mat,
  interpolateHsl: tEe,
  interpolateHslLong: Sat,
  interpolateHue: yat,
  interpolateLab: nEe,
  interpolateNumber: Ku,
  interpolateNumberArray: JK,
  interpolateObject: Q_e,
  interpolateRgb: tw,
  interpolateRgbBasis: V_e,
  interpolateRgbBasisClosed: dat,
  interpolateRound: fN,
  interpolateString: eZ,
  interpolateTransformCss: Z_e,
  interpolateTransformSvg: J_e,
  interpolateZoom: Eat,
  piecewise: dN,
  quantize: dp
}, Symbol.toStringTag, { value: "Module" }));
var uC = 0, DO = 0, HA = 0, aEe = 1e3, gL, AO, mL = 0, TS = 0, kF = 0, Nk = typeof performance == "object" && performance.now ? performance : Date, sEe = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function $F() {
  return TS || (sEe(Nat), TS = Nk.now() + kF);
}
function Nat() {
  TS = 0;
}
function Dk() {
  this._call = this._time = this._next = null;
}
Dk.prototype = tZ.prototype = {
  constructor: Dk,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? $F() : +n) + (t == null ? 0 : +t), !this._next && AO !== this && (AO ? AO._next = this : gL = this, AO = this), this._call = e, this._time = n, Rq();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Rq());
  }
};
function tZ(e, t, n) {
  var r = new Dk();
  return r.restart(e, t, n), r;
}
function Dat() {
  $F(), ++uC;
  for (var e = gL, t; e; )
    (t = TS - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --uC;
}
function ide() {
  TS = (mL = Nk.now()) + kF, uC = DO = 0;
  try {
    Dat();
  } finally {
    uC = 0, Oat(), TS = 0;
  }
}
function Aat() {
  var e = Nk.now(), t = e - mL;
  t > aEe && (kF -= t, mL = e);
}
function Oat() {
  for (var e, t = gL, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : gL = n);
  AO = e, Rq(r);
}
function Rq(e) {
  if (!uC) {
    DO && (DO = clearTimeout(DO));
    var t = e - TS;
    t > 24 ? (e < 1 / 0 && (DO = setTimeout(ide, e - Nk.now() - kF)), HA && (HA = clearInterval(HA))) : (HA || (mL = Nk.now(), HA = setInterval(Aat, aEe)), uC = 1, sEe(ide));
  }
}
function ode(e, t, n) {
  var r = new Dk();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
function Rat(e, t, n) {
  var r = new Dk(), i = t;
  return t == null ? (r.restart(e, t, n), r) : (r._restart = r.restart, r.restart = function(o, a, s) {
    a = +a, s = s == null ? $F() : +s, r._restart(function u(l) {
      l += i, r._restart(u, i += a, s), o(l);
    }, a, s);
  }, r.restart(e, t, n), r);
}
var kat = qK("start", "end", "cancel", "interrupt"), $at = [], uEe = 0, ade = 1, kq = 2, ij = 3, sde = 4, $q = 5, oj = 6;
function PF(e, t, n, r, i, o) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (n in a)
    return;
  Pat(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: kat,
    tween: $at,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: uEe
  });
}
function nZ(e, t) {
  var n = Kg(e, t);
  if (n.state > uEe)
    throw new Error("too late; already scheduled");
  return n;
}
function nv(e, t) {
  var n = Kg(e, t);
  if (n.state > ij)
    throw new Error("too late; already running");
  return n;
}
function Kg(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Pat(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = tZ(o, 0, n.time);
  function o(l) {
    n.state = ade, n.timer.restart(a, n.delay, n.time), n.delay <= l && a(l - n.delay);
  }
  function a(l) {
    var f, h, p, g;
    if (n.state !== ade)
      return u();
    for (f in r)
      if (g = r[f], g.name === n.name) {
        if (g.state === ij)
          return ode(a);
        g.state === sde ? (g.state = oj, g.timer.stop(), g.on.call("interrupt", e, e.__data__, g.index, g.group), delete r[f]) : +f < t && (g.state = oj, g.timer.stop(), g.on.call("cancel", e, e.__data__, g.index, g.group), delete r[f]);
      }
    if (ode(function() {
      n.state === ij && (n.state = sde, n.timer.restart(s, n.delay, n.time), s(l));
    }), n.state = kq, n.on.call("start", e, e.__data__, n.index, n.group), n.state === kq) {
      for (n.state = ij, i = new Array(p = n.tween.length), f = 0, h = -1; f < p; ++f)
        (g = n.tween[f].value.call(e, e.__data__, n.index, n.group)) && (i[++h] = g);
      i.length = h + 1;
    }
  }
  function s(l) {
    for (var f = l < n.duration ? n.ease.call(null, l / n.duration) : (n.timer.restart(u), n.state = $q, 1), h = -1, p = i.length; ++h < p; )
      i[h].call(e, f);
    n.state === $q && (n.on.call("end", e, e.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = oj, n.timer.stop(), delete r[t];
    for (var l in r)
      return;
    delete e.__transition;
  }
}
function Iat(e, t) {
  var n = e.__transition, r, i, o = !0, a;
  if (n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((r = n[a]).name !== t) {
        o = !1;
        continue;
      }
      i = r.state > kq && r.state < $q, r.state = oj, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];
    }
    o && delete e.__transition;
  }
}
function jat(e) {
  return this.each(function() {
    Iat(this, e);
  });
}
function Lat(e, t) {
  var n, r;
  return function() {
    var i = nv(this, e), o = i.tween;
    if (o !== n) {
      r = n = o;
      for (var a = 0, s = r.length; a < s; ++a)
        if (r[a].name === t) {
          r = r.slice(), r.splice(a, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function zat(e, t, n) {
  var r, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var o = nv(this, e), a = o.tween;
    if (a !== r) {
      i = (r = a).slice();
      for (var s = { name: t, value: n }, u = 0, l = i.length; u < l; ++u)
        if (i[u].name === t) {
          i[u] = s;
          break;
        }
      u === l && i.push(s);
    }
    o.tween = i;
  };
}
function Fat(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Kg(this.node(), n).tween, i = 0, o = r.length, a; i < o; ++i)
      if ((a = r[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? Lat : zat)(n, e, t));
}
function rZ(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = nv(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Kg(i, r).value[t];
  };
}
function lEe(e, t) {
  var n;
  return (typeof t == "number" ? Ku : t instanceof ew ? tw : (n = ew(t)) ? (t = n, tw) : eZ)(e, t);
}
function Bat(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Uat(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Yat(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === r ? o : o = t(r = a, n);
  };
}
function Hat(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === r ? o : o = t(r = a, n);
  };
}
function Vat(e, t, n) {
  var r, i, o;
  return function() {
    var a, s = n(this), u;
    return s == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), u = s + "", a === u ? null : a === r && u === i ? o : (i = u, o = t(r = a, s)));
  };
}
function Wat(e, t, n) {
  var r, i, o;
  return function() {
    var a, s = n(this), u;
    return s == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), u = s + "", a === u ? null : a === r && u === i ? o : (i = u, o = t(r = a, s)));
  };
}
function qat(e, t) {
  var n = CF(e), r = n === "transform" ? J_e : lEe;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Wat : Vat)(n, r, rZ(this, "attr." + e, t)) : t == null ? (n.local ? Uat : Bat)(n) : (n.local ? Hat : Yat)(n, r, t));
}
function Gat(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Qat(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Xat(e, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && Qat(e, o)), n;
  }
  return i._value = t, i;
}
function Kat(e, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && Gat(e, o)), n;
  }
  return i._value = t, i;
}
function Zat(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var r = CF(e);
  return this.tween(n, (r.local ? Xat : Kat)(r, t));
}
function Jat(e, t) {
  return function() {
    nZ(this, e).delay = +t.apply(this, arguments);
  };
}
function est(e, t) {
  return t = +t, function() {
    nZ(this, e).delay = t;
  };
}
function tst(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Jat : est)(t, e)) : Kg(this.node(), t).delay;
}
function nst(e, t) {
  return function() {
    nv(this, e).duration = +t.apply(this, arguments);
  };
}
function rst(e, t) {
  return t = +t, function() {
    nv(this, e).duration = t;
  };
}
function ist(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? nst : rst)(t, e)) : Kg(this.node(), t).duration;
}
function ost(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    nv(this, e).ease = t;
  };
}
function ast(e) {
  var t = this._id;
  return arguments.length ? this.each(ost(t, e)) : Kg(this.node(), t).ease;
}
function sst(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    nv(this, e).ease = n;
  };
}
function ust(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(sst(this._id, e));
}
function lst(e) {
  typeof e != "function" && (e = b_e(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], a = o.length, s = r[i] = [], u, l = 0; l < a; ++l)
      (u = o[l]) && e.call(u, u.__data__, l, o) && s.push(u);
  return new lb(r, this._parents, this._name, this._id);
}
function cst(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, o = Math.min(r, i), a = new Array(r), s = 0; s < o; ++s)
    for (var u = t[s], l = n[s], f = u.length, h = a[s] = new Array(f), p, g = 0; g < f; ++g)
      (p = u[g] || l[g]) && (h[g] = p);
  for (; s < r; ++s)
    a[s] = t[s];
  return new lb(a, this._parents, this._name, this._id);
}
function fst(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function dst(e, t, n) {
  var r, i, o = fst(t) ? nZ : nv;
  return function() {
    var a = o(this, e), s = a.on;
    s !== r && (i = (r = s).copy()).on(t, n), a.on = i;
  };
}
function hst(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Kg(this.node(), n).on.on(e) : this.each(dst(n, e, t));
}
function pst(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function gst() {
  return this.on("end.remove", pst(this._id));
}
function mst(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = GK(e));
  for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a)
    for (var s = r[a], u = s.length, l = o[a] = new Array(u), f, h, p = 0; p < u; ++p)
      (f = s[p]) && (h = e.call(f, f.__data__, p, s)) && ("__data__" in f && (h.__data__ = f.__data__), l[p] = h, PF(l[p], t, n, p, l, Kg(f, n)));
  return new lb(o, this._parents, t, n);
}
function yst(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = v_e(e));
  for (var r = this._groups, i = r.length, o = [], a = [], s = 0; s < i; ++s)
    for (var u = r[s], l = u.length, f, h = 0; h < l; ++h)
      if (f = u[h]) {
        for (var p = e.call(f, f.__data__, h, u), g, y = Kg(f, n), b = 0, _ = p.length; b < _; ++b)
          (g = p[b]) && PF(g, t, n, b, p, y);
        o.push(p), a.push(f);
      }
  return new lb(o, a, t, n);
}
var vst = C$.prototype.constructor;
function bst() {
  return new vst(this._groups, this._parents);
}
function xst(e, t) {
  var n, r, i;
  return function() {
    var o = aC(this, e), a = (this.style.removeProperty(e), aC(this, e));
    return o === a ? null : o === n && a === r ? i : i = t(n = o, r = a);
  };
}
function cEe(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function wst(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var a = aC(this, e);
    return a === i ? null : a === r ? o : o = t(r = a, n);
  };
}
function _st(e, t, n) {
  var r, i, o;
  return function() {
    var a = aC(this, e), s = n(this), u = s + "";
    return s == null && (u = s = (this.style.removeProperty(e), aC(this, e))), a === u ? null : a === r && u === i ? o : (i = u, o = t(r = a, s));
  };
}
function Est(e, t) {
  var n, r, i, o = "style." + t, a = "end." + o, s;
  return function() {
    var u = nv(this, e), l = u.on, f = u.value[o] == null ? s || (s = cEe(t)) : void 0;
    (l !== n || i !== f) && (r = (n = l).copy()).on(a, i = f), u.on = r;
  };
}
function Sst(e, t, n) {
  var r = (e += "") == "transform" ? Z_e : lEe;
  return t == null ? this.styleTween(e, xst(e, r)).on("end.style." + e, cEe(e)) : typeof t == "function" ? this.styleTween(e, _st(e, r, rZ(this, "style." + e, t))).each(Est(this._id, e)) : this.styleTween(e, wst(e, r, t), n).on("end.style." + e, null);
}
function Mst(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function Tst(e, t, n) {
  var r, i;
  function o() {
    var a = t.apply(this, arguments);
    return a !== i && (r = (i = a) && Mst(e, a, n)), r;
  }
  return o._value = t, o;
}
function Cst(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(r, Tst(e, t, n ?? ""));
}
function Nst(e) {
  return function() {
    this.textContent = e;
  };
}
function Dst(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Ast(e) {
  return this.tween("text", typeof e == "function" ? Dst(rZ(this, "text", e)) : Nst(e == null ? "" : e + ""));
}
function Ost(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Rst(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && Ost(i)), t;
  }
  return r._value = e, r;
}
function kst(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, Rst(e));
}
function $st() {
  for (var e = this._name, t = this._id, n = fEe(), r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var a = r[o], s = a.length, u, l = 0; l < s; ++l)
      if (u = a[l]) {
        var f = Kg(u, t);
        PF(u, e, n, l, a, {
          time: f.time + f.delay + f.duration,
          delay: 0,
          duration: f.duration,
          ease: f.ease
        });
      }
  return new lb(r, this._parents, e, n);
}
function Pst() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(o, a) {
    var s = { value: a }, u = { value: function() {
      --i === 0 && o();
    } };
    n.each(function() {
      var l = nv(this, r), f = l.on;
      f !== e && (t = (e = f).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(u)), l.on = t;
    }), i === 0 && o();
  });
}
var Ist = 0;
function lb(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function fEe() {
  return ++Ist;
}
var T0 = C$.prototype;
lb.prototype = {
  constructor: lb,
  select: mst,
  selectAll: yst,
  selectChild: T0.selectChild,
  selectChildren: T0.selectChildren,
  filter: lst,
  merge: cst,
  selection: bst,
  transition: $st,
  call: T0.call,
  nodes: T0.nodes,
  node: T0.node,
  size: T0.size,
  empty: T0.empty,
  each: T0.each,
  on: hst,
  attr: qat,
  attrTween: Zat,
  style: Sst,
  styleTween: Cst,
  text: Ast,
  textTween: kst,
  remove: gst,
  tween: Fat,
  delay: tst,
  duration: ist,
  ease: ast,
  easeVarying: ust,
  end: Pst,
  [Symbol.iterator]: T0[Symbol.iterator]
};
function jst(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Lst = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: jst
};
function zst(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Fst(e) {
  var t, n;
  e instanceof lb ? (t = e._id, e = e._name) : (t = fEe(), (n = Lst).time = $F(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var a = r[o], s = a.length, u, l = 0; l < s; ++l)
      (u = a[l]) && PF(u, e, t, l, a, n || zst(u, t));
  return new lb(r, this._parents, e, t);
}
C$.prototype.interrupt = jat;
C$.prototype.transition = Fst;
var Bst = Array.prototype, dEe = Bst.slice;
function Ust(e, t) {
  return e - t;
}
function Yst(e) {
  for (var t = 0, n = e.length, r = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; )
    r += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
  return r;
}
const cx = (e) => () => e;
function Hst(e, t) {
  for (var n = -1, r = t.length, i; ++n < r; )
    if (i = Vst(e, t[n]))
      return i;
  return 0;
}
function Vst(e, t) {
  for (var n = t[0], r = t[1], i = -1, o = 0, a = e.length, s = a - 1; o < a; s = o++) {
    var u = e[o], l = u[0], f = u[1], h = e[s], p = h[0], g = h[1];
    if (Wst(u, h, t))
      return 0;
    f > r != g > r && n < (p - l) * (r - f) / (g - f) + l && (i = -i);
  }
  return i;
}
function Wst(e, t, n) {
  var r;
  return qst(e, t, n) && Gst(e[r = +(e[0] === t[0])], n[r], t[r]);
}
function qst(e, t, n) {
  return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
}
function Gst(e, t, n) {
  return e <= t && t <= n || n <= t && t <= e;
}
function Qst() {
}
var C0 = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function Pq() {
  var e = 1, t = 1, n = VK, r = u;
  function i(l) {
    var f = n(l);
    if (Array.isArray(f))
      f = f.slice().sort(Ust);
    else {
      const h = Zu(l, Xst);
      for (f = Kx(...d_e(h[0], h[1], f), f); f[f.length - 1] >= h[1]; )
        f.pop();
      for (; f[1] < h[0]; )
        f.shift();
    }
    return f.map((h) => o(l, h));
  }
  function o(l, f) {
    const h = f == null ? NaN : +f;
    if (isNaN(h))
      throw new Error(`invalid value: ${f}`);
    var p = [], g = [];
    return a(l, h, function(y) {
      r(y, l, h), Yst(y) > 0 ? p.push([y]) : g.push(y);
    }), g.forEach(function(y) {
      for (var b = 0, _ = p.length, S; b < _; ++b)
        if (Hst((S = p[b])[0], y) !== -1) {
          S.push(y);
          return;
        }
    }), {
      type: "MultiPolygon",
      value: f,
      coordinates: p
    };
  }
  function a(l, f, h) {
    var p = new Array(), g = new Array(), y, b, _, S, C, A;
    for (y = b = -1, S = lE(l[0], f), C0[S << 1].forEach(O); ++y < e - 1; )
      _ = S, S = lE(l[y + 1], f), C0[_ | S << 1].forEach(O);
    for (C0[S << 0].forEach(O); ++b < t - 1; ) {
      for (y = -1, S = lE(l[b * e + e], f), C = lE(l[b * e], f), C0[S << 1 | C << 2].forEach(O); ++y < e - 1; )
        _ = S, S = lE(l[b * e + e + y + 1], f), A = C, C = lE(l[b * e + y + 1], f), C0[_ | S << 1 | C << 2 | A << 3].forEach(O);
      C0[S | C << 3].forEach(O);
    }
    for (y = -1, C = l[b * e] >= f, C0[C << 2].forEach(O); ++y < e - 1; )
      A = C, C = lE(l[b * e + y + 1], f), C0[C << 2 | A << 3].forEach(O);
    C0[C << 3].forEach(O);
    function O(R) {
      var j = [R[0][0] + y, R[0][1] + b], $ = [R[1][0] + y, R[1][1] + b], z = s(j), W = s($), Y, V;
      (Y = g[z]) ? (V = p[W]) ? (delete g[Y.end], delete p[V.start], Y === V ? (Y.ring.push($), h(Y.ring)) : p[Y.start] = g[V.end] = { start: Y.start, end: V.end, ring: Y.ring.concat(V.ring) }) : (delete g[Y.end], Y.ring.push($), g[Y.end = W] = Y) : (Y = p[W]) ? (V = g[z]) ? (delete p[Y.start], delete g[V.end], Y === V ? (Y.ring.push($), h(Y.ring)) : p[V.start] = g[Y.end] = { start: V.start, end: Y.end, ring: V.ring.concat(Y.ring) }) : (delete p[Y.start], Y.ring.unshift(j), p[Y.start = z] = Y) : p[z] = g[W] = { start: z, end: W, ring: [j, $] };
    }
  }
  function s(l) {
    return l[0] * 2 + l[1] * (e + 1) * 4;
  }
  function u(l, f, h) {
    l.forEach(function(p) {
      var g = p[0], y = p[1], b = g | 0, _ = y | 0, S = uH(f[_ * e + b]);
      g > 0 && g < e && b === g && (p[0] = ude(g, uH(f[_ * e + b - 1]), S, h)), y > 0 && y < t && _ === y && (p[1] = ude(y, uH(f[(_ - 1) * e + b]), S, h));
    });
  }
  return i.contour = o, i.size = function(l) {
    if (!arguments.length)
      return [e, t];
    var f = Math.floor(l[0]), h = Math.floor(l[1]);
    if (!(f >= 0 && h >= 0))
      throw new Error("invalid size");
    return e = f, t = h, i;
  }, i.thresholds = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : Array.isArray(l) ? cx(dEe.call(l)) : cx(l), i) : n;
  }, i.smooth = function(l) {
    return arguments.length ? (r = l ? u : Qst, i) : r === u;
  }, i;
}
function Xst(e) {
  return isFinite(e) ? e : NaN;
}
function lE(e, t) {
  return e == null ? !1 : +e >= t;
}
function uH(e) {
  return e == null || isNaN(e = +e) ? -1 / 0 : e;
}
function ude(e, t, n, r) {
  const i = r - t, o = n - t, a = isFinite(i) || isFinite(o) ? i / o : Math.sign(i) / Math.sign(o);
  return isNaN(a) ? e : e + a - 0.5;
}
function Kst(e) {
  return e[0];
}
function Zst(e) {
  return e[1];
}
function Jst() {
  return 1;
}
function eut() {
  var e = Kst, t = Zst, n = Jst, r = 960, i = 500, o = 20, a = 2, s = o * 3, u = r + s * 2 >> a, l = i + s * 2 >> a, f = cx(20);
  function h(C) {
    var A = new Float32Array(u * l), O = Math.pow(2, -a), R = -1;
    for (const K of C) {
      var j = (e(K, ++R, C) + s) * O, $ = (t(K, R, C) + s) * O, z = +n(K, R, C);
      if (z && j >= 0 && j < u && $ >= 0 && $ < l) {
        var W = Math.floor(j), Y = Math.floor($), V = j - W - 0.5, ee = $ - Y - 0.5;
        A[W + Y * u] += (1 - V) * (1 - ee) * z, A[W + 1 + Y * u] += V * (1 - ee) * z, A[W + 1 + (Y + 1) * u] += V * ee * z, A[W + (Y + 1) * u] += (1 - V) * ee * z;
      }
    }
    return o_e({ data: A, width: u, height: l }, o * O), A;
  }
  function p(C) {
    var A = h(C), O = f(A), R = Math.pow(2, 2 * a);
    return Array.isArray(O) || (O = Kx(Number.MIN_VALUE, Ha(A) / R, O)), Pq().size([u, l]).thresholds(O.map((j) => j * R))(A).map((j, $) => (j.value = +O[$], g(j)));
  }
  p.contours = function(C) {
    var A = h(C), O = Pq().size([u, l]), R = Math.pow(2, 2 * a), j = ($) => {
      $ = +$;
      var z = g(O.contour(A, $ * R));
      return z.value = $, z;
    };
    return Object.defineProperty(j, "max", { get: () => Ha(A) / R }), j;
  };
  function g(C) {
    return C.coordinates.forEach(y), C;
  }
  function y(C) {
    C.forEach(b);
  }
  function b(C) {
    C.forEach(_);
  }
  function _(C) {
    C[0] = C[0] * Math.pow(2, a) - s, C[1] = C[1] * Math.pow(2, a) - s;
  }
  function S() {
    return s = o * 3, u = r + s * 2 >> a, l = i + s * 2 >> a, p;
  }
  return p.x = function(C) {
    return arguments.length ? (e = typeof C == "function" ? C : cx(+C), p) : e;
  }, p.y = function(C) {
    return arguments.length ? (t = typeof C == "function" ? C : cx(+C), p) : t;
  }, p.weight = function(C) {
    return arguments.length ? (n = typeof C == "function" ? C : cx(+C), p) : n;
  }, p.size = function(C) {
    if (!arguments.length)
      return [r, i];
    var A = +C[0], O = +C[1];
    if (!(A >= 0 && O >= 0))
      throw new Error("invalid size");
    return r = A, i = O, S();
  }, p.cellSize = function(C) {
    if (!arguments.length)
      return 1 << a;
    if (!((C = +C) >= 1))
      throw new Error("invalid cell size");
    return a = Math.floor(Math.log(C) / Math.LN2), S();
  }, p.thresholds = function(C) {
    return arguments.length ? (f = typeof C == "function" ? C : Array.isArray(C) ? cx(dEe.call(C)) : cx(C), p) : f;
  }, p.bandwidth = function(C) {
    if (!arguments.length)
      return Math.sqrt(o * (o + 1));
    if (!((C = +C) >= 0))
      throw new Error("invalid bandwidth");
    return o = (Math.sqrt(4 * C * C + 1) - 1) / 2, S();
  }, p;
}
const K0 = 11102230246251565e-32, Rl = 134217729, tut = (3 + 8 * K0) * K0;
function lH(e, t, n, r, i) {
  let o, a, s, u, l = t[0], f = r[0], h = 0, p = 0;
  f > l == f > -l ? (o = l, l = t[++h]) : (o = f, f = r[++p]);
  let g = 0;
  if (h < e && p < n)
    for (f > l == f > -l ? (a = l + o, s = o - (a - l), l = t[++h]) : (a = f + o, s = o - (a - f), f = r[++p]), o = a, s !== 0 && (i[g++] = s); h < e && p < n; )
      f > l == f > -l ? (a = o + l, u = a - o, s = o - (a - u) + (l - u), l = t[++h]) : (a = o + f, u = a - o, s = o - (a - u) + (f - u), f = r[++p]), o = a, s !== 0 && (i[g++] = s);
  for (; h < e; )
    a = o + l, u = a - o, s = o - (a - u) + (l - u), l = t[++h], o = a, s !== 0 && (i[g++] = s);
  for (; p < n; )
    a = o + f, u = a - o, s = o - (a - u) + (f - u), f = r[++p], o = a, s !== 0 && (i[g++] = s);
  return (o !== 0 || g === 0) && (i[g++] = o), g;
}
function nut(e, t) {
  let n = t[0];
  for (let r = 1; r < e; r++)
    n += t[r];
  return n;
}
function D$(e) {
  return new Float64Array(e);
}
const rut = (3 + 16 * K0) * K0, iut = (2 + 12 * K0) * K0, out = (9 + 64 * K0) * K0 * K0, zM = D$(4), lde = D$(8), cde = D$(12), fde = D$(16), mc = D$(4);
function aut(e, t, n, r, i, o, a) {
  let s, u, l, f, h, p, g, y, b, _, S, C, A, O, R, j, $, z;
  const W = e - i, Y = n - i, V = t - o, ee = r - o;
  O = W * ee, p = Rl * W, g = p - (p - W), y = W - g, p = Rl * ee, b = p - (p - ee), _ = ee - b, R = y * _ - (O - g * b - y * b - g * _), j = V * Y, p = Rl * V, g = p - (p - V), y = V - g, p = Rl * Y, b = p - (p - Y), _ = Y - b, $ = y * _ - (j - g * b - y * b - g * _), S = R - $, h = R - S, zM[0] = R - (S + h) + (h - $), C = O + S, h = C - O, A = O - (C - h) + (S - h), S = A - j, h = A - S, zM[1] = A - (S + h) + (h - j), z = C + S, h = z - C, zM[2] = C - (z - h) + (S - h), zM[3] = z;
  let K = nut(4, zM), Q = iut * a;
  if (K >= Q || -K >= Q || (h = e - W, s = e - (W + h) + (h - i), h = n - Y, l = n - (Y + h) + (h - i), h = t - V, u = t - (V + h) + (h - o), h = r - ee, f = r - (ee + h) + (h - o), s === 0 && u === 0 && l === 0 && f === 0) || (Q = out * a + tut * Math.abs(K), K += W * f + ee * s - (V * l + Y * u), K >= Q || -K >= Q))
    return K;
  O = s * ee, p = Rl * s, g = p - (p - s), y = s - g, p = Rl * ee, b = p - (p - ee), _ = ee - b, R = y * _ - (O - g * b - y * b - g * _), j = u * Y, p = Rl * u, g = p - (p - u), y = u - g, p = Rl * Y, b = p - (p - Y), _ = Y - b, $ = y * _ - (j - g * b - y * b - g * _), S = R - $, h = R - S, mc[0] = R - (S + h) + (h - $), C = O + S, h = C - O, A = O - (C - h) + (S - h), S = A - j, h = A - S, mc[1] = A - (S + h) + (h - j), z = C + S, h = z - C, mc[2] = C - (z - h) + (S - h), mc[3] = z;
  const q = lH(4, zM, 4, mc, lde);
  O = W * f, p = Rl * W, g = p - (p - W), y = W - g, p = Rl * f, b = p - (p - f), _ = f - b, R = y * _ - (O - g * b - y * b - g * _), j = V * l, p = Rl * V, g = p - (p - V), y = V - g, p = Rl * l, b = p - (p - l), _ = l - b, $ = y * _ - (j - g * b - y * b - g * _), S = R - $, h = R - S, mc[0] = R - (S + h) + (h - $), C = O + S, h = C - O, A = O - (C - h) + (S - h), S = A - j, h = A - S, mc[1] = A - (S + h) + (h - j), z = C + S, h = z - C, mc[2] = C - (z - h) + (S - h), mc[3] = z;
  const te = lH(q, lde, 4, mc, cde);
  O = s * f, p = Rl * s, g = p - (p - s), y = s - g, p = Rl * f, b = p - (p - f), _ = f - b, R = y * _ - (O - g * b - y * b - g * _), j = u * l, p = Rl * u, g = p - (p - u), y = u - g, p = Rl * l, b = p - (p - l), _ = l - b, $ = y * _ - (j - g * b - y * b - g * _), S = R - $, h = R - S, mc[0] = R - (S + h) + (h - $), C = O + S, h = C - O, A = O - (C - h) + (S - h), S = A - j, h = A - S, mc[1] = A - (S + h) + (h - j), z = C + S, h = z - C, mc[2] = C - (z - h) + (S - h), mc[3] = z;
  const X = lH(te, cde, 4, mc, fde);
  return fde[X - 1];
}
function VI(e, t, n, r, i, o) {
  const a = (t - o) * (n - i), s = (e - i) * (r - o), u = a - s, l = Math.abs(a + s);
  return Math.abs(u) >= rut * l ? u : -aut(e, t, n, r, i, o, l);
}
const dde = Math.pow(2, -52), WI = new Uint32Array(512);
class yL {
  static from(t, n = fut, r = dut) {
    const i = t.length, o = new Float64Array(i * 2);
    for (let a = 0; a < i; a++) {
      const s = t[a];
      o[2 * a] = n(s), o[2 * a + 1] = r(s);
    }
    return new yL(o);
  }
  constructor(t) {
    const n = t.length >> 1;
    if (n > 0 && typeof t[0] != "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const r = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(r * 3), this._halfedges = new Int32Array(r * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: t, _hullPrev: n, _hullNext: r, _hullTri: i, _hullHash: o } = this, a = t.length >> 1;
    let s = 1 / 0, u = 1 / 0, l = -1 / 0, f = -1 / 0;
    for (let Y = 0; Y < a; Y++) {
      const V = t[2 * Y], ee = t[2 * Y + 1];
      V < s && (s = V), ee < u && (u = ee), V > l && (l = V), ee > f && (f = ee), this._ids[Y] = Y;
    }
    const h = (s + l) / 2, p = (u + f) / 2;
    let g = 1 / 0, y, b, _;
    for (let Y = 0; Y < a; Y++) {
      const V = cH(h, p, t[2 * Y], t[2 * Y + 1]);
      V < g && (y = Y, g = V);
    }
    const S = t[2 * y], C = t[2 * y + 1];
    g = 1 / 0;
    for (let Y = 0; Y < a; Y++) {
      if (Y === y)
        continue;
      const V = cH(S, C, t[2 * Y], t[2 * Y + 1]);
      V < g && V > 0 && (b = Y, g = V);
    }
    let A = t[2 * b], O = t[2 * b + 1], R = 1 / 0;
    for (let Y = 0; Y < a; Y++) {
      if (Y === y || Y === b)
        continue;
      const V = lut(S, C, A, O, t[2 * Y], t[2 * Y + 1]);
      V < R && (_ = Y, R = V);
    }
    let j = t[2 * _], $ = t[2 * _ + 1];
    if (R === 1 / 0) {
      for (let ee = 0; ee < a; ee++)
        this._dists[ee] = t[2 * ee] - t[0] || t[2 * ee + 1] - t[1];
      dT(this._ids, this._dists, 0, a - 1);
      const Y = new Uint32Array(a);
      let V = 0;
      for (let ee = 0, K = -1 / 0; ee < a; ee++) {
        const Q = this._ids[ee];
        this._dists[Q] > K && (Y[V++] = Q, K = this._dists[Q]);
      }
      this.hull = Y.subarray(0, V), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (VI(S, C, A, O, j, $) < 0) {
      const Y = b, V = A, ee = O;
      b = _, A = j, O = $, _ = Y, j = V, $ = ee;
    }
    const z = cut(S, C, A, O, j, $);
    this._cx = z.x, this._cy = z.y;
    for (let Y = 0; Y < a; Y++)
      this._dists[Y] = cH(t[2 * Y], t[2 * Y + 1], z.x, z.y);
    dT(this._ids, this._dists, 0, a - 1), this._hullStart = y;
    let W = 3;
    r[y] = n[_] = b, r[b] = n[y] = _, r[_] = n[b] = y, i[y] = 0, i[b] = 1, i[_] = 2, o.fill(-1), o[this._hashKey(S, C)] = y, o[this._hashKey(A, O)] = b, o[this._hashKey(j, $)] = _, this.trianglesLen = 0, this._addTriangle(y, b, _, -1, -1, -1);
    for (let Y = 0, V, ee; Y < this._ids.length; Y++) {
      const K = this._ids[Y], Q = t[2 * K], q = t[2 * K + 1];
      if (Y > 0 && Math.abs(Q - V) <= dde && Math.abs(q - ee) <= dde || (V = Q, ee = q, K === y || K === b || K === _))
        continue;
      let te = 0;
      for (let ie = 0, he = this._hashKey(Q, q); ie < this._hashSize && (te = o[(he + ie) % this._hashSize], !(te !== -1 && te !== r[te])); ie++)
        ;
      te = n[te];
      let X = te, Z;
      for (; Z = r[X], VI(Q, q, t[2 * X], t[2 * X + 1], t[2 * Z], t[2 * Z + 1]) >= 0; )
        if (X = Z, X === te) {
          X = -1;
          break;
        }
      if (X === -1)
        continue;
      let se = this._addTriangle(X, K, r[X], -1, -1, i[X]);
      i[K] = this._legalize(se + 2), i[X] = se, W++;
      let H = r[X];
      for (; Z = r[H], VI(Q, q, t[2 * H], t[2 * H + 1], t[2 * Z], t[2 * Z + 1]) < 0; )
        se = this._addTriangle(H, K, Z, i[K], -1, i[H]), i[K] = this._legalize(se + 2), r[H] = H, W--, H = Z;
      if (X === te)
        for (; Z = n[X], VI(Q, q, t[2 * Z], t[2 * Z + 1], t[2 * X], t[2 * X + 1]) < 0; )
          se = this._addTriangle(Z, K, X, -1, i[X], i[Z]), this._legalize(se + 2), i[Z] = se, r[X] = X, W--, X = Z;
      this._hullStart = n[K] = X, r[X] = n[H] = K, r[K] = H, o[this._hashKey(Q, q)] = K, o[this._hashKey(t[2 * X], t[2 * X + 1])] = X;
    }
    this.hull = new Uint32Array(W);
    for (let Y = 0, V = this._hullStart; Y < W; Y++)
      this.hull[Y] = V, V = r[V];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, n) {
    return Math.floor(sut(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: n, _halfedges: r, coords: i } = this;
    let o = 0, a = 0;
    for (; ; ) {
      const s = r[t], u = t - t % 3;
      if (a = u + (t + 2) % 3, s === -1) {
        if (o === 0)
          break;
        t = WI[--o];
        continue;
      }
      const l = s - s % 3, f = u + (t + 1) % 3, h = l + (s + 2) % 3, p = n[a], g = n[t], y = n[f], b = n[h];
      if (uut(
        i[2 * p],
        i[2 * p + 1],
        i[2 * g],
        i[2 * g + 1],
        i[2 * y],
        i[2 * y + 1],
        i[2 * b],
        i[2 * b + 1]
      )) {
        n[t] = b, n[s] = p;
        const S = r[h];
        if (S === -1) {
          let A = this._hullStart;
          do {
            if (this._hullTri[A] === h) {
              this._hullTri[A] = t;
              break;
            }
            A = this._hullPrev[A];
          } while (A !== this._hullStart);
        }
        this._link(t, S), this._link(s, r[a]), this._link(a, h);
        const C = l + (s + 1) % 3;
        o < WI.length && (WI[o++] = C);
      } else {
        if (o === 0)
          break;
        t = WI[--o];
      }
    }
    return a;
  }
  _link(t, n) {
    this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(t, n, r, i, o, a) {
    const s = this.trianglesLen;
    return this._triangles[s] = t, this._triangles[s + 1] = n, this._triangles[s + 2] = r, this._link(s, i), this._link(s + 1, o), this._link(s + 2, a), this.trianglesLen += 3, s;
  }
}
function sut(e, t) {
  const n = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - n : 1 + n) / 4;
}
function cH(e, t, n, r) {
  const i = e - n, o = t - r;
  return i * i + o * o;
}
function uut(e, t, n, r, i, o, a, s) {
  const u = e - a, l = t - s, f = n - a, h = r - s, p = i - a, g = o - s, y = u * u + l * l, b = f * f + h * h, _ = p * p + g * g;
  return u * (h * _ - b * g) - l * (f * _ - b * p) + y * (f * g - h * p) < 0;
}
function lut(e, t, n, r, i, o) {
  const a = n - e, s = r - t, u = i - e, l = o - t, f = a * a + s * s, h = u * u + l * l, p = 0.5 / (a * l - s * u), g = (l * f - s * h) * p, y = (a * h - u * f) * p;
  return g * g + y * y;
}
function cut(e, t, n, r, i, o) {
  const a = n - e, s = r - t, u = i - e, l = o - t, f = a * a + s * s, h = u * u + l * l, p = 0.5 / (a * l - s * u), g = e + (l * f - s * h) * p, y = t + (a * h - u * f) * p;
  return { x: g, y };
}
function dT(e, t, n, r) {
  if (r - n <= 20)
    for (let i = n + 1; i <= r; i++) {
      const o = e[i], a = t[o];
      let s = i - 1;
      for (; s >= n && t[e[s]] > a; )
        e[s + 1] = e[s--];
      e[s + 1] = o;
    }
  else {
    const i = n + r >> 1;
    let o = n + 1, a = r;
    VA(e, i, o), t[e[n]] > t[e[r]] && VA(e, n, r), t[e[o]] > t[e[r]] && VA(e, o, r), t[e[n]] > t[e[o]] && VA(e, n, o);
    const s = e[o], u = t[s];
    for (; ; ) {
      do
        o++;
      while (t[e[o]] < u);
      do
        a--;
      while (t[e[a]] > u);
      if (a < o)
        break;
      VA(e, o, a);
    }
    e[n + 1] = e[a], e[a] = s, r - o + 1 >= a - n ? (dT(e, t, o, r), dT(e, t, n, a - 1)) : (dT(e, t, n, a - 1), dT(e, t, o, r));
  }
}
function VA(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function fut(e) {
  return e[0];
}
function dut(e) {
  return e[1];
}
const hde = 1e-6;
class UE {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, n) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, n) {
    this._ += `L${this._x1 = +t},${this._y1 = +n}`;
  }
  arc(t, n, r) {
    t = +t, n = +n, r = +r;
    const i = t + r, o = n;
    if (r < 0)
      throw new Error("negative radius");
    this._x1 === null ? this._ += `M${i},${o}` : (Math.abs(this._x1 - i) > hde || Math.abs(this._y1 - o) > hde) && (this._ += "L" + i + "," + o), r && (this._ += `A${r},${r},0,1,1,${t - r},${n}A${r},${r},0,1,1,${this._x1 = i},${this._y1 = o}`);
  }
  rect(t, n, r, i) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+r}v${+i}h${-r}Z`;
  }
  value() {
    return this._ || null;
  }
}
class Iq {
  constructor() {
    this._ = [];
  }
  moveTo(t, n) {
    this._.push([t, n]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, n) {
    this._.push([t, n]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
let hut = class {
  constructor(t, [n, r, i, o] = [0, 0, 960, 500]) {
    if (!((i = +i) >= (n = +n)) || !((o = +o) >= (r = +r)))
      throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = i, this.xmin = n, this.ymax = o, this.ymin = r, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: n, triangles: r }, vectors: i } = this;
    let o, a;
    const s = this.circumcenters = this._circumcenters.subarray(0, r.length / 3 * 2);
    for (let b = 0, _ = 0, S = r.length, C, A; b < S; b += 3, _ += 2) {
      const O = r[b] * 2, R = r[b + 1] * 2, j = r[b + 2] * 2, $ = t[O], z = t[O + 1], W = t[R], Y = t[R + 1], V = t[j], ee = t[j + 1], K = W - $, Q = Y - z, q = V - $, te = ee - z, X = (K * te - Q * q) * 2;
      if (Math.abs(X) < 1e-9) {
        if (o === void 0) {
          o = a = 0;
          for (const se of n)
            o += t[se * 2], a += t[se * 2 + 1];
          o /= n.length, a /= n.length;
        }
        const Z = 1e9 * Math.sign((o - $) * te - (a - z) * q);
        C = ($ + V) / 2 - Z * te, A = (z + ee) / 2 + Z * q;
      } else {
        const Z = 1 / X, se = K * K + Q * Q, H = q * q + te * te;
        C = $ + (te * se - Q * H) * Z, A = z + (K * H - q * se) * Z;
      }
      s[_] = C, s[_ + 1] = A;
    }
    let u = n[n.length - 1], l, f = u * 4, h, p = t[2 * u], g, y = t[2 * u + 1];
    i.fill(0);
    for (let b = 0; b < n.length; ++b)
      u = n[b], l = f, h = p, g = y, f = u * 4, p = t[2 * u], y = t[2 * u + 1], i[l + 2] = i[f] = g - y, i[l + 3] = i[f + 1] = p - h;
  }
  render(t) {
    const n = t == null ? t = new UE() : void 0, { delaunay: { halfedges: r, inedges: i, hull: o }, circumcenters: a, vectors: s } = this;
    if (o.length <= 1)
      return null;
    for (let f = 0, h = r.length; f < h; ++f) {
      const p = r[f];
      if (p < f)
        continue;
      const g = Math.floor(f / 3) * 2, y = Math.floor(p / 3) * 2, b = a[g], _ = a[g + 1], S = a[y], C = a[y + 1];
      this._renderSegment(b, _, S, C, t);
    }
    let u, l = o[o.length - 1];
    for (let f = 0; f < o.length; ++f) {
      u = l, l = o[f];
      const h = Math.floor(i[l] / 3) * 2, p = a[h], g = a[h + 1], y = u * 4, b = this._project(p, g, s[y + 2], s[y + 3]);
      b && this._renderSegment(p, g, b[0], b[1], t);
    }
    return n && n.value();
  }
  renderBounds(t) {
    const n = t == null ? t = new UE() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
  }
  renderCell(t, n) {
    const r = n == null ? n = new UE() : void 0, i = this._clip(t);
    if (i === null || !i.length)
      return;
    n.moveTo(i[0], i[1]);
    let o = i.length;
    for (; i[0] === i[o - 2] && i[1] === i[o - 1] && o > 1; )
      o -= 2;
    for (let a = 2; a < o; a += 2)
      (i[a] !== i[a - 2] || i[a + 1] !== i[a - 1]) && n.lineTo(i[a], i[a + 1]);
    return n.closePath(), r && r.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let n = 0, r = t.length / 2; n < r; ++n) {
      const i = this.cellPolygon(n);
      i && (i.index = n, yield i);
    }
  }
  cellPolygon(t) {
    const n = new Iq();
    return this.renderCell(t, n), n.value();
  }
  _renderSegment(t, n, r, i, o) {
    let a;
    const s = this._regioncode(t, n), u = this._regioncode(r, i);
    s === 0 && u === 0 ? (o.moveTo(t, n), o.lineTo(r, i)) : (a = this._clipSegment(t, n, r, i, s, u)) && (o.moveTo(a[0], a[1]), o.lineTo(a[2], a[3]));
  }
  contains(t, n, r) {
    return n = +n, n !== n || (r = +r, r !== r) ? !1 : this.delaunay._step(t, n, r) === t;
  }
  *neighbors(t) {
    const n = this._clip(t);
    if (n)
      for (const r of this.delaunay.neighbors(t)) {
        const i = this._clip(r);
        if (i) {
          e:
            for (let o = 0, a = n.length; o < a; o += 2)
              for (let s = 0, u = i.length; s < u; s += 2)
                if (n[o] === i[s] && n[o + 1] === i[s + 1] && n[(o + 2) % a] === i[(s + u - 2) % u] && n[(o + 3) % a] === i[(s + u - 1) % u]) {
                  yield r;
                  break e;
                }
        }
      }
  }
  _cell(t) {
    const { circumcenters: n, delaunay: { inedges: r, halfedges: i, triangles: o } } = this, a = r[t];
    if (a === -1)
      return null;
    const s = [];
    let u = a;
    do {
      const l = Math.floor(u / 3);
      if (s.push(n[l * 2], n[l * 2 + 1]), u = u % 3 === 2 ? u - 2 : u + 1, o[u] !== t)
        break;
      u = i[u];
    } while (u !== a && u !== -1);
    return s;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const n = this._cell(t);
    if (n === null)
      return null;
    const { vectors: r } = this, i = t * 4;
    return this._simplify(r[i] || r[i + 1] ? this._clipInfinite(t, n, r[i], r[i + 1], r[i + 2], r[i + 3]) : this._clipFinite(t, n));
  }
  _clipFinite(t, n) {
    const r = n.length;
    let i = null, o, a, s = n[r - 2], u = n[r - 1], l, f = this._regioncode(s, u), h, p = 0;
    for (let g = 0; g < r; g += 2)
      if (o = s, a = u, s = n[g], u = n[g + 1], l = f, f = this._regioncode(s, u), l === 0 && f === 0)
        h = p, p = 0, i ? i.push(s, u) : i = [s, u];
      else {
        let y, b, _, S, C;
        if (l === 0) {
          if ((y = this._clipSegment(o, a, s, u, l, f)) === null)
            continue;
          [b, _, S, C] = y;
        } else {
          if ((y = this._clipSegment(s, u, o, a, f, l)) === null)
            continue;
          [S, C, b, _] = y, h = p, p = this._edgecode(b, _), h && p && this._edge(t, h, p, i, i.length), i ? i.push(b, _) : i = [b, _];
        }
        h = p, p = this._edgecode(S, C), h && p && this._edge(t, h, p, i, i.length), i ? i.push(S, C) : i = [S, C];
      }
    if (i)
      h = p, p = this._edgecode(i[0], i[1]), h && p && this._edge(t, h, p, i, i.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return i;
  }
  _clipSegment(t, n, r, i, o, a) {
    const s = o < a;
    for (s && ([t, n, r, i, o, a] = [r, i, t, n, a, o]); ; ) {
      if (o === 0 && a === 0)
        return s ? [r, i, t, n] : [t, n, r, i];
      if (o & a)
        return null;
      let u, l, f = o || a;
      f & 8 ? (u = t + (r - t) * (this.ymax - n) / (i - n), l = this.ymax) : f & 4 ? (u = t + (r - t) * (this.ymin - n) / (i - n), l = this.ymin) : f & 2 ? (l = n + (i - n) * (this.xmax - t) / (r - t), u = this.xmax) : (l = n + (i - n) * (this.xmin - t) / (r - t), u = this.xmin), o ? (t = u, n = l, o = this._regioncode(t, n)) : (r = u, i = l, a = this._regioncode(r, i));
    }
  }
  _clipInfinite(t, n, r, i, o, a) {
    let s = Array.from(n), u;
    if ((u = this._project(s[0], s[1], r, i)) && s.unshift(u[0], u[1]), (u = this._project(s[s.length - 2], s[s.length - 1], o, a)) && s.push(u[0], u[1]), s = this._clipFinite(t, s))
      for (let l = 0, f = s.length, h, p = this._edgecode(s[f - 2], s[f - 1]); l < f; l += 2)
        h = p, p = this._edgecode(s[l], s[l + 1]), h && p && (l = this._edge(t, h, p, s, l), f = s.length);
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (s = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return s;
  }
  _edge(t, n, r, i, o) {
    for (; n !== r; ) {
      let a, s;
      switch (n) {
        case 5:
          n = 4;
          continue;
        case 4:
          n = 6, a = this.xmax, s = this.ymin;
          break;
        case 6:
          n = 2;
          continue;
        case 2:
          n = 10, a = this.xmax, s = this.ymax;
          break;
        case 10:
          n = 8;
          continue;
        case 8:
          n = 9, a = this.xmin, s = this.ymax;
          break;
        case 9:
          n = 1;
          continue;
        case 1:
          n = 5, a = this.xmin, s = this.ymin;
          break;
      }
      (i[o] !== a || i[o + 1] !== s) && this.contains(t, a, s) && (i.splice(o, 0, a, s), o += 2);
    }
    return o;
  }
  _project(t, n, r, i) {
    let o = 1 / 0, a, s, u;
    if (i < 0) {
      if (n <= this.ymin)
        return null;
      (a = (this.ymin - n) / i) < o && (u = this.ymin, s = t + (o = a) * r);
    } else if (i > 0) {
      if (n >= this.ymax)
        return null;
      (a = (this.ymax - n) / i) < o && (u = this.ymax, s = t + (o = a) * r);
    }
    if (r > 0) {
      if (t >= this.xmax)
        return null;
      (a = (this.xmax - t) / r) < o && (s = this.xmax, u = n + (o = a) * i);
    } else if (r < 0) {
      if (t <= this.xmin)
        return null;
      (a = (this.xmin - t) / r) < o && (s = this.xmin, u = n + (o = a) * i);
    }
    return [s, u];
  }
  _edgecode(t, n) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
  }
  _regioncode(t, n) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let n = 0; n < t.length; n += 2) {
        const r = (n + 2) % t.length, i = (n + 4) % t.length;
        (t[n] === t[r] && t[r] === t[i] || t[n + 1] === t[r + 1] && t[r + 1] === t[i + 1]) && (t.splice(r, 2), n -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
};
const put = 2 * Math.PI, FM = Math.pow;
function gut(e) {
  return e[0];
}
function mut(e) {
  return e[1];
}
function yut(e) {
  const { triangles: t, coords: n } = e;
  for (let r = 0; r < t.length; r += 3) {
    const i = 2 * t[r], o = 2 * t[r + 1], a = 2 * t[r + 2];
    if ((n[a] - n[i]) * (n[o + 1] - n[i + 1]) - (n[o] - n[i]) * (n[a + 1] - n[i + 1]) > 1e-10)
      return !1;
  }
  return !0;
}
function vut(e, t, n) {
  return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
}
class wb {
  static from(t, n = gut, r = mut, i) {
    return new wb("length" in t ? but(t, n, r, i) : Float64Array.from(xut(t, n, r, i)));
  }
  constructor(t) {
    this._delaunator = new yL(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, n = this.points;
    if (t.hull && t.hull.length > 2 && yut(t)) {
      this.collinear = Int32Array.from({ length: n.length / 2 }, (p, g) => g).sort((p, g) => n[2 * p] - n[2 * g] || n[2 * p + 1] - n[2 * g + 1]);
      const u = this.collinear[0], l = this.collinear[this.collinear.length - 1], f = [n[2 * u], n[2 * u + 1], n[2 * l], n[2 * l + 1]], h = 1e-8 * Math.hypot(f[3] - f[1], f[2] - f[0]);
      for (let p = 0, g = n.length / 2; p < g; ++p) {
        const y = vut(n[2 * p], n[2 * p + 1], h);
        n[2 * p] = y[0], n[2 * p + 1] = y[1];
      }
      this._delaunator = new yL(n);
    } else
      delete this.collinear;
    const r = this.halfedges = this._delaunator.halfedges, i = this.hull = this._delaunator.hull, o = this.triangles = this._delaunator.triangles, a = this.inedges.fill(-1), s = this._hullIndex.fill(-1);
    for (let u = 0, l = r.length; u < l; ++u) {
      const f = o[u % 3 === 2 ? u - 2 : u + 1];
      (r[u] === -1 || a[f] === -1) && (a[f] = u);
    }
    for (let u = 0, l = i.length; u < l; ++u)
      s[i[u]] = u;
    i.length <= 2 && i.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = i[0], a[i[0]] = 1, i.length === 2 && (a[i[1]] = 0, this.triangles[1] = i[1], this.triangles[2] = i[1]));
  }
  voronoi(t) {
    return new hut(this, t);
  }
  *neighbors(t) {
    const { inedges: n, hull: r, _hullIndex: i, halfedges: o, triangles: a, collinear: s } = this;
    if (s) {
      const h = s.indexOf(t);
      h > 0 && (yield s[h - 1]), h < s.length - 1 && (yield s[h + 1]);
      return;
    }
    const u = n[t];
    if (u === -1)
      return;
    let l = u, f = -1;
    do {
      if (yield f = a[l], l = l % 3 === 2 ? l - 2 : l + 1, a[l] !== t)
        return;
      if (l = o[l], l === -1) {
        const h = r[(i[t] + 1) % r.length];
        h !== f && (yield h);
        return;
      }
    } while (l !== u);
  }
  find(t, n, r = 0) {
    if (t = +t, t !== t || (n = +n, n !== n))
      return -1;
    const i = r;
    let o;
    for (; (o = this._step(r, t, n)) >= 0 && o !== r && o !== i; )
      r = o;
    return o;
  }
  _step(t, n, r) {
    const { inedges: i, hull: o, _hullIndex: a, halfedges: s, triangles: u, points: l } = this;
    if (i[t] === -1 || !l.length)
      return (t + 1) % (l.length >> 1);
    let f = t, h = FM(n - l[t * 2], 2) + FM(r - l[t * 2 + 1], 2);
    const p = i[t];
    let g = p;
    do {
      let y = u[g];
      const b = FM(n - l[y * 2], 2) + FM(r - l[y * 2 + 1], 2);
      if (b < h && (h = b, f = y), g = g % 3 === 2 ? g - 2 : g + 1, u[g] !== t)
        break;
      if (g = s[g], g === -1) {
        if (g = o[(a[t] + 1) % o.length], g !== y && FM(n - l[g * 2], 2) + FM(r - l[g * 2 + 1], 2) < h)
          return g;
        break;
      }
    } while (g !== p);
    return f;
  }
  render(t) {
    const n = t == null ? t = new UE() : void 0, { points: r, halfedges: i, triangles: o } = this;
    for (let a = 0, s = i.length; a < s; ++a) {
      const u = i[a];
      if (u < a)
        continue;
      const l = o[a] * 2, f = o[u] * 2;
      t.moveTo(r[l], r[l + 1]), t.lineTo(r[f], r[f + 1]);
    }
    return this.renderHull(t), n && n.value();
  }
  renderPoints(t, n) {
    n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
    const r = t == null ? t = new UE() : void 0, { points: i } = this;
    for (let o = 0, a = i.length; o < a; o += 2) {
      const s = i[o], u = i[o + 1];
      t.moveTo(s + n, u), t.arc(s, u, n, 0, put);
    }
    return r && r.value();
  }
  renderHull(t) {
    const n = t == null ? t = new UE() : void 0, { hull: r, points: i } = this, o = r[0] * 2, a = r.length;
    t.moveTo(i[o], i[o + 1]);
    for (let s = 1; s < a; ++s) {
      const u = 2 * r[s];
      t.lineTo(i[u], i[u + 1]);
    }
    return t.closePath(), n && n.value();
  }
  hullPolygon() {
    const t = new Iq();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, n) {
    const r = n == null ? n = new UE() : void 0, { points: i, triangles: o } = this, a = o[t *= 3] * 2, s = o[t + 1] * 2, u = o[t + 2] * 2;
    return n.moveTo(i[a], i[a + 1]), n.lineTo(i[s], i[s + 1]), n.lineTo(i[u], i[u + 1]), n.closePath(), r && r.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let n = 0, r = t.length / 3; n < r; ++n)
      yield this.trianglePolygon(n);
  }
  trianglePolygon(t) {
    const n = new Iq();
    return this.renderTriangle(t, n), n.value();
  }
}
function but(e, t, n, r) {
  const i = e.length, o = new Float64Array(i * 2);
  for (let a = 0; a < i; ++a) {
    const s = e[a];
    o[a * 2] = t.call(r, s, a, e), o[a * 2 + 1] = n.call(r, s, a, e);
  }
  return o;
}
function* xut(e, t, n, r) {
  let i = 0;
  for (const o of e)
    yield t.call(r, o, i, e), yield n.call(r, o, i, e), ++i;
}
var pde = {}, fH = {}, dH = 34, WA = 10, hH = 13;
function hEe(e) {
  return new Function("d", "return {" + e.map(function(t, n) {
    return JSON.stringify(t) + ": d[" + n + '] || ""';
  }).join(",") + "}");
}
function wut(e, t) {
  var n = hEe(e);
  return function(r, i) {
    return t(n(r), i, e);
  };
}
function gde(e) {
  var t = /* @__PURE__ */ Object.create(null), n = [];
  return e.forEach(function(r) {
    for (var i in r)
      i in t || n.push(t[i] = i);
  }), n;
}
function df(e, t) {
  var n = e + "", r = n.length;
  return r < t ? new Array(t - r + 1).join(0) + n : n;
}
function _ut(e) {
  return e < 0 ? "-" + df(-e, 6) : e > 9999 ? "+" + df(e, 6) : df(e, 4);
}
function Eut(e) {
  var t = e.getUTCHours(), n = e.getUTCMinutes(), r = e.getUTCSeconds(), i = e.getUTCMilliseconds();
  return isNaN(e) ? "Invalid Date" : _ut(e.getUTCFullYear()) + "-" + df(e.getUTCMonth() + 1, 2) + "-" + df(e.getUTCDate(), 2) + (i ? "T" + df(t, 2) + ":" + df(n, 2) + ":" + df(r, 2) + "." + df(i, 3) + "Z" : r ? "T" + df(t, 2) + ":" + df(n, 2) + ":" + df(r, 2) + "Z" : n || t ? "T" + df(t, 2) + ":" + df(n, 2) + "Z" : "");
}
function Sut(e) {
  var t = new RegExp('["' + e + `
\r]`), n = e.charCodeAt(0);
  function r(h, p) {
    var g, y, b = i(h, function(_, S) {
      if (g)
        return g(_, S - 1);
      y = _, g = p ? wut(_, p) : hEe(_);
    });
    return b.columns = y || [], b;
  }
  function i(h, p) {
    var g = [], y = h.length, b = 0, _ = 0, S, C = y <= 0, A = !1;
    h.charCodeAt(y - 1) === WA && --y, h.charCodeAt(y - 1) === hH && --y;
    function O() {
      if (C)
        return fH;
      if (A)
        return A = !1, pde;
      var j, $ = b, z;
      if (h.charCodeAt($) === dH) {
        for (; b++ < y && h.charCodeAt(b) !== dH || h.charCodeAt(++b) === dH; )
          ;
        return (j = b) >= y ? C = !0 : (z = h.charCodeAt(b++)) === WA ? A = !0 : z === hH && (A = !0, h.charCodeAt(b) === WA && ++b), h.slice($ + 1, j - 1).replace(/""/g, '"');
      }
      for (; b < y; ) {
        if ((z = h.charCodeAt(j = b++)) === WA)
          A = !0;
        else if (z === hH)
          A = !0, h.charCodeAt(b) === WA && ++b;
        else if (z !== n)
          continue;
        return h.slice($, j);
      }
      return C = !0, h.slice($, y);
    }
    for (; (S = O()) !== fH; ) {
      for (var R = []; S !== pde && S !== fH; )
        R.push(S), S = O();
      p && (R = p(R, _++)) == null || g.push(R);
    }
    return g;
  }
  function o(h, p) {
    return h.map(function(g) {
      return p.map(function(y) {
        return f(g[y]);
      }).join(e);
    });
  }
  function a(h, p) {
    return p == null && (p = gde(h)), [p.map(f).join(e)].concat(o(h, p)).join(`
`);
  }
  function s(h, p) {
    return p == null && (p = gde(h)), o(h, p).join(`
`);
  }
  function u(h) {
    return h.map(l).join(`
`);
  }
  function l(h) {
    return h.map(f).join(e);
  }
  function f(h) {
    return h == null ? "" : h instanceof Date ? Eut(h) : t.test(h += "") ? '"' + h.replace(/"/g, '""') + '"' : h;
  }
  return {
    parse: r,
    parseRows: i,
    format: a,
    formatBody: s,
    formatRows: u,
    formatRow: l,
    formatValue: f
  };
}
function Mut(e, t) {
  var n, r = 1;
  e == null && (e = 0), t == null && (t = 0);
  function i() {
    var o, a = n.length, s, u = 0, l = 0;
    for (o = 0; o < a; ++o)
      s = n[o], u += s.x, l += s.y;
    for (u = (u / a - e) * r, l = (l / a - t) * r, o = 0; o < a; ++o)
      s = n[o], s.x -= u, s.y -= l;
  }
  return i.initialize = function(o) {
    n = o;
  }, i.x = function(o) {
    return arguments.length ? (e = +o, i) : e;
  }, i.y = function(o) {
    return arguments.length ? (t = +o, i) : t;
  }, i.strength = function(o) {
    return arguments.length ? (r = +o, i) : r;
  }, i;
}
function Tut(e) {
  const t = +this._x.call(null, e), n = +this._y.call(null, e);
  return pEe(this.cover(t, n), t, n, e);
}
function pEe(e, t, n, r) {
  if (isNaN(t) || isNaN(n))
    return e;
  var i, o = e._root, a = { data: r }, s = e._x0, u = e._y0, l = e._x1, f = e._y1, h, p, g, y, b, _, S, C;
  if (!o)
    return e._root = a, e;
  for (; o.length; )
    if ((b = t >= (h = (s + l) / 2)) ? s = h : l = h, (_ = n >= (p = (u + f) / 2)) ? u = p : f = p, i = o, !(o = o[S = _ << 1 | b]))
      return i[S] = a, e;
  if (g = +e._x.call(null, o.data), y = +e._y.call(null, o.data), t === g && n === y)
    return a.next = o, i ? i[S] = a : e._root = a, e;
  do
    i = i ? i[S] = new Array(4) : e._root = new Array(4), (b = t >= (h = (s + l) / 2)) ? s = h : l = h, (_ = n >= (p = (u + f) / 2)) ? u = p : f = p;
  while ((S = _ << 1 | b) === (C = (y >= p) << 1 | g >= h));
  return i[C] = o, i[S] = a, e;
}
function Cut(e) {
  var t, n, r = e.length, i, o, a = new Array(r), s = new Array(r), u = 1 / 0, l = 1 / 0, f = -1 / 0, h = -1 / 0;
  for (n = 0; n < r; ++n)
    isNaN(i = +this._x.call(null, t = e[n])) || isNaN(o = +this._y.call(null, t)) || (a[n] = i, s[n] = o, i < u && (u = i), i > f && (f = i), o < l && (l = o), o > h && (h = o));
  if (u > f || l > h)
    return this;
  for (this.cover(u, l).cover(f, h), n = 0; n < r; ++n)
    pEe(this, a[n], s[n], e[n]);
  return this;
}
function Nut(e, t) {
  if (isNaN(e = +e) || isNaN(t = +t))
    return this;
  var n = this._x0, r = this._y0, i = this._x1, o = this._y1;
  if (isNaN(n))
    i = (n = Math.floor(e)) + 1, o = (r = Math.floor(t)) + 1;
  else {
    for (var a = i - n || 1, s = this._root, u, l; n > e || e >= i || r > t || t >= o; )
      switch (l = (t < r) << 1 | e < n, u = new Array(4), u[l] = s, s = u, a *= 2, l) {
        case 0:
          i = n + a, o = r + a;
          break;
        case 1:
          n = i - a, o = r + a;
          break;
        case 2:
          i = n + a, r = o - a;
          break;
        case 3:
          n = i - a, r = o - a;
          break;
      }
    this._root && this._root.length && (this._root = s);
  }
  return this._x0 = n, this._y0 = r, this._x1 = i, this._y1 = o, this;
}
function Dut() {
  var e = [];
  return this.visit(function(t) {
    if (!t.length)
      do
        e.push(t.data);
      while (t = t.next);
  }), e;
}
function Aut(e) {
  return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Cc(e, t, n, r, i) {
  this.node = e, this.x0 = t, this.y0 = n, this.x1 = r, this.y1 = i;
}
function Out(e, t, n) {
  var r, i = this._x0, o = this._y0, a, s, u, l, f = this._x1, h = this._y1, p = [], g = this._root, y, b;
  for (g && p.push(new Cc(g, i, o, f, h)), n == null ? n = 1 / 0 : (i = e - n, o = t - n, f = e + n, h = t + n, n *= n); y = p.pop(); )
    if (!(!(g = y.node) || (a = y.x0) > f || (s = y.y0) > h || (u = y.x1) < i || (l = y.y1) < o))
      if (g.length) {
        var _ = (a + u) / 2, S = (s + l) / 2;
        p.push(
          new Cc(g[3], _, S, u, l),
          new Cc(g[2], a, S, _, l),
          new Cc(g[1], _, s, u, S),
          new Cc(g[0], a, s, _, S)
        ), (b = (t >= S) << 1 | e >= _) && (y = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - b], p[p.length - 1 - b] = y);
      } else {
        var C = e - +this._x.call(null, g.data), A = t - +this._y.call(null, g.data), O = C * C + A * A;
        if (O < n) {
          var R = Math.sqrt(n = O);
          i = e - R, o = t - R, f = e + R, h = t + R, r = g.data;
        }
      }
  return r;
}
function Rut(e) {
  if (isNaN(f = +this._x.call(null, e)) || isNaN(h = +this._y.call(null, e)))
    return this;
  var t, n = this._root, r, i, o, a = this._x0, s = this._y0, u = this._x1, l = this._y1, f, h, p, g, y, b, _, S;
  if (!n)
    return this;
  if (n.length)
    for (; ; ) {
      if ((y = f >= (p = (a + u) / 2)) ? a = p : u = p, (b = h >= (g = (s + l) / 2)) ? s = g : l = g, t = n, !(n = n[_ = b << 1 | y]))
        return this;
      if (!n.length)
        break;
      (t[_ + 1 & 3] || t[_ + 2 & 3] || t[_ + 3 & 3]) && (r = t, S = _);
    }
  for (; n.data !== e; )
    if (i = n, !(n = n.next))
      return this;
  return (o = n.next) && delete n.next, i ? (o ? i.next = o : delete i.next, this) : t ? (o ? t[_] = o : delete t[_], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (r ? r[S] = n : this._root = n), this) : (this._root = o, this);
}
function kut(e) {
  for (var t = 0, n = e.length; t < n; ++t)
    this.remove(e[t]);
  return this;
}
function $ut() {
  return this._root;
}
function Put() {
  var e = 0;
  return this.visit(function(t) {
    if (!t.length)
      do
        ++e;
      while (t = t.next);
  }), e;
}
function Iut(e) {
  var t = [], n, r = this._root, i, o, a, s, u;
  for (r && t.push(new Cc(r, this._x0, this._y0, this._x1, this._y1)); n = t.pop(); )
    if (!e(r = n.node, o = n.x0, a = n.y0, s = n.x1, u = n.y1) && r.length) {
      var l = (o + s) / 2, f = (a + u) / 2;
      (i = r[3]) && t.push(new Cc(i, l, f, s, u)), (i = r[2]) && t.push(new Cc(i, o, f, l, u)), (i = r[1]) && t.push(new Cc(i, l, a, s, f)), (i = r[0]) && t.push(new Cc(i, o, a, l, f));
    }
  return this;
}
function jut(e) {
  var t = [], n = [], r;
  for (this._root && t.push(new Cc(this._root, this._x0, this._y0, this._x1, this._y1)); r = t.pop(); ) {
    var i = r.node;
    if (i.length) {
      var o, a = r.x0, s = r.y0, u = r.x1, l = r.y1, f = (a + u) / 2, h = (s + l) / 2;
      (o = i[0]) && t.push(new Cc(o, a, s, f, h)), (o = i[1]) && t.push(new Cc(o, f, s, u, h)), (o = i[2]) && t.push(new Cc(o, a, h, f, l)), (o = i[3]) && t.push(new Cc(o, f, h, u, l));
    }
    n.push(r);
  }
  for (; r = n.pop(); )
    e(r.node, r.x0, r.y0, r.x1, r.y1);
  return this;
}
function Lut(e) {
  return e[0];
}
function zut(e) {
  return arguments.length ? (this._x = e, this) : this._x;
}
function Fut(e) {
  return e[1];
}
function But(e) {
  return arguments.length ? (this._y = e, this) : this._y;
}
function iZ(e, t, n) {
  var r = new oZ(t ?? Lut, n ?? Fut, NaN, NaN, NaN, NaN);
  return e == null ? r : r.addAll(e);
}
function oZ(e, t, n, r, i, o) {
  this._x = e, this._y = t, this._x0 = n, this._y0 = r, this._x1 = i, this._y1 = o, this._root = void 0;
}
function mde(e) {
  for (var t = { data: e.data }, n = t; e = e.next; )
    n = n.next = { data: e.data };
  return t;
}
var Ic = iZ.prototype = oZ.prototype;
Ic.copy = function() {
  var e = new oZ(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t = this._root, n, r;
  if (!t)
    return e;
  if (!t.length)
    return e._root = mde(t), e;
  for (n = [{ source: t, target: e._root = new Array(4) }]; t = n.pop(); )
    for (var i = 0; i < 4; ++i)
      (r = t.source[i]) && (r.length ? n.push({ source: r, target: t.target[i] = new Array(4) }) : t.target[i] = mde(r));
  return e;
};
Ic.add = Tut;
Ic.addAll = Cut;
Ic.cover = Nut;
Ic.data = Dut;
Ic.extent = Aut;
Ic.find = Out;
Ic.remove = Rut;
Ic.removeAll = kut;
Ic.root = $ut;
Ic.size = Put;
Ic.visit = Iut;
Ic.visitAfter = jut;
Ic.x = zut;
Ic.y = But;
function Nc(e) {
  return function() {
    return e;
  };
}
function Sx(e) {
  return (e() - 0.5) * 1e-6;
}
function Uut(e) {
  return e.x + e.vx;
}
function Yut(e) {
  return e.y + e.vy;
}
function Hut(e) {
  var t, n, r, i = 1, o = 1;
  typeof e != "function" && (e = Nc(e == null ? 1 : +e));
  function a() {
    for (var l, f = t.length, h, p, g, y, b, _, S = 0; S < o; ++S)
      for (h = iZ(t, Uut, Yut).visitAfter(s), l = 0; l < f; ++l)
        p = t[l], b = n[p.index], _ = b * b, g = p.x + p.vx, y = p.y + p.vy, h.visit(C);
    function C(A, O, R, j, $) {
      var z = A.data, W = A.r, Y = b + W;
      if (z) {
        if (z.index > p.index) {
          var V = g - z.x - z.vx, ee = y - z.y - z.vy, K = V * V + ee * ee;
          K < Y * Y && (V === 0 && (V = Sx(r), K += V * V), ee === 0 && (ee = Sx(r), K += ee * ee), K = (Y - (K = Math.sqrt(K))) / K * i, p.vx += (V *= K) * (Y = (W *= W) / (_ + W)), p.vy += (ee *= K) * Y, z.vx -= V * (Y = 1 - Y), z.vy -= ee * Y);
        }
        return;
      }
      return O > g + Y || j < g - Y || R > y + Y || $ < y - Y;
    }
  }
  function s(l) {
    if (l.data)
      return l.r = n[l.data.index];
    for (var f = l.r = 0; f < 4; ++f)
      l[f] && l[f].r > l.r && (l.r = l[f].r);
  }
  function u() {
    if (t) {
      var l, f = t.length, h;
      for (n = new Array(f), l = 0; l < f; ++l)
        h = t[l], n[h.index] = +e(h, l, t);
    }
  }
  return a.initialize = function(l, f) {
    t = l, r = f, u();
  }, a.iterations = function(l) {
    return arguments.length ? (o = +l, a) : o;
  }, a.strength = function(l) {
    return arguments.length ? (i = +l, a) : i;
  }, a.radius = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Nc(+l), u(), a) : e;
  }, a;
}
function Vut(e) {
  return e.index;
}
function yde(e, t) {
  var n = e.get(t);
  if (!n)
    throw new Error("node not found: " + t);
  return n;
}
function Wut(e) {
  var t = Vut, n = h, r, i = Nc(30), o, a, s, u, l, f = 1;
  e == null && (e = []);
  function h(_) {
    return 1 / Math.min(s[_.source.index], s[_.target.index]);
  }
  function p(_) {
    for (var S = 0, C = e.length; S < f; ++S)
      for (var A = 0, O, R, j, $, z, W, Y; A < C; ++A)
        O = e[A], R = O.source, j = O.target, $ = j.x + j.vx - R.x - R.vx || Sx(l), z = j.y + j.vy - R.y - R.vy || Sx(l), W = Math.sqrt($ * $ + z * z), W = (W - o[A]) / W * _ * r[A], $ *= W, z *= W, j.vx -= $ * (Y = u[A]), j.vy -= z * Y, R.vx += $ * (Y = 1 - Y), R.vy += z * Y;
  }
  function g() {
    if (a) {
      var _, S = a.length, C = e.length, A = new Map(a.map((R, j) => [t(R, j, a), R])), O;
      for (_ = 0, s = new Array(S); _ < C; ++_)
        O = e[_], O.index = _, typeof O.source != "object" && (O.source = yde(A, O.source)), typeof O.target != "object" && (O.target = yde(A, O.target)), s[O.source.index] = (s[O.source.index] || 0) + 1, s[O.target.index] = (s[O.target.index] || 0) + 1;
      for (_ = 0, u = new Array(C); _ < C; ++_)
        O = e[_], u[_] = s[O.source.index] / (s[O.source.index] + s[O.target.index]);
      r = new Array(C), y(), o = new Array(C), b();
    }
  }
  function y() {
    if (a)
      for (var _ = 0, S = e.length; _ < S; ++_)
        r[_] = +n(e[_], _, e);
  }
  function b() {
    if (a)
      for (var _ = 0, S = e.length; _ < S; ++_)
        o[_] = +i(e[_], _, e);
  }
  return p.initialize = function(_, S) {
    a = _, l = S, g();
  }, p.links = function(_) {
    return arguments.length ? (e = _, g(), p) : e;
  }, p.id = function(_) {
    return arguments.length ? (t = _, p) : t;
  }, p.iterations = function(_) {
    return arguments.length ? (f = +_, p) : f;
  }, p.strength = function(_) {
    return arguments.length ? (n = typeof _ == "function" ? _ : Nc(+_), y(), p) : n;
  }, p.distance = function(_) {
    return arguments.length ? (i = typeof _ == "function" ? _ : Nc(+_), b(), p) : i;
  }, p;
}
const qut = 1664525, Gut = 1013904223, vde = 4294967296;
function Qut() {
  let e = 1;
  return () => (e = (qut * e + Gut) % vde) / vde;
}
function Xut(e) {
  return e.x;
}
function Kut(e) {
  return e.y;
}
var Zut = 10, Jut = Math.PI * (3 - Math.sqrt(5));
function elt(e) {
  var t, n = 1, r = 1e-3, i = 1 - Math.pow(r, 1 / 300), o = 0, a = 0.6, s = /* @__PURE__ */ new Map(), u = tZ(h), l = qK("tick", "end"), f = Qut();
  e == null && (e = []);
  function h() {
    p(), l.call("tick", t), n < r && (u.stop(), l.call("end", t));
  }
  function p(b) {
    var _, S = e.length, C;
    b === void 0 && (b = 1);
    for (var A = 0; A < b; ++A)
      for (n += (o - n) * i, s.forEach(function(O) {
        O(n);
      }), _ = 0; _ < S; ++_)
        C = e[_], C.fx == null ? C.x += C.vx *= a : (C.x = C.fx, C.vx = 0), C.fy == null ? C.y += C.vy *= a : (C.y = C.fy, C.vy = 0);
    return t;
  }
  function g() {
    for (var b = 0, _ = e.length, S; b < _; ++b) {
      if (S = e[b], S.index = b, S.fx != null && (S.x = S.fx), S.fy != null && (S.y = S.fy), isNaN(S.x) || isNaN(S.y)) {
        var C = Zut * Math.sqrt(0.5 + b), A = b * Jut;
        S.x = C * Math.cos(A), S.y = C * Math.sin(A);
      }
      (isNaN(S.vx) || isNaN(S.vy)) && (S.vx = S.vy = 0);
    }
  }
  function y(b) {
    return b.initialize && b.initialize(e, f), b;
  }
  return g(), t = {
    tick: p,
    restart: function() {
      return u.restart(h), t;
    },
    stop: function() {
      return u.stop(), t;
    },
    nodes: function(b) {
      return arguments.length ? (e = b, g(), s.forEach(y), t) : e;
    },
    alpha: function(b) {
      return arguments.length ? (n = +b, t) : n;
    },
    alphaMin: function(b) {
      return arguments.length ? (r = +b, t) : r;
    },
    alphaDecay: function(b) {
      return arguments.length ? (i = +b, t) : +i;
    },
    alphaTarget: function(b) {
      return arguments.length ? (o = +b, t) : o;
    },
    velocityDecay: function(b) {
      return arguments.length ? (a = 1 - b, t) : 1 - a;
    },
    randomSource: function(b) {
      return arguments.length ? (f = b, s.forEach(y), t) : f;
    },
    force: function(b, _) {
      return arguments.length > 1 ? (_ == null ? s.delete(b) : s.set(b, y(_)), t) : s.get(b);
    },
    find: function(b, _, S) {
      var C = 0, A = e.length, O, R, j, $, z;
      for (S == null ? S = 1 / 0 : S *= S, C = 0; C < A; ++C)
        $ = e[C], O = b - $.x, R = _ - $.y, j = O * O + R * R, j < S && (z = $, S = j);
      return z;
    },
    on: function(b, _) {
      return arguments.length > 1 ? (l.on(b, _), t) : l.on(b);
    }
  };
}
function tlt() {
  var e, t, n, r, i = Nc(-30), o, a = 1, s = 1 / 0, u = 0.81;
  function l(g) {
    var y, b = e.length, _ = iZ(e, Xut, Kut).visitAfter(h);
    for (r = g, y = 0; y < b; ++y)
      t = e[y], _.visit(p);
  }
  function f() {
    if (e) {
      var g, y = e.length, b;
      for (o = new Array(y), g = 0; g < y; ++g)
        b = e[g], o[b.index] = +i(b, g, e);
    }
  }
  function h(g) {
    var y = 0, b, _, S = 0, C, A, O;
    if (g.length) {
      for (C = A = O = 0; O < 4; ++O)
        (b = g[O]) && (_ = Math.abs(b.value)) && (y += b.value, S += _, C += _ * b.x, A += _ * b.y);
      g.x = C / S, g.y = A / S;
    } else {
      b = g, b.x = b.data.x, b.y = b.data.y;
      do
        y += o[b.data.index];
      while (b = b.next);
    }
    g.value = y;
  }
  function p(g, y, b, _) {
    if (!g.value)
      return !0;
    var S = g.x - t.x, C = g.y - t.y, A = _ - y, O = S * S + C * C;
    if (A * A / u < O)
      return O < s && (S === 0 && (S = Sx(n), O += S * S), C === 0 && (C = Sx(n), O += C * C), O < a && (O = Math.sqrt(a * O)), t.vx += S * g.value * r / O, t.vy += C * g.value * r / O), !0;
    if (g.length || O >= s)
      return;
    (g.data !== t || g.next) && (S === 0 && (S = Sx(n), O += S * S), C === 0 && (C = Sx(n), O += C * C), O < a && (O = Math.sqrt(a * O)));
    do
      g.data !== t && (A = o[g.data.index] * r / O, t.vx += S * A, t.vy += C * A);
    while (g = g.next);
  }
  return l.initialize = function(g, y) {
    e = g, n = y, f();
  }, l.strength = function(g) {
    return arguments.length ? (i = typeof g == "function" ? g : Nc(+g), f(), l) : i;
  }, l.distanceMin = function(g) {
    return arguments.length ? (a = g * g, l) : Math.sqrt(a);
  }, l.distanceMax = function(g) {
    return arguments.length ? (s = g * g, l) : Math.sqrt(s);
  }, l.theta = function(g) {
    return arguments.length ? (u = g * g, l) : Math.sqrt(u);
  }, l;
}
function nlt(e) {
  var t = Nc(0.1), n, r, i;
  typeof e != "function" && (e = Nc(e == null ? 0 : +e));
  function o(s) {
    for (var u = 0, l = n.length, f; u < l; ++u)
      f = n[u], f.vx += (i[u] - f.x) * r[u] * s;
  }
  function a() {
    if (n) {
      var s, u = n.length;
      for (r = new Array(u), i = new Array(u), s = 0; s < u; ++s)
        r[s] = isNaN(i[s] = +e(n[s], s, n)) ? 0 : +t(n[s], s, n);
    }
  }
  return o.initialize = function(s) {
    n = s, a();
  }, o.strength = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Nc(+s), a(), o) : t;
  }, o.x = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Nc(+s), a(), o) : e;
  }, o;
}
function rlt(e) {
  var t = Nc(0.1), n, r, i;
  typeof e != "function" && (e = Nc(e == null ? 0 : +e));
  function o(s) {
    for (var u = 0, l = n.length, f; u < l; ++u)
      f = n[u], f.vy += (i[u] - f.y) * r[u] * s;
  }
  function a() {
    if (n) {
      var s, u = n.length;
      for (r = new Array(u), i = new Array(u), s = 0; s < u; ++s)
        r[s] = isNaN(i[s] = +e(n[s], s, n)) ? 0 : +t(n[s], s, n);
    }
  }
  return o.initialize = function(s) {
    n = s, a();
  }, o.strength = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Nc(+s), a(), o) : t;
  }, o.y = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Nc(+s), a(), o) : e;
  }, o;
}
function ilt(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function vL(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function lC(e) {
  return e = vL(Math.abs(e)), e ? e[1] : NaN;
}
function olt(e, t) {
  return function(n, r) {
    for (var i = n.length, o = [], a = 0, s = e[0], u = 0; i > 0 && s > 0 && (u + s + 1 > r && (s = Math.max(1, r - u)), o.push(n.substring(i -= s, i + s)), !((u += s + 1) > r)); )
      s = e[a = (a + 1) % e.length];
    return o.reverse().join(t);
  };
}
function alt(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var slt = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function CS(e) {
  if (!(t = slt.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new aZ({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
CS.prototype = aZ.prototype;
function aZ(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
aZ.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function ult(e) {
  e:
    for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
      switch (e[n]) {
        case ".":
          r = i = n;
          break;
        case "0":
          r === 0 && (r = n), i = n;
          break;
        default:
          if (!+e[n])
            break e;
          r > 0 && (r = 0);
          break;
      }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var gEe;
function llt(e, t) {
  var n = vL(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1], o = i - (gEe = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;
  return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + vL(e, Math.max(0, t + o - 1))[0];
}
function bde(e, t) {
  var n = vL(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const xde = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: ilt,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => bde(e * 100, t),
  r: bde,
  s: llt,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function wde(e) {
  return e;
}
var _de = Array.prototype.map, Ede = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function mEe(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? wde : olt(_de.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? wde : alt(_de.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", s = e.minus === void 0 ? "−" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function l(h) {
    h = CS(h);
    var p = h.fill, g = h.align, y = h.sign, b = h.symbol, _ = h.zero, S = h.width, C = h.comma, A = h.precision, O = h.trim, R = h.type;
    R === "n" ? (C = !0, R = "g") : xde[R] || (A === void 0 && (A = 12), O = !0, R = "g"), (_ || p === "0" && g === "=") && (_ = !0, p = "0", g = "=");
    var j = b === "$" ? n : b === "#" && /[boxX]/.test(R) ? "0" + R.toLowerCase() : "", $ = b === "$" ? r : /[%p]/.test(R) ? a : "", z = xde[R], W = /[defgprs%]/.test(R);
    A = A === void 0 ? 6 : /[gprs]/.test(R) ? Math.max(1, Math.min(21, A)) : Math.max(0, Math.min(20, A));
    function Y(V) {
      var ee = j, K = $, Q, q, te;
      if (R === "c")
        K = z(V) + K, V = "";
      else {
        V = +V;
        var X = V < 0 || 1 / V < 0;
        if (V = isNaN(V) ? u : z(Math.abs(V), A), O && (V = ult(V)), X && +V == 0 && y !== "+" && (X = !1), ee = (X ? y === "(" ? y : s : y === "-" || y === "(" ? "" : y) + ee, K = (R === "s" ? Ede[8 + gEe / 3] : "") + K + (X && y === "(" ? ")" : ""), W) {
          for (Q = -1, q = V.length; ++Q < q; )
            if (te = V.charCodeAt(Q), 48 > te || te > 57) {
              K = (te === 46 ? i + V.slice(Q + 1) : V.slice(Q)) + K, V = V.slice(0, Q);
              break;
            }
        }
      }
      C && !_ && (V = t(V, 1 / 0));
      var Z = ee.length + V.length + K.length, se = Z < S ? new Array(S - Z + 1).join(p) : "";
      switch (C && _ && (V = t(se + V, se.length ? S - K.length : 1 / 0), se = ""), g) {
        case "<":
          V = ee + V + K + se;
          break;
        case "=":
          V = ee + se + V + K;
          break;
        case "^":
          V = se.slice(0, Z = se.length >> 1) + ee + V + K + se.slice(Z);
          break;
        default:
          V = se + ee + V + K;
          break;
      }
      return o(V);
    }
    return Y.toString = function() {
      return h + "";
    }, Y;
  }
  function f(h, p) {
    var g = l((h = CS(h), h.type = "f", h)), y = Math.max(-8, Math.min(8, Math.floor(lC(p) / 3))) * 3, b = Math.pow(10, -y), _ = Ede[8 + y / 3];
    return function(S) {
      return g(b * S) + _;
    };
  }
  return {
    format: l,
    formatPrefix: f
  };
}
var qI, hN, sZ;
clt({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function clt(e) {
  return qI = mEe(e), hN = qI.format, sZ = qI.formatPrefix, qI;
}
function yEe(e) {
  return Math.max(0, -lC(Math.abs(e)));
}
function vEe(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(lC(t) / 3))) * 3 - lC(Math.abs(e)));
}
function bEe(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, lC(t) - lC(e)) + 1;
}
var Bn = 1e-6, bL = 1e-12, Pr = Math.PI, Fa = Pr / 2, Sde = Pr / 4, Fd = Pr * 2, Gu = 180 / Pr, Ti = Pr / 180, Bi = Math.abs, pN = Math.atan, Hg = Math.atan2, Hn = Math.cos, GI = Math.ceil, xEe = Math.exp, jq = Math.hypot, xL = Math.log, pH = Math.pow, $n = Math.sin, Zh = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, Rc = Math.sqrt, uZ = Math.tan;
function wEe(e) {
  return e > 1 ? 0 : e < -1 ? Pr : Math.acos(e);
}
function Nf(e) {
  return e > 1 ? Fa : e < -1 ? -Fa : Math.asin(e);
}
function Td() {
}
function wL(e, t) {
  e && Tde.hasOwnProperty(e.type) && Tde[e.type](e, t);
}
var Mde = {
  Feature: function(e, t) {
    wL(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, r = -1, i = n.length; ++r < i; )
      wL(n[r].geometry, t);
  }
}, Tde = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      e = n[r], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    Lq(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      Lq(n[r], t, 0);
  },
  Polygon: function(e, t) {
    Cde(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      Cde(n[r], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, r = -1, i = n.length; ++r < i; )
      wL(n[r], t);
  }
};
function Lq(e, t, n) {
  var r = -1, i = e.length - n, o;
  for (t.lineStart(); ++r < i; )
    o = e[r], t.point(o[0], o[1], o[2]);
  t.lineEnd();
}
function Cde(e, t) {
  var n = -1, r = e.length;
  for (t.polygonStart(); ++n < r; )
    Lq(e[n], t, 1);
  t.polygonEnd();
}
function yx(e, t) {
  e && Mde.hasOwnProperty(e.type) ? Mde[e.type](e, t) : wL(e, t);
}
function zq(e) {
  return [Hg(e[1], e[0]), Nf(e[2])];
}
function cC(e) {
  var t = e[0], n = e[1], r = Hn(n);
  return [r * Hn(t), r * $n(t), $n(n)];
}
function QI(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function _L(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function gH(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function XI(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function Fq(e) {
  var t = Rc(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
var OO, EL, SL, ML, TL, CL, NL, DL, Bq, Uq, Yq, _Ee, EEe, wc, _c, Ec, Rg = {
  sphere: Td,
  point: lZ,
  lineStart: Nde,
  lineEnd: Dde,
  polygonStart: function() {
    Rg.lineStart = hlt, Rg.lineEnd = plt;
  },
  polygonEnd: function() {
    Rg.lineStart = Nde, Rg.lineEnd = Dde;
  }
};
function lZ(e, t) {
  e *= Ti, t *= Ti;
  var n = Hn(t);
  A$(n * Hn(e), n * $n(e), $n(t));
}
function A$(e, t, n) {
  ++OO, SL += (e - SL) / OO, ML += (t - ML) / OO, TL += (n - TL) / OO;
}
function Nde() {
  Rg.point = flt;
}
function flt(e, t) {
  e *= Ti, t *= Ti;
  var n = Hn(t);
  wc = n * Hn(e), _c = n * $n(e), Ec = $n(t), Rg.point = dlt, A$(wc, _c, Ec);
}
function dlt(e, t) {
  e *= Ti, t *= Ti;
  var n = Hn(t), r = n * Hn(e), i = n * $n(e), o = $n(t), a = Hg(Rc((a = _c * o - Ec * i) * a + (a = Ec * r - wc * o) * a + (a = wc * i - _c * r) * a), wc * r + _c * i + Ec * o);
  EL += a, CL += a * (wc + (wc = r)), NL += a * (_c + (_c = i)), DL += a * (Ec + (Ec = o)), A$(wc, _c, Ec);
}
function Dde() {
  Rg.point = lZ;
}
function hlt() {
  Rg.point = glt;
}
function plt() {
  SEe(_Ee, EEe), Rg.point = lZ;
}
function glt(e, t) {
  _Ee = e, EEe = t, e *= Ti, t *= Ti, Rg.point = SEe;
  var n = Hn(t);
  wc = n * Hn(e), _c = n * $n(e), Ec = $n(t), A$(wc, _c, Ec);
}
function SEe(e, t) {
  e *= Ti, t *= Ti;
  var n = Hn(t), r = n * Hn(e), i = n * $n(e), o = $n(t), a = _c * o - Ec * i, s = Ec * r - wc * o, u = wc * i - _c * r, l = jq(a, s, u), f = Nf(l), h = l && -f / l;
  Bq.add(h * a), Uq.add(h * s), Yq.add(h * u), EL += f, CL += f * (wc + (wc = r)), NL += f * (_c + (_c = i)), DL += f * (Ec + (Ec = o)), A$(wc, _c, Ec);
}
function mlt(e) {
  OO = EL = SL = ML = TL = CL = NL = DL = 0, Bq = new Qo(), Uq = new Qo(), Yq = new Qo(), yx(e, Rg);
  var t = +Bq, n = +Uq, r = +Yq, i = jq(t, n, r);
  return i < bL && (t = CL, n = NL, r = DL, EL < Bn && (t = SL, n = ML, r = TL), i = jq(t, n, r), i < bL) ? [NaN, NaN] : [Hg(n, t) * Gu, Nf(r / i) * Gu];
}
function Hq(e, t) {
  function n(r, i) {
    return r = e(r, i), t(r[0], r[1]);
  }
  return e.invert && t.invert && (n.invert = function(r, i) {
    return r = t.invert(r, i), r && e.invert(r[0], r[1]);
  }), n;
}
function Vq(e, t) {
  return Bi(e) > Pr && (e -= Math.round(e / Fd) * Fd), [e, t];
}
Vq.invert = Vq;
function MEe(e, t, n) {
  return (e %= Fd) ? t || n ? Hq(Ode(e), Rde(t, n)) : Ode(e) : t || n ? Rde(t, n) : Vq;
}
function Ade(e) {
  return function(t, n) {
    return t += e, Bi(t) > Pr && (t -= Math.round(t / Fd) * Fd), [t, n];
  };
}
function Ode(e) {
  var t = Ade(e);
  return t.invert = Ade(-e), t;
}
function Rde(e, t) {
  var n = Hn(e), r = $n(e), i = Hn(t), o = $n(t);
  function a(s, u) {
    var l = Hn(u), f = Hn(s) * l, h = $n(s) * l, p = $n(u), g = p * n + f * r;
    return [
      Hg(h * i - g * o, f * n - p * r),
      Nf(g * i + h * o)
    ];
  }
  return a.invert = function(s, u) {
    var l = Hn(u), f = Hn(s) * l, h = $n(s) * l, p = $n(u), g = p * i - h * o;
    return [
      Hg(h * i + p * o, f * n + g * r),
      Nf(g * n - f * r)
    ];
  }, a;
}
function ylt(e) {
  e = MEe(e[0] * Ti, e[1] * Ti, e.length > 2 ? e[2] * Ti : 0);
  function t(n) {
    return n = e(n[0] * Ti, n[1] * Ti), n[0] *= Gu, n[1] *= Gu, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * Ti, n[1] * Ti), n[0] *= Gu, n[1] *= Gu, n;
  }, t;
}
function vlt(e, t, n, r, i, o) {
  if (n) {
    var a = Hn(t), s = $n(t), u = r * n;
    i == null ? (i = t + r * Fd, o = t - u / 2) : (i = kde(a, i), o = kde(a, o), (r > 0 ? i < o : i > o) && (i += r * Fd));
    for (var l, f = i; r > 0 ? f > o : f < o; f -= u)
      l = zq([a, -s * Hn(f), -s * $n(f)]), e.point(l[0], l[1]);
  }
}
function kde(e, t) {
  t = cC(t), t[0] -= e, Fq(t);
  var n = wEe(-t[1]);
  return ((-t[2] < 0 ? -n : n) + Fd - Bn) % Fd;
}
function TEe() {
  var e = [], t;
  return {
    point: function(n, r, i) {
      t.push([n, r, i]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: Td,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function aj(e, t) {
  return Bi(e[0] - t[0]) < Bn && Bi(e[1] - t[1]) < Bn;
}
function KI(e, t, n, r) {
  this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;
}
function CEe(e, t, n, r, i) {
  var o = [], a = [], s, u;
  if (e.forEach(function(y) {
    if (!((b = y.length - 1) <= 0)) {
      var b, _ = y[0], S = y[b], C;
      if (aj(_, S)) {
        if (!_[2] && !S[2]) {
          for (i.lineStart(), s = 0; s < b; ++s)
            i.point((_ = y[s])[0], _[1]);
          i.lineEnd();
          return;
        }
        S[0] += 2 * Bn;
      }
      o.push(C = new KI(_, y, null, !0)), a.push(C.o = new KI(_, null, C, !1)), o.push(C = new KI(S, y, null, !1)), a.push(C.o = new KI(S, null, C, !0));
    }
  }), !!o.length) {
    for (a.sort(t), $de(o), $de(a), s = 0, u = a.length; s < u; ++s)
      a[s].e = n = !n;
    for (var l = o[0], f, h; ; ) {
      for (var p = l, g = !0; p.v; )
        if ((p = p.n) === l)
          return;
      f = p.z, i.lineStart();
      do {
        if (p.v = p.o.v = !0, p.e) {
          if (g)
            for (s = 0, u = f.length; s < u; ++s)
              i.point((h = f[s])[0], h[1]);
          else
            r(p.x, p.n.x, 1, i);
          p = p.n;
        } else {
          if (g)
            for (f = p.p.z, s = f.length - 1; s >= 0; --s)
              i.point((h = f[s])[0], h[1]);
          else
            r(p.x, p.p.x, -1, i);
          p = p.p;
        }
        p = p.o, f = p.z, g = !g;
      } while (!p.v);
      i.lineEnd();
    }
  }
}
function $de(e) {
  if (t = e.length) {
    for (var t, n = 0, r = e[0], i; ++n < t; )
      r.n = i = e[n], i.p = r, r = i;
    r.n = i = e[0], i.p = r;
  }
}
function mH(e) {
  return Bi(e[0]) <= Pr ? e[0] : Zh(e[0]) * ((Bi(e[0]) + Pr) % Fd - Pr);
}
function blt(e, t) {
  var n = mH(t), r = t[1], i = $n(r), o = [$n(n), -Hn(n), 0], a = 0, s = 0, u = new Qo();
  i === 1 ? r = Fa + Bn : i === -1 && (r = -Fa - Bn);
  for (var l = 0, f = e.length; l < f; ++l)
    if (p = (h = e[l]).length)
      for (var h, p, g = h[p - 1], y = mH(g), b = g[1] / 2 + Sde, _ = $n(b), S = Hn(b), C = 0; C < p; ++C, y = O, _ = j, S = $, g = A) {
        var A = h[C], O = mH(A), R = A[1] / 2 + Sde, j = $n(R), $ = Hn(R), z = O - y, W = z >= 0 ? 1 : -1, Y = W * z, V = Y > Pr, ee = _ * j;
        if (u.add(Hg(ee * W * $n(Y), S * $ + ee * Hn(Y))), a += V ? z + W * Fd : z, V ^ y >= n ^ O >= n) {
          var K = _L(cC(g), cC(A));
          Fq(K);
          var Q = _L(o, K);
          Fq(Q);
          var q = (V ^ z >= 0 ? -1 : 1) * Nf(Q[2]);
          (r > q || r === q && (K[0] || K[1])) && (s += V ^ z >= 0 ? 1 : -1);
        }
      }
  return (a < -Bn || a < Bn && u < -bL) ^ s & 1;
}
function NEe(e, t, n, r) {
  return function(i) {
    var o = t(i), a = TEe(), s = t(a), u = !1, l, f, h, p = {
      point: g,
      lineStart: b,
      lineEnd: _,
      polygonStart: function() {
        p.point = S, p.lineStart = C, p.lineEnd = A, f = [], l = [];
      },
      polygonEnd: function() {
        p.point = g, p.lineStart = b, p.lineEnd = _, f = TF(f);
        var O = blt(l, r);
        f.length ? (u || (i.polygonStart(), u = !0), CEe(f, wlt, O, n, i)) : O && (u || (i.polygonStart(), u = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), u && (i.polygonEnd(), u = !1), f = l = null;
      },
      sphere: function() {
        i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();
      }
    };
    function g(O, R) {
      e(O, R) && i.point(O, R);
    }
    function y(O, R) {
      o.point(O, R);
    }
    function b() {
      p.point = y, o.lineStart();
    }
    function _() {
      p.point = g, o.lineEnd();
    }
    function S(O, R) {
      h.push([O, R]), s.point(O, R);
    }
    function C() {
      s.lineStart(), h = [];
    }
    function A() {
      S(h[0][0], h[0][1]), s.lineEnd();
      var O = s.clean(), R = a.result(), j, $ = R.length, z, W, Y;
      if (h.pop(), l.push(h), h = null, !!$) {
        if (O & 1) {
          if (W = R[0], (z = W.length - 1) > 0) {
            for (u || (i.polygonStart(), u = !0), i.lineStart(), j = 0; j < z; ++j)
              i.point((Y = W[j])[0], Y[1]);
            i.lineEnd();
          }
          return;
        }
        $ > 1 && O & 2 && R.push(R.pop().concat(R.shift())), f.push(R.filter(xlt));
      }
    }
    return p;
  };
}
function xlt(e) {
  return e.length > 1;
}
function wlt(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - Fa - Bn : Fa - e[1]) - ((t = t.x)[0] < 0 ? t[1] - Fa - Bn : Fa - t[1]);
}
const Pde = NEe(
  function() {
    return !0;
  },
  _lt,
  Slt,
  [-Pr, -Fa]
);
function _lt(e) {
  var t = NaN, n = NaN, r = NaN, i;
  return {
    lineStart: function() {
      e.lineStart(), i = 1;
    },
    point: function(o, a) {
      var s = o > 0 ? Pr : -Pr, u = Bi(o - t);
      Bi(u - Pr) < Bn ? (e.point(t, n = (n + a) / 2 > 0 ? Fa : -Fa), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(s, n), e.point(o, n), i = 0) : r !== s && u >= Pr && (Bi(t - r) < Bn && (t -= r * Bn), Bi(o - s) < Bn && (o -= s * Bn), n = Elt(t, n, o, a), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(s, n), i = 0), e.point(t = o, n = a), r = s;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function Elt(e, t, n, r) {
  var i, o, a = $n(e - n);
  return Bi(a) > Bn ? pN(($n(t) * (o = Hn(r)) * $n(n) - $n(r) * (i = Hn(t)) * $n(e)) / (i * o * a)) : (t + r) / 2;
}
function Slt(e, t, n, r) {
  var i;
  if (e == null)
    i = n * Fa, r.point(-Pr, i), r.point(0, i), r.point(Pr, i), r.point(Pr, 0), r.point(Pr, -i), r.point(0, -i), r.point(-Pr, -i), r.point(-Pr, 0), r.point(-Pr, i);
  else if (Bi(e[0] - t[0]) > Bn) {
    var o = e[0] < t[0] ? Pr : -Pr;
    i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i);
  } else
    r.point(t[0], t[1]);
}
function Mlt(e) {
  var t = Hn(e), n = 6 * Ti, r = t > 0, i = Bi(t) > Bn;
  function o(f, h, p, g) {
    vlt(g, e, n, p, f, h);
  }
  function a(f, h) {
    return Hn(f) * Hn(h) > t;
  }
  function s(f) {
    var h, p, g, y, b;
    return {
      lineStart: function() {
        y = g = !1, b = 1;
      },
      point: function(_, S) {
        var C = [_, S], A, O = a(_, S), R = r ? O ? 0 : l(_, S) : O ? l(_ + (_ < 0 ? Pr : -Pr), S) : 0;
        if (!h && (y = g = O) && f.lineStart(), O !== g && (A = u(h, C), (!A || aj(h, A) || aj(C, A)) && (C[2] = 1)), O !== g)
          b = 0, O ? (f.lineStart(), A = u(C, h), f.point(A[0], A[1])) : (A = u(h, C), f.point(A[0], A[1], 2), f.lineEnd()), h = A;
        else if (i && h && r ^ O) {
          var j;
          !(R & p) && (j = u(C, h, !0)) && (b = 0, r ? (f.lineStart(), f.point(j[0][0], j[0][1]), f.point(j[1][0], j[1][1]), f.lineEnd()) : (f.point(j[1][0], j[1][1]), f.lineEnd(), f.lineStart(), f.point(j[0][0], j[0][1], 3)));
        }
        O && (!h || !aj(h, C)) && f.point(C[0], C[1]), h = C, g = O, p = R;
      },
      lineEnd: function() {
        g && f.lineEnd(), h = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return b | (y && g) << 1;
      }
    };
  }
  function u(f, h, p) {
    var g = cC(f), y = cC(h), b = [1, 0, 0], _ = _L(g, y), S = QI(_, _), C = _[0], A = S - C * C;
    if (!A)
      return !p && f;
    var O = t * S / A, R = -t * C / A, j = _L(b, _), $ = XI(b, O), z = XI(_, R);
    gH($, z);
    var W = j, Y = QI($, W), V = QI(W, W), ee = Y * Y - V * (QI($, $) - 1);
    if (!(ee < 0)) {
      var K = Rc(ee), Q = XI(W, (-Y - K) / V);
      if (gH(Q, $), Q = zq(Q), !p)
        return Q;
      var q = f[0], te = h[0], X = f[1], Z = h[1], se;
      te < q && (se = q, q = te, te = se);
      var H = te - q, ie = Bi(H - Pr) < Bn, he = ie || H < Bn;
      if (!ie && Z < X && (se = X, X = Z, Z = se), he ? ie ? X + Z > 0 ^ Q[1] < (Bi(Q[0] - q) < Bn ? X : Z) : X <= Q[1] && Q[1] <= Z : H > Pr ^ (q <= Q[0] && Q[0] <= te)) {
        var ye = XI(W, (-Y + K) / V);
        return gH(ye, $), [Q, zq(ye)];
      }
    }
  }
  function l(f, h) {
    var p = r ? e : Pr - e, g = 0;
    return f < -p ? g |= 1 : f > p && (g |= 2), h < -p ? g |= 4 : h > p && (g |= 8), g;
  }
  return NEe(a, s, o, r ? [0, -e] : [-Pr, e - Pr]);
}
function Tlt(e, t, n, r, i, o) {
  var a = e[0], s = e[1], u = t[0], l = t[1], f = 0, h = 1, p = u - a, g = l - s, y;
  if (y = n - a, !(!p && y > 0)) {
    if (y /= p, p < 0) {
      if (y < f)
        return;
      y < h && (h = y);
    } else if (p > 0) {
      if (y > h)
        return;
      y > f && (f = y);
    }
    if (y = i - a, !(!p && y < 0)) {
      if (y /= p, p < 0) {
        if (y > h)
          return;
        y > f && (f = y);
      } else if (p > 0) {
        if (y < f)
          return;
        y < h && (h = y);
      }
      if (y = r - s, !(!g && y > 0)) {
        if (y /= g, g < 0) {
          if (y < f)
            return;
          y < h && (h = y);
        } else if (g > 0) {
          if (y > h)
            return;
          y > f && (f = y);
        }
        if (y = o - s, !(!g && y < 0)) {
          if (y /= g, g < 0) {
            if (y > h)
              return;
            y > f && (f = y);
          } else if (g > 0) {
            if (y < f)
              return;
            y < h && (h = y);
          }
          return f > 0 && (e[0] = a + f * p, e[1] = s + f * g), h < 1 && (t[0] = a + h * p, t[1] = s + h * g), !0;
        }
      }
    }
  }
}
var RO = 1e9, ZI = -RO;
function DEe(e, t, n, r) {
  function i(l, f) {
    return e <= l && l <= n && t <= f && f <= r;
  }
  function o(l, f, h, p) {
    var g = 0, y = 0;
    if (l == null || (g = a(l, h)) !== (y = a(f, h)) || u(l, f) < 0 ^ h > 0)
      do
        p.point(g === 0 || g === 3 ? e : n, g > 1 ? r : t);
      while ((g = (g + h + 4) % 4) !== y);
    else
      p.point(f[0], f[1]);
  }
  function a(l, f) {
    return Bi(l[0] - e) < Bn ? f > 0 ? 0 : 3 : Bi(l[0] - n) < Bn ? f > 0 ? 2 : 1 : Bi(l[1] - t) < Bn ? f > 0 ? 1 : 0 : f > 0 ? 3 : 2;
  }
  function s(l, f) {
    return u(l.x, f.x);
  }
  function u(l, f) {
    var h = a(l, 1), p = a(f, 1);
    return h !== p ? h - p : h === 0 ? f[1] - l[1] : h === 1 ? l[0] - f[0] : h === 2 ? l[1] - f[1] : f[0] - l[0];
  }
  return function(l) {
    var f = l, h = TEe(), p, g, y, b, _, S, C, A, O, R, j, $ = {
      point: z,
      lineStart: ee,
      lineEnd: K,
      polygonStart: Y,
      polygonEnd: V
    };
    function z(q, te) {
      i(q, te) && f.point(q, te);
    }
    function W() {
      for (var q = 0, te = 0, X = g.length; te < X; ++te)
        for (var Z = g[te], se = 1, H = Z.length, ie = Z[0], he, ye, _e = ie[0], Ne = ie[1]; se < H; ++se)
          he = _e, ye = Ne, ie = Z[se], _e = ie[0], Ne = ie[1], ye <= r ? Ne > r && (_e - he) * (r - ye) > (Ne - ye) * (e - he) && ++q : Ne <= r && (_e - he) * (r - ye) < (Ne - ye) * (e - he) && --q;
      return q;
    }
    function Y() {
      f = h, p = [], g = [], j = !0;
    }
    function V() {
      var q = W(), te = j && q, X = (p = TF(p)).length;
      (te || X) && (l.polygonStart(), te && (l.lineStart(), o(null, null, 1, l), l.lineEnd()), X && CEe(p, s, q, o, l), l.polygonEnd()), f = l, p = g = y = null;
    }
    function ee() {
      $.point = Q, g && g.push(y = []), R = !0, O = !1, C = A = NaN;
    }
    function K() {
      p && (Q(b, _), S && O && h.rejoin(), p.push(h.result())), $.point = z, O && f.lineEnd();
    }
    function Q(q, te) {
      var X = i(q, te);
      if (g && y.push([q, te]), R)
        b = q, _ = te, S = X, R = !1, X && (f.lineStart(), f.point(q, te));
      else if (X && O)
        f.point(q, te);
      else {
        var Z = [C = Math.max(ZI, Math.min(RO, C)), A = Math.max(ZI, Math.min(RO, A))], se = [q = Math.max(ZI, Math.min(RO, q)), te = Math.max(ZI, Math.min(RO, te))];
        Tlt(Z, se, e, t, n, r) ? (O || (f.lineStart(), f.point(Z[0], Z[1])), f.point(se[0], se[1]), X || f.lineEnd(), j = !1) : X && (f.lineStart(), f.point(q, te), j = !1);
      }
      C = q, A = te, O = X;
    }
    return $;
  };
}
function Ide(e, t, n) {
  var r = qo(e, t - Bn, n).concat(t);
  return function(i) {
    return r.map(function(o) {
      return [i, o];
    });
  };
}
function jde(e, t, n) {
  var r = qo(e, t - Bn, n).concat(t);
  return function(i) {
    return r.map(function(o) {
      return [o, i];
    });
  };
}
function Clt() {
  var e, t, n, r, i, o, a, s, u = 10, l = u, f = 90, h = 360, p, g, y, b, _ = 2.5;
  function S() {
    return { type: "MultiLineString", coordinates: C() };
  }
  function C() {
    return qo(GI(r / f) * f, n, f).map(y).concat(qo(GI(s / h) * h, a, h).map(b)).concat(qo(GI(t / u) * u, e, u).filter(function(A) {
      return Bi(A % f) > Bn;
    }).map(p)).concat(qo(GI(o / l) * l, i, l).filter(function(A) {
      return Bi(A % h) > Bn;
    }).map(g));
  }
  return S.lines = function() {
    return C().map(function(A) {
      return { type: "LineString", coordinates: A };
    });
  }, S.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        y(r).concat(
          b(a).slice(1),
          y(n).reverse().slice(1),
          b(s).reverse().slice(1)
        )
      ]
    };
  }, S.extent = function(A) {
    return arguments.length ? S.extentMajor(A).extentMinor(A) : S.extentMinor();
  }, S.extentMajor = function(A) {
    return arguments.length ? (r = +A[0][0], n = +A[1][0], s = +A[0][1], a = +A[1][1], r > n && (A = r, r = n, n = A), s > a && (A = s, s = a, a = A), S.precision(_)) : [[r, s], [n, a]];
  }, S.extentMinor = function(A) {
    return arguments.length ? (t = +A[0][0], e = +A[1][0], o = +A[0][1], i = +A[1][1], t > e && (A = t, t = e, e = A), o > i && (A = o, o = i, i = A), S.precision(_)) : [[t, o], [e, i]];
  }, S.step = function(A) {
    return arguments.length ? S.stepMajor(A).stepMinor(A) : S.stepMinor();
  }, S.stepMajor = function(A) {
    return arguments.length ? (f = +A[0], h = +A[1], S) : [f, h];
  }, S.stepMinor = function(A) {
    return arguments.length ? (u = +A[0], l = +A[1], S) : [u, l];
  }, S.precision = function(A) {
    return arguments.length ? (_ = +A, p = Ide(o, i, 90), g = jde(t, e, _), y = Ide(s, a, 90), b = jde(r, n, _), S) : _;
  }, S.extentMajor([[-180, -90 + Bn], [180, 90 - Bn]]).extentMinor([[-180, -80 - Bn], [180, 80 + Bn]]);
}
function Nlt() {
  return Clt()();
}
const Wq = (e) => e;
var yH = new Qo(), qq = new Qo(), AEe, OEe, Gq, Qq, vx = {
  point: Td,
  lineStart: Td,
  lineEnd: Td,
  polygonStart: function() {
    vx.lineStart = Dlt, vx.lineEnd = Olt;
  },
  polygonEnd: function() {
    vx.lineStart = vx.lineEnd = vx.point = Td, yH.add(Bi(qq)), qq = new Qo();
  },
  result: function() {
    var e = yH / 2;
    return yH = new Qo(), e;
  }
};
function Dlt() {
  vx.point = Alt;
}
function Alt(e, t) {
  vx.point = REe, AEe = Gq = e, OEe = Qq = t;
}
function REe(e, t) {
  qq.add(Qq * e - Gq * t), Gq = e, Qq = t;
}
function Olt() {
  REe(AEe, OEe);
}
const Lde = vx;
var fC = 1 / 0, AL = fC, Ak = -fC, OL = Ak, Rlt = {
  point: klt,
  lineStart: Td,
  lineEnd: Td,
  polygonStart: Td,
  polygonEnd: Td,
  result: function() {
    var e = [[fC, AL], [Ak, OL]];
    return Ak = OL = -(AL = fC = 1 / 0), e;
  }
};
function klt(e, t) {
  e < fC && (fC = e), e > Ak && (Ak = e), t < AL && (AL = t), t > OL && (OL = t);
}
const RL = Rlt;
var Xq = 0, Kq = 0, kO = 0, kL = 0, $L = 0, hT = 0, Zq = 0, Jq = 0, $O = 0, kEe, $Ee, Ty, Cy, Dg = {
  point: NS,
  lineStart: zde,
  lineEnd: Fde,
  polygonStart: function() {
    Dg.lineStart = Ilt, Dg.lineEnd = jlt;
  },
  polygonEnd: function() {
    Dg.point = NS, Dg.lineStart = zde, Dg.lineEnd = Fde;
  },
  result: function() {
    var e = $O ? [Zq / $O, Jq / $O] : hT ? [kL / hT, $L / hT] : kO ? [Xq / kO, Kq / kO] : [NaN, NaN];
    return Xq = Kq = kO = kL = $L = hT = Zq = Jq = $O = 0, e;
  }
};
function NS(e, t) {
  Xq += e, Kq += t, ++kO;
}
function zde() {
  Dg.point = $lt;
}
function $lt(e, t) {
  Dg.point = Plt, NS(Ty = e, Cy = t);
}
function Plt(e, t) {
  var n = e - Ty, r = t - Cy, i = Rc(n * n + r * r);
  kL += i * (Ty + e) / 2, $L += i * (Cy + t) / 2, hT += i, NS(Ty = e, Cy = t);
}
function Fde() {
  Dg.point = NS;
}
function Ilt() {
  Dg.point = Llt;
}
function jlt() {
  PEe(kEe, $Ee);
}
function Llt(e, t) {
  Dg.point = PEe, NS(kEe = Ty = e, $Ee = Cy = t);
}
function PEe(e, t) {
  var n = e - Ty, r = t - Cy, i = Rc(n * n + r * r);
  kL += i * (Ty + e) / 2, $L += i * (Cy + t) / 2, hT += i, i = Cy * e - Ty * t, Zq += i * (Ty + e), Jq += i * (Cy + t), $O += i * 3, NS(Ty = e, Cy = t);
}
const Bde = Dg;
function IEe(e) {
  this._context = e;
}
IEe.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Fd);
        break;
      }
    }
  },
  result: Td
};
var eG = new Qo(), vH, jEe, LEe, PO, IO, PL = {
  point: Td,
  lineStart: function() {
    PL.point = zlt;
  },
  lineEnd: function() {
    vH && zEe(jEe, LEe), PL.point = Td;
  },
  polygonStart: function() {
    vH = !0;
  },
  polygonEnd: function() {
    vH = null;
  },
  result: function() {
    var e = +eG;
    return eG = new Qo(), e;
  }
};
function zlt(e, t) {
  PL.point = zEe, jEe = PO = e, LEe = IO = t;
}
function zEe(e, t) {
  PO -= e, IO -= t, eG.add(Rc(PO * PO + IO * IO)), PO = e, IO = t;
}
const Ude = PL;
let Yde, IL, Hde, Vde, Wde = class {
  constructor(t) {
    this._append = t == null ? FEe : Flt(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== Hde || this._append !== IL) {
          const r = this._radius, i = this._;
          this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, Hde = r, IL = this._append, Vde = this._, this._ = i;
        }
        this._ += Vde;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
};
function FEe(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function Flt(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return FEe;
  if (t !== Yde) {
    const n = 10 ** t;
    Yde = t, IL = function(i) {
      let o = 1;
      this._ += i[0];
      for (const a = i.length; o < a; ++o)
        this._ += Math.round(arguments[o] * n) / n + i[o];
    };
  }
  return IL;
}
function Cw(e, t) {
  let n = 3, r = 4.5, i, o;
  function a(s) {
    return s && (typeof r == "function" && o.pointRadius(+r.apply(this, arguments)), yx(s, i(o))), o.result();
  }
  return a.area = function(s) {
    return yx(s, i(Lde)), Lde.result();
  }, a.measure = function(s) {
    return yx(s, i(Ude)), Ude.result();
  }, a.bounds = function(s) {
    return yx(s, i(RL)), RL.result();
  }, a.centroid = function(s) {
    return yx(s, i(Bde)), Bde.result();
  }, a.projection = function(s) {
    return arguments.length ? (i = s == null ? (e = null, Wq) : (e = s).stream, a) : e;
  }, a.context = function(s) {
    return arguments.length ? (o = s == null ? (t = null, new Wde(n)) : new IEe(t = s), typeof r != "function" && o.pointRadius(r), a) : t;
  }, a.pointRadius = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : (o.pointRadius(+s), +s), a) : r;
  }, a.digits = function(s) {
    if (!arguments.length)
      return n;
    if (s == null)
      n = null;
    else {
      const u = Math.floor(s);
      if (!(u >= 0))
        throw new RangeError(`invalid digits: ${s}`);
      n = u;
    }
    return t === null && (o = new Wde(n)), a;
  }, a.projection(e).digits(n).context(t);
}
function jL(e) {
  return {
    stream: IF(e)
  };
}
function IF(e) {
  return function(t) {
    var n = new tG();
    for (var r in e)
      n[r] = e[r];
    return n.stream = t, n;
  };
}
function tG() {
}
tG.prototype = {
  constructor: tG,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function cZ(e, t, n) {
  var r = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), yx(n, e.stream(RL)), t(RL.result()), r != null && e.clipExtent(r), e;
}
function fZ(e, t, n) {
  return cZ(e, function(r) {
    var i = t[1][0] - t[0][0], o = t[1][1] - t[0][1], a = Math.min(i / (r[1][0] - r[0][0]), o / (r[1][1] - r[0][1])), s = +t[0][0] + (i - a * (r[1][0] + r[0][0])) / 2, u = +t[0][1] + (o - a * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * a).translate([s, u]);
  }, n);
}
function BEe(e, t, n) {
  return fZ(e, [[0, 0], t], n);
}
function UEe(e, t, n) {
  return cZ(e, function(r) {
    var i = +t, o = i / (r[1][0] - r[0][0]), a = (i - o * (r[1][0] + r[0][0])) / 2, s = -o * r[0][1];
    e.scale(150 * o).translate([a, s]);
  }, n);
}
function YEe(e, t, n) {
  return cZ(e, function(r) {
    var i = +t, o = i / (r[1][1] - r[0][1]), a = -o * r[0][0], s = (i - o * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * o).translate([a, s]);
  }, n);
}
var qde = 16, Blt = Hn(30 * Ti);
function Gde(e, t) {
  return +t ? Ylt(e, t) : Ult(e);
}
function Ult(e) {
  return IF({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function Ylt(e, t) {
  function n(r, i, o, a, s, u, l, f, h, p, g, y, b, _) {
    var S = l - r, C = f - i, A = S * S + C * C;
    if (A > 4 * t && b--) {
      var O = a + p, R = s + g, j = u + y, $ = Rc(O * O + R * R + j * j), z = Nf(j /= $), W = Bi(Bi(j) - 1) < Bn || Bi(o - h) < Bn ? (o + h) / 2 : Hg(R, O), Y = e(W, z), V = Y[0], ee = Y[1], K = V - r, Q = ee - i, q = C * K - S * Q;
      (q * q / A > t || Bi((S * K + C * Q) / A - 0.5) > 0.3 || a * p + s * g + u * y < Blt) && (n(r, i, o, a, s, u, V, ee, W, O /= $, R /= $, j, b, _), _.point(V, ee), n(V, ee, W, O, R, j, l, f, h, p, g, y, b, _));
    }
  }
  return function(r) {
    var i, o, a, s, u, l, f, h, p, g, y, b, _ = {
      point: S,
      lineStart: C,
      lineEnd: O,
      polygonStart: function() {
        r.polygonStart(), _.lineStart = R;
      },
      polygonEnd: function() {
        r.polygonEnd(), _.lineStart = C;
      }
    };
    function S(z, W) {
      z = e(z, W), r.point(z[0], z[1]);
    }
    function C() {
      h = NaN, _.point = A, r.lineStart();
    }
    function A(z, W) {
      var Y = cC([z, W]), V = e(z, W);
      n(h, p, f, g, y, b, h = V[0], p = V[1], f = z, g = Y[0], y = Y[1], b = Y[2], qde, r), r.point(h, p);
    }
    function O() {
      _.point = S, r.lineEnd();
    }
    function R() {
      C(), _.point = j, _.lineEnd = $;
    }
    function j(z, W) {
      A(i = z, W), o = h, a = p, s = g, u = y, l = b, _.point = A;
    }
    function $() {
      n(h, p, f, g, y, b, o, a, i, s, u, l, qde, r), _.lineEnd = O, O();
    }
    return _;
  };
}
var Hlt = IF({
  point: function(e, t) {
    this.stream.point(e * Ti, t * Ti);
  }
});
function Vlt(e) {
  return IF({
    point: function(t, n) {
      var r = e(t, n);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function Wlt(e, t, n, r, i) {
  function o(a, s) {
    return a *= r, s *= i, [t + e * a, n - e * s];
  }
  return o.invert = function(a, s) {
    return [(a - t) / e * r, (n - s) / e * i];
  }, o;
}
function Qde(e, t, n, r, i, o) {
  if (!o)
    return Wlt(e, t, n, r, i);
  var a = Hn(o), s = $n(o), u = a * e, l = s * e, f = a / e, h = s / e, p = (s * n - a * t) / e, g = (s * t + a * n) / e;
  function y(b, _) {
    return b *= r, _ *= i, [u * b - l * _ + t, n - l * b - u * _];
  }
  return y.invert = function(b, _) {
    return [r * (f * b - h * _ + p), i * (g - h * b - f * _)];
  }, y;
}
function Nw(e) {
  return HEe(function() {
    return e;
  })();
}
function HEe(e) {
  var t, n = 150, r = 480, i = 250, o = 0, a = 0, s = 0, u = 0, l = 0, f, h = 0, p = 1, g = 1, y = null, b = Pde, _ = null, S, C, A, O = Wq, R = 0.5, j, $, z, W, Y;
  function V(q) {
    return z(q[0] * Ti, q[1] * Ti);
  }
  function ee(q) {
    return q = z.invert(q[0], q[1]), q && [q[0] * Gu, q[1] * Gu];
  }
  V.stream = function(q) {
    return W && Y === q ? W : W = Hlt(Vlt(f)(b(j(O(Y = q)))));
  }, V.preclip = function(q) {
    return arguments.length ? (b = q, y = void 0, Q()) : b;
  }, V.postclip = function(q) {
    return arguments.length ? (O = q, _ = S = C = A = null, Q()) : O;
  }, V.clipAngle = function(q) {
    return arguments.length ? (b = +q ? Mlt(y = q * Ti) : (y = null, Pde), Q()) : y * Gu;
  }, V.clipExtent = function(q) {
    return arguments.length ? (O = q == null ? (_ = S = C = A = null, Wq) : DEe(_ = +q[0][0], S = +q[0][1], C = +q[1][0], A = +q[1][1]), Q()) : _ == null ? null : [[_, S], [C, A]];
  }, V.scale = function(q) {
    return arguments.length ? (n = +q, K()) : n;
  }, V.translate = function(q) {
    return arguments.length ? (r = +q[0], i = +q[1], K()) : [r, i];
  }, V.center = function(q) {
    return arguments.length ? (o = q[0] % 360 * Ti, a = q[1] % 360 * Ti, K()) : [o * Gu, a * Gu];
  }, V.rotate = function(q) {
    return arguments.length ? (s = q[0] % 360 * Ti, u = q[1] % 360 * Ti, l = q.length > 2 ? q[2] % 360 * Ti : 0, K()) : [s * Gu, u * Gu, l * Gu];
  }, V.angle = function(q) {
    return arguments.length ? (h = q % 360 * Ti, K()) : h * Gu;
  }, V.reflectX = function(q) {
    return arguments.length ? (p = q ? -1 : 1, K()) : p < 0;
  }, V.reflectY = function(q) {
    return arguments.length ? (g = q ? -1 : 1, K()) : g < 0;
  }, V.precision = function(q) {
    return arguments.length ? (j = Gde($, R = q * q), Q()) : Rc(R);
  }, V.fitExtent = function(q, te) {
    return fZ(V, q, te);
  }, V.fitSize = function(q, te) {
    return BEe(V, q, te);
  }, V.fitWidth = function(q, te) {
    return UEe(V, q, te);
  }, V.fitHeight = function(q, te) {
    return YEe(V, q, te);
  };
  function K() {
    var q = Qde(n, 0, 0, p, g, h).apply(null, t(o, a)), te = Qde(n, r - q[0], i - q[1], p, g, h);
    return f = MEe(s, u, l), $ = Hq(t, te), z = Hq(f, $), j = Gde($, R), Q();
  }
  function Q() {
    return W = Y = null, V;
  }
  return function() {
    return t = e.apply(this, arguments), V.invert = t.invert && ee, K();
  };
}
function dZ(e) {
  var t = 0, n = Pr / 3, r = HEe(e), i = r(t, n);
  return i.parallels = function(o) {
    return arguments.length ? r(t = o[0] * Ti, n = o[1] * Ti) : [t * Gu, n * Gu];
  }, i;
}
function qlt(e) {
  var t = Hn(e);
  function n(r, i) {
    return [r * t, $n(i) / t];
  }
  return n.invert = function(r, i) {
    return [r / t, Nf(i * t)];
  }, n;
}
function Glt(e, t) {
  var n = $n(e), r = (n + $n(t)) / 2;
  if (Bi(r) < Bn)
    return qlt(e);
  var i = 1 + n * (2 * r - n), o = Rc(i) / r;
  function a(s, u) {
    var l = Rc(i - 2 * r * $n(u)) / r;
    return [l * $n(s *= r), o - l * Hn(s)];
  }
  return a.invert = function(s, u) {
    var l = o - u, f = Hg(s, Bi(l)) * Zh(l);
    return l * r < 0 && (f -= Pr * Zh(s) * Zh(l)), [f / r, Nf((i - (s * s + l * l) * r * r) / (2 * r))];
  }, a;
}
function LL() {
  return dZ(Glt).scale(155.424).center([0, 33.6442]);
}
function VEe() {
  return LL().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function Qlt(e) {
  var t = e.length;
  return {
    point: function(n, r) {
      for (var i = -1; ++i < t; )
        e[i].point(n, r);
    },
    sphere: function() {
      for (var n = -1; ++n < t; )
        e[n].sphere();
    },
    lineStart: function() {
      for (var n = -1; ++n < t; )
        e[n].lineStart();
    },
    lineEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].lineEnd();
    },
    polygonStart: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonStart();
    },
    polygonEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonEnd();
    }
  };
}
function Xlt() {
  var e, t, n = VEe(), r, i = LL().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), o, a = LL().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), s, u, l = { point: function(p, g) {
    u = [p, g];
  } };
  function f(p) {
    var g = p[0], y = p[1];
    return u = null, r.point(g, y), u || (o.point(g, y), u) || (s.point(g, y), u);
  }
  f.invert = function(p) {
    var g = n.scale(), y = n.translate(), b = (p[0] - y[0]) / g, _ = (p[1] - y[1]) / g;
    return (_ >= 0.12 && _ < 0.234 && b >= -0.425 && b < -0.214 ? i : _ >= 0.166 && _ < 0.234 && b >= -0.214 && b < -0.115 ? a : n).invert(p);
  }, f.stream = function(p) {
    return e && t === p ? e : e = Qlt([n.stream(t = p), i.stream(p), a.stream(p)]);
  }, f.precision = function(p) {
    return arguments.length ? (n.precision(p), i.precision(p), a.precision(p), h()) : n.precision();
  }, f.scale = function(p) {
    return arguments.length ? (n.scale(p), i.scale(p * 0.35), a.scale(p), f.translate(n.translate())) : n.scale();
  }, f.translate = function(p) {
    if (!arguments.length)
      return n.translate();
    var g = n.scale(), y = +p[0], b = +p[1];
    return r = n.translate(p).clipExtent([[y - 0.455 * g, b - 0.238 * g], [y + 0.455 * g, b + 0.238 * g]]).stream(l), o = i.translate([y - 0.307 * g, b + 0.201 * g]).clipExtent([[y - 0.425 * g + Bn, b + 0.12 * g + Bn], [y - 0.214 * g - Bn, b + 0.234 * g - Bn]]).stream(l), s = a.translate([y - 0.205 * g, b + 0.212 * g]).clipExtent([[y - 0.214 * g + Bn, b + 0.166 * g + Bn], [y - 0.115 * g - Bn, b + 0.234 * g - Bn]]).stream(l), h();
  }, f.fitExtent = function(p, g) {
    return fZ(f, p, g);
  }, f.fitSize = function(p, g) {
    return BEe(f, p, g);
  }, f.fitWidth = function(p, g) {
    return UEe(f, p, g);
  }, f.fitHeight = function(p, g) {
    return YEe(f, p, g);
  };
  function h() {
    return e = t = null, f;
  }
  return f.scale(1070);
}
function WEe(e) {
  return function(t, n) {
    var r = Hn(t), i = Hn(n), o = e(r * i);
    return o === 1 / 0 ? [2, 0] : [
      o * i * $n(t),
      o * $n(n)
    ];
  };
}
function O$(e) {
  return function(t, n) {
    var r = Rc(t * t + n * n), i = e(r), o = $n(i), a = Hn(i);
    return [
      Hg(t * o, r * a),
      Nf(r && n * o / r)
    ];
  };
}
var qEe = WEe(function(e) {
  return Rc(2 / (1 + e));
});
qEe.invert = O$(function(e) {
  return 2 * Nf(e / 2);
});
function Klt() {
  return Nw(qEe).scale(124.75).clipAngle(180 - 1e-3);
}
var GEe = WEe(function(e) {
  return (e = wEe(e)) && e / $n(e);
});
GEe.invert = O$(function(e) {
  return e;
});
function Zlt() {
  return Nw(GEe).scale(79.4188).clipAngle(180 - 1e-3);
}
function jF(e, t) {
  return [e, xL(uZ((Fa + t) / 2))];
}
jF.invert = function(e, t) {
  return [e, 2 * pN(xEe(t)) - Fa];
};
function Jlt() {
  return QEe(jF).scale(961 / Fd);
}
function QEe(e) {
  var t = Nw(e), n = t.center, r = t.scale, i = t.translate, o = t.clipExtent, a = null, s, u, l;
  t.scale = function(h) {
    return arguments.length ? (r(h), f()) : r();
  }, t.translate = function(h) {
    return arguments.length ? (i(h), f()) : i();
  }, t.center = function(h) {
    return arguments.length ? (n(h), f()) : n();
  }, t.clipExtent = function(h) {
    return arguments.length ? (h == null ? a = s = u = l = null : (a = +h[0][0], s = +h[0][1], u = +h[1][0], l = +h[1][1]), f()) : a == null ? null : [[a, s], [u, l]];
  };
  function f() {
    var h = Pr * r(), p = t(ylt(t.rotate()).invert([0, 0]));
    return o(a == null ? [[p[0] - h, p[1] - h], [p[0] + h, p[1] + h]] : e === jF ? [[Math.max(p[0] - h, a), s], [Math.min(p[0] + h, u), l]] : [[a, Math.max(p[1] - h, s)], [u, Math.min(p[1] + h, l)]]);
  }
  return f();
}
function JI(e) {
  return uZ((Fa + e) / 2);
}
function ect(e, t) {
  var n = Hn(e), r = e === t ? $n(e) : xL(n / Hn(t)) / xL(JI(t) / JI(e)), i = n * pH(JI(e), r) / r;
  if (!r)
    return jF;
  function o(a, s) {
    i > 0 ? s < -Fa + Bn && (s = -Fa + Bn) : s > Fa - Bn && (s = Fa - Bn);
    var u = i / pH(JI(s), r);
    return [u * $n(r * a), i - u * Hn(r * a)];
  }
  return o.invert = function(a, s) {
    var u = i - s, l = Zh(r) * Rc(a * a + u * u), f = Hg(a, Bi(u)) * Zh(u);
    return u * r < 0 && (f -= Pr * Zh(a) * Zh(u)), [f / r, 2 * pN(pH(i / l, 1 / r)) - Fa];
  }, o;
}
function tct() {
  return dZ(ect).scale(109.5).parallels([30, 30]);
}
function zL(e, t) {
  return [e, t];
}
zL.invert = zL;
function nct() {
  return Nw(zL).scale(152.63);
}
function rct(e, t) {
  var n = Hn(e), r = e === t ? $n(e) : (n - Hn(t)) / (t - e), i = n / r + e;
  if (Bi(r) < Bn)
    return zL;
  function o(a, s) {
    var u = i - s, l = r * a;
    return [u * $n(l), i - u * Hn(l)];
  }
  return o.invert = function(a, s) {
    var u = i - s, l = Hg(a, Bi(u)) * Zh(u);
    return u * r < 0 && (l -= Pr * Zh(a) * Zh(u)), [l / r, i - Zh(r) * Rc(a * a + u * u)];
  }, o;
}
function ict() {
  return dZ(rct).scale(131.154).center([0, 13.9389]);
}
var NR = 1.340264, DR = -0.081106, AR = 893e-6, OR = 3796e-6, FL = Rc(3) / 2, oct = 12;
function XEe(e, t) {
  var n = Nf(FL * $n(t)), r = n * n, i = r * r * r;
  return [
    e * Hn(n) / (FL * (NR + 3 * DR * r + i * (7 * AR + 9 * OR * r))),
    n * (NR + DR * r + i * (AR + OR * r))
  ];
}
XEe.invert = function(e, t) {
  for (var n = t, r = n * n, i = r * r * r, o = 0, a, s, u; o < oct && (s = n * (NR + DR * r + i * (AR + OR * r)) - t, u = NR + 3 * DR * r + i * (7 * AR + 9 * OR * r), n -= a = s / u, r = n * n, i = r * r * r, !(Bi(a) < bL)); ++o)
    ;
  return [
    FL * e * (NR + 3 * DR * r + i * (7 * AR + 9 * OR * r)) / Hn(n),
    Nf($n(n) / FL)
  ];
};
function act() {
  return Nw(XEe).scale(177.158);
}
function KEe(e, t) {
  var n = Hn(t), r = Hn(e) * n;
  return [n * $n(e) / r, $n(t) / r];
}
KEe.invert = O$(pN);
function sct() {
  return Nw(KEe).scale(144.049).clipAngle(60);
}
function ZEe(e, t) {
  return [Hn(t) * $n(e), $n(t)];
}
ZEe.invert = O$(Nf);
function uct() {
  return Nw(ZEe).scale(249.5).clipAngle(90 + Bn);
}
function JEe(e, t) {
  var n = Hn(t), r = 1 + Hn(e) * n;
  return [n * $n(e) / r, $n(t) / r];
}
JEe.invert = O$(function(e) {
  return 2 * pN(e);
});
function lct() {
  return Nw(JEe).scale(250).clipAngle(142);
}
function eSe(e, t) {
  return [xL(uZ((Fa + t) / 2)), -e];
}
eSe.invert = function(e, t) {
  return [-t, 2 * pN(xEe(e)) - Fa];
};
function cct() {
  var e = QEe(eSe), t = e.center, n = e.rotate;
  return e.center = function(r) {
    return arguments.length ? t([-r[1], r[0]]) : (r = t(), [r[1], -r[0]]);
  }, e.rotate = function(r) {
    return arguments.length ? n([r[0], r[1], r.length > 2 ? r[2] + 90 : 90]) : (r = n(), [r[0], r[1], r[2] - 90]);
  }, n([0, 0, 90]).scale(159.155);
}
function fct(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function dct(e) {
  return e.reduce(hct, 0) / e.length;
}
function hct(e, t) {
  return e + t.x;
}
function pct(e) {
  return 1 + e.reduce(gct, 0);
}
function gct(e, t) {
  return Math.max(e, t.y);
}
function mct(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function yct(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function hZ() {
  var e = fct, t = 1, n = 1, r = !1;
  function i(o) {
    var a, s = 0;
    o.eachAfter(function(p) {
      var g = p.children;
      g ? (p.x = dct(g), p.y = pct(g)) : (p.x = a ? s += e(p, a) : 0, p.y = 0, a = p);
    });
    var u = mct(o), l = yct(o), f = u.x - e(u, l) / 2, h = l.x + e(l, u) / 2;
    return o.eachAfter(r ? function(p) {
      p.x = (p.x - o.x) * t, p.y = (o.y - p.y) * n;
    } : function(p) {
      p.x = (p.x - f) / (h - f) * t, p.y = (1 - (o.y ? p.y / o.y : 1)) * n;
    });
  }
  return i.separation = function(o) {
    return arguments.length ? (e = o, i) : e;
  }, i.size = function(o) {
    return arguments.length ? (r = !1, t = +o[0], n = +o[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(o) {
    return arguments.length ? (r = !0, t = +o[0], n = +o[1], i) : r ? [t, n] : null;
  }, i;
}
function vct(e) {
  var t = 0, n = e.children, r = n && n.length;
  if (!r)
    t = 1;
  else
    for (; --r >= 0; )
      t += n[r].value;
  e.value = t;
}
function bct() {
  return this.eachAfter(vct);
}
function xct(e, t) {
  let n = -1;
  for (const r of this)
    e.call(t, r, ++n, this);
  return this;
}
function wct(e, t) {
  for (var n = this, r = [n], i, o, a = -1; n = r.pop(); )
    if (e.call(t, n, ++a, this), i = n.children)
      for (o = i.length - 1; o >= 0; --o)
        r.push(i[o]);
  return this;
}
function _ct(e, t) {
  for (var n = this, r = [n], i = [], o, a, s, u = -1; n = r.pop(); )
    if (i.push(n), o = n.children)
      for (a = 0, s = o.length; a < s; ++a)
        r.push(o[a]);
  for (; n = i.pop(); )
    e.call(t, n, ++u, this);
  return this;
}
function Ect(e, t) {
  let n = -1;
  for (const r of this)
    if (e.call(t, r, ++n, this))
      return r;
}
function Sct(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; )
      n += r[i].value;
    t.value = n;
  });
}
function Mct(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function Tct(e) {
  for (var t = this, n = Cct(t, e), r = [t]; t !== n; )
    t = t.parent, r.push(t);
  for (var i = r.length; e !== n; )
    r.splice(i, 0, e), e = e.parent;
  return r;
}
function Cct(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), r = t.ancestors(), i = null;
  for (e = n.pop(), t = r.pop(); e === t; )
    i = e, e = n.pop(), t = r.pop();
  return i;
}
function Nct() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function Dct() {
  return Array.from(this);
}
function Act() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function Oct() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* Rct() {
  var e = this, t, n = [e], r, i, o;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, r = e.children)
        for (i = 0, o = r.length; i < o; ++i)
          n.push(r[i]);
  while (n.length);
}
function pZ(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = Pct)) : t === void 0 && (t = $ct);
  for (var n = new dC(e), r, i = [n], o, a, s, u; r = i.pop(); )
    if ((a = t(r.data)) && (u = (a = Array.from(a)).length))
      for (r.children = a, s = u - 1; s >= 0; --s)
        i.push(o = a[s] = new dC(a[s])), o.parent = r, o.depth = r.depth + 1;
  return n.eachBefore(tSe);
}
function kct() {
  return pZ(this).eachBefore(Ict);
}
function $ct(e) {
  return e.children;
}
function Pct(e) {
  return Array.isArray(e) ? e[1] : null;
}
function Ict(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function tSe(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function dC(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
dC.prototype = pZ.prototype = {
  constructor: dC,
  count: bct,
  each: xct,
  eachAfter: _ct,
  eachBefore: wct,
  find: Ect,
  sum: Sct,
  sort: Mct,
  path: Tct,
  ancestors: Nct,
  descendants: Dct,
  leaves: Act,
  links: Oct,
  copy: kct,
  [Symbol.iterator]: Rct
};
function sj(e) {
  return e == null ? null : nSe(e);
}
function nSe(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
function kE() {
  return 0;
}
function aT(e) {
  return function() {
    return e;
  };
}
const jct = 1664525, Lct = 1013904223, Xde = 4294967296;
function zct() {
  let e = 1;
  return () => (e = (jct * e + Lct) % Xde) / Xde;
}
function Fct(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Bct(e, t) {
  let n = e.length, r, i;
  for (; n; )
    i = t() * n-- | 0, r = e[n], e[n] = e[i], e[i] = r;
  return e;
}
function Uct(e, t) {
  for (var n = 0, r = (e = Bct(Array.from(e), t)).length, i = [], o, a; n < r; )
    o = e[n], a && rSe(a, o) ? ++n : (a = Hct(i = Yct(i, o)), n = 0);
  return a;
}
function Yct(e, t) {
  var n, r;
  if (bH(t, e))
    return [t];
  for (n = 0; n < e.length; ++n)
    if (e3(t, e[n]) && bH(jO(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (r = n + 1; r < e.length; ++r)
      if (e3(jO(e[n], e[r]), t) && e3(jO(e[n], t), e[r]) && e3(jO(e[r], t), e[n]) && bH(iSe(e[n], e[r], t), e))
        return [e[n], e[r], t];
  throw new Error();
}
function e3(e, t) {
  var n = e.r - t.r, r = t.x - e.x, i = t.y - e.y;
  return n < 0 || n * n < r * r + i * i;
}
function rSe(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function bH(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!rSe(e, t[n]))
      return !1;
  return !0;
}
function Hct(e) {
  switch (e.length) {
    case 1:
      return Vct(e[0]);
    case 2:
      return jO(e[0], e[1]);
    case 3:
      return iSe(e[0], e[1], e[2]);
  }
}
function Vct(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function jO(e, t) {
  var n = e.x, r = e.y, i = e.r, o = t.x, a = t.y, s = t.r, u = o - n, l = a - r, f = s - i, h = Math.sqrt(u * u + l * l);
  return {
    x: (n + o + u / h * f) / 2,
    y: (r + a + l / h * f) / 2,
    r: (h + i + s) / 2
  };
}
function iSe(e, t, n) {
  var r = e.x, i = e.y, o = e.r, a = t.x, s = t.y, u = t.r, l = n.x, f = n.y, h = n.r, p = r - a, g = r - l, y = i - s, b = i - f, _ = u - o, S = h - o, C = r * r + i * i - o * o, A = C - a * a - s * s + u * u, O = C - l * l - f * f + h * h, R = g * y - p * b, j = (y * O - b * A) / (R * 2) - r, $ = (b * _ - y * S) / R, z = (g * A - p * O) / (R * 2) - i, W = (p * S - g * _) / R, Y = $ * $ + W * W - 1, V = 2 * (o + j * $ + z * W), ee = j * j + z * z - o * o, K = -(Math.abs(Y) > 1e-6 ? (V + Math.sqrt(V * V - 4 * Y * ee)) / (2 * Y) : ee / V);
  return {
    x: r + j + $ * K,
    y: i + z + W * K,
    r: K
  };
}
function Kde(e, t, n) {
  var r = e.x - t.x, i, o, a = e.y - t.y, s, u, l = r * r + a * a;
  l ? (o = t.r + n.r, o *= o, u = e.r + n.r, u *= u, o > u ? (i = (l + u - o) / (2 * l), s = Math.sqrt(Math.max(0, u / l - i * i)), n.x = e.x - i * r - s * a, n.y = e.y - i * a + s * r) : (i = (l + o - u) / (2 * l), s = Math.sqrt(Math.max(0, o / l - i * i)), n.x = t.x + i * r - s * a, n.y = t.y + i * a + s * r)) : (n.x = t.x + n.r, n.y = t.y);
}
function Zde(e, t) {
  var n = e.r + t.r - 1e-6, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function Jde(e) {
  var t = e._, n = e.next._, r = t.r + n.r, i = (t.x * n.r + n.x * t.r) / r, o = (t.y * n.r + n.y * t.r) / r;
  return i * i + o * o;
}
function t3(e) {
  this._ = e, this.next = null, this.previous = null;
}
function Wct(e, t) {
  if (!(o = (e = Fct(e)).length))
    return 0;
  var n, r, i, o, a, s, u, l, f, h, p;
  if (n = e[0], n.x = 0, n.y = 0, !(o > 1))
    return n.r;
  if (r = e[1], n.x = -r.r, r.x = n.r, r.y = 0, !(o > 2))
    return n.r + r.r;
  Kde(r, n, i = e[2]), n = new t3(n), r = new t3(r), i = new t3(i), n.next = i.previous = r, r.next = n.previous = i, i.next = r.previous = n;
  e:
    for (u = 3; u < o; ++u) {
      Kde(n._, r._, i = e[u]), i = new t3(i), l = r.next, f = n.previous, h = r._.r, p = n._.r;
      do
        if (h <= p) {
          if (Zde(l._, i._)) {
            r = l, n.next = r, r.previous = n, --u;
            continue e;
          }
          h += l._.r, l = l.next;
        } else {
          if (Zde(f._, i._)) {
            n = f, n.next = r, r.previous = n, --u;
            continue e;
          }
          p += f._.r, f = f.previous;
        }
      while (l !== f.next);
      for (i.previous = n, i.next = r, n.next = r.previous = r = i, a = Jde(n); (i = i.next) !== r; )
        (s = Jde(i)) < a && (n = i, a = s);
      r = n.next;
    }
  for (n = [r._], i = r; (i = i.next) !== r; )
    n.push(i._);
  for (i = Uct(n, t), u = 0; u < o; ++u)
    n = e[u], n.x -= i.x, n.y -= i.y;
  return i.r;
}
function qct(e) {
  return Math.sqrt(e.value);
}
function Gct() {
  var e = null, t = 1, n = 1, r = kE;
  function i(o) {
    const a = zct();
    return o.x = t / 2, o.y = n / 2, e ? o.eachBefore(ehe(e)).eachAfter(xH(r, 0.5, a)).eachBefore(the(1)) : o.eachBefore(ehe(qct)).eachAfter(xH(kE, 1, a)).eachAfter(xH(r, o.r / Math.min(t, n), a)).eachBefore(the(Math.min(t, n) / (2 * o.r))), o;
  }
  return i.radius = function(o) {
    return arguments.length ? (e = sj(o), i) : e;
  }, i.size = function(o) {
    return arguments.length ? (t = +o[0], n = +o[1], i) : [t, n];
  }, i.padding = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : aT(+o), i) : r;
  }, i;
}
function ehe(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function xH(e, t, n) {
  return function(r) {
    if (i = r.children) {
      var i, o, a = i.length, s = e(r) * t || 0, u;
      if (s)
        for (o = 0; o < a; ++o)
          i[o].r += s;
      if (u = Wct(i, n), s)
        for (o = 0; o < a; ++o)
          i[o].r -= s;
      r.r = u + s;
    }
  };
}
function the(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function oSe(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function R$(e, t, n, r, i) {
  for (var o = e.children, a, s = -1, u = o.length, l = e.value && (r - t) / e.value; ++s < u; )
    a = o[s], a.y0 = n, a.y1 = i, a.x0 = t, a.x1 = t += a.value * l;
}
function Qct() {
  var e = 1, t = 1, n = 0, r = !1;
  function i(a) {
    var s = a.height + 1;
    return a.x0 = a.y0 = n, a.x1 = e, a.y1 = t / s, a.eachBefore(o(t, s)), r && a.eachBefore(oSe), a;
  }
  function o(a, s) {
    return function(u) {
      u.children && R$(u, u.x0, a * (u.depth + 1) / s, u.x1, a * (u.depth + 2) / s);
      var l = u.x0, f = u.y0, h = u.x1 - n, p = u.y1 - n;
      h < l && (l = h = (l + h) / 2), p < f && (f = p = (f + p) / 2), u.x0 = l, u.y0 = f, u.x1 = h, u.y1 = p;
    };
  }
  return i.round = function(a) {
    return arguments.length ? (r = !!a, i) : r;
  }, i.size = function(a) {
    return arguments.length ? (e = +a[0], t = +a[1], i) : [e, t];
  }, i.padding = function(a) {
    return arguments.length ? (n = +a, i) : n;
  }, i;
}
var Xct = { depth: -1 }, nhe = {}, wH = {};
function Kct(e) {
  return e.id;
}
function Zct(e) {
  return e.parentId;
}
function BL() {
  var e = Kct, t = Zct, n;
  function r(i) {
    var o = Array.from(i), a = e, s = t, u, l, f, h, p, g, y, b, _ = /* @__PURE__ */ new Map();
    if (n != null) {
      const S = o.map((O, R) => Jct(n(O, R, i))), C = S.map(rhe), A = new Set(S).add("");
      for (const O of C)
        A.has(O) || (A.add(O), S.push(O), C.push(rhe(O)), o.push(wH));
      a = (O, R) => S[R], s = (O, R) => C[R];
    }
    for (f = 0, u = o.length; f < u; ++f)
      l = o[f], g = o[f] = new dC(l), (y = a(l, f, i)) != null && (y += "") && (b = g.id = y, _.set(b, _.has(b) ? nhe : g)), (y = s(l, f, i)) != null && (y += "") && (g.parent = y);
    for (f = 0; f < u; ++f)
      if (g = o[f], y = g.parent) {
        if (p = _.get(y), !p)
          throw new Error("missing: " + y);
        if (p === nhe)
          throw new Error("ambiguous: " + y);
        p.children ? p.children.push(g) : p.children = [g], g.parent = p;
      } else {
        if (h)
          throw new Error("multiple roots");
        h = g;
      }
    if (!h)
      throw new Error("no root");
    if (n != null) {
      for (; h.data === wH && h.children.length === 1; )
        h = h.children[0], --u;
      for (let S = o.length - 1; S >= 0 && (g = o[S], g.data === wH); --S)
        g.data = null;
    }
    if (h.parent = Xct, h.eachBefore(function(S) {
      S.depth = S.parent.depth + 1, --u;
    }).eachBefore(tSe), h.parent = null, u > 0)
      throw new Error("cycle");
    return h;
  }
  return r.id = function(i) {
    return arguments.length ? (e = sj(i), r) : e;
  }, r.parentId = function(i) {
    return arguments.length ? (t = sj(i), r) : t;
  }, r.path = function(i) {
    return arguments.length ? (n = sj(i), r) : n;
  }, r;
}
function Jct(e) {
  e = `${e}`;
  let t = e.length;
  return nG(e, t - 1) && !nG(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
}
function rhe(e) {
  let t = e.length;
  if (t < 2)
    return "";
  for (; --t > 1 && !nG(e, t); )
    ;
  return e.slice(0, t);
}
function nG(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if (!(n & 1))
      return !0;
  }
  return !1;
}
function eft(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function _H(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function EH(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function tft(e, t, n) {
  var r = n / (t.i - e.i);
  t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n;
}
function nft(e) {
  for (var t = 0, n = 0, r = e.children, i = r.length, o; --i >= 0; )
    o = r[i], o.z += t, o.m += t, t += o.s + (n += o.c);
}
function rft(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function uj(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
uj.prototype = Object.create(dC.prototype);
function ift(e) {
  for (var t = new uj(e, 0), n, r = [t], i, o, a, s; n = r.pop(); )
    if (o = n._.children)
      for (n.children = new Array(s = o.length), a = s - 1; a >= 0; --a)
        r.push(i = n.children[a] = new uj(o[a], a)), i.parent = n;
  return (t.parent = new uj(null, 0)).children = [t], t;
}
function Ok() {
  var e = eft, t = 1, n = 1, r = null;
  function i(l) {
    var f = ift(l);
    if (f.eachAfter(o), f.parent.m = -f.z, f.eachBefore(a), r)
      l.eachBefore(u);
    else {
      var h = l, p = l, g = l;
      l.eachBefore(function(C) {
        C.x < h.x && (h = C), C.x > p.x && (p = C), C.depth > g.depth && (g = C);
      });
      var y = h === p ? 1 : e(h, p) / 2, b = y - h.x, _ = t / (p.x + y + b), S = n / (g.depth || 1);
      l.eachBefore(function(C) {
        C.x = (C.x + b) * _, C.y = C.depth * S;
      });
    }
    return l;
  }
  function o(l) {
    var f = l.children, h = l.parent.children, p = l.i ? h[l.i - 1] : null;
    if (f) {
      nft(l);
      var g = (f[0].z + f[f.length - 1].z) / 2;
      p ? (l.z = p.z + e(l._, p._), l.m = l.z - g) : l.z = g;
    } else
      p && (l.z = p.z + e(l._, p._));
    l.parent.A = s(l, p, l.parent.A || h[0]);
  }
  function a(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function s(l, f, h) {
    if (f) {
      for (var p = l, g = l, y = f, b = p.parent.children[0], _ = p.m, S = g.m, C = y.m, A = b.m, O; y = EH(y), p = _H(p), y && p; )
        b = _H(b), g = EH(g), g.a = l, O = y.z + C - p.z - _ + e(y._, p._), O > 0 && (tft(rft(y, l, h), l, O), _ += O, S += O), C += y.m, _ += p.m, A += b.m, S += g.m;
      y && !EH(g) && (g.t = y, g.m += C - S), p && !_H(b) && (b.t = p, b.m += _ - A, h = l);
    }
    return h;
  }
  function u(l) {
    l.x *= t, l.y = l.depth * n;
  }
  return i.separation = function(l) {
    return arguments.length ? (e = l, i) : e;
  }, i.size = function(l) {
    return arguments.length ? (r = !1, t = +l[0], n = +l[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(l) {
    return arguments.length ? (r = !0, t = +l[0], n = +l[1], i) : r ? [t, n] : null;
  }, i;
}
function LF(e, t, n, r, i) {
  for (var o = e.children, a, s = -1, u = o.length, l = e.value && (i - n) / e.value; ++s < u; )
    a = o[s], a.x0 = t, a.x1 = r, a.y0 = n, a.y1 = n += a.value * l;
}
var aSe = (1 + Math.sqrt(5)) / 2;
function sSe(e, t, n, r, i, o) {
  for (var a = [], s = t.children, u, l, f = 0, h = 0, p = s.length, g, y, b = t.value, _, S, C, A, O, R, j; f < p; ) {
    g = i - n, y = o - r;
    do
      _ = s[h++].value;
    while (!_ && h < p);
    for (S = C = _, R = Math.max(y / g, g / y) / (b * e), j = _ * _ * R, O = Math.max(C / j, j / S); h < p; ++h) {
      if (_ += l = s[h].value, l < S && (S = l), l > C && (C = l), j = _ * _ * R, A = Math.max(C / j, j / S), A > O) {
        _ -= l;
        break;
      }
      O = A;
    }
    a.push(u = { value: _, dice: g < y, children: s.slice(f, h) }), u.dice ? R$(u, n, r, i, b ? r += y * _ / b : o) : LF(u, n, r, b ? n += g * _ / b : i, o), b -= _, f = h;
  }
  return a;
}
const uSe = function e(t) {
  function n(r, i, o, a, s) {
    sSe(t, r, i, o, a, s);
  }
  return n.ratio = function(r) {
    return e((r = +r) > 1 ? r : 1);
  }, n;
}(aSe);
function oft() {
  var e = uSe, t = !1, n = 1, r = 1, i = [0], o = kE, a = kE, s = kE, u = kE, l = kE;
  function f(p) {
    return p.x0 = p.y0 = 0, p.x1 = n, p.y1 = r, p.eachBefore(h), i = [0], t && p.eachBefore(oSe), p;
  }
  function h(p) {
    var g = i[p.depth], y = p.x0 + g, b = p.y0 + g, _ = p.x1 - g, S = p.y1 - g;
    _ < y && (y = _ = (y + _) / 2), S < b && (b = S = (b + S) / 2), p.x0 = y, p.y0 = b, p.x1 = _, p.y1 = S, p.children && (g = i[p.depth + 1] = o(p) / 2, y += l(p) - g, b += a(p) - g, _ -= s(p) - g, S -= u(p) - g, _ < y && (y = _ = (y + _) / 2), S < b && (b = S = (b + S) / 2), e(p, y, b, _, S));
  }
  return f.round = function(p) {
    return arguments.length ? (t = !!p, f) : t;
  }, f.size = function(p) {
    return arguments.length ? (n = +p[0], r = +p[1], f) : [n, r];
  }, f.tile = function(p) {
    return arguments.length ? (e = nSe(p), f) : e;
  }, f.padding = function(p) {
    return arguments.length ? f.paddingInner(p).paddingOuter(p) : f.paddingInner();
  }, f.paddingInner = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : aT(+p), f) : o;
  }, f.paddingOuter = function(p) {
    return arguments.length ? f.paddingTop(p).paddingRight(p).paddingBottom(p).paddingLeft(p) : f.paddingTop();
  }, f.paddingTop = function(p) {
    return arguments.length ? (a = typeof p == "function" ? p : aT(+p), f) : a;
  }, f.paddingRight = function(p) {
    return arguments.length ? (s = typeof p == "function" ? p : aT(+p), f) : s;
  }, f.paddingBottom = function(p) {
    return arguments.length ? (u = typeof p == "function" ? p : aT(+p), f) : u;
  }, f.paddingLeft = function(p) {
    return arguments.length ? (l = typeof p == "function" ? p : aT(+p), f) : l;
  }, f;
}
function aft(e, t, n, r, i) {
  var o = e.children, a, s = o.length, u, l = new Array(s + 1);
  for (l[0] = u = a = 0; a < s; ++a)
    l[a + 1] = u += o[a].value;
  f(0, s, e.value, t, n, r, i);
  function f(h, p, g, y, b, _, S) {
    if (h >= p - 1) {
      var C = o[h];
      C.x0 = y, C.y0 = b, C.x1 = _, C.y1 = S;
      return;
    }
    for (var A = l[h], O = g / 2 + A, R = h + 1, j = p - 1; R < j; ) {
      var $ = R + j >>> 1;
      l[$] < O ? R = $ + 1 : j = $;
    }
    O - l[R - 1] < l[R] - O && h + 1 < R && --R;
    var z = l[R] - A, W = g - z;
    if (_ - y > S - b) {
      var Y = g ? (y * W + _ * z) / g : _;
      f(h, R, z, y, b, Y, S), f(R, p, W, Y, b, _, S);
    } else {
      var V = g ? (b * W + S * z) / g : S;
      f(h, R, z, y, b, _, V), f(R, p, W, y, V, _, S);
    }
  }
}
function sft(e, t, n, r, i) {
  (e.depth & 1 ? LF : R$)(e, t, n, r, i);
}
const uft = function e(t) {
  function n(r, i, o, a, s) {
    if ((u = r._squarify) && u.ratio === t)
      for (var u, l, f, h, p = -1, g, y = u.length, b = r.value; ++p < y; ) {
        for (l = u[p], f = l.children, h = l.value = 0, g = f.length; h < g; ++h)
          l.value += f[h].value;
        l.dice ? R$(l, i, o, a, b ? o += (s - o) * l.value / b : s) : LF(l, i, o, b ? i += (a - i) * l.value / b : a, s), b -= l.value;
      }
    else
      r._squarify = u = sSe(t, r, i, o, a, s), u.ratio = t;
  }
  return n.ratio = function(r) {
    return e((r = +r) > 1 ? r : 1);
  }, n;
}(aSe), lft = 1664525, cft = 1013904223, ihe = 1 / 4294967296;
function gZ(e = Math.random()) {
  let t = (0 <= e && e < 1 ? e / ihe : Math.abs(e)) | 0;
  return () => (t = lft * t + cft | 0, ihe * (t >>> 0));
}
function Zg(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Dw(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const UL = Symbol("implicit");
function k$() {
  var e = new ES(), t = [], n = [], r = UL;
  function i(o) {
    let a = e.get(o);
    if (a === void 0) {
      if (r !== UL)
        return r;
      e.set(o, a = t.push(o) - 1);
    }
    return n[a % n.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new ES();
    for (const a of o)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (n = Array.from(o), i) : n.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return k$(t, n).unknown(r);
  }, Zg.apply(i, arguments), i;
}
function zF() {
  var e = k$().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, a, s = !1, u = 0, l = 0, f = 0.5;
  delete e.unknown;
  function h() {
    var p = t().length, g = i < r, y = g ? i : r, b = g ? r : i;
    o = (b - y) / Math.max(1, p - u + l * 2), s && (o = Math.floor(o)), y += (b - y - o * (p - u)) * f, a = o * (1 - u), s && (y = Math.round(y), a = Math.round(a));
    var _ = qo(p).map(function(S) {
      return y + o * S;
    });
    return n(g ? _.reverse() : _);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), h()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([r, i] = p, r = +r, i = +i, h()) : [r, i];
  }, e.rangeRound = function(p) {
    return [r, i] = p, r = +r, i = +i, s = !0, h();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return o;
  }, e.round = function(p) {
    return arguments.length ? (s = !!p, h()) : s;
  }, e.padding = function(p) {
    return arguments.length ? (u = Math.min(1, l = +p), h()) : u;
  }, e.paddingInner = function(p) {
    return arguments.length ? (u = Math.min(1, p), h()) : u;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (l = +p, h()) : l;
  }, e.align = function(p) {
    return arguments.length ? (f = Math.max(0, Math.min(1, p)), h()) : f;
  }, e.copy = function() {
    return zF(t(), [r, i]).round(s).paddingInner(u).paddingOuter(l).align(f);
  }, Zg.apply(h(), arguments);
}
function lSe(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return lSe(t());
  }, e;
}
function fft() {
  return lSe(zF.apply(null, arguments).paddingInner(1));
}
function dft(e) {
  return function() {
    return e;
  };
}
function rG(e) {
  return +e;
}
var ohe = [0, 1];
function bf(e) {
  return e;
}
function iG(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : dft(isNaN(t) ? NaN : 0.5);
}
function hft(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function pft(e, t, n) {
  var r = e[0], i = e[1], o = t[0], a = t[1];
  return i < r ? (r = iG(i, r), o = n(a, o)) : (r = iG(r, i), o = n(o, a)), function(s) {
    return o(r(s));
  };
}
function gft(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), o = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    i[a] = iG(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);
  return function(s) {
    var u = uN(e, s, 1, r) - 1;
    return o[u](i[u](s));
  };
}
function $$(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function FF() {
  var e = ohe, t = ohe, n = Tw, r, i, o, a = bf, s, u, l;
  function f() {
    var p = Math.min(e.length, t.length);
    return a !== bf && (a = hft(e[0], e[p - 1])), s = p > 2 ? gft : pft, u = l = null, h;
  }
  function h(p) {
    return p == null || isNaN(p = +p) ? o : (u || (u = s(e.map(r), t, n)))(r(a(p)));
  }
  return h.invert = function(p) {
    return a(i((l || (l = s(t, e.map(r), Ku)))(p)));
  }, h.domain = function(p) {
    return arguments.length ? (e = Array.from(p, rG), f()) : e.slice();
  }, h.range = function(p) {
    return arguments.length ? (t = Array.from(p), f()) : t.slice();
  }, h.rangeRound = function(p) {
    return t = Array.from(p), n = fN, f();
  }, h.clamp = function(p) {
    return arguments.length ? (a = p ? !0 : bf, f()) : a !== bf;
  }, h.interpolate = function(p) {
    return arguments.length ? (n = p, f()) : n;
  }, h.unknown = function(p) {
    return arguments.length ? (o = p, h) : o;
  }, function(p, g) {
    return r = p, i = g, f();
  };
}
function cSe() {
  return FF()(bf, bf);
}
function fSe(e, t, n, r) {
  var i = Zx(e, t, n), o;
  switch (r = CS(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(o = vEe(i, a)) && (r.precision = o), sZ(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(o = bEe(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = o - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(o = yEe(i)) && (r.precision = o - (r.type === "%") * 2);
      break;
    }
  }
  return hN(r);
}
function e2(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return Kx(r[0], r[r.length - 1], n ?? 10);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return fSe(i[0], i[i.length - 1], n ?? 10, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, o = r.length - 1, a = r[i], s = r[o], u, l, f = 10;
    for (s < a && (l = a, a = s, s = l, l = i, i = o, o = l); f-- > 0; ) {
      if (l = Mk(a, s, n), l === u)
        return r[i] = a, r[o] = s, t(r);
      if (l > 0)
        a = Math.floor(a / l) * l, s = Math.ceil(s / l) * l;
      else if (l < 0)
        a = Math.ceil(a * l) / l, s = Math.floor(s * l) / l;
      else
        break;
      u = l;
    }
    return e;
  }, e;
}
function BF() {
  var e = cSe();
  return e.copy = function() {
    return $$(e, BF());
  }, Zg.apply(e, arguments), e2(e);
}
function mZ(e) {
  var t;
  function n(r) {
    return r == null || isNaN(r = +r) ? t : r;
  }
  return n.invert = n, n.domain = n.range = function(r) {
    return arguments.length ? (e = Array.from(r, rG), n) : e.slice();
  }, n.unknown = function(r) {
    return arguments.length ? (t = r, n) : t;
  }, n.copy = function() {
    return mZ(e).unknown(t);
  }, e = arguments.length ? Array.from(e, rG) : [0, 1], e2(n);
}
function dSe(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], o = e[r], a;
  return o < i && (a = n, n = r, r = a, a = i, i = o, o = a), e[n] = t.floor(i), e[r] = t.ceil(o), e;
}
function ahe(e) {
  return Math.log(e);
}
function she(e) {
  return Math.exp(e);
}
function mft(e) {
  return -Math.log(-e);
}
function yft(e) {
  return -Math.exp(-e);
}
function vft(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function bft(e) {
  return e === 10 ? vft : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function xft(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function uhe(e) {
  return (t, n) => -e(-t, n);
}
function yZ(e) {
  const t = e(ahe, she), n = t.domain;
  let r = 10, i, o;
  function a() {
    return i = xft(r), o = bft(r), n()[0] < 0 ? (i = uhe(i), o = uhe(o), e(mft, yft)) : e(ahe, she), t;
  }
  return t.base = function(s) {
    return arguments.length ? (r = +s, a()) : r;
  }, t.domain = function(s) {
    return arguments.length ? (n(s), a()) : n();
  }, t.ticks = (s) => {
    const u = n();
    let l = u[0], f = u[u.length - 1];
    const h = f < l;
    h && ([l, f] = [f, l]);
    let p = i(l), g = i(f), y, b;
    const _ = s == null ? 10 : +s;
    let S = [];
    if (!(r % 1) && g - p < _) {
      if (p = Math.floor(p), g = Math.ceil(g), l > 0) {
        for (; p <= g; ++p)
          for (y = 1; y < r; ++y)
            if (b = p < 0 ? y / o(-p) : y * o(p), !(b < l)) {
              if (b > f)
                break;
              S.push(b);
            }
      } else
        for (; p <= g; ++p)
          for (y = r - 1; y >= 1; --y)
            if (b = p > 0 ? y / o(-p) : y * o(p), !(b < l)) {
              if (b > f)
                break;
              S.push(b);
            }
      S.length * 2 < _ && (S = Kx(l, f, _));
    } else
      S = Kx(p, g, Math.min(g - p, _)).map(o);
    return h ? S.reverse() : S;
  }, t.tickFormat = (s, u) => {
    if (s == null && (s = 10), u == null && (u = r === 10 ? "s" : ","), typeof u != "function" && (!(r % 1) && (u = CS(u)).precision == null && (u.trim = !0), u = hN(u)), s === 1 / 0)
      return u;
    const l = Math.max(1, r * s / t.ticks().length);
    return (f) => {
      let h = f / o(Math.round(i(f)));
      return h * r < r - 0.5 && (h *= r), h <= l ? u(f) : "";
    };
  }, t.nice = () => n(dSe(n(), {
    floor: (s) => o(Math.floor(i(s))),
    ceil: (s) => o(Math.ceil(i(s)))
  })), t;
}
function vZ() {
  const e = yZ(FF()).domain([1, 10]);
  return e.copy = () => $$(e, vZ()).base(e.base()), Zg.apply(e, arguments), e;
}
function lhe(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function che(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function bZ(e) {
  var t = 1, n = e(lhe(t), che(t));
  return n.constant = function(r) {
    return arguments.length ? e(lhe(t = +r), che(t)) : t;
  }, e2(n);
}
function xZ() {
  var e = bZ(FF());
  return e.copy = function() {
    return $$(e, xZ()).constant(e.constant());
  }, Zg.apply(e, arguments);
}
function fhe(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function wft(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function _ft(e) {
  return e < 0 ? -e * e : e * e;
}
function wZ(e) {
  var t = e(bf, bf), n = 1;
  function r() {
    return n === 1 ? e(bf, bf) : n === 0.5 ? e(wft, _ft) : e(fhe(n), fhe(1 / n));
  }
  return t.exponent = function(i) {
    return arguments.length ? (n = +i, r()) : n;
  }, e2(t);
}
function UF() {
  var e = wZ(FF());
  return e.copy = function() {
    return $$(e, UF()).exponent(e.exponent());
  }, Zg.apply(e, arguments), e;
}
function Eft() {
  return UF.apply(null, arguments).exponent(0.5);
}
function _Z() {
  var e = [], t = [], n = [], r;
  function i() {
    var a = 0, s = Math.max(1, t.length);
    for (n = new Array(s - 1); ++a < s; )
      n[a - 1] = p_e(e, a / s);
    return o;
  }
  function o(a) {
    return a == null || isNaN(a = +a) ? r : t[uN(n, a)];
  }
  return o.invertExtent = function(a) {
    var s = t.indexOf(a);
    return s < 0 ? [NaN, NaN] : [
      s > 0 ? n[s - 1] : e[0],
      s < n.length ? n[s] : e[e.length - 1]
    ];
  }, o.domain = function(a) {
    if (!arguments.length)
      return e.slice();
    e = [];
    for (let s of a)
      s != null && !isNaN(s = +s) && e.push(s);
    return e.sort(Go), i();
  }, o.range = function(a) {
    return arguments.length ? (t = Array.from(a), i()) : t.slice();
  }, o.unknown = function(a) {
    return arguments.length ? (r = a, o) : r;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return _Z().domain(e).range(t).unknown(r);
  }, Zg.apply(o, arguments);
}
function hSe() {
  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], o;
  function a(u) {
    return u != null && u <= u ? i[uN(r, u, 0, n)] : o;
  }
  function s() {
    var u = -1;
    for (r = new Array(n); ++u < n; )
      r[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, s()) : [e, t];
  }, a.range = function(u) {
    return arguments.length ? (n = (i = Array.from(u)).length - 1, s()) : i.slice();
  }, a.invertExtent = function(u) {
    var l = i.indexOf(u);
    return l < 0 ? [NaN, NaN] : l < 1 ? [e, r[0]] : l >= n ? [r[n - 1], t] : [r[l - 1], r[l]];
  }, a.unknown = function(u) {
    return arguments.length && (o = u), a;
  }, a.thresholds = function() {
    return r.slice();
  }, a.copy = function() {
    return hSe().domain([e, t]).range(i).unknown(o);
  }, Zg.apply(e2(a), arguments);
}
function EZ() {
  var e = [0.5], t = [0, 1], n, r = 1;
  function i(o) {
    return o != null && o <= o ? t[uN(e, o, 0, r)] : n;
  }
  return i.domain = function(o) {
    return arguments.length ? (e = Array.from(o), r = Math.min(e.length, t.length - 1), i) : e.slice();
  }, i.range = function(o) {
    return arguments.length ? (t = Array.from(o), r = Math.min(e.length, t.length - 1), i) : t.slice();
  }, i.invertExtent = function(o) {
    var a = t.indexOf(o);
    return [e[a - 1], e[a]];
  }, i.unknown = function(o) {
    return arguments.length ? (n = o, i) : n;
  }, i.copy = function() {
    return EZ().domain(e).range(t).unknown(n);
  }, Zg.apply(i, arguments);
}
const SH = /* @__PURE__ */ new Date(), MH = /* @__PURE__ */ new Date();
function Gs(e, t, n, r) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), i.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), i.round = (o) => {
    const a = i(o), s = i.ceil(o);
    return o - a < s - o ? a : s;
  }, i.offset = (o, a) => (t(o = /* @__PURE__ */ new Date(+o), a == null ? 1 : Math.floor(a)), o), i.range = (o, a, s) => {
    const u = [];
    if (o = i.ceil(o), s = s == null ? 1 : Math.floor(s), !(o < a) || !(s > 0))
      return u;
    let l;
    do
      u.push(l = /* @__PURE__ */ new Date(+o)), t(o, s), e(o);
    while (l < o && o < a);
    return u;
  }, i.filter = (o) => Gs((a) => {
    if (a >= a)
      for (; e(a), !o(a); )
        a.setTime(a - 1);
  }, (a, s) => {
    if (a >= a)
      if (s < 0)
        for (; ++s <= 0; )
          for (; t(a, -1), !o(a); )
            ;
      else
        for (; --s >= 0; )
          for (; t(a, 1), !o(a); )
            ;
  }), n && (i.count = (o, a) => (SH.setTime(+o), MH.setTime(+a), e(SH), e(MH), Math.floor(n(SH, MH))), i.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(r ? (a) => r(a) % o === 0 : (a) => i.count(0, a) % o === 0) : i)), i;
}
const hC = Gs(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
hC.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Gs((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : hC);
hC.range;
const W0 = 1e3, Jh = W0 * 60, q0 = Jh * 60, cb = q0 * 24, SZ = cb * 7, dhe = cb * 30, TH = cb * 365, kg = Gs((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * W0);
}, (e, t) => (t - e) / W0, (e) => e.getUTCSeconds());
kg.range;
const P$ = Gs((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * W0);
}, (e, t) => {
  e.setTime(+e + t * Jh);
}, (e, t) => (t - e) / Jh, (e) => e.getMinutes());
P$.range;
const I$ = Gs((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Jh);
}, (e, t) => (t - e) / Jh, (e) => e.getUTCMinutes());
I$.range;
const j$ = Gs((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * W0 - e.getMinutes() * Jh);
}, (e, t) => {
  e.setTime(+e + t * q0);
}, (e, t) => (t - e) / q0, (e) => e.getHours());
j$.range;
const L$ = Gs((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * q0);
}, (e, t) => (t - e) / q0, (e) => e.getUTCHours());
L$.range;
const Fy = Gs(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Jh) / cb,
  (e) => e.getDate() - 1
);
Fy.range;
const jx = Gs((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / cb, (e) => e.getUTCDate() - 1);
jx.range;
const MZ = Gs((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / cb, (e) => Math.floor(e / cb));
MZ.range;
function t2(e) {
  return Gs((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Jh) / SZ);
}
const nw = t2(0), Rk = t2(1), pSe = t2(2), gSe = t2(3), DS = t2(4), mSe = t2(5), ySe = t2(6);
nw.range;
Rk.range;
pSe.range;
gSe.range;
DS.range;
mSe.range;
ySe.range;
function n2(e) {
  return Gs((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / SZ);
}
const rw = n2(0), kk = n2(1), vSe = n2(2), bSe = n2(3), AS = n2(4), xSe = n2(5), wSe = n2(6);
rw.range;
kk.range;
vSe.range;
bSe.range;
AS.range;
xSe.range;
wSe.range;
const pC = Gs((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
pC.range;
const gC = Gs((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
gC.range;
const hp = Gs((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
hp.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Gs((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
hp.range;
const pp = Gs((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
pp.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Gs((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
pp.range;
function _Se(e, t, n, r, i, o) {
  const a = [
    [kg, 1, W0],
    [kg, 5, 5 * W0],
    [kg, 15, 15 * W0],
    [kg, 30, 30 * W0],
    [o, 1, Jh],
    [o, 5, 5 * Jh],
    [o, 15, 15 * Jh],
    [o, 30, 30 * Jh],
    [i, 1, q0],
    [i, 3, 3 * q0],
    [i, 6, 6 * q0],
    [i, 12, 12 * q0],
    [r, 1, cb],
    [r, 2, 2 * cb],
    [n, 1, SZ],
    [t, 1, dhe],
    [t, 3, 3 * dhe],
    [e, 1, TH]
  ];
  function s(l, f, h) {
    const p = f < l;
    p && ([l, f] = [f, l]);
    const g = h && typeof h.range == "function" ? h : u(l, f, h), y = g ? g.range(l, +f + 1) : [];
    return p ? y.reverse() : y;
  }
  function u(l, f, h) {
    const p = Math.abs(f - l) / h, g = Qx(([, , _]) => _).right(a, p);
    if (g === a.length)
      return e.every(Zx(l / TH, f / TH, h));
    if (g === 0)
      return hC.every(Math.max(Zx(l, f, h), 1));
    const [y, b] = a[p / a[g - 1][2] < a[g][2] / p ? g - 1 : g];
    return y.every(b);
  }
  return [s, u];
}
const [Sft, ESe] = _Se(pp, gC, rw, MZ, L$, I$), [Mft, Tft] = _Se(hp, pC, nw, Fy, j$, P$);
function CH(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function NH(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function qA(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function SSe(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, o = e.days, a = e.shortDays, s = e.months, u = e.shortMonths, l = GA(i), f = QA(i), h = GA(o), p = QA(o), g = GA(a), y = QA(a), b = GA(s), _ = QA(s), S = GA(u), C = QA(u), A = {
    a: X,
    A: Z,
    b: se,
    B: H,
    c: null,
    d: vhe,
    e: vhe,
    f: Qft,
    g: odt,
    G: sdt,
    H: Wft,
    I: qft,
    j: Gft,
    L: MSe,
    m: Xft,
    M: Kft,
    p: ie,
    q: he,
    Q: whe,
    s: _he,
    S: Zft,
    u: Jft,
    U: edt,
    V: tdt,
    w: ndt,
    W: rdt,
    x: null,
    X: null,
    y: idt,
    Y: adt,
    Z: udt,
    "%": xhe
  }, O = {
    a: ye,
    A: _e,
    b: Ne,
    B: Oe,
    c: null,
    d: bhe,
    e: bhe,
    f: ddt,
    g: _dt,
    G: Sdt,
    H: ldt,
    I: cdt,
    j: fdt,
    L: CSe,
    m: hdt,
    M: pdt,
    p: ke,
    q: Me,
    Q: whe,
    s: _he,
    S: gdt,
    u: mdt,
    U: ydt,
    V: vdt,
    w: bdt,
    W: xdt,
    x: null,
    X: null,
    y: wdt,
    Y: Edt,
    Z: Mdt,
    "%": xhe
  }, R = {
    a: Y,
    A: V,
    b: ee,
    B: K,
    c: Q,
    d: mhe,
    e: mhe,
    f: Uft,
    g: ghe,
    G: phe,
    H: yhe,
    I: yhe,
    j: Lft,
    L: Bft,
    m: jft,
    M: zft,
    p: W,
    q: Ift,
    Q: Hft,
    s: Vft,
    S: Fft,
    u: Oft,
    U: Rft,
    V: kft,
    w: Aft,
    W: $ft,
    x: q,
    X: te,
    y: ghe,
    Y: phe,
    Z: Pft,
    "%": Yft
  };
  A.x = j(n, A), A.X = j(r, A), A.c = j(t, A), O.x = j(n, O), O.X = j(r, O), O.c = j(t, O);
  function j(we, Ye) {
    return function(ze) {
      var fe = [], Qe = -1, $e = 0, pt = we.length, _t, Ot, mn;
      for (ze instanceof Date || (ze = /* @__PURE__ */ new Date(+ze)); ++Qe < pt; )
        we.charCodeAt(Qe) === 37 && (fe.push(we.slice($e, Qe)), (Ot = hhe[_t = we.charAt(++Qe)]) != null ? _t = we.charAt(++Qe) : Ot = _t === "e" ? " " : "0", (mn = Ye[_t]) && (_t = mn(ze, Ot)), fe.push(_t), $e = Qe + 1);
      return fe.push(we.slice($e, Qe)), fe.join("");
    };
  }
  function $(we, Ye) {
    return function(ze) {
      var fe = qA(1900, void 0, 1), Qe = z(fe, we, ze += "", 0), $e, pt;
      if (Qe != ze.length)
        return null;
      if ("Q" in fe)
        return new Date(fe.Q);
      if ("s" in fe)
        return new Date(fe.s * 1e3 + ("L" in fe ? fe.L : 0));
      if (Ye && !("Z" in fe) && (fe.Z = 0), "p" in fe && (fe.H = fe.H % 12 + fe.p * 12), fe.m === void 0 && (fe.m = "q" in fe ? fe.q : 0), "V" in fe) {
        if (fe.V < 1 || fe.V > 53)
          return null;
        "w" in fe || (fe.w = 1), "Z" in fe ? ($e = NH(qA(fe.y, 0, 1)), pt = $e.getUTCDay(), $e = pt > 4 || pt === 0 ? kk.ceil($e) : kk($e), $e = jx.offset($e, (fe.V - 1) * 7), fe.y = $e.getUTCFullYear(), fe.m = $e.getUTCMonth(), fe.d = $e.getUTCDate() + (fe.w + 6) % 7) : ($e = CH(qA(fe.y, 0, 1)), pt = $e.getDay(), $e = pt > 4 || pt === 0 ? Rk.ceil($e) : Rk($e), $e = Fy.offset($e, (fe.V - 1) * 7), fe.y = $e.getFullYear(), fe.m = $e.getMonth(), fe.d = $e.getDate() + (fe.w + 6) % 7);
      } else
        ("W" in fe || "U" in fe) && ("w" in fe || (fe.w = "u" in fe ? fe.u % 7 : "W" in fe ? 1 : 0), pt = "Z" in fe ? NH(qA(fe.y, 0, 1)).getUTCDay() : CH(qA(fe.y, 0, 1)).getDay(), fe.m = 0, fe.d = "W" in fe ? (fe.w + 6) % 7 + fe.W * 7 - (pt + 5) % 7 : fe.w + fe.U * 7 - (pt + 6) % 7);
      return "Z" in fe ? (fe.H += fe.Z / 100 | 0, fe.M += fe.Z % 100, NH(fe)) : CH(fe);
    };
  }
  function z(we, Ye, ze, fe) {
    for (var Qe = 0, $e = Ye.length, pt = ze.length, _t, Ot; Qe < $e; ) {
      if (fe >= pt)
        return -1;
      if (_t = Ye.charCodeAt(Qe++), _t === 37) {
        if (_t = Ye.charAt(Qe++), Ot = R[_t in hhe ? Ye.charAt(Qe++) : _t], !Ot || (fe = Ot(we, ze, fe)) < 0)
          return -1;
      } else if (_t != ze.charCodeAt(fe++))
        return -1;
    }
    return fe;
  }
  function W(we, Ye, ze) {
    var fe = l.exec(Ye.slice(ze));
    return fe ? (we.p = f.get(fe[0].toLowerCase()), ze + fe[0].length) : -1;
  }
  function Y(we, Ye, ze) {
    var fe = g.exec(Ye.slice(ze));
    return fe ? (we.w = y.get(fe[0].toLowerCase()), ze + fe[0].length) : -1;
  }
  function V(we, Ye, ze) {
    var fe = h.exec(Ye.slice(ze));
    return fe ? (we.w = p.get(fe[0].toLowerCase()), ze + fe[0].length) : -1;
  }
  function ee(we, Ye, ze) {
    var fe = S.exec(Ye.slice(ze));
    return fe ? (we.m = C.get(fe[0].toLowerCase()), ze + fe[0].length) : -1;
  }
  function K(we, Ye, ze) {
    var fe = b.exec(Ye.slice(ze));
    return fe ? (we.m = _.get(fe[0].toLowerCase()), ze + fe[0].length) : -1;
  }
  function Q(we, Ye, ze) {
    return z(we, t, Ye, ze);
  }
  function q(we, Ye, ze) {
    return z(we, n, Ye, ze);
  }
  function te(we, Ye, ze) {
    return z(we, r, Ye, ze);
  }
  function X(we) {
    return a[we.getDay()];
  }
  function Z(we) {
    return o[we.getDay()];
  }
  function se(we) {
    return u[we.getMonth()];
  }
  function H(we) {
    return s[we.getMonth()];
  }
  function ie(we) {
    return i[+(we.getHours() >= 12)];
  }
  function he(we) {
    return 1 + ~~(we.getMonth() / 3);
  }
  function ye(we) {
    return a[we.getUTCDay()];
  }
  function _e(we) {
    return o[we.getUTCDay()];
  }
  function Ne(we) {
    return u[we.getUTCMonth()];
  }
  function Oe(we) {
    return s[we.getUTCMonth()];
  }
  function ke(we) {
    return i[+(we.getUTCHours() >= 12)];
  }
  function Me(we) {
    return 1 + ~~(we.getUTCMonth() / 3);
  }
  return {
    format: function(we) {
      var Ye = j(we += "", A);
      return Ye.toString = function() {
        return we;
      }, Ye;
    },
    parse: function(we) {
      var Ye = $(we += "", !1);
      return Ye.toString = function() {
        return we;
      }, Ye;
    },
    utcFormat: function(we) {
      var Ye = j(we += "", O);
      return Ye.toString = function() {
        return we;
      }, Ye;
    },
    utcParse: function(we) {
      var Ye = $(we += "", !0);
      return Ye.toString = function() {
        return we;
      }, Ye;
    }
  };
}
var hhe = { "-": "", _: " ", 0: "0" }, wu = /^\s*\d+/, Cft = /^%/, Nft = /[\\^$*+?|[\]().{}]/g;
function Ni(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", o = i.length;
  return r + (o < n ? new Array(n - o + 1).join(t) + i : i);
}
function Dft(e) {
  return e.replace(Nft, "\\$&");
}
function GA(e) {
  return new RegExp("^(?:" + e.map(Dft).join("|") + ")", "i");
}
function QA(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function Aft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function Oft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function Rft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function kft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function $ft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function phe(e, t, n) {
  var r = wu.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function ghe(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function Pft(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function Ift(e, t, n) {
  var r = wu.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function jft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function mhe(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function Lft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function yhe(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function zft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function Fft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function Bft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function Uft(e, t, n) {
  var r = wu.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function Yft(e, t, n) {
  var r = Cft.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function Hft(e, t, n) {
  var r = wu.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function Vft(e, t, n) {
  var r = wu.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function vhe(e, t) {
  return Ni(e.getDate(), t, 2);
}
function Wft(e, t) {
  return Ni(e.getHours(), t, 2);
}
function qft(e, t) {
  return Ni(e.getHours() % 12 || 12, t, 2);
}
function Gft(e, t) {
  return Ni(1 + Fy.count(hp(e), e), t, 3);
}
function MSe(e, t) {
  return Ni(e.getMilliseconds(), t, 3);
}
function Qft(e, t) {
  return MSe(e, t) + "000";
}
function Xft(e, t) {
  return Ni(e.getMonth() + 1, t, 2);
}
function Kft(e, t) {
  return Ni(e.getMinutes(), t, 2);
}
function Zft(e, t) {
  return Ni(e.getSeconds(), t, 2);
}
function Jft(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function edt(e, t) {
  return Ni(nw.count(hp(e) - 1, e), t, 2);
}
function TSe(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? DS(e) : DS.ceil(e);
}
function tdt(e, t) {
  return e = TSe(e), Ni(DS.count(hp(e), e) + (hp(e).getDay() === 4), t, 2);
}
function ndt(e) {
  return e.getDay();
}
function rdt(e, t) {
  return Ni(Rk.count(hp(e) - 1, e), t, 2);
}
function idt(e, t) {
  return Ni(e.getFullYear() % 100, t, 2);
}
function odt(e, t) {
  return e = TSe(e), Ni(e.getFullYear() % 100, t, 2);
}
function adt(e, t) {
  return Ni(e.getFullYear() % 1e4, t, 4);
}
function sdt(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? DS(e) : DS.ceil(e), Ni(e.getFullYear() % 1e4, t, 4);
}
function udt(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ni(t / 60 | 0, "0", 2) + Ni(t % 60, "0", 2);
}
function bhe(e, t) {
  return Ni(e.getUTCDate(), t, 2);
}
function ldt(e, t) {
  return Ni(e.getUTCHours(), t, 2);
}
function cdt(e, t) {
  return Ni(e.getUTCHours() % 12 || 12, t, 2);
}
function fdt(e, t) {
  return Ni(1 + jx.count(pp(e), e), t, 3);
}
function CSe(e, t) {
  return Ni(e.getUTCMilliseconds(), t, 3);
}
function ddt(e, t) {
  return CSe(e, t) + "000";
}
function hdt(e, t) {
  return Ni(e.getUTCMonth() + 1, t, 2);
}
function pdt(e, t) {
  return Ni(e.getUTCMinutes(), t, 2);
}
function gdt(e, t) {
  return Ni(e.getUTCSeconds(), t, 2);
}
function mdt(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function ydt(e, t) {
  return Ni(rw.count(pp(e) - 1, e), t, 2);
}
function NSe(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? AS(e) : AS.ceil(e);
}
function vdt(e, t) {
  return e = NSe(e), Ni(AS.count(pp(e), e) + (pp(e).getUTCDay() === 4), t, 2);
}
function bdt(e) {
  return e.getUTCDay();
}
function xdt(e, t) {
  return Ni(kk.count(pp(e) - 1, e), t, 2);
}
function wdt(e, t) {
  return Ni(e.getUTCFullYear() % 100, t, 2);
}
function _dt(e, t) {
  return e = NSe(e), Ni(e.getUTCFullYear() % 100, t, 2);
}
function Edt(e, t) {
  return Ni(e.getUTCFullYear() % 1e4, t, 4);
}
function Sdt(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? AS(e) : AS.ceil(e), Ni(e.getUTCFullYear() % 1e4, t, 4);
}
function Mdt() {
  return "+0000";
}
function xhe() {
  return "%";
}
function whe(e) {
  return +e;
}
function _he(e) {
  return Math.floor(+e / 1e3);
}
var BM, z$, DSe, mC, ASe;
Tdt({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Tdt(e) {
  return BM = SSe(e), z$ = BM.format, DSe = BM.parse, mC = BM.utcFormat, ASe = BM.utcParse, BM;
}
function Cdt(e) {
  return new Date(e);
}
function Ndt(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function TZ(e, t, n, r, i, o, a, s, u, l) {
  var f = cSe(), h = f.invert, p = f.domain, g = l(".%L"), y = l(":%S"), b = l("%I:%M"), _ = l("%I %p"), S = l("%a %d"), C = l("%b %d"), A = l("%B"), O = l("%Y");
  function R(j) {
    return (u(j) < j ? g : s(j) < j ? y : a(j) < j ? b : o(j) < j ? _ : r(j) < j ? i(j) < j ? S : C : n(j) < j ? A : O)(j);
  }
  return f.invert = function(j) {
    return new Date(h(j));
  }, f.domain = function(j) {
    return arguments.length ? p(Array.from(j, Ndt)) : p().map(Cdt);
  }, f.ticks = function(j) {
    var $ = p();
    return e($[0], $[$.length - 1], j ?? 10);
  }, f.tickFormat = function(j, $) {
    return $ == null ? R : l($);
  }, f.nice = function(j) {
    var $ = p();
    return (!j || typeof j.range != "function") && (j = t($[0], $[$.length - 1], j ?? 10)), j ? p(dSe($, j)) : f;
  }, f.copy = function() {
    return $$(f, TZ(e, t, n, r, i, o, a, s, u, l));
  }, f;
}
function OSe() {
  return Zg.apply(TZ(Mft, Tft, hp, pC, nw, Fy, j$, P$, kg, z$).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function RSe() {
  return Zg.apply(TZ(Sft, ESe, pp, gC, rw, jx, L$, I$, kg, mC).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function YF() {
  var e = 0, t = 1, n, r, i, o, a = bf, s = !1, u;
  function l(h) {
    return h == null || isNaN(h = +h) ? u : a(i === 0 ? 0.5 : (h = (o(h) - n) * i, s ? Math.max(0, Math.min(1, h)) : h));
  }
  l.domain = function(h) {
    return arguments.length ? ([e, t] = h, n = o(e = +e), r = o(t = +t), i = n === r ? 0 : 1 / (r - n), l) : [e, t];
  }, l.clamp = function(h) {
    return arguments.length ? (s = !!h, l) : s;
  }, l.interpolator = function(h) {
    return arguments.length ? (a = h, l) : a;
  };
  function f(h) {
    return function(p) {
      var g, y;
      return arguments.length ? ([g, y] = p, a = h(g, y), l) : [a(0), a(1)];
    };
  }
  return l.range = f(Tw), l.rangeRound = f(fN), l.unknown = function(h) {
    return arguments.length ? (u = h, l) : u;
  }, function(h) {
    return o = h, n = h(e), r = h(t), i = n === r ? 0 : 1 / (r - n), l;
  };
}
function Aw(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function CZ() {
  var e = e2(YF()(bf));
  return e.copy = function() {
    return Aw(e, CZ());
  }, Dw.apply(e, arguments);
}
function kSe() {
  var e = yZ(YF()).domain([1, 10]);
  return e.copy = function() {
    return Aw(e, kSe()).base(e.base());
  }, Dw.apply(e, arguments);
}
function $Se() {
  var e = bZ(YF());
  return e.copy = function() {
    return Aw(e, $Se()).constant(e.constant());
  }, Dw.apply(e, arguments);
}
function NZ() {
  var e = wZ(YF());
  return e.copy = function() {
    return Aw(e, NZ()).exponent(e.exponent());
  }, Dw.apply(e, arguments);
}
function Ddt() {
  return NZ.apply(null, arguments).exponent(0.5);
}
function HF() {
  var e = 0, t = 0.5, n = 1, r = 1, i, o, a, s, u, l = bf, f, h = !1, p;
  function g(b) {
    return isNaN(b = +b) ? p : (b = 0.5 + ((b = +f(b)) - o) * (r * b < r * o ? s : u), l(h ? Math.max(0, Math.min(1, b)) : b));
  }
  g.domain = function(b) {
    return arguments.length ? ([e, t, n] = b, i = f(e = +e), o = f(t = +t), a = f(n = +n), s = i === o ? 0 : 0.5 / (o - i), u = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, g) : [e, t, n];
  }, g.clamp = function(b) {
    return arguments.length ? (h = !!b, g) : h;
  }, g.interpolator = function(b) {
    return arguments.length ? (l = b, g) : l;
  };
  function y(b) {
    return function(_) {
      var S, C, A;
      return arguments.length ? ([S, C, A] = _, l = dN(b, [S, C, A]), g) : [l(0), l(0.5), l(1)];
    };
  }
  return g.range = y(Tw), g.rangeRound = y(fN), g.unknown = function(b) {
    return arguments.length ? (p = b, g) : p;
  }, function(b) {
    return f = b, i = b(e), o = b(t), a = b(n), s = i === o ? 0 : 0.5 / (o - i), u = o === a ? 0 : 0.5 / (a - o), r = o < i ? -1 : 1, g;
  };
}
function DZ() {
  var e = e2(HF()(bf));
  return e.copy = function() {
    return Aw(e, DZ());
  }, Dw.apply(e, arguments);
}
function AZ() {
  var e = yZ(HF()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return Aw(e, AZ()).base(e.base());
  }, Dw.apply(e, arguments);
}
function OZ() {
  var e = bZ(HF());
  return e.copy = function() {
    return Aw(e, OZ()).constant(e.constant());
  }, Dw.apply(e, arguments);
}
function VF() {
  var e = wZ(HF());
  return e.copy = function() {
    return Aw(e, VF()).exponent(e.exponent());
  }, Dw.apply(e, arguments);
}
function Adt() {
  return VF.apply(null, arguments).exponent(0.5);
}
function br(e) {
  for (var t = e.length / 6 | 0, n = new Array(t), r = 0; r < t; )
    n[r] = "#" + e.slice(r * 6, ++r * 6);
  return n;
}
const Odt = br("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), Rdt = br("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), kdt = br("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), $dt = br("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), Pdt = br("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), Idt = br("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), jdt = br("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), Ldt = br("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), zdt = br("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"), Fdt = br("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"), Mo = (e) => V_e(e[e.length - 1]);
var PSe = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(br);
const ISe = Mo(PSe);
var jSe = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(br);
const LSe = Mo(jSe);
var zSe = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(br);
const FSe = Mo(zSe);
var BSe = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(br);
const USe = Mo(BSe);
var oG = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(br);
const YL = Mo(oG);
var YSe = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(br);
const HSe = Mo(YSe);
var aG = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(br);
const HL = Mo(aG);
var VSe = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(br);
const WSe = Mo(VSe);
var qSe = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(br);
const GSe = Mo(qSe);
var QSe = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(br);
const XSe = Mo(QSe);
var KSe = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(br);
const ZSe = Mo(KSe);
var JSe = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(br);
const e2e = Mo(JSe);
var t2e = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(br);
const n2e = Mo(t2e);
var r2e = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(br);
const i2e = Mo(r2e);
var o2e = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(br);
const a2e = Mo(o2e);
var s2e = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(br);
const u2e = Mo(s2e);
var l2e = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(br);
const c2e = Mo(l2e);
var f2e = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(br);
const d2e = Mo(f2e);
var h2e = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(br);
const p2e = Mo(h2e);
var g2e = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(br);
const m2e = Mo(g2e);
var y2e = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(br);
const v2e = Mo(y2e);
var b2e = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(br);
const x2e = Mo(b2e);
var w2e = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(br);
const _2e = Mo(w2e);
var E2e = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(br);
const S2e = Mo(E2e);
var M2e = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(br);
const T2e = Mo(M2e);
var C2e = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(br);
const N2e = Mo(C2e);
var D2e = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(br);
const A2e = Mo(D2e);
function O2e(e) {
  return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - e * (35.34 - e * (2381.73 - e * (6402.7 - e * (7024.72 - e * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + e * (170.73 + e * (52.82 - e * (131.46 - e * (176.58 - e * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + e * (442.36 - e * (2482.43 - e * (6167.24 - e * (6614.94 - e * 2475.67))))))) + ")";
}
const R2e = RF(qy(300, 0.5, 0), qy(-240, 0.5, 1));
var k2e = RF(qy(-100, 0.75, 0.35), qy(80, 1.5, 0.8)), $2e = RF(qy(260, 0.75, 0.35), qy(80, 1.5, 0.8)), n3 = qy();
function P2e(e) {
  (e < 0 || e > 1) && (e -= Math.floor(e));
  var t = Math.abs(e - 0.5);
  return n3.h = 360 * e - 100, n3.s = 1.5 - 1.5 * t, n3.l = 0.8 - 0.9 * t, n3 + "";
}
var r3 = Cf(), Bdt = Math.PI / 3, Udt = Math.PI * 2 / 3;
function I2e(e) {
  var t;
  return e = (0.5 - e) * Math.PI, r3.r = 255 * (t = Math.sin(e)) * t, r3.g = 255 * (t = Math.sin(e + Bdt)) * t, r3.b = 255 * (t = Math.sin(e + Udt)) * t, r3 + "";
}
function j2e(e) {
  return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + e * (1172.33 - e * (10793.56 - e * (33300.12 - e * (38394.49 - e * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + e * (557.33 + e * (1225.33 - e * (3574.96 - e * (1073.77 + e * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + e * (3211.1 - e * (15327.97 - e * (27814 - e * (22569.18 - e * 6838.66))))))) + ")";
}
function WF(e) {
  var t = e.length;
  return function(n) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
  };
}
const L2e = WF(br("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var z2e = WF(br("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), F2e = WF(br("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")), B2e = WF(br("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function LO(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
LO.prototype = {
  constructor: LO,
  scale: function(e) {
    return e === 1 ? this : new LO(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new LO(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
LO.prototype;
function Dc(e) {
  return e != null && !Number.isNaN(e);
}
function gp(e, t) {
  return +Dc(t) - +Dc(e) || Go(e, t);
}
function VL(e, t) {
  return +Dc(t) - +Dc(e) || _S(e, t);
}
function RZ(e) {
  return e != null && `${e}` != "";
}
function WL(e) {
  return isFinite(e) ? e : NaN;
}
function Z0(e) {
  return e > 0 && isFinite(e) ? e : NaN;
}
function qF(e) {
  return e < 0 && isFinite(e) ? e : NaN;
}
function Ydt(e, t) {
  if (e instanceof Date || (e = /* @__PURE__ */ new Date(+e)), isNaN(e))
    return typeof t == "function" ? t(e) : t;
  const n = e.getUTCHours(), r = e.getUTCMinutes(), i = e.getUTCSeconds(), o = e.getUTCMilliseconds();
  return `${Hdt(e.getUTCFullYear())}-${z0(e.getUTCMonth() + 1, 2)}-${z0(e.getUTCDate(), 2)}${n || r || i || o ? `T${z0(n, 2)}:${z0(r, 2)}${i || o ? `:${z0(i, 2)}${o ? `.${z0(o, 3)}` : ""}` : ""}Z` : ""}`;
}
function Hdt(e) {
  return e < 0 ? `-${z0(-e, 6)}` : e > 9999 ? `+${z0(e, 6)}` : z0(e, 4);
}
function z0(e, t) {
  return `${e}`.padStart(t, "0");
}
const Vdt = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function U2e(e, t) {
  return Vdt.test(e += "") ? new Date(e) : typeof t == "function" ? t(e) : t;
}
const lj = 1e3, sG = lj * 60, uG = sG * 60, $k = uG * 24, Wdt = $k * 7, Ehe = $k * 30, qdt = $k * 365, XA = [
  ["millisecond", 0.5 * lj],
  ["second", lj],
  ["second", 30 * lj],
  ["minute", sG],
  ["minute", 30 * sG],
  ["hour", uG],
  ["hour", 12 * uG],
  ["day", $k],
  ["day", 2 * $k],
  ["week", Wdt],
  ["month", Ehe],
  ["month", 3 * Ehe],
  ["year", qdt]
], Gdt = /* @__PURE__ */ new Map([
  ["second", kg],
  ["minute", P$],
  ["hour", j$],
  ["day", Fy],
  // TODO local time equivalent of unixDay?
  ["week", nw],
  ["month", pC],
  ["year", hp],
  ["monday", Rk],
  ["tuesday", pSe],
  ["wednesday", gSe],
  ["thursday", DS],
  ["friday", mSe],
  ["saturday", ySe],
  ["sunday", nw]
]), Qdt = /* @__PURE__ */ new Map([
  ["second", kg],
  ["minute", I$],
  ["hour", L$],
  ["day", MZ],
  ["week", rw],
  ["month", gC],
  ["year", pp],
  ["monday", kk],
  ["tuesday", vSe],
  ["wednesday", bSe],
  ["thursday", AS],
  ["friday", xSe],
  ["saturday", wSe],
  ["sunday", rw]
]);
function Y2e(e, t) {
  let n = `${e}`.toLowerCase();
  n.endsWith("s") && (n = n.slice(0, -1));
  let r = 1;
  const i = /^(?:(\d+)\s+)/.exec(n);
  switch (i && (n = n.slice(i[0].length), r = +i[1]), n) {
    case "quarter":
      n = "month", r *= 3;
      break;
    case "half":
      n = "month", r *= 6;
      break;
  }
  let o = t.get(n);
  if (!o)
    throw new Error(`unknown interval: ${e}`);
  if (!(r > 1))
    return o;
  if (!o.every)
    throw new Error(`non-periodic interval: ${n}`);
  return o.every(r);
}
function Xdt(e) {
  return Y2e(e, Gdt);
}
function H2e(e) {
  return Y2e(e, Qdt);
}
function Kdt(e) {
  if (!e)
    return !1;
  const t = e.floor(new Date(Date.UTC(2e3, 11, 31)));
  return pp(t) >= t;
}
function Zdt(e) {
  if (!e)
    return !1;
  const t = e.floor(new Date(2e3, 11, 31));
  return hp(t) >= t;
}
function Jdt(e, t, n, r) {
  const i = e.type === "time" ? z$ : mC, o = r === "left" || r === "right" ? (a, s) => `
${a}
${s}` : r === "top" ? (a, s) => `${s}
${a}` : (a, s) => `${a}
${s}`;
  switch (eht(e, t, n)) {
    case "millisecond":
      return cE(i(".%L"), i(":%M:%S"), o);
    case "second":
      return cE(i(":%S"), i("%-I:%M"), o);
    case "minute":
      return cE(i("%-I:%M"), i("%p"), o);
    case "hour":
      return cE(i("%-I %p"), i("%b %-d"), o);
    case "day":
      return cE(i("%-d"), i("%b"), o);
    case "week":
      return cE(i("%-d"), i("%b"), o);
    case "month":
      return cE(i("%b"), i("%Y"), o);
    case "year":
      return i("%Y");
  }
  throw new Error("unable to format time ticks");
}
function eht(e, t, n) {
  const r = Jx(eit(t, (u, l) => Math.abs(l - u) || NaN));
  if (r > 0)
    return XA[Qx(([, u]) => u).right(XA, r, 1, XA.length) - 1][0];
  const [i, o] = Zu(e.domain()), a = typeof n == "number" ? n : 10, s = Math.abs(o - i) / a;
  return XA[Qx(([, u]) => Math.log(u)).center(XA, Math.log(s))][0];
}
function cE(e, t, n) {
  return (r, i, o) => {
    const a = e(r, i), s = t(r, i), u = i - bC(o);
    return i !== u && o[u] !== void 0 && s === t(o[u], u) ? a : n(a, s);
  };
}
const yC = Object.getPrototypeOf(Uint8Array), tht = Object.prototype.toString;
function Qr(e, t, n) {
  const r = typeof t;
  return r === "string" ? She(e, V2e(t), n) : r === "function" ? She(e, t, n) : r === "number" || t instanceof Date || r === "boolean" ? jo(e, Bd(t), n) : typeof (t == null ? void 0 : t.transform) == "function" ? Mhe(t.transform(e), n) : Mhe(t, n);
}
function She(e, t, n) {
  return jo(e, (n == null ? void 0 : n.prototype) instanceof yC ? nht(t) : t, n);
}
function Mhe(e, t) {
  return t === void 0 ? Af(e) : e instanceof t ? e : t.prototype instanceof yC && !(e instanceof yC) ? t.from(e, PZ) : t.from(e);
}
function nht(e) {
  return (t, n) => PZ(e(t, n));
}
const RR = [null], V2e = (e) => (t) => t[e], zf = { transform: _b }, Wn = { transform: (e) => e }, kZ = () => 1, rht = () => !0, Ll = (e) => e == null ? e : `${e}`, ti = (e) => e == null ? e : +e, F$ = (e) => e ? e[0] : void 0, Pk = (e) => e ? e[1] : void 0, iht = (e) => e ? e[2] : void 0, Bd = (e) => () => e;
function $Z(e) {
  const t = +`${e}`.slice(1) / 100;
  return (n, r) => Wy(n, t, r);
}
function xf(e) {
  return e instanceof yC ? e : jo(e, PZ, Float64Array);
}
function PZ(e) {
  return e == null ? NaN : Number(e);
}
function oht(e) {
  return jo(e, W2e);
}
function W2e(e) {
  return e instanceof Date && !isNaN(e) ? e : typeof e == "string" ? U2e(e) : e == null || isNaN(e = +e) ? void 0 : new Date(e);
}
function Df(e, t) {
  return e === void 0 && (e = t), e === null ? [void 0, "none"] : U$(e) ? [void 0, e] : [e, void 0];
}
function ns(e, t) {
  return e === void 0 && (e = t), e === null || typeof e == "number" ? [void 0, e] : [e, void 0];
}
function IZ(e, t, n) {
  if (e != null)
    return Sp(e, t, n);
}
function Sp(e, t, n) {
  const r = `${e}`.toLowerCase();
  if (!n.includes(r))
    throw new Error(`invalid ${t}: ${e}`);
  return r;
}
function Af(e) {
  return e == null || e instanceof Array || e instanceof yC ? e : Array.from(e);
}
function jo(e, t, n = Array) {
  return e == null ? e : e instanceof n ? e.map(t) : n.from(e, t);
}
function lG(e, t = Array) {
  return e instanceof t ? e.slice() : t.from(e);
}
function q2e({ x: e, x1: t, x2: n }) {
  return e !== void 0 || t !== void 0 || n !== void 0;
}
function G2e({ y: e, y1: t, y2: n }) {
  return e !== void 0 || t !== void 0 || n !== void 0;
}
function GF(e) {
  return q2e(e) || G2e(e) || e.interval !== void 0;
}
function Jg(e) {
  return (e == null ? void 0 : e.toString) === tht;
}
function tS(e) {
  return Jg(e) && (e.type !== void 0 || e.domain !== void 0);
}
function Ey(e) {
  return Jg(e) && typeof e.transform != "function";
}
function iw(e) {
  return Ey(e) && e.value === void 0 && e.channel === void 0;
}
function Q2e(e, t, n, r = Wn) {
  return t === void 0 && n === void 0 ? (t = 0, n = e === void 0 ? r : e) : t === void 0 ? t = e === void 0 ? 0 : e : n === void 0 && (n = e === void 0 ? 0 : e), [t, n];
}
function em(e, t) {
  return e === void 0 && t === void 0 ? [F$, Pk] : [e, t];
}
function Ow({ z: e, fill: t, stroke: n } = {}) {
  return e === void 0 && ([e] = Df(t)), e === void 0 && ([e] = Df(n)), e;
}
function _b(e) {
  const t = e.length, n = new Uint32Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = r;
  return n;
}
function jZ(e, t) {
  return jo(t, (n) => e[n]);
}
function LZ(e) {
  return e.length === 1 ? (t, n) => e(jZ(n, t)) : e;
}
function nS(e, t, n) {
  return e.subarray ? e.subarray(t, n) : e.slice(t, n);
}
function YE(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function X2e(e, t) {
  if (t[e] !== void 0)
    return t[e];
  switch (e) {
    case "x1":
    case "x2":
      e = "x";
      break;
    case "y1":
    case "y2":
      e = "y";
      break;
  }
  return t[e];
}
function Cd(e) {
  let t;
  return [
    {
      transform: () => t,
      label: Eb(e)
    },
    (n) => t = n
  ];
}
function pf(e) {
  return e == null ? [e] : Cd(e);
}
function Eb(e, t) {
  return typeof e == "string" ? e : e && e.label !== void 0 ? e.label : t;
}
function qL(e, t) {
  return {
    transform(n) {
      const r = e.transform(n), i = t.transform(n);
      return mp(r) || mp(i) ? jo(r, (o, a) => new Date((+r[a] + +i[a]) / 2)) : jo(r, (o, a) => (+r[a] + +i[a]) / 2, Float64Array);
    },
    label: e.label
  };
}
function GL(e, t) {
  const n = K2e(t == null ? void 0 : t.interval, t == null ? void 0 : t.type);
  return n ? jo(e, n) : e;
}
function K2e(e, t) {
  const n = zZ(e, t);
  return n && ((r) => Dc(r) ? n.floor(r) : r);
}
function zZ(e, t) {
  if (e != null) {
    if (typeof e == "number") {
      0 < e && e < 1 && Number.isInteger(1 / e) && (e = -1 / e);
      const n = Math.abs(e);
      return e < 0 ? {
        floor: (r) => Math.floor(r * n) / n,
        offset: (r) => (r * n + 1) / n,
        // note: no optional step for simplicity
        range: (r, i) => qo(Math.ceil(r * n), i * n).map((o) => o / n)
      } : {
        floor: (r) => Math.floor(r / n) * n,
        offset: (r) => r + n,
        // note: no optional step for simplicity
        range: (r, i) => qo(Math.ceil(r / n), i / n).map((o) => o * n)
      };
    }
    if (typeof e == "string")
      return (t === "time" ? Xdt : H2e)(e);
    if (typeof e.floor != "function")
      throw new Error("invalid interval; missing floor method");
    if (typeof e.offset != "function")
      throw new Error("invalid interval; missing offset method");
    return e;
  }
}
function gN(e, t) {
  if (e = zZ(e, t), e && typeof e.range != "function")
    throw new Error("invalid interval: missing range method");
  return e;
}
function aht(e, t) {
  if (e = gN(e, t), e && typeof e.ceil != "function")
    throw new Error("invalid interval: missing ceil method");
  return e;
}
function B$(e) {
  return e === void 0 || Ey(e) ? e : { value: e };
}
function sht(e) {
  return e == null ? null : {
    transform: (t) => Qr(t, e, Float64Array),
    label: Eb(e)
  };
}
function uht(e) {
  if (!rv(e))
    return !1;
  for (const t of e)
    if (t != null)
      return typeof t == "object" && "0" in t && "1" in t;
}
function rv(e) {
  return e && typeof e[Symbol.iterator] == "function";
}
function Z2e(e) {
  for (const t of e)
    if (t != null)
      return typeof t != "object" || t instanceof Date;
}
function $a(e) {
  for (const t of e) {
    if (t == null)
      continue;
    const n = typeof t;
    return n === "string" || n === "boolean";
  }
}
function mp(e) {
  for (const t of e)
    if (t != null)
      return t instanceof Date;
}
function lht(e) {
  for (const t of e)
    if (t != null)
      return typeof t == "string" && isNaN(t) && U2e(t);
}
function cht(e) {
  for (const t of e)
    if (t != null) {
      if (typeof t != "string")
        return !1;
      if (t.trim())
        return !isNaN(t);
    }
}
function pT(e) {
  for (const t of e)
    if (t != null)
      return typeof t == "number";
}
function DH(e, t) {
  let n;
  for (const r of e)
    if (r != null) {
      if (!t(r))
        return !1;
      n = !0;
    }
  return n;
}
function U$(e) {
  return typeof e != "string" ? !1 : (e = e.toLowerCase().trim(), e === "none" || e === "currentcolor" || e.startsWith("url(") && e.endsWith(")") || // <funciri>, e.g. pattern or gradient
  e.startsWith("var(") && e.endsWith(")") || // CSS variable
  ew(e) !== null);
}
function fht(e) {
  return typeof e == "number" && (0 <= e && e <= 1 || isNaN(e));
}
function Ba(e) {
  return e == null || vC(e);
}
function vC(e) {
  return /^\s*none\s*$/i.test(e);
}
function dht(e) {
  return /^\s*round\s*$/i.test(e);
}
function J2e(e, t) {
  return IZ(e, t, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function Y$(e = "middle") {
  return J2e(e, "frameAnchor");
}
function bC(e) {
  if (e == null)
    return;
  const t = e[0], n = e[e.length - 1];
  return _S(t, n);
}
function hht(e = {}, ...t) {
  let n = e;
  for (const r of t)
    for (const i in r)
      if (n[i] === void 0) {
        const o = r[i];
        n === e ? n = { ...n, [i]: o } : n[i] = o;
      }
  return n;
}
function pht(e) {
  console.warn("named iterables are deprecated; please use an object instead");
  const t = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(e, (n) => {
      const { name: r } = n;
      if (r == null)
        throw new Error("missing name");
      const i = `${r}`;
      if (i === "__proto__")
        throw new Error(`illegal name: ${i}`);
      if (t.has(i))
        throw new Error(`duplicate name: ${i}`);
      return t.add(i), [r, n];
    })
  );
}
function FZ(e) {
  return rv(e) ? pht(e) : e;
}
const ky = Symbol("position"), Sb = Symbol("color"), QF = Symbol("radius"), XF = Symbol("length"), KF = Symbol("opacity"), ZF = Symbol("symbol"), eMe = Symbol("projection"), ba = /* @__PURE__ */ new Map([
  ["x", ky],
  ["y", ky],
  ["fx", ky],
  ["fy", ky],
  ["r", QF],
  ["color", Sb],
  ["opacity", KF],
  ["symbol", ZF],
  ["length", XF],
  ["projection", eMe]
]);
function ght(e) {
  return e === ky || e === eMe;
}
const tMe = Math.sqrt(3), nMe = 2 / tMe, mht = {
  draw(e, t) {
    const n = Math.sqrt(t / Math.PI), r = n * nMe, i = r / 2;
    e.moveTo(0, r), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(0, -r), e.lineTo(-n, -i), e.lineTo(-n, i), e.closePath();
  }
}, BZ = /* @__PURE__ */ new Map([
  ["asterisk", mwe],
  ["circle", oC],
  ["cross", ywe],
  ["diamond", bwe],
  ["diamond2", xwe],
  ["hexagon", mht],
  ["plus", wwe],
  ["square", _we],
  ["square2", Ewe],
  ["star", Mwe],
  ["times", Dwe],
  ["triangle", Twe],
  ["triangle2", Cwe],
  ["wye", Nwe]
]);
function UZ(e) {
  return e && typeof e.draw == "function";
}
function yht(e) {
  return UZ(e) ? !0 : typeof e != "string" ? !1 : BZ.has(e.toLowerCase());
}
function YZ(e) {
  if (e == null || UZ(e))
    return e;
  const t = BZ.get(`${e}`.toLowerCase());
  if (t)
    return t;
  throw new Error(`invalid symbol: ${e}`);
}
function vht(e) {
  if (e == null || UZ(e))
    return [void 0, e];
  if (typeof e == "string") {
    const t = BZ.get(`${e}`.toLowerCase());
    if (t)
      return [void 0, t];
  }
  return [e, void 0];
}
function iv({ filter: e, sort: t, reverse: n, transform: r, initializer: i, ...o } = {}, a) {
  if (r === void 0 && (e != null && (r = HZ(e)), t != null && !iw(t) && (r = AH(r, WZ(t))), n && (r = AH(r, VZ))), a != null && i != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...o,
    ...(t === null || iw(t)) && { sort: t },
    transform: AH(r, a)
  };
}
function Of({ filter: e, sort: t, reverse: n, initializer: r, ...i } = {}, o) {
  return r === void 0 && (e != null && (r = HZ(e)), t != null && !iw(t) && (r = OH(r, WZ(t))), n && (r = OH(r, VZ))), {
    ...i,
    ...(t === null || iw(t)) && { sort: t },
    initializer: OH(r, o)
  };
}
function AH(e, t) {
  return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, r, i) {
    return { data: n, facets: r } = e.call(this, n, r, i), t.call(this, Af(n), r, i);
  };
}
function OH(e, t) {
  return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, r, i, ...o) {
    let a, s, u, l, f, h;
    return { data: s = n, facets: u = r, channels: a } = e.call(this, n, r, i, ...o), { data: f = s, facets: h = u, channels: l } = t.call(this, s, u, { ...i, ...a }, ...o), { data: f, facets: h, channels: { ...a, ...l } };
  };
}
function JF(e, t) {
  return (e.initializer != null ? Of : iv)(e, t);
}
function bht(e, t) {
  return JF(t, HZ(e));
}
function HZ(e) {
  return (t, n) => {
    const r = Qr(t, e);
    return { data: t, facets: n.map((i) => i.filter((o) => r[o])) };
  };
}
function xht({ sort: e, ...t } = {}) {
  return {
    ...JF(t, VZ),
    sort: iw(e) ? e : null
  };
}
function VZ(e, t) {
  return { data: e, facets: t.map((n) => n.slice().reverse()) };
}
function wht({ seed: e, sort: t, ...n } = {}) {
  return {
    ...JF(n, iMe(e == null ? Math.random : gZ(e))),
    sort: iw(t) ? t : null
  };
}
function rMe(e, { sort: t, ...n } = {}) {
  return {
    ...(Ey(e) && e.channel !== void 0 ? Of : JF)(n, WZ(e)),
    sort: iw(t) ? t : null
  };
}
function WZ(e) {
  return (typeof e == "function" && e.length !== 1 ? _ht : iMe)(e);
}
function _ht(e) {
  return (t, n) => {
    const r = (i, o) => e(t[i], t[o]);
    return { data: t, facets: n.map((i) => i.slice().sort(r)) };
  };
}
function iMe(e) {
  let t, n;
  ({ channel: t, value: e, order: n } = { ...B$(e) });
  const r = t == null ? void 0 : t.startsWith("-");
  if (r && (t = t.slice(1)), n === void 0 && (n = r ? VL : gp), typeof n != "function")
    switch (`${n}`.toLowerCase()) {
      case "ascending":
        n = gp;
        break;
      case "descending":
        n = VL;
        break;
      default:
        throw new Error(`invalid order: ${n}`);
    }
  return (i, o, a) => {
    let s;
    if (t === void 0)
      s = Qr(i, e);
    else {
      if (a === void 0)
        throw new Error("channel sort requires an initializer");
      if (s = a[t], !s)
        return {};
      s = s.value;
    }
    const u = (l, f) => n(s[l], s[f]);
    return { data: i, facets: o.map((l) => l.slice().sort(u)) };
  };
}
function qZ(e, t) {
  return e6(null, null, e, t);
}
function Ik(e = { y: "count" }, t = {}) {
  const { x: n = Wn } = t;
  if (n == null)
    throw new Error("missing channel: x");
  return e6(n, null, e, t);
}
function jk(e = { x: "count" }, t = {}) {
  const { y: n = Wn } = t;
  if (n == null)
    throw new Error("missing channel: y");
  return e6(null, n, e, t);
}
function GZ(e = { fill: "count" }, t = {}) {
  let { x: n, y: r } = t;
  if ([n, r] = em(n, r), n == null)
    throw new Error("missing channel: x");
  if (r == null)
    throw new Error("missing channel: y");
  return e6(n, r, e, t);
}
function e6(e, t, {
  data: n = JZ,
  filter: r,
  sort: i,
  reverse: o,
  ...a
  // output channel definitions
} = {}, s = {}) {
  a = QZ(a, s), n = t6(n, Wn), i = i == null ? void 0 : XZ("sort", i, s), r = r == null ? void 0 : KZ("filter", r, s);
  const [u, l] = pf(e), [f, h] = pf(t), {
    z: p,
    fill: g,
    stroke: y,
    x1: b,
    x2: _,
    // consumed if x is an output
    y1: S,
    y2: C,
    // consumed if y is an output
    ...A
  } = s, [O, R] = pf(p), [j] = Df(g), [$] = Df(y), [z, W] = pf(j), [Y, V] = pf($);
  return {
    ..."z" in s && { z: O || p },
    ..."fill" in s && { fill: z || g },
    ..."stroke" in s && { stroke: Y || y },
    ...iv(A, (ee, K, Q) => {
      const q = GL(Qr(ee, e), Q == null ? void 0 : Q.x), te = GL(Qr(ee, t), Q == null ? void 0 : Q.y), X = Qr(ee, p), Z = Qr(ee, j), se = Qr(ee, $), H = ZZ(a, { z: X, fill: Z, stroke: se }), ie = [], he = [], ye = q && l([]), _e = te && h([]), Ne = X && R([]), Oe = Z && W([]), ke = se && V([]);
      let Me = 0;
      for (const we of a)
        we.initialize(ee);
      i && i.initialize(ee), r && r.initialize(ee);
      for (const we of K) {
        const Ye = [];
        for (const ze of a)
          ze.scope("facet", we);
        i && i.scope("facet", we), r && r.scope("facet", we);
        for (const [ze, fe] of OT(we, H))
          for (const [Qe, $e] of OT(fe, te))
            for (const [pt, _t] of OT($e, q))
              if (!(r && !r.reduce(_t))) {
                Ye.push(Me++), he.push(n.reduceIndex(_t, ee)), q && ye.push(pt), te && _e.push(Qe), X && Ne.push(H === X ? ze : X[_t[0]]), Z && Oe.push(H === Z ? ze : Z[_t[0]]), se && ke.push(H === se ? ze : se[_t[0]]);
                for (const Ot of a)
                  Ot.reduce(_t);
                i && i.reduce(_t);
              }
        ie.push(Ye);
      }
      return oMe(ie, i, o), { data: he, facets: ie };
    }),
    ...!Mx(a, "x") && (u ? { x: u } : { x1: b, x2: _ }),
    ...!Mx(a, "y") && (f ? { y: f } : { y1: S, y2: C }),
    ...Object.fromEntries(a.map(({ name: ee, output: K }) => [ee, K]))
  };
}
function Mx(e, ...t) {
  for (const { name: n } of e)
    if (t.includes(n))
      return !0;
  return !1;
}
function QZ(e, t, n = XZ) {
  const r = Object.entries(e);
  return t.title != null && e.title === void 0 && r.push(["title", Cht]), t.href != null && e.href === void 0 && r.push(["href", eJ]), r.filter(([, i]) => i !== void 0).map(([i, o]) => o === null ? Eht(i) : n(i, o, t));
}
function XZ(e, t, n, r = KZ) {
  let i;
  Jg(t) && "reduce" in t && (i = t.scale, t = t.reduce);
  const o = r(e, t, n), [a, s] = Cd(o.label);
  let u;
  return {
    name: e,
    output: i === void 0 ? a : { value: a, scale: i },
    initialize(l) {
      o.initialize(l), u = s([]);
    },
    scope(l, f) {
      o.scope(l, f);
    },
    reduce(l, f) {
      u.push(o.reduce(l, f));
    }
  };
}
function Eht(e) {
  return { name: e, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function KZ(e, t, n, r = t6) {
  const i = X2e(e, n), o = r(t, i);
  let a, s;
  return {
    label: Eb(o === QL ? null : i, o.label),
    initialize(u) {
      a = i === void 0 ? u : Qr(u, i), o.scope === "data" && (s = o.reduceIndex(_b(u), a));
    },
    scope(u, l) {
      o.scope === u && (s = o.reduceIndex(l, a));
    },
    reduce(u, l) {
      return o.scope == null ? o.reduceIndex(u, a, l) : o.reduceIndex(u, a, s, l);
    }
  };
}
function OT(e, t) {
  return t ? Ek(
    xb(e, (n) => t[n]),
    F$
  ) : [[, e]];
}
function t6(e, t, n = Sht) {
  if (e == null)
    return n(e);
  if (typeof e.reduceIndex == "function")
    return e;
  if (typeof e.reduce == "function" && Jg(e))
    return Mht(e);
  if (typeof e == "function")
    return Tht(e);
  if (/^p\d{2}$/i.test(e))
    return P0($Z(e));
  switch (`${e}`.toLowerCase()) {
    case "first":
      return eJ;
    case "last":
      return Nht;
    case "identity":
      return JZ;
    case "count":
      return QL;
    case "distinct":
      return Dht;
    case "sum":
      return t == null ? QL : Aht;
    case "proportion":
      return Che(t, "data");
    case "proportion-facet":
      return Che(t, "facet");
    case "deviation":
      return P0(lN);
    case "min":
      return P0(Oc);
    case "min-index":
      return P0(Krt);
    case "max":
      return P0(Ha);
    case "max-index":
      return P0(Xrt);
    case "mean":
      return The(T$);
    case "median":
      return The(Jx);
    case "variance":
      return P0(BK);
    case "mode":
      return P0(m_e);
  }
  return n(e);
}
function Sht(e) {
  throw new Error(`invalid reduce: ${e}`);
}
function ZZ(e, t) {
  for (const n in t) {
    const r = t[n];
    if (r !== void 0 && !e.some((i) => i.name === n))
      return r;
  }
}
function oMe(e, t, n) {
  if (t) {
    const r = t.output.transform(), i = (o, a) => gp(r[o], r[a]);
    e.forEach((o) => o.sort(i));
  }
  n && e.forEach((r) => r.reverse());
}
function Mht(e) {
  return console.warn("deprecated reduce interface; implement reduceIndex instead."), { ...e, reduceIndex: e.reduce.bind(e) };
}
function Tht(e) {
  return {
    reduceIndex(t, n, r) {
      return e(jZ(n, t), r);
    }
  };
}
function P0(e) {
  return {
    reduceIndex(t, n) {
      return e(t, (r) => n[r]);
    }
  };
}
function The(e) {
  return {
    reduceIndex(t, n) {
      const r = e(t, (i) => n[i]);
      return mp(n) ? new Date(r) : r;
    }
  };
}
const JZ = {
  reduceIndex(e, t) {
    return jZ(t, e);
  }
}, eJ = {
  reduceIndex(e, t) {
    return t[e[0]];
  }
}, Cht = {
  reduceIndex(e, t) {
    const r = Ek(
      NT(
        e,
        (o) => o.length,
        (o) => t[o]
      ),
      Pk
    ), i = r.slice(-5).reverse();
    if (i.length < r.length) {
      const o = r.slice(0, -4);
      i[5 - 1] = [`… ${o.length.toLocaleString("en-US")} more`, fp(o, Pk)];
    }
    return i.map(([o, a]) => `${o} (${a.toLocaleString("en-US")})`).join(`
`);
  }
}, Nht = {
  reduceIndex(e, t) {
    return t[e[e.length - 1]];
  }
}, QL = {
  label: "Frequency",
  reduceIndex(e) {
    return e.length;
  }
}, Dht = {
  label: "Distinct",
  reduceIndex(e, t) {
    const n = new Xx();
    for (const r of e)
      n.add(t[r]);
    return n.size;
  }
}, Aht = P0(fp);
function Che(e, t) {
  return e == null ? { scope: t, label: "Frequency", reduceIndex: (n, r, i = 1) => n.length / i } : { scope: t, reduceIndex: (n, r, i = 1) => fp(n, (o) => r[o]) / i };
}
function Lk(e, { scale: t, type: n, value: r, filter: i, hint: o }, a) {
  return o === void 0 && typeof (r == null ? void 0 : r.transform) == "function" && (o = r.hint), sMe(a, {
    scale: t,
    type: n,
    value: Qr(e, r),
    label: Eb(r),
    filter: i,
    hint: o
  });
}
function aMe(e, t) {
  return Object.fromEntries(
    Object.entries(e).map(([n, r]) => [n, Lk(t, r, n)])
  );
}
function tJ(e, t) {
  const n = Object.fromEntries(
    Object.entries(e).map(([r, { scale: i, value: o }]) => {
      const a = i == null ? null : t[i];
      return [r, a == null ? o : jo(o, a)];
    })
  );
  return n.channels = e, n;
}
function sMe(e, t) {
  const { scale: n, value: r } = t;
  if (n === !0 || n === "auto")
    switch (e) {
      case "fill":
      case "stroke":
      case "color":
        t.scale = n !== !0 && DH(r, U$) ? null : "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        t.scale = n !== !0 && DH(r, fht) ? null : "opacity";
        break;
      case "symbol":
        n !== !0 && DH(r, yht) ? (t.scale = null, t.value = jo(r, YZ)) : t.scale = "symbol";
        break;
      default:
        t.scale = ba.has(e) ? e : null;
        break;
    }
  else if (n === !1)
    t.scale = null;
  else if (n != null && !ba.has(n))
    throw new Error(`unknown scale: ${n}`);
  return t;
}
function Oht(e, t, n, r, i) {
  const { order: o, reverse: a, reduce: s = !0, limit: u } = i;
  for (const l in i) {
    if (!ba.has(l))
      continue;
    let { value: f, order: h = o, reverse: p = a, reduce: g = s, limit: y = u } = B$(i[l]);
    const b = f == null ? void 0 : f.startsWith("-");
    if (b && (f = f.slice(1)), h = h === void 0 ? b !== (f === "width" || f === "height") ? lMe : uMe : $ht(h), g == null || g === !1)
      continue;
    const _ = l === "fx" || l === "fy" ? kht(t, r[l]) : Rht(n, l);
    if (!_)
      throw new Error(`missing channel for scale: ${l}`);
    const S = _.value, [C = 0, A = 1 / 0] = rv(y) ? y : y < 0 ? [y] : [0, y];
    if (f == null)
      _.domain = () => {
        let O = Array.from(new Xx(S));
        return p && (O = O.reverse()), (C !== 0 || A !== 1 / 0) && (O = O.slice(C, A)), O;
      };
    else {
      const O = f === "data" ? e : f === "height" ? Nhe(n, "y1", "y2") : f === "width" ? Nhe(n, "x1", "x2") : cG(n, f, f === "y" ? "y2" : f === "x" ? "x2" : void 0), R = t6(g === !0 ? "max" : g, O);
      _.domain = () => {
        let j = Wrt(
          _b(S),
          ($) => R.reduceIndex($, O),
          ($) => S[$]
        );
        return h && j.sort(h), p && j.reverse(), (C !== 0 || A !== 1 / 0) && (j = j.slice(C, A)), j.map(F$);
      };
    }
  }
}
function Rht(e, t) {
  for (const n in e) {
    const r = e[n];
    if (r.scale === t)
      return r;
  }
}
function kht(e, t) {
  const n = e.original;
  if (n === e)
    return t;
  const r = t.value, i = t.value = [];
  for (let o = 0; o < n.length; ++o) {
    const a = r[n[o][0]];
    for (const s of e[o])
      i[s] = a;
  }
  return t;
}
function Nhe(e, t, n) {
  const r = cG(e, t), i = cG(e, n);
  return jo(i, (o, a) => Math.abs(o - r[a]), Float64Array);
}
function cG(e, t, n) {
  let r = e[t];
  if (!r && n !== void 0 && (r = e[n]), r)
    return r.value;
  throw new Error(`missing channel: ${t}`);
}
function $ht(e) {
  if (e == null || typeof e == "function")
    return e;
  switch (`${e}`.toLowerCase()) {
    case "ascending":
      return uMe;
    case "descending":
      return lMe;
  }
  throw new Error(`invalid order: ${e}`);
}
function uMe([e, t], [n, r]) {
  return gp(t, r) || gp(e, n);
}
function lMe([e, t], [n, r]) {
  return VL(t, r) || gp(e, n);
}
function cMe(e, t) {
  let n = e[t];
  if (n) {
    for (; n.source; )
      n = n.source;
    return n.source === null ? null : n;
  }
}
function nJ(e) {
  let t, n;
  return (...r) => (((n == null ? void 0 : n.length) !== r.length || n.some((i, o) => i !== r[o])) && (n = r, t = e(...r)), t);
}
const Pht = nJ((e) => new Intl.NumberFormat(e)), Iht = nJ((e, t) => new Intl.DateTimeFormat(e, { timeZone: "UTC", ...t && { month: t } })), jht = nJ((e, t) => new Intl.DateTimeFormat(e, { timeZone: "UTC", ...t && { weekday: t } }));
function Lht(e = "en-US") {
  const t = Pht(e);
  return (n) => n != null && !isNaN(n) ? t.format(n) : void 0;
}
function zht(e = "en-US", t = "short") {
  const n = Iht(e, t);
  return (r) => r != null && !isNaN(r = +new Date(Date.UTC(2e3, +r))) ? n.format(r) : void 0;
}
function Fht(e = "en-US", t = "short") {
  const n = jht(e, t);
  return (r) => r != null && !isNaN(r = +new Date(Date.UTC(2001, 0, +r))) ? n.format(r) : void 0;
}
function fMe(e) {
  return Ydt(e, "Invalid Date");
}
function Bht(e = "en-US") {
  const t = Lht(e);
  return (n) => (n instanceof Date ? fMe : typeof n == "number" ? t : Ll)(n);
}
const J0 = Bht();
let fG = 0;
function Uht() {
  const e = fG;
  return fG = 0, e;
}
function Lx(e) {
  console.warn(e), ++fG;
}
const Ju = (typeof window < "u" ? window.devicePixelRatio > 1 : typeof it > "u") ? 0 : 0.5;
let Yht = 0;
function Dhe() {
  return `plot-clip-${++Yht}`;
}
function dMe(e, {
  title: t,
  href: n,
  ariaLabel: r,
  ariaDescription: i,
  ariaHidden: o,
  target: a,
  fill: s,
  fillOpacity: u,
  stroke: l,
  strokeWidth: f,
  strokeOpacity: h,
  strokeLinejoin: p,
  strokeLinecap: g,
  strokeMiterlimit: y,
  strokeDasharray: b,
  strokeDashoffset: _,
  opacity: S,
  mixBlendMode: C,
  imageFilter: A,
  paintOrder: O,
  pointerEvents: R,
  shapeRendering: j,
  channels: $
}, {
  ariaLabel: z,
  fill: W = "currentColor",
  fillOpacity: Y,
  stroke: V = "none",
  strokeOpacity: ee,
  strokeWidth: K,
  strokeLinecap: Q,
  strokeLinejoin: q,
  strokeMiterlimit: te,
  paintOrder: X
}) {
  W === null && (s = null, u = null), V === null && (l = null, h = null), Ba(W) ? !Ba(V) && (!Ba(s) || $ != null && $.fill) && (V = "none") : Ba(V) && (!Ba(l) || $ != null && $.stroke) && (W = "none");
  const [Z, se] = Df(s, W), [H, ie] = ns(u, Y), [he, ye] = Df(l, V), [_e, Ne] = ns(h, ee), [Oe, ke] = ns(S);
  vC(ye) || (f === void 0 && (f = K), g === void 0 && (g = Q), p === void 0 && (p = q), y === void 0 && !dht(p) && (y = te), !vC(se) && O === void 0 && (O = X));
  const [Me, we] = ns(f);
  return W !== null && (e.fill = ja(se, "currentColor"), e.fillOpacity = KA(ie, 1)), V !== null && (e.stroke = ja(ye, "none"), e.strokeWidth = KA(we, 1), e.strokeOpacity = KA(Ne, 1), e.strokeLinejoin = ja(p, "miter"), e.strokeLinecap = ja(g, "butt"), e.strokeMiterlimit = KA(y, 4), e.strokeDasharray = ja(b, "none"), e.strokeDashoffset = ja(_, "0")), e.target = Ll(a), e.ariaLabel = Ll(z), e.ariaDescription = Ll(i), e.ariaHidden = Ll(o), e.opacity = KA(ke, 1), e.mixBlendMode = ja(C, "normal"), e.imageFilter = ja(A, "none"), e.paintOrder = ja(O, "normal"), e.pointerEvents = ja(R, "auto"), e.shapeRendering = ja(j, "auto"), {
    title: { value: t, optional: !0, filter: null },
    href: { value: n, optional: !0, filter: null },
    ariaLabel: { value: r, optional: !0, filter: null },
    fill: { value: Z, scale: "auto", optional: !0 },
    fillOpacity: { value: H, scale: "auto", optional: !0 },
    stroke: { value: he, scale: "auto", optional: !0 },
    strokeOpacity: { value: _e, scale: "auto", optional: !0 },
    strokeWidth: { value: Me, optional: !0 },
    opacity: { value: Oe, scale: "auto", optional: !0 }
  };
}
function Hht(e, t) {
  t && e.filter((n) => RZ(t[n])).append("title").call(Wht, t);
}
function Vht(e, t) {
  t && e.filter(([n]) => RZ(t[n])).append("title").call(qht, t);
}
function Wht(e, t) {
  t && e.text((n) => J0(t[n]));
}
function qht(e, t) {
  t && e.text(([n]) => J0(t[n]));
}
function Qs(e, { target: t, tip: n }, {
  ariaLabel: r,
  title: i,
  fill: o,
  fillOpacity: a,
  stroke: s,
  strokeOpacity: u,
  strokeWidth: l,
  opacity: f,
  href: h
}) {
  r && Fn(e, "aria-label", (p) => r[p]), o && Fn(e, "fill", (p) => o[p]), a && Fn(e, "fill-opacity", (p) => a[p]), s && Fn(e, "stroke", (p) => s[p]), u && Fn(e, "stroke-opacity", (p) => u[p]), l && Fn(e, "stroke-width", (p) => l[p]), f && Fn(e, "opacity", (p) => f[p]), h && gMe(e, (p) => h[p], t), n || Hht(e, i);
}
function XL(e, { target: t, tip: n }, {
  ariaLabel: r,
  title: i,
  fill: o,
  fillOpacity: a,
  stroke: s,
  strokeOpacity: u,
  strokeWidth: l,
  opacity: f,
  href: h
}) {
  r && Fn(e, "aria-label", ([p]) => r[p]), o && Fn(e, "fill", ([p]) => o[p]), a && Fn(e, "fill-opacity", ([p]) => a[p]), s && Fn(e, "stroke", ([p]) => s[p]), u && Fn(e, "stroke-opacity", ([p]) => u[p]), l && Fn(e, "stroke-width", ([p]) => l[p]), f && Fn(e, "opacity", ([p]) => f[p]), h && gMe(e, ([p]) => h[p], t), n || Vht(e, i);
}
function Ght({
  ariaLabel: e,
  title: t,
  fill: n,
  fillOpacity: r,
  stroke: i,
  strokeOpacity: o,
  strokeWidth: a,
  opacity: s,
  href: u
}, { tip: l }) {
  return [e, l ? void 0 : t, n, r, i, o, a, s, u].filter((f) => f !== void 0);
}
function rJ(e, t, n) {
  const r = xb(e, (i) => t[i]);
  return n === void 0 && r.size > 1 + e.length >> 1 && Lx(
    "Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null."
  ), r.values();
}
function* hMe(e, t, n, r) {
  const { z: i } = n, { z: o } = r, a = Ght(r, n), s = [...t, ...a];
  for (const u of o ? rJ(e, o, i) : [e]) {
    let l, f;
    e:
      for (const h of u) {
        for (const p of s)
          if (!Dc(p[h])) {
            f && f.push(-1);
            continue e;
          }
        if (l === void 0) {
          f && (yield f), l = a.map((p) => YE(p[h])), f = [h];
          continue;
        }
        f.push(h);
        for (let p = 0; p < a.length; ++p)
          if (YE(a[p][h]) !== l[p]) {
            yield f, l = a.map((y) => YE(y[h])), f = [h];
            continue e;
          }
      }
    f && (yield f);
  }
}
function pMe(e) {
  return e === !0 ? e = "frame" : e === !1 ? e = null : e != null && (e = Sp(e, "clip", ["frame", "sphere"])), e;
}
function Qht(e, t, n, r) {
  let i;
  const { clip: o = r.clip } = t;
  switch (o) {
    case "frame": {
      const { width: a, height: s, marginLeft: u, marginRight: l, marginTop: f, marginBottom: h } = n, p = Dhe();
      i = `url(#${p})`, e = Yi("svg:g", r).call(
        (g) => g.append("svg:clipPath").attr("id", p).append("rect").attr("x", u).attr("y", f).attr("width", a - l - u).attr("height", s - f - h)
      ).each(function() {
        this.appendChild(e.node()), e.node = () => this;
      });
      break;
    }
    case "sphere": {
      const { projection: a } = r;
      if (!a)
        throw new Error('the "sphere" clip option requires a projection');
      const s = Dhe();
      i = `url(#${s})`, e.append("clipPath").attr("id", s).append("path").attr("d", Cw(a)({ type: "Sphere" }));
      break;
    }
  }
  Fn(e, "aria-label", t.ariaLabel), Fn(e, "aria-description", t.ariaDescription), Fn(e, "aria-hidden", t.ariaHidden), Fn(e, "clip-path", i);
}
function sa(e, t, n, r) {
  Qht(e, t, n, r), Fn(e, "fill", t.fill), Fn(e, "fill-opacity", t.fillOpacity), Fn(e, "stroke", t.stroke), Fn(e, "stroke-width", t.strokeWidth), Fn(e, "stroke-opacity", t.strokeOpacity), Fn(e, "stroke-linejoin", t.strokeLinejoin), Fn(e, "stroke-linecap", t.strokeLinecap), Fn(e, "stroke-miterlimit", t.strokeMiterlimit), Fn(e, "stroke-dasharray", t.strokeDasharray), Fn(e, "stroke-dashoffset", t.strokeDashoffset), Fn(e, "shape-rendering", t.shapeRendering), Fn(e, "filter", t.imageFilter), Fn(e, "paint-order", t.paintOrder);
  const { pointerEvents: i = r.pointerSticky === !1 ? "none" : void 0 } = t;
  Fn(e, "pointer-events", i);
}
function Xo(e, t) {
  Xht(e, "mix-blend-mode", t.mixBlendMode), Fn(e, "opacity", t.opacity);
}
function gMe(e, t, n) {
  e.each(function(r) {
    const i = t(r);
    if (i != null) {
      const o = this.ownerDocument.createElementNS(SS.svg, "a");
      o.setAttribute("fill", "inherit"), o.setAttributeNS(SS.xlink, "href", i), n != null && o.setAttribute("target", n), this.parentNode.insertBefore(o, this).appendChild(this);
    }
  });
}
function Fn(e, t, n) {
  n != null && e.attr(t, n);
}
function Xht(e, t, n) {
  n != null && e.style(t, n);
}
function To(e, t, { x: n, y: r }, i = Ju, o = Ju) {
  i += t.dx, o += t.dy, n != null && n.bandwidth && (i += n.bandwidth() / 2), r != null && r.bandwidth && (o += r.bandwidth() / 2), (i || o) && e.attr("transform", `translate(${i},${o})`);
}
function ja(e, t) {
  if ((e = Ll(e)) !== t)
    return e;
}
function KA(e, t) {
  if ((e = ti(e)) !== t)
    return e;
}
const Kht = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function iJ(e) {
  if (e === void 0)
    return "plot-d6a7b5";
  if (e = `${e}`, !Kht.test(e))
    throw new Error(`invalid class name: ${e}`);
  return e;
}
function oJ(e, t) {
  if (typeof t == "string")
    e.property("style", t);
  else if (t != null)
    for (const n of e)
      Object.assign(n.style, t);
}
function ov({ frameAnchor: e }, { width: t, height: n, marginTop: r, marginRight: i, marginBottom: o, marginLeft: a }) {
  return [
    /left$/.test(e) ? a : /right$/.test(e) ? t - i : (a + t - i) / 2,
    /^top/.test(e) ? r : /^bottom/.test(e) ? n - o : (r + n - o) / 2
  ];
}
function n6(e = {}) {
  const { document: t = typeof window < "u" ? window.document : void 0, clip: n } = e;
  return { document: t, clip: pMe(n) };
}
function Yi(e, { document: t }) {
  return Ix(NF(e).call(t.documentElement));
}
const mMe = Math.PI, N0 = 2 * mMe, Ahe = 0.618;
function Zht({
  projection: e,
  inset: t = 0,
  insetTop: n = t,
  insetRight: r = t,
  insetBottom: i = t,
  insetLeft: o = t
} = {}, a) {
  if (e == null)
    return;
  if (typeof e.stream == "function")
    return e;
  let s, u, l = "frame";
  if (Jg(e)) {
    let R;
    if ({
      type: e,
      domain: u,
      inset: R,
      insetTop: n = R !== void 0 ? R : n,
      insetRight: r = R !== void 0 ? R : r,
      insetBottom: i = R !== void 0 ? R : i,
      insetLeft: o = R !== void 0 ? R : o,
      clip: l = l,
      ...s
    } = e, e == null)
      return;
  }
  typeof e != "function" && ({ type: e } = yMe(e));
  const { width: f, height: h, marginLeft: p, marginRight: g, marginTop: y, marginBottom: b } = a, _ = f - p - g - o - r, S = h - y - b - n - i;
  if (e = e == null ? void 0 : e({ width: _, height: S, clip: l, ...s }), e == null)
    return;
  l = Jht(l, p, y, f - g, h - b);
  let C = p + o, A = y + n, O;
  if (u != null) {
    const [[R, j], [$, z]] = Cw(e).bounds(u), W = Math.min(_ / ($ - R), S / (z - j));
    W > 0 ? (C -= (W * (R + $) - _) / 2, A -= (W * (j + z) - S) / 2, O = jL({
      point(Y, V) {
        this.stream.point(Y * W + C, V * W + A);
      }
    })) : Lx("Warning: the projection could not be fit to the specified domain; using the default scale.");
  }
  return O ?? (O = C === 0 && A === 0 ? vMe() : jL({
    point(R, j) {
      this.stream.point(R + C, j + A);
    }
  })), { stream: (R) => e.stream(O.stream(l(R))) };
}
function yMe(e) {
  switch (`${e}`.toLowerCase()) {
    case "albers-usa":
      return vg(Xlt, 0.7463, 0.4673);
    case "albers":
      return i3(VEe, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return vg(Klt, 4, 4);
    case "azimuthal-equidistant":
      return vg(Zlt, N0, N0);
    case "conic-conformal":
      return i3(tct, N0, N0);
    case "conic-equal-area":
      return i3(LL, 6.1702, 2.9781);
    case "conic-equidistant":
      return i3(ict, 7.312, 3.6282);
    case "equal-earth":
      return vg(act, 5.4133, 2.6347);
    case "equirectangular":
      return vg(nct, N0, mMe);
    case "gnomonic":
      return vg(sct, 3.4641, 3.4641);
    case "identity":
      return { type: vMe };
    case "reflect-y":
      return { type: ept };
    case "mercator":
      return vg(Jlt, N0, N0);
    case "orthographic":
      return vg(uct, 2, 2);
    case "stereographic":
      return vg(lct, 2, 2);
    case "transverse-mercator":
      return vg(cct, N0, N0);
    default:
      throw new Error(`unknown projection type: ${e}`);
  }
}
function Jht(e, t, n, r, i) {
  if (e === !1 || e == null || typeof e == "number")
    return (o) => o;
  switch (e === !0 && (e = "frame"), `${e}`.toLowerCase()) {
    case "frame":
      return DEe(t, n, r, i);
    default:
      throw new Error(`unknown projection clip type: ${e}`);
  }
}
function vg(e, t, n) {
  return {
    type: ({ width: r, height: i, rotate: o, precision: a = 0.15, clip: s }) => {
      var l, f, h;
      const u = e();
      return a != null && ((l = u.precision) == null || l.call(u, a)), o != null && ((f = u.rotate) == null || f.call(u, o)), typeof s == "number" && ((h = u.clipAngle) == null || h.call(u, s)), u.scale(Math.min(r / t, i / n)), u.translate([r / 2, i / 2]), u;
    },
    aspectRatio: n / t
  };
}
function i3(e, t, n) {
  const { type: r, aspectRatio: i } = vg(e, t, n);
  return {
    type: (o) => {
      const { parallels: a, domain: s, width: u, height: l } = o, f = r(o);
      return a != null && (f.parallels(a), s === void 0 && f.fitSize([u, l], { type: "Sphere" })), f;
    },
    aspectRatio: i
  };
}
const vMe = Bd({ stream: (e) => e }), ept = Bd(
  jL({
    point(e, t) {
      this.stream.point(e, -t);
    }
  })
);
function bMe(e, t, n, r) {
  const i = n[e], o = n[t], a = i.length, s = n[e] = new Float64Array(a).fill(NaN), u = n[t] = new Float64Array(a).fill(NaN);
  let l;
  const f = r.stream({
    point(h, p) {
      s[l] = h, u[l] = p;
    }
  });
  for (l = 0; l < a; ++l)
    f.point(i[l], o[l]);
}
function tpt({ projection: e } = {}) {
  return e == null ? !1 : typeof e.stream == "function" ? !0 : (Jg(e) && (e = e.type), e != null);
}
function npt(e) {
  if (typeof (e == null ? void 0 : e.stream) == "function")
    return Ahe;
  if (Jg(e) && (e = e.type), e != null) {
    if (typeof e != "function") {
      const { aspectRatio: t } = yMe(e);
      if (t)
        return t;
    }
    return Ahe;
  }
}
function r6(e, t, { projection: n }) {
  const { x: r, y: i } = e;
  let o = {};
  return r && (o.x = r), i && (o.y = i), o = tJ(o, t), n && (r == null ? void 0 : r.scale) === "x" && (i == null ? void 0 : i.scale) === "y" && bMe("x", "y", o, n), r && (o.x = xf(o.x)), i && (o.y = xf(o.y)), o;
}
function rpt(e) {
  const t = [], n = [], r = { scale: "x", value: t }, i = { scale: "y", value: n }, o = {
    point(a, s) {
      t.push(a), n.push(s);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const a of e.value)
    yx(a, o);
  return [r, i];
}
const xMe = /* @__PURE__ */ new Map([
  ["accent", Rdt],
  ["category10", Odt],
  ["dark2", kdt],
  ["paired", $dt],
  ["pastel1", Pdt],
  ["pastel2", Idt],
  ["set1", jdt],
  ["set2", Ldt],
  ["set3", zdt],
  ["tableau10", Fdt]
]);
function ipt(e) {
  return e != null && xMe.has(`${e}`.toLowerCase());
}
const Ohe = new Map([
  ...xMe,
  // diverging
  ["brbg", D0(PSe, ISe)],
  ["prgn", D0(jSe, LSe)],
  ["piyg", D0(zSe, FSe)],
  ["puor", D0(BSe, USe)],
  ["rdbu", D0(oG, YL)],
  ["rdgy", D0(YSe, HSe)],
  ["rdylbu", D0(aG, HL)],
  ["rdylgn", D0(VSe, WSe)],
  ["spectral", D0(qSe, GSe)],
  // reversed diverging (for temperature data)
  ["burd", Rhe(oG, YL)],
  ["buylrd", Rhe(aG, HL)],
  // sequential (single-hue)
  ["blues", cu(b2e, x2e)],
  ["greens", cu(w2e, _2e)],
  ["greys", cu(E2e, S2e)],
  ["oranges", cu(D2e, A2e)],
  ["purples", cu(M2e, T2e)],
  ["reds", cu(C2e, N2e)],
  // sequential (multi-hue)
  ["turbo", A0(j2e)],
  ["viridis", A0(L2e)],
  ["magma", A0(z2e)],
  ["inferno", A0(F2e)],
  ["plasma", A0(B2e)],
  ["cividis", A0(O2e)],
  ["cubehelix", A0(R2e)],
  ["warm", A0(k2e)],
  ["cool", A0($2e)],
  ["bugn", cu(QSe, XSe)],
  ["bupu", cu(KSe, ZSe)],
  ["gnbu", cu(JSe, e2e)],
  ["orrd", cu(t2e, n2e)],
  ["pubu", cu(o2e, a2e)],
  ["pubugn", cu(r2e, i2e)],
  ["purd", cu(s2e, u2e)],
  ["rdpu", cu(l2e, c2e)],
  ["ylgn", cu(h2e, p2e)],
  ["ylgnbu", cu(f2e, d2e)],
  ["ylorbr", cu(g2e, m2e)],
  ["ylorrd", cu(y2e, v2e)],
  // cyclical
  ["rainbow", khe(P2e)],
  ["sinebow", khe(I2e)]
]);
function cu(e, t) {
  return ({ length: n }) => n === 1 ? [e[3][1]] : n === 2 ? [e[3][1], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 9 ? dp(t, n) : e[n]);
}
function D0(e, t) {
  return ({ length: n }) => n === 2 ? [e[3][0], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 11 ? dp(t, n) : e[n]);
}
function Rhe(e, t) {
  return ({ length: n }) => n === 2 ? [e[3][2], e[3][0]] : (n = Math.max(3, Math.floor(n)), n > 11 ? dp((r) => t(1 - r), n) : e[n].slice().reverse());
}
function A0(e) {
  return ({ length: t }) => dp(e, Math.max(2, Math.floor(t)));
}
function khe(e) {
  return ({ length: t }) => dp(e, Math.floor(t) + 1).slice(0, -1);
}
function wMe(e) {
  const t = `${e}`.toLowerCase();
  if (!Ohe.has(t))
    throw new Error(`unknown ordinal scheme: ${t}`);
  return Ohe.get(t);
}
function i6(e, t) {
  const n = wMe(e), r = typeof n == "function" ? n({ length: t }) : n;
  return r.length !== t ? r.slice(0, t) : r;
}
function opt(e, t = "greys") {
  const n = /* @__PURE__ */ new Set(), [r, i] = i6(t, 2);
  for (const o of e)
    if (o != null)
      if (o === !0)
        n.add(i);
      else if (o === !1)
        n.add(r);
      else
        return;
  return [...n];
}
const $he = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", ISe],
  ["prgn", LSe],
  ["piyg", FSe],
  ["puor", USe],
  ["rdbu", YL],
  ["rdgy", HSe],
  ["rdylbu", HL],
  ["rdylgn", WSe],
  ["spectral", GSe],
  // reversed diverging (for temperature data)
  ["burd", (e) => YL(1 - e)],
  ["buylrd", (e) => HL(1 - e)],
  // sequential (single-hue)
  ["blues", x2e],
  ["greens", _2e],
  ["greys", S2e],
  ["purples", T2e],
  ["reds", N2e],
  ["oranges", A2e],
  // sequential (multi-hue)
  ["turbo", j2e],
  ["viridis", L2e],
  ["magma", z2e],
  ["inferno", F2e],
  ["plasma", B2e],
  ["cividis", O2e],
  ["cubehelix", R2e],
  ["warm", k2e],
  ["cool", $2e],
  ["bugn", XSe],
  ["bupu", ZSe],
  ["gnbu", e2e],
  ["orrd", n2e],
  ["pubugn", i2e],
  ["pubu", a2e],
  ["purd", u2e],
  ["rdpu", c2e],
  ["ylgnbu", d2e],
  ["ylgn", p2e],
  ["ylorbr", m2e],
  ["ylorrd", v2e],
  // cyclical
  ["rainbow", P2e],
  ["sinebow", I2e]
]);
function aJ(e) {
  const t = `${e}`.toLowerCase();
  if (!$he.has(t))
    throw new Error(`unknown quantitative scheme: ${t}`);
  return $he.get(t);
}
const apt = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function spt(e) {
  return e != null && apt.has(`${e}`.toLowerCase());
}
const _Me = (e) => (t) => e(1 - t), RH = [0, 1], Phe = /* @__PURE__ */ new Map([
  // numbers
  ["number", Ku],
  // color spaces
  ["rgb", tw],
  ["hsl", tEe],
  ["hcl", iEe],
  ["lab", nEe]
]);
function EMe(e) {
  const t = `${e}`.toLowerCase();
  if (!Phe.has(t))
    throw new Error(`unknown interpolator: ${t}`);
  return Phe.get(t);
}
function H$(e, t, n, {
  type: r,
  nice: i,
  clamp: o,
  zero: a,
  domain: s = MMe(e, n),
  unknown: u,
  round: l,
  scheme: f,
  interval: h,
  range: p = ba.get(e) === QF ? vpt(n, s) : ba.get(e) === XF ? bpt(n, s) : ba.get(e) === KF ? RH : void 0,
  interpolate: g = ba.get(e) === Sb ? f == null && p !== void 0 ? tw : aJ(f !== void 0 ? f : r === "cyclical" ? "rainbow" : "turbo") : l ? fN : Ku,
  reverse: y
}) {
  if (h = gN(h, r), (r === "cyclical" || r === "sequential") && (r = "linear"), typeof g != "function" && (g = EMe(g)), y = !!y, p !== void 0) {
    const b = (s = Af(s)).length, _ = (p = Af(p)).length;
    if (b !== _) {
      if (g.length === 1)
        throw new Error("invalid piecewise interpolator");
      g = dN(g, p), p = void 0;
    }
  }
  if (g.length === 1 ? (y && (g = _Me(g), y = !1), p === void 0 && (p = Float64Array.from(s, (b, _) => _ / (s.length - 1)), p.length === 2 && (p = RH)), t.interpolate((p === RH ? Bd : uJ)(g))) : t.interpolate(g), a) {
    const [b, _] = Zu(s);
    (b > 0 || _ < 0) && (s = lG(s), bC(s) !== Math.sign(b) ? s[s.length - 1] = 0 : s[0] = 0);
  }
  return y && (s = uL(s)), t.domain(s).unknown(u), i && (t.nice(upt(i, r)), s = t.domain()), p !== void 0 && t.range(p), o && t.clamp(o), { type: r, domain: s, range: p, scale: t, interpolate: g, interval: h };
}
function upt(e, t) {
  return e === !0 ? void 0 : typeof e == "number" ? e : aht(e, t);
}
function lpt(e, t, n) {
  return H$(e, BF(), t, n);
}
function cpt(e, t, n) {
  return SMe(e, t, { ...n, exponent: 0.5 });
}
function SMe(e, t, { exponent: n = 1, ...r }) {
  return H$(e, UF().exponent(n), t, { ...r, type: "pow" });
}
function fpt(e, t, { base: n = 10, domain: r = xpt(t), ...i }) {
  return H$(e, vZ().base(n), t, { ...i, domain: r });
}
function dpt(e, t, { constant: n = 1, ...r }) {
  return H$(e, xZ().constant(n), t, r);
}
function hpt(e, t, {
  range: n,
  quantiles: r = n === void 0 ? 5 : (n = [...n]).length,
  // deprecated; use n instead
  n: i = r,
  scheme: o = "rdylbu",
  domain: a = wpt(t),
  unknown: s,
  interpolate: u,
  reverse: l
}) {
  return n === void 0 && (n = u !== void 0 ? dp(u, i) : ba.get(e) === Sb ? i6(o, i) : void 0), a.length > 0 && (a = _Z(a, n === void 0 ? { length: i } : n).quantiles()), sJ(e, t, { domain: a, range: n, reverse: l, unknown: s });
}
function ppt(e, t, {
  range: n,
  n: r = n === void 0 ? 5 : (n = [...n]).length,
  scheme: i = "rdylbu",
  domain: o = MMe(e, t),
  unknown: a,
  interpolate: s,
  reverse: u
}) {
  const [l, f] = Zu(o);
  let h;
  return n === void 0 ? (h = Kx(l, f, r), h[0] <= l && h.splice(0, 1), h[h.length - 1] >= f && h.pop(), r = h.length + 1, n = s !== void 0 ? dp(s, r) : ba.get(e) === Sb ? i6(i, r) : void 0) : (h = dp(Ku(l, f), r + 1).slice(1, -1), l instanceof Date && (h = h.map((p) => new Date(p)))), bC(Af(o)) < 0 && h.reverse(), sJ(e, t, { domain: h, range: n, reverse: u, unknown: a });
}
function sJ(e, t, {
  domain: n = [0],
  // explicit thresholds in ascending order
  unknown: r,
  scheme: i = "rdylbu",
  interpolate: o,
  range: a = o !== void 0 ? dp(o, n.length + 1) : ba.get(e) === Sb ? i6(i, n.length + 1) : void 0,
  reverse: s
}) {
  n = Af(n);
  const u = bC(n);
  if (!isNaN(u) && !gpt(n, u))
    throw new Error(`the ${e} scale has a non-monotonic domain`);
  return s && (a = uL(a)), {
    type: "threshold",
    scale: EZ(u < 0 ? uL(n) : n, a === void 0 ? [] : a).unknown(r),
    domain: n,
    range: a
  };
}
function gpt(e, t) {
  for (let n = 1, r = e.length, i = e[0]; n < r; ++n) {
    const o = _S(i, i = e[n]);
    if (o !== 0 && o !== t)
      return !1;
  }
  return !0;
}
function mpt() {
  return { type: "identity", scale: mZ() };
}
function zk(e, t = WL) {
  return e.length ? [
    Oc(e, ({ value: n }) => n === void 0 ? n : Oc(n, t)),
    Ha(e, ({ value: n }) => n === void 0 ? n : Ha(n, t))
  ] : [0, 1];
}
function MMe(e, t) {
  const n = ba.get(e);
  return (n === QF || n === KF || n === XF ? ypt : zk)(t);
}
function ypt(e) {
  return [0, e.length ? Ha(e, ({ value: t }) => t === void 0 ? t : Ha(t, WL)) : 1];
}
function vpt(e, t) {
  const n = e.find(({ radius: a }) => a !== void 0);
  if (n !== void 0)
    return [0, n.radius];
  const r = Wy(e, 0.5, ({ value: a }) => a === void 0 ? NaN : Wy(a, 0.25, Z0)), i = t.map((a) => 3 * Math.sqrt(a / r)), o = 30 / Ha(i);
  return o < 1 ? i.map((a) => a * o) : i;
}
function bpt(e, t) {
  const n = Jx(e, ({ value: o }) => o === void 0 ? NaN : Jx(o, Math.abs)), r = t.map((o) => 12 * o / n), i = 60 / Ha(r);
  return i < 1 ? r.map((o) => o * i) : r;
}
function xpt(e) {
  for (const { value: t } of e)
    if (t !== void 0)
      for (let n of t) {
        if (n > 0)
          return zk(e, Z0);
        if (n < 0)
          return zk(e, qF);
      }
  return [1, 10];
}
function wpt(e) {
  const t = [];
  for (const { value: n } of e)
    if (n !== void 0)
      for (const r of n)
        t.push(r);
  return t;
}
function uJ(e) {
  return (t, n) => (r) => e(t + r * (n - t));
}
function o6(e, t, n, r, {
  type: i,
  nice: o,
  clamp: a,
  domain: s = zk(r),
  unknown: u,
  pivot: l = 0,
  scheme: f,
  range: h,
  symmetric: p = !0,
  interpolate: g = ba.get(e) === Sb ? f == null && h !== void 0 ? tw : aJ(f !== void 0 ? f : "rdbu") : Ku,
  reverse: y
}) {
  l = +l, s = Af(s);
  let [b, _] = s;
  if (s.length > 2 && Lx(`Warning: the diverging ${e} scale domain contains extra elements.`), _S(b, _) < 0 && ([b, _] = [_, b], y = !y), b = Math.min(b, l), _ = Math.max(_, l), typeof g != "function" && (g = EMe(g)), h !== void 0 && (g = g.length === 1 ? uJ(g)(...h) : dN(g, h)), y && (g = _Me(g)), p) {
    const S = n.apply(l), C = S - n.apply(b), A = n.apply(_) - S;
    C < A ? b = n.invert(S - A) : C > A && (_ = n.invert(S + C));
  }
  return t.domain([b, l, _]).unknown(u).interpolator(g), a && t.clamp(a), o && t.nice(o), { type: i, domain: [b, _], pivot: l, interpolate: g, scale: t };
}
function _pt(e, t, n) {
  return o6(e, DZ(), Tpt, t, n);
}
function Ept(e, t, n) {
  return TMe(e, t, { ...n, exponent: 0.5 });
}
function TMe(e, t, { exponent: n = 1, ...r }) {
  return o6(e, VF().exponent(n = +n), Dpt(n), t, {
    ...r,
    type: "diverging-pow"
  });
}
function Spt(e, t, { base: n = 10, pivot: r = 1, domain: i = zk(t, r < 0 ? qF : Z0), ...o }) {
  return o6(e, AZ().base(n = +n), Cpt, t, {
    domain: i,
    pivot: r,
    ...o
  });
}
function Mpt(e, t, { constant: n = 1, ...r }) {
  return o6(
    e,
    OZ().constant(n = +n),
    Apt(n),
    t,
    r
  );
}
const Tpt = {
  apply(e) {
    return e;
  },
  invert(e) {
    return e;
  }
}, Cpt = {
  apply: Math.log,
  invert: Math.exp
}, Npt = {
  apply(e) {
    return Math.sign(e) * Math.sqrt(Math.abs(e));
  },
  invert(e) {
    return Math.sign(e) * (e * e);
  }
};
function Dpt(e) {
  return e === 0.5 ? Npt : {
    apply(t) {
      return Math.sign(t) * Math.pow(Math.abs(t), e);
    },
    invert(t) {
      return Math.sign(t) * Math.pow(Math.abs(t), 1 / e);
    }
  };
}
function Apt(e) {
  return {
    apply(t) {
      return Math.sign(t) * Math.log1p(Math.abs(t / e));
    },
    invert(t) {
      return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
    }
  };
}
function CMe(e, t, n, r) {
  return H$(e, t, n, r);
}
function Opt(e, t, n) {
  return CMe(e, OSe(), t, n);
}
function Rpt(e, t, n) {
  return CMe(e, RSe(), t, n);
}
const V$ = Symbol("ordinal");
function NMe(e, t, n, { type: r, interval: i, domain: o, range: a, reverse: s, hint: u }) {
  return i = gN(i, r), o === void 0 && (o = AMe(n, i, e)), (r === "categorical" || r === V$) && (r = "ordinal"), s && (o = uL(o)), t.domain(o), a !== void 0 && (typeof a == "function" && (a = a(o)), t.range(a)), { type: r, domain: o, range: a, scale: t, hint: u, interval: i };
}
function kpt(e, t, { type: n, interval: r, domain: i, range: o, scheme: a, unknown: s, ...u }) {
  r = gN(r, n), i === void 0 && (i = AMe(t, r, e));
  let l;
  if (ba.get(e) === ZF)
    l = Ipt(t), o = o === void 0 ? jpt(l) : jo(o, YZ);
  else if (ba.get(e) === Sb && (o === void 0 && (n === "ordinal" || n === V$) && (o = opt(i, a), o !== void 0 && (a = void 0)), a === void 0 && o === void 0 && (a = n === "ordinal" ? "turbo" : "tableau10"), a !== void 0))
    if (o !== void 0) {
      const f = aJ(a), h = o[0], p = o[1] - o[0];
      o = ({ length: g }) => dp((y) => f(h + p * y), g);
    } else
      o = wMe(a);
  if (s === UL)
    throw new Error(`implicit unknown on ${e} scale is not supported`);
  return NMe(e, k$().unknown(s), t, { ...u, type: n, domain: i, range: o, hint: l });
}
function $pt(e, t, { align: n = 0.5, padding: r = 0.5, ...i }) {
  return DMe(fft().align(n).padding(r), t, i, e);
}
function Ppt(e, t, {
  align: n = 0.5,
  padding: r = 0.1,
  paddingInner: i = r,
  paddingOuter: o = e === "fx" || e === "fy" ? 0 : r,
  ...a
}) {
  return DMe(
    zF().align(n).paddingInner(i).paddingOuter(o),
    t,
    a,
    e
  );
}
function DMe(e, t, n, r) {
  let { round: i } = n;
  return i !== void 0 && e.round(i = !!i), e = NMe(r, e, t, n), e.round = i, e;
}
function AMe(e, t, n) {
  const r = new Xx();
  for (const { value: i, domain: o } of e) {
    if (o !== void 0)
      return o();
    if (i !== void 0)
      for (const a of i)
        r.add(a);
  }
  if (t !== void 0) {
    const [i, o] = Zu(r).map(t.floor, t);
    return t.range(i, t.offset(o));
  }
  if (r.size > 1e4 && ba.get(n) === ky)
    throw new Error(`implicit ordinal domain of ${n} scale has more than 10,000 values`);
  return Ek(r, gp);
}
function Ihe(e, t) {
  let n;
  for (const { hint: r } of e) {
    const i = r == null ? void 0 : r[t];
    if (i !== void 0) {
      if (n === void 0)
        n = i;
      else if (n !== i)
        return;
    }
  }
  return n;
}
function Ipt(e) {
  return {
    fill: Ihe(e, "fill"),
    stroke: Ihe(e, "stroke")
  };
}
function jpt(e) {
  return Ba(e.fill) ? Trt : Mrt;
}
function dG(e, {
  label: t,
  inset: n = 0,
  insetTop: r = n,
  insetRight: i = n,
  insetBottom: o = n,
  insetLeft: a = n,
  round: s,
  nice: u,
  clamp: l,
  zero: f,
  align: h,
  padding: p,
  projection: g,
  facet: { label: y = t } = {},
  ...b
} = {}) {
  const _ = {};
  for (const [S, C] of e) {
    const A = b[S], O = $Me(S, C, {
      round: ba.get(S) === ky ? s : void 0,
      // only for position
      nice: u,
      clamp: l,
      zero: f,
      align: h,
      padding: p,
      projection: g,
      ...A
    });
    if (O) {
      let {
        label: R = S === "fx" || S === "fy" ? y : t,
        percent: j,
        transform: $,
        inset: z,
        insetTop: W = z !== void 0 ? z : S === "y" ? r : 0,
        // not fy
        insetRight: Y = z !== void 0 ? z : S === "x" ? i : 0,
        // not fx
        insetBottom: V = z !== void 0 ? z : S === "y" ? o : 0,
        // not fy
        insetLeft: ee = z !== void 0 ? z : S === "x" ? a : 0
        // not fx
      } = A || {};
      if ($ == null)
        $ = void 0;
      else if (typeof $ != "function")
        throw new Error("invalid scale transform; not a function");
      O.percent = !!j, O.label = R === void 0 ? zpt(C, O) : R, O.transform = $, S === "x" || S === "fx" ? (O.insetLeft = +ee, O.insetRight = +Y) : (S === "y" || S === "fy") && (O.insetTop = +W, O.insetBottom = +V), _[S] = O;
    }
  }
  return _;
}
function jhe(e) {
  return Object.fromEntries(
    Object.entries(e).filter(([, { scale: t }]) => t).map(([t, { scale: n, type: r, interval: i, label: o }]) => (n.type = r, i != null && (n.interval = i), o != null && (n.label = o), [t, n]))
  );
}
function Lpt(e, t) {
  const { x: n, y: r, fx: i, fy: o } = e, a = i || o ? lJ(t) : t;
  i && Lhe(i, a), o && zhe(o, a);
  const s = i || o ? OMe(e, t) : t;
  n && Lhe(n, s), r && zhe(r, s);
}
function zpt(e = [], t) {
  let n;
  for (const { label: r } of e)
    if (r !== void 0) {
      if (n === void 0)
        n = r;
      else if (n !== r)
        return;
    }
  if (n !== void 0)
    return !r2(t) && t.percent && (n = `${n} (%)`), { inferred: !0, toString: () => n };
}
function lJ(e) {
  const {
    marginTop: t,
    marginRight: n,
    marginBottom: r,
    marginLeft: i,
    width: o,
    height: a,
    facet: {
      marginTop: s,
      marginRight: u,
      marginBottom: l,
      marginLeft: f
    }
  } = e;
  return {
    marginTop: Math.max(t, s),
    marginRight: Math.max(n, u),
    marginBottom: Math.max(r, l),
    marginLeft: Math.max(i, f),
    width: o,
    height: a
  };
}
function OMe({ fx: e, fy: t }, n) {
  const { marginTop: r, marginRight: i, marginBottom: o, marginLeft: a, width: s, height: u } = lJ(n);
  return {
    marginTop: r,
    marginRight: i,
    marginBottom: o,
    marginLeft: a,
    width: e ? e.scale.bandwidth() + a + i : s,
    height: t ? t.scale.bandwidth() + r + o : u,
    facet: { width: s, height: u }
  };
}
function Lhe(e, t) {
  if (e.range === void 0) {
    const { insetLeft: n, insetRight: r } = e, { width: i, marginLeft: o = 0, marginRight: a = 0 } = t, s = o + n, u = i - a - r;
    e.range = [s, Math.max(s, u)], r2(e) || (e.range = kMe(e)), e.scale.range(e.range);
  }
  RMe(e);
}
function zhe(e, t) {
  if (e.range === void 0) {
    const { insetTop: n, insetBottom: r } = e, { height: i, marginTop: o = 0, marginBottom: a = 0 } = t, s = o + n, u = i - a - r;
    e.range = [Math.max(s, u), s], r2(e) ? e.range.reverse() : e.range = kMe(e), e.scale.range(e.range);
  }
  RMe(e);
}
function RMe(e) {
  e.round === void 0 && Upt(e) && Fpt(e) <= 30 && e.scale.round(!0);
}
function Fpt({ scale: e }) {
  const t = e.domain().length, [n, r] = e.range(), i = e.paddingInner ? e.paddingInner() : 1, o = e.paddingOuter ? e.paddingOuter() : e.padding(), a = t - i, s = Math.abs(r - n) / Math.max(1, a + o * 2);
  return (s - Math.floor(s)) * a;
}
function kMe(e) {
  const t = e.scale.domain().length + PMe(e);
  if (!(t > 2))
    return e.range;
  const [n, r] = e.range;
  return Array.from({ length: t }, (i, o) => n + o / (t - 1) * (r - n));
}
function hG(e, t, n) {
  return $Me(e, n === void 0 ? void 0 : [{ hint: n }], { ...t });
}
function $Me(e, t = [], n = {}) {
  const r = Bpt(e, t, n);
  if (n.type === void 0 && n.domain === void 0 && n.range === void 0 && n.interval == null && e !== "fx" && e !== "fy" && r2({ type: r })) {
    const i = t.map(({ value: o }) => o).filter((o) => o !== void 0);
    i.some(mp) ? Lx(
      `Warning: some data associated with the ${e} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${UM(
        r
      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${e} scale to "${UM(
        r
      )}".`
    ) : i.some(lht) ? Lx(
      `Warning: some data associated with the ${e} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${UM(
        r
      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${e} scale to "${UM(
        r
      )}".`
    ) : i.some(cht) && Lx(
      `Warning: some data associated with the ${e} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${UM(
        r
      )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${e} scale to "${UM(
        r
      )}".`
    );
  }
  switch (n.type = r, r) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      n = o3(t, n, xf);
      break;
    case "identity":
      switch (ba.get(e)) {
        case ky:
          n = o3(t, n, xf);
          break;
        case ZF:
          n = o3(t, n, Ypt);
          break;
      }
      break;
    case "utc":
    case "time":
      n = o3(t, n, oht);
      break;
  }
  switch (r) {
    case "diverging":
      return _pt(e, t, n);
    case "diverging-sqrt":
      return Ept(e, t, n);
    case "diverging-pow":
      return TMe(e, t, n);
    case "diverging-log":
      return Spt(e, t, n);
    case "diverging-symlog":
      return Mpt(e, t, n);
    case "categorical":
    case "ordinal":
    case V$:
      return kpt(e, t, n);
    case "cyclical":
    case "sequential":
    case "linear":
      return lpt(e, t, n);
    case "sqrt":
      return cpt(e, t, n);
    case "threshold":
      return sJ(e, t, n);
    case "quantile":
      return hpt(e, t, n);
    case "quantize":
      return ppt(e, t, n);
    case "pow":
      return SMe(e, t, n);
    case "log":
      return fpt(e, t, n);
    case "symlog":
      return dpt(e, t, n);
    case "utc":
      return Rpt(e, t, n);
    case "time":
      return Opt(e, t, n);
    case "point":
      return $pt(e, t, n);
    case "band":
      return Ppt(e, t, n);
    case "identity":
      return ba.get(e) === ky ? mpt() : { type: "identity" };
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${r}`);
  }
}
function UM(e) {
  return typeof e == "symbol" ? e.description : e;
}
const Fhe = { toString: () => "projection" };
function Bpt(e, t, { type: n, domain: r, range: i, scheme: o, pivot: a, projection: s }) {
  if (e === "fx" || e === "fy")
    return "band";
  (e === "x" || e === "y") && s != null && (n = Fhe);
  for (const { type: l } of t)
    if (l !== void 0) {
      if (n === void 0)
        n = l;
      else if (n !== l)
        throw new Error(`scale incompatible with channel: ${n} !== ${l}`);
    }
  if (n === Fhe)
    return;
  if (n !== void 0)
    return n;
  if (r === void 0 && !t.some(({ value: l }) => l !== void 0))
    return;
  const u = ba.get(e);
  if (u === QF)
    return "sqrt";
  if (u === KF || u === XF)
    return "linear";
  if (u === ZF)
    return "ordinal";
  if ((r || i || []).length > 2)
    return kH(u);
  if (r !== void 0) {
    if ($a(r))
      return kH(u);
    if (mp(r))
      return "utc";
  } else {
    const l = t.map(({ value: f }) => f).filter((f) => f !== void 0);
    if (l.some($a))
      return kH(u);
    if (l.some(mp))
      return "utc";
  }
  if (u === Sb) {
    if (a != null || spt(o))
      return "diverging";
    if (ipt(o))
      return "categorical";
  }
  return "linear";
}
function kH(e) {
  switch (e) {
    case ky:
      return "point";
    case Sb:
      return V$;
    default:
      return "ordinal";
  }
}
function cJ({ type: e }) {
  return e === "time" || e === "utc";
}
function r2({ type: e }) {
  return e === "ordinal" || e === "point" || e === "band" || e === V$;
}
function PMe({ type: e }) {
  return e === "threshold";
}
function Upt({ type: e }) {
  return e === "point" || e === "band";
}
function ep(e) {
  if (e === void 0)
    return !0;
  const t = e.domain(), n = e(t[0]);
  for (let r = 1, i = t.length; r < i; ++r)
    if (e(t[r]) - n)
      return !1;
  return !0;
}
function o3(e, { domain: t, ...n }, r) {
  for (const i of e)
    i.value !== void 0 && (i.value = r(i.value));
  return {
    domain: t === void 0 ? t : r(t),
    ...n
  };
}
function Ypt(e) {
  return jo(e, YZ);
}
function Hpt(e = {}) {
  let t;
  for (const n in e)
    if (ba.has(n) && tS(e[n])) {
      if (t !== void 0)
        throw new Error("ambiguous scale definition; multiple scales found");
      t = IMe(hG(n, e[n]));
    }
  if (t === void 0)
    throw new Error("invalid scale definition; no scale found");
  return t;
}
function Vpt(e) {
  return (t) => {
    if (!ba.has(t = `${t}`))
      throw new Error(`unknown scale: ${t}`);
    return t in e ? IMe(e[t]) : void 0;
  };
}
function IMe({ scale: e, type: t, domain: n, range: r, interpolate: i, interval: o, transform: a, percent: s, pivot: u }) {
  if (t === "identity")
    return { type: "identity", apply: (f) => f, invert: (f) => f };
  const l = e.unknown ? e.unknown() : void 0;
  return {
    type: t,
    domain: lG(n),
    // defensive copy
    ...r !== void 0 && { range: lG(r) },
    // defensive copy
    ...a !== void 0 && { transform: a },
    ...s && { percent: s },
    // only exposed if truthy
    ...l !== void 0 && { unknown: l },
    ...o !== void 0 && { interval: o },
    // quantitative
    ...i !== void 0 && { interpolate: i },
    ...e.clamp && { clamp: e.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...u !== void 0 && { pivot: u, symmetric: !1 },
    // log, diverging-log
    ...e.base && { base: e.base() },
    // pow, diverging-pow
    ...e.exponent && { exponent: e.exponent() },
    // symlog, diverging-symlog
    ...e.constant && { constant: e.constant() },
    // band, point
    ...e.align && { align: e.align(), round: e.round() },
    ...e.padding && (e.paddingInner ? { paddingInner: e.paddingInner(), paddingOuter: e.paddingOuter() } : { padding: e.padding() }),
    ...e.bandwidth && { bandwidth: e.bandwidth(), step: e.step() },
    // utilities
    apply: (f) => e(f),
    ...e.invert && { invert: (f) => e.invert(f) }
  };
}
function Wpt(e, t, n = {}) {
  let r = 0.5 - Ju, i = 0.5 + Ju, o = 0.5 + Ju, a = 0.5 - Ju;
  for (const { marginTop: b, marginRight: _, marginBottom: S, marginLeft: C } of t)
    b > r && (r = b), _ > i && (i = _), S > o && (o = S), C > a && (a = C);
  let {
    margin: s,
    marginTop: u = s !== void 0 ? s : r,
    marginRight: l = s !== void 0 ? s : i,
    marginBottom: f = s !== void 0 ? s : o,
    marginLeft: h = s !== void 0 ? s : a
  } = n;
  u = +u, l = +l, f = +f, h = +h;
  let {
    width: p = 640,
    height: g = qpt(e, n, {
      width: p,
      marginTopDefault: r,
      marginRightDefault: i,
      marginBottomDefault: o,
      marginLeftDefault: a
    }) + Math.max(0, u - r + f - o)
  } = n;
  p = +p, g = +g;
  const y = {
    width: p,
    height: g,
    marginTop: u,
    marginRight: l,
    marginBottom: f,
    marginLeft: h
  };
  if (e.fx || e.fy) {
    let {
      margin: b,
      marginTop: _ = b !== void 0 ? b : u,
      marginRight: S = b !== void 0 ? b : l,
      marginBottom: C = b !== void 0 ? b : f,
      marginLeft: A = b !== void 0 ? b : h
    } = n.facet ?? {};
    _ = +_, S = +S, C = +C, A = +A, y.facet = {
      marginTop: _,
      marginRight: S,
      marginBottom: C,
      marginLeft: A
    };
  }
  return y;
}
function qpt({ x: e, y: t, fy: n, fx: r }, { projection: i, aspectRatio: o }, { width: a, marginTopDefault: s, marginRightDefault: u, marginBottomDefault: l, marginLeftDefault: f }) {
  const h = n ? n.scale.domain().length : 1, p = npt(i);
  if (p) {
    const y = r ? r.scale.domain().length : 1, b = (1.1 * h - 0.1) / (1.1 * y - 0.1) * p, _ = Math.max(0.1, Math.min(10, b));
    return Math.round((a - f - u) * _ + s + l);
  }
  const g = t ? r2(t) ? t.scale.domain().length : Math.max(7, 17 / h) : 1;
  if (o != null) {
    if (o = +o, !(isFinite(o) && o > 0))
      throw new Error(`invalid aspectRatio: ${o}`);
    const y = Bhe("y", t) / (Bhe("x", e) * o), b = r ? r.scale.bandwidth() : 1, _ = n ? n.scale.bandwidth() : 1, S = b * (a - f - u) - e.insetLeft - e.insetRight;
    return (y * S + t.insetTop + t.insetBottom) / _ + s + l;
  }
  return !!(t || n) * Math.max(1, Math.min(60, g * h)) * 20 + !!r * 30 + 60;
}
function Bhe(e, t) {
  if (!t)
    throw new Error(`aspectRatio requires ${e} scale`);
  const { type: n, domain: r } = t;
  let i;
  switch (n) {
    case "linear":
    case "utc":
    case "time":
      i = Number;
      break;
    case "pow": {
      const s = t.scale.exponent();
      i = (u) => Math.pow(u, s);
      break;
    }
    case "log":
      i = Math.log;
      break;
    case "point":
    case "band":
      return r.length;
    default:
      throw new Error(`unsupported ${e} scale for aspectRatio: ${n}`);
  }
  const [o, a] = Zu(r);
  return Math.abs(i(a) - i(o));
}
function Gpt(e, t) {
  const { fx: n, fy: r } = dG(e, t), i = n == null ? void 0 : n.scale.domain(), o = r == null ? void 0 : r.scale.domain();
  return i && o ? Hrt(i, o).map(([a, s], u) => ({ x: a, y: s, i: u })) : i ? i.map((a, s) => ({ x: a, i: s })) : o ? o.map((a, s) => ({ y: a, i: s })) : void 0;
}
function Qpt(e, { x: t, y: n }) {
  return t && (t = pG(t)), n && (n = pG(n)), e.filter(
    t && n ? (r) => t.has(r.x) && n.has(r.y) : t ? (r) => t.has(r.x) : (r) => n.has(r.y)
  ).sort(
    t && n ? (r, i) => t.get(r.x) - t.get(i.x) || n.get(r.y) - n.get(i.y) : t ? (r, i) => t.get(r.x) - t.get(i.x) : (r, i) => n.get(r.y) - n.get(i.y)
  );
}
function fJ(e, { fx: t, fy: n }) {
  const r = _b(e), i = t == null ? void 0 : t.value, o = n == null ? void 0 : n.value;
  return t && n ? NT(
    r,
    (a) => (a.fx = i[a[0]], a.fy = o[a[0]], a),
    (a) => i[a],
    (a) => o[a]
  ) : t ? NT(
    r,
    (a) => (a.fx = i[a[0]], a),
    (a) => i[a]
  ) : NT(
    r,
    (a) => (a.fy = o[a[0]], a),
    (a) => o[a]
  );
}
function Xpt(e, t, { marginTop: n, marginLeft: r }) {
  return e && t ? ({ x: i, y: o }) => `translate(${e(i) - r},${t(o) - n})` : e ? ({ x: i }) => `translate(${e(i) - r},0)` : ({ y: i }) => `translate(0,${t(i) - n})`;
}
function Kpt(e) {
  const t = [], n = new Uint32Array(fp(e, (r) => r.length));
  for (const r of e) {
    let i = 0;
    for (const o of e)
      r !== o && (n.set(o, i), i += o.length);
    t.push(n.slice(0, i));
  }
  return t;
}
const Zpt = /* @__PURE__ */ new Map([
  ["top", $H],
  ["right", jH],
  ["bottom", PH],
  ["left", IH],
  ["top-left", a3($H, IH)],
  ["top-right", a3($H, jH)],
  ["bottom-left", a3(PH, IH)],
  ["bottom-right", a3(PH, jH)],
  ["top-empty", tgt],
  ["right-empty", igt],
  ["bottom-empty", ngt],
  ["left-empty", rgt],
  ["empty", ogt]
]);
function Jpt(e) {
  if (e == null)
    return null;
  const t = Zpt.get(`${e}`.toLowerCase());
  if (t)
    return t;
  throw new Error(`invalid facet anchor: ${e}`);
}
const Uhe = /* @__PURE__ */ new WeakMap();
function pG(e) {
  let t = Uhe.get(e);
  return t || Uhe.set(e, t = new ES(jo(e, (n, r) => [n, r]))), t;
}
function Rw(e, t) {
  return pG(e).get(t);
}
function egt(e, t, n) {
  return t = YE(t), n = YE(n), e.find((r) => Object.is(YE(r.x), t) && Object.is(YE(r.y), n));
}
function a6(e, t, n) {
  var r;
  return (r = egt(e, t, n)) == null ? void 0 : r.empty;
}
function $H(e, { y: t }, { y: n }) {
  return t ? Rw(t, n) === 0 : !0;
}
function PH(e, { y: t }, { y: n }) {
  return t ? Rw(t, n) === t.length - 1 : !0;
}
function IH(e, { x: t }, { x: n }) {
  return t ? Rw(t, n) === 0 : !0;
}
function jH(e, { x: t }, { x: n }) {
  return t ? Rw(t, n) === t.length - 1 : !0;
}
function tgt(e, { y: t }, { x: n, y: r, empty: i }) {
  if (i)
    return !1;
  if (!t)
    return;
  const o = Rw(t, r);
  if (o > 0)
    return a6(e, n, t[o - 1]);
}
function ngt(e, { y: t }, { x: n, y: r, empty: i }) {
  if (i)
    return !1;
  if (!t)
    return;
  const o = Rw(t, r);
  if (o < t.length - 1)
    return a6(e, n, t[o + 1]);
}
function rgt(e, { x: t }, { x: n, y: r, empty: i }) {
  if (i)
    return !1;
  if (!t)
    return;
  const o = Rw(t, n);
  if (o > 0)
    return a6(e, t[o - 1], r);
}
function igt(e, { x: t }, { x: n, y: r, empty: i }) {
  if (i)
    return !1;
  if (!t)
    return;
  const o = Rw(t, n);
  if (o < t.length - 1)
    return a6(e, t[o + 1], r);
}
function ogt(e, t, { empty: n }) {
  return n;
}
function a3(e, t) {
  return function() {
    return e.apply(null, arguments) && t.apply(null, arguments);
  };
}
function LH(e, { channels: { fx: t, fy: n }, groups: r }) {
  return t && n ? e.map(({ x: i, y: o }) => {
    var a;
    return ((a = r.get(i)) == null ? void 0 : a.get(o)) ?? [];
  }) : t ? e.map(({ x: i }) => r.get(i) ?? []) : e.map(({ y: i }) => r.get(i) ?? []);
}
let Co = class {
  constructor(t, n = {}, r = {}, i) {
    const {
      facet: o = "auto",
      facetAnchor: a,
      fx: s,
      fy: u,
      sort: l,
      dx: f = 0,
      dy: h = 0,
      margin: p = 0,
      marginTop: g = p,
      marginRight: y = p,
      marginBottom: b = p,
      marginLeft: _ = p,
      clip: S = i == null ? void 0 : i.clip,
      channels: C,
      tip: A,
      render: O
    } = r;
    if (this.data = t, this.sort = iw(l) ? l : null, this.initializer = Of(r).initializer, this.transform = this.initializer ? r.transform : iv(r).transform, o === null || o === !1 ? this.facet = null : (this.facet = Sp(o === !0 ? "include" : o, "facet", ["auto", "include", "exclude", "super"]), this.fx = t === RR && typeof s == "string" ? [s] : s, this.fy = t === RR && typeof u == "string" ? [u] : u), this.facetAnchor = Jpt(a), n = FZ(n), C !== void 0 && (n = { ...agt(C), ...n }), i !== void 0 && (n = { ...dMe(this, r, i), ...n }), this.channels = Object.fromEntries(
      Object.entries(n).map(([R, j]) => {
        if (Ey(j.value)) {
          const { value: $, scale: z = j.scale } = j.value;
          j = { ...j, scale: z, value: $ };
        }
        if (t === RR && typeof j.value == "string") {
          const { value: $ } = j;
          j = { ...j, value: [$] };
        }
        return [R, j];
      }).filter(([R, { value: j, optional: $ }]) => {
        if (j != null)
          return !0;
        if ($)
          return !1;
        throw new Error(`missing channel value: ${R}`);
      })
    ), this.dx = +f, this.dy = +h, this.marginTop = +g, this.marginRight = +y, this.marginBottom = +b, this.marginLeft = +_, this.clip = pMe(S), this.tip = sgt(A), this.facet === "super") {
      if (s || u)
        throw new Error("super-faceting cannot use fx or fy");
      for (const R in this.channels) {
        const { scale: j } = n[R];
        if (!(j !== "x" && j !== "y"))
          throw new Error("super-faceting cannot use x or y");
      }
    }
    O != null && (this.render = jMe(O, this.render));
  }
  initialize(t, n, r) {
    let i = Af(this.data);
    t === void 0 && i != null && (t = [_b(i)]);
    const o = t;
    this.transform != null && ({ facets: t, data: i } = this.transform(i, t, r), i = Af(i)), t !== void 0 && (t.original = o);
    const a = aMe(this.channels, i);
    return this.sort != null && Oht(i, t, a, n, this.sort), { data: i, facets: t, channels: a };
  }
  filter(t, n, r) {
    for (const i in n) {
      const { filter: o = Dc } = n[i];
      if (o !== null) {
        const a = r[i];
        t = t.filter((s) => o(a[s]));
      }
    }
    return t;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves don’t exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(t, n, r) {
    for (const i in t)
      if (t[i].scale === "x" && /^x|x$/.test(i)) {
        const o = i.replace(/^x|x$/, "y");
        o in t && t[o].scale === "y" && bMe(i, o, n, r.projection);
      }
  }
  scale(t, n, r) {
    const i = tJ(t, n);
    return r.projection && this.project(t, i, r), i;
  }
};
function Vg(...e) {
  return e.plot = Co.prototype.plot, e;
}
function jMe(e, t) {
  if (e == null)
    return t === null ? void 0 : t;
  if (t == null)
    return e === null ? void 0 : e;
  if (typeof e != "function")
    throw new TypeError(`invalid render transform: ${e}`);
  if (typeof t != "function")
    throw new TypeError(`invalid render transform: ${t}`);
  return function(n, r, i, o, a, s) {
    return e.call(this, n, r, i, o, a, (u, l, f, h, p) => t.call(this, u, l, f, h, p, s));
  };
}
function agt(e) {
  return Object.fromEntries(
    Object.entries(FZ(e)).map(([t, n]) => (n = B$(n), n.filter === void 0 && n.scale == null && (n = { ...n, filter: null }), [t, n]))
  );
}
function sgt(e) {
  return e === !0 ? "xy" : e === !1 ? null : IZ(e, "tip", ["x", "y", "xy"]);
}
function mN(e, t) {
  return (e == null ? void 0 : e.tip) === !0 ? { ...e, tip: t } : e;
}
const Yhe = /* @__PURE__ */ new WeakMap();
function dJ(e, t, { x: n, y: r, px: i, py: o, maxRadius: a = 40, channels: s, render: u, ...l } = {}) {
  return a = +a, i != null && (n ?? (n = null), s = { ...s, px: { value: i, scale: "x" } }), o != null && (r ?? (r = null), s = { ...s, py: { value: o, scale: "y" } }), {
    x: n,
    y: r,
    channels: s,
    ...l,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: jMe(function(f, h, p, g, y, b) {
      y = { ...y, pointerSticky: !1 };
      const _ = y.ownerSVGElement, { data: S } = y.getMarkState(this);
      let C = Yhe.get(_);
      C || Yhe.set(_, C = { sticky: !1, roots: [], renders: [] });
      let A = C.renders.push(ye) - 1;
      const { x: O, y: R, fx: j, fy: $ } = h;
      let z = j ? j(f.fx) - g.marginLeft : 0, W = $ ? $(f.fy) - g.marginTop : 0;
      O != null && O.bandwidth && (z += O.bandwidth() / 2), R != null && R.bandwidth && (W += R.bandwidth() / 2);
      const Y = f.fi != null;
      let V;
      if (Y) {
        let ke = C.facetStates;
        ke || (C.facetStates = ke = /* @__PURE__ */ new Map()), V = ke.get(this), V || ke.set(this, V = /* @__PURE__ */ new Map());
      }
      const [ee, K] = ov(this, g), { px: Q, py: q } = p, te = Q ? (ke) => Q[ke] : LMe(p, ee), X = q ? (ke) => q[ke] : zMe(p, K);
      let Z, se, H, ie;
      function he(ke, Me) {
        if (Y)
          if (ie && (ie = cancelAnimationFrame(ie)), ke == null)
            V.delete(f.fi);
          else {
            V.set(f.fi, Me), ie = requestAnimationFrame(() => {
              ie = null;
              for (const [we, Ye] of V)
                if (Ye < Me || Ye === Me && we < f.fi) {
                  ke = null;
                  break;
                }
              ye(ke);
            });
            return;
          }
        ye(ke);
      }
      function ye(ke) {
        if (Z === ke && H === C.sticky)
          return;
        Z = ke, H = y.pointerSticky = C.sticky;
        const Me = Z == null ? [] : [Z];
        Y && (Me.fx = f.fx, Me.fy = f.fy, Me.fi = f.fi);
        const we = b(Me, h, p, g, y);
        if (se) {
          if (Y) {
            const Ye = se.parentNode, ze = se.getAttribute("transform"), fe = we.getAttribute("transform");
            ze ? we.setAttribute("transform", ze) : we.removeAttribute("transform"), fe ? Ye.setAttribute("transform", fe) : Ye.removeAttribute("transform"), we.removeAttribute("aria-label"), we.removeAttribute("aria-description"), we.removeAttribute("aria-hidden");
          }
          se.replaceWith(we);
        }
        return C.roots[A] = se = we, Z == null && (V == null ? void 0 : V.size) > 1 || y.dispatchValue(Z == null ? null : S[Z]), we;
      }
      function _e(ke) {
        if (C.sticky || ke.pointerType === "mouse" && ke.buttons === 1)
          return;
        let [Me, we] = Xot(ke);
        Me -= z, we -= W;
        const Ye = Me < g.marginLeft || Me > g.width - g.marginRight ? 1 : e, ze = we < g.marginTop || we > g.height - g.marginBottom ? 1 : t;
        let fe = null, Qe = a * a;
        for (const $e of f) {
          const pt = Ye * (te($e) - Me), _t = ze * (X($e) - we), Ot = pt * pt + _t * _t;
          Ot <= Qe && (fe = $e, Qe = Ot);
        }
        if (fe != null && (e !== 1 || t !== 1)) {
          const $e = te(fe) - Me, pt = X(fe) - we;
          Qe = $e * $e + pt * pt;
        }
        he(fe, Qe);
      }
      function Ne(ke) {
        ke.pointerType === "mouse" && Z != null && (C.sticky && C.roots.some((Me) => Me == null ? void 0 : Me.contains(ke.target)) || (C.sticky ? (C.sticky = !1, C.renders.forEach((Me) => Me(null))) : (C.sticky = !0, ye(Z)), ke.stopImmediatePropagation()));
      }
      function Oe(ke) {
        ke.pointerType === "mouse" && (C.sticky || he(null));
      }
      return _.addEventListener("pointerenter", _e), _.addEventListener("pointermove", _e), _.addEventListener("pointerdown", Ne), _.addEventListener("pointerleave", Oe), ye(null);
    }, u)
  };
}
function hJ(e) {
  return dJ(1, 1, e);
}
function pJ(e) {
  return dJ(1, 0.01, e);
}
function gJ(e) {
  return dJ(0.01, 1, e);
}
function LMe({ x1: e, x2: t, x: n = e }, r) {
  return e && t ? (i) => (e[i] + t[i]) / 2 : n ? (i) => n[i] : () => r;
}
function zMe({ y1: e, y2: t, y: n = e }, r) {
  return e && t ? (i) => (e[i] + t[i]) / 2 : n ? (i) => n[i] : () => r;
}
function FMe(e) {
  return r2(e) && e.interval === void 0 ? void 0 : "tabular-nums";
}
function ugt(e, t) {
  let {
    label: n = e.label,
    tickSize: r = 6,
    width: i = 240,
    height: o = 44 + r,
    marginTop: a = 18,
    marginRight: s = 0,
    marginBottom: u = 16 + r,
    marginLeft: l = 0,
    style: f,
    ticks: h = (i - l - s) / 64,
    tickFormat: p,
    fontVariant: g = FMe(e),
    round: y = !0,
    opacity: b,
    className: _
  } = t;
  const S = n6(t);
  _ = iJ(_), b = ns(b)[1], p === null && (p = () => null);
  const C = Yi("svg", S).attr("class", `${_}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", i).attr("height", o).attr("viewBox", `0 0 ${i} ${o}`).call(
    (ee) => (
      // Warning: if you edit this, change defaultClassName.
      ee.append("style").text(
        `.${_}-ramp {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
.${_}-ramp text {
  white-space: pre;
}`
      )
    )
  ).call(oJ, f);
  let A = (ee) => ee.selectAll(".tick line").attr("y1", a + u - o), O;
  const R = y ? (ee, K) => ee.rangeRound(K) : (ee, K) => ee.range(K), { type: j, domain: $, range: z, interpolate: W, scale: Y, pivot: V } = e;
  if (W) {
    const ee = z === void 0 ? W : dN(W.length === 1 ? uJ(W) : W, z);
    O = R(
      Y.copy(),
      dp(
        Ku(l, i - s),
        Math.min($.length + (V !== void 0), z === void 0 ? 1 / 0 : z.length)
      )
    );
    const K = 256, Q = S.document.createElement("canvas");
    Q.width = K, Q.height = 1;
    const q = Q.getContext("2d");
    for (let te = 0, X = K - 1; te < K; ++te)
      q.fillStyle = ee(te / X), q.fillRect(te, 0, 1, 1);
    C.append("image").attr("opacity", b).attr("x", l).attr("y", a).attr("width", i - l - s).attr("height", o - a - u).attr("preserveAspectRatio", "none").attr("xlink:href", Q.toDataURL());
  } else if (j === "threshold") {
    const ee = $, K = p === void 0 ? (Q) => Q : typeof p == "string" ? hN(p) : p;
    O = R(BF().domain([-1, z.length - 1]), [l, i - s]), C.append("g").attr("fill-opacity", b).selectAll().data(z).enter().append("rect").attr("x", (Q, q) => O(q - 1)).attr("y", a).attr("width", (Q, q) => O(q) - O(q - 1)).attr("height", o - a - u).attr("fill", (Q) => Q), h = jo(ee, (Q, q) => q), p = (Q) => K(ee[Q], Q);
  } else
    O = R(zF().domain($), [l, i - s]), C.append("g").attr("fill-opacity", b).selectAll().data($).enter().append("rect").attr("x", O).attr("y", a).attr("width", Math.max(0, O.bandwidth() - 1)).attr("height", o - a - u).attr("fill", Y), A = () => {
    };
  return C.append("g").attr("transform", `translate(0,${o - u})`).call(
    hit(O).ticks(Array.isArray(h) ? null : h, typeof p == "string" ? p : void 0).tickFormat(typeof p == "function" ? p : void 0).tickSize(r).tickValues(Array.isArray(h) ? h : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", ja(g, "normal")).call(A).call((ee) => ee.select(".domain").remove()), n !== void 0 && C.append("text").attr("x", l).attr("y", a - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(n), C.node();
}
const KL = Math.PI / 180;
function yN(e, { marker: t, markerStart: n = t, markerMid: r = t, markerEnd: i = t } = {}) {
  e.markerStart = zH(n), e.markerMid = zH(r), e.markerEnd = zH(i);
}
function zH(e) {
  if (e == null || e === !1)
    return null;
  if (e === !0)
    return Vhe;
  if (typeof e == "function")
    return e;
  switch (`${e}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return Hhe("auto");
    case "arrow-reverse":
      return Hhe("auto-start-reverse");
    case "dot":
      return lgt;
    case "circle":
    case "circle-fill":
      return Vhe;
    case "circle-stroke":
      return cgt;
  }
  throw new Error(`invalid marker: ${e}`);
}
function Hhe(e) {
  return (t, n) => Yi("svg:marker", n).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", e).attr("fill", "none").attr("stroke", t).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((r) => r.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function lgt(e, t) {
  return Yi("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "none").call((n) => n.append("circle").attr("r", 2.5)).node();
}
function Vhe(e, t) {
  return Yi("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "white").attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
}
function cgt(e, t) {
  return Yi("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", e).attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
}
let fgt = 0;
function W$(e, t, { stroke: n }, r) {
  return BMe(e, t, n && ((i) => n[i]), r);
}
function dgt(e, t, { stroke: n }, r) {
  return BMe(e, t, n && (([i]) => n[i]), r);
}
function BMe(e, { markerStart: t, markerMid: n, markerEnd: r, stroke: i }, o = () => i, a) {
  const s = /* @__PURE__ */ new Map();
  function u(l) {
    return function(f) {
      const h = o(f);
      let p = s.get(l);
      p || s.set(l, p = /* @__PURE__ */ new Map());
      let g = p.get(h);
      if (!g) {
        const y = this.parentNode.insertBefore(l(h, a), this), b = `plot-marker-${++fgt}`;
        y.setAttribute("id", b), p.set(h, g = `url(#${b})`);
      }
      return g;
    };
  }
  t && e.attr("marker-start", u(t)), n && e.attr("marker-mid", u(n)), r && e.attr("marker-end", u(r));
}
function q$({ inset: e, insetLeft: t, insetRight: n, ...r } = {}) {
  return [t, n] = UMe(e, t, n), { inset: e, insetLeft: t, insetRight: n, ...r };
}
function G$({ inset: e, insetTop: t, insetBottom: n, ...r } = {}) {
  return [t, n] = UMe(e, t, n), { inset: e, insetTop: t, insetBottom: n, ...r };
}
function UMe(e, t, n) {
  return e === void 0 && t === void 0 && n === void 0 ? Ju ? [1, 0] : [0.5, 0.5] : [t, n];
}
function YMe(e, { interval: t }) {
  return e = { ...B$(e) }, e.interval = zZ(e.interval === void 0 ? t : e.interval), e;
}
function s6(e, t, n, r) {
  const { [e]: i, [`${e}1`]: o, [`${e}2`]: a } = n, { value: s, interval: u } = YMe(i, n);
  if (s == null || u == null && !r)
    return n;
  const l = Eb(i);
  if (u == null) {
    let g;
    const y = { transform: (b) => g || (g = Qr(b, s)), label: l };
    return {
      ...n,
      [e]: void 0,
      [`${e}1`]: o === void 0 ? y : o,
      [`${e}2`]: a === void 0 ? y : a
    };
  }
  let f, h;
  function p(g) {
    return h !== void 0 && g === f ? h : h = jo(Qr(f = g, s), (y) => u.floor(y));
  }
  return t({
    ...n,
    [e]: void 0,
    [`${e}1`]: o === void 0 ? { transform: p, label: l } : o,
    [`${e}2`]: a === void 0 ? { transform: (g) => p(g).map((y) => u.offset(y)), label: l } : a
  });
}
function HMe(e, t, n) {
  const { [e]: r } = n, { value: i, interval: o } = YMe(r, n);
  return i == null || o == null ? n : t({
    ...n,
    [e]: {
      label: Eb(r),
      transform: (a) => {
        const s = jo(Qr(a, i), (l) => o.floor(l)), u = s.map((l) => o.offset(l));
        return s.map(
          mp(s) ? (l, f) => l == null || isNaN(l = +l) || (f = u[f], f == null) || isNaN(f = +f) ? void 0 : new Date((l + f) / 2) : (l, f) => l == null || (f = u[f], f == null) ? NaN : (+l + +f) / 2
        );
      }
    }
  });
}
function VMe(e = {}) {
  return s6("x", q$, e, !0);
}
function WMe(e = {}) {
  return s6("y", G$, e, !0);
}
function qMe(e = {}) {
  return s6("x", q$, e);
}
function GMe(e = {}) {
  return s6("y", G$, e);
}
function QMe(e = {}) {
  return HMe("x", q$, e);
}
function XMe(e = {}) {
  return HMe("y", G$, e);
}
const KMe = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
class ZMe extends Co {
  constructor(t, n = {}) {
    const { x: r, y1: i, y2: o, inset: a = 0, insetTop: s = a, insetBottom: u = a } = n;
    super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y1: { value: i, scale: "y", optional: !0 },
        y2: { value: o, scale: "y", optional: !0 }
      },
      mN(n, "x"),
      KMe
    ), this.insetTop = ti(s), this.insetBottom = ti(u), yN(this, n);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y1: l, y2: f } = r, { width: h, height: p, marginTop: g, marginRight: y, marginLeft: b, marginBottom: _ } = i, { insetTop: S, insetBottom: C } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a }, Ju, 0).call(
      (A) => A.selectAll().data(t).enter().append("line").call(Xo, this).attr("x1", u ? (O) => u[O] : (b + h - y) / 2).attr("x2", u ? (O) => u[O] : (b + h - y) / 2).attr("y1", l && !ep(s) ? (O) => l[O] + S : g + S).attr(
        "y2",
        f && !ep(s) ? s.bandwidth ? (O) => f[O] + s.bandwidth() - C : (O) => f[O] - C : p - _ - C
      ).call(Qs, this, r).call(W$, this, r, o)
    ).node();
  }
}
class JMe extends Co {
  constructor(t, n = {}) {
    const { x1: r, x2: i, y: o, inset: a = 0, insetRight: s = a, insetLeft: u = a } = n;
    super(
      t,
      {
        y: { value: o, scale: "y", optional: !0 },
        x1: { value: r, scale: "x", optional: !0 },
        x2: { value: i, scale: "x", optional: !0 }
      },
      mN(n, "y"),
      KMe
    ), this.insetRight = ti(s), this.insetLeft = ti(u), yN(this, n);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { y: u, x1: l, x2: f } = r, { width: h, height: p, marginTop: g, marginRight: y, marginLeft: b, marginBottom: _ } = i, { insetLeft: S, insetRight: C } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { y: u && s }, 0, Ju).call(
      (A) => A.selectAll().data(t).enter().append("line").call(Xo, this).attr("x1", l && !ep(a) ? (O) => l[O] + S : b + S).attr(
        "x2",
        f && !ep(a) ? a.bandwidth ? (O) => f[O] + a.bandwidth() - C : (O) => f[O] - C : h - y - C
      ).attr("y1", u ? (O) => u[O] : (g + p - _) / 2).attr("y2", u ? (O) => u[O] : (g + p - _) / 2).call(Qs, this, r).call(W$, this, r, o)
    ).node();
  }
}
function ow(e, t) {
  let { x: n = Wn, y: r, y1: i, y2: o, ...a } = GMe(t);
  return [i, o] = eTe(r, i, o), new ZMe(e, { ...a, x: n, y1: i, y2: o });
}
function aw(e, t) {
  let { y: n = Wn, x: r, x1: i, x2: o, ...a } = qMe(t);
  return [i, o] = eTe(r, i, o), new JMe(e, { ...a, y: n, x1: i, x2: o });
}
function eTe(e, t, n) {
  if (e == null) {
    if (t === void 0) {
      if (n !== void 0)
        return [0, n];
    } else if (n === void 0)
      return [0, t];
  } else {
    if (t === void 0)
      return n === void 0 ? [0, e] : [e, n];
    if (n === void 0)
      return [e, t];
  }
  return [t, n];
}
function u6(e, ...t) {
  let n = t.length;
  for (let r = 0, i = !0; r < n; ++r)
    typeof t[r] != "function" && (i && (e = e.slice(), i = !1), e.splice(r, 2, e[r] + t[r] + e[r + 1]), t.splice(r, 1), --r, --n);
  return (r) => {
    let i = e[0];
    for (let o = 0; o < n; ++o)
      i += t[o](r) + e[o + 1];
    return i;
  };
}
const hgt = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
}, tTe = "­";
class l6 extends Co {
  constructor(t, n = {}) {
    const {
      x: r,
      y: i,
      text: o = rv(t) && Z2e(t) ? Wn : zf,
      frameAnchor: a,
      textAnchor: s = /right$/i.test(a) ? "end" : /left$/i.test(a) ? "start" : "middle",
      lineAnchor: u = /^top/i.test(a) ? "top" : /^bottom/i.test(a) ? "bottom" : "middle",
      lineHeight: l = 1,
      lineWidth: f = 1 / 0,
      textOverflow: h,
      monospace: p,
      fontFamily: g = p ? "ui-monospace, monospace" : void 0,
      fontSize: y,
      fontStyle: b,
      fontVariant: _,
      fontWeight: S,
      rotate: C
    } = n, [A, O] = ns(C, 0), [R, j] = ygt(y);
    if (super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        fontSize: { value: R, optional: !0 },
        rotate: { value: sht(A), optional: !0 },
        text: { value: o, filter: RZ, optional: !0 }
      },
      n,
      hgt
    ), this.rotate = O, this.textAnchor = ja(s, "middle"), this.lineAnchor = Sp(u, "lineAnchor", ["top", "middle", "bottom"]), this.lineHeight = +l, this.lineWidth = +f, this.textOverflow = nTe(h), this.monospace = !!p, this.fontFamily = Ll(g), this.fontSize = j, this.fontStyle = Ll(b), this.fontVariant = Ll(_), this.fontWeight = Ll(S), this.frameAnchor = Y$(a), !(this.lineWidth >= 0))
      throw new Error(`invalid lineWidth: ${f}`);
    this.splitLines = aTe(this), this.clipLine = sTe(this);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, rotate: f, text: h, title: p, fontSize: g } = r, { rotate: y } = this, [b, _] = ov(this, i);
    return Yi("svg:g", o).call(sa, this, i, o).call(oTe, this, h, i).call(To, this, { x: u && a, y: l && s }).call(
      (S) => S.selectAll().data(t).enter().append("text").call(Xo, this).call(pgt, this, h, p).attr(
        "transform",
        u6`translate(${u ? (C) => u[C] : b},${l ? (C) => l[C] : _})${f ? (C) => ` rotate(${f[C]})` : y ? ` rotate(${y})` : ""}`
      ).call(Fn, "font-size", g && ((C) => g[C])).call(Qs, this, r)
    ).node();
  }
}
function nTe(e) {
  return e == null ? null : Sp(e, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    // … ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function pgt(e, t, n, r) {
  if (!n)
    return;
  const { lineAnchor: i, lineHeight: o, textOverflow: a, splitLines: s, clipLine: u } = t;
  e.each(function(l) {
    const f = s(J0(n[l]) ?? "").map(u), h = f.length, p = i === "top" ? 0.71 : i === "bottom" ? 1 - h : (164 - h * 100) / 200;
    if (h > 1) {
      let g = 0;
      for (let y = 0; y < h; ++y) {
        if (++g, !f[y])
          continue;
        const b = this.ownerDocument.createElementNS(SS.svg, "tspan");
        b.setAttribute("x", 0), y === g - 1 ? b.setAttribute("y", `${(p + y) * o}em`) : b.setAttribute("dy", `${g * o}em`), b.textContent = f[y], this.appendChild(b), g = 0;
      }
    } else
      p && this.setAttribute("y", `${p * o}em`), this.textContent = f[0];
    if (a && !r && f[0] !== n[l]) {
      const g = this.ownerDocument.createElementNS(SS.svg, "title");
      g.textContent = n[l], this.appendChild(g);
    }
  });
}
function xC(e, { x: t, y: n, ...r } = {}) {
  return r.frameAnchor === void 0 && ([t, n] = em(t, n)), new l6(e, { ...r, x: t, y: n });
}
function rTe(e, { x: t = Wn, ...n } = {}) {
  return new l6(e, XMe({ ...n, x: t }));
}
function iTe(e, { y: t = Wn, ...n } = {}) {
  return new l6(e, QMe({ ...n, y: t }));
}
function oTe(e, t, n) {
  Fn(e, "text-anchor", t.textAnchor), Fn(e, "font-family", t.fontFamily), Fn(e, "font-size", t.fontSize), Fn(e, "font-style", t.fontStyle), Fn(e, "font-variant", t.fontVariant === void 0 ? ggt(n) : t.fontVariant), Fn(e, "font-weight", t.fontWeight);
}
function ggt(e) {
  return e && (pT(e) || mp(e)) ? "tabular-nums" : void 0;
}
const mgt = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function ygt(e) {
  return e == null || typeof e == "number" ? [void 0, e] : typeof e != "string" ? [e, void 0] : (e = e.trim().toLowerCase(), mgt.has(e) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(e) ? [void 0, e] : [e, void 0]);
}
function vgt(e, t, n) {
  const r = [];
  let i, o = 0;
  for (const [a, s, u] of bgt(e)) {
    if (i === void 0 && (i = a), o > i && n(e, i, s) > t && (r.push(e.slice(i, o) + (e[o - 1] === tTe ? "-" : "")), i = a), u) {
      r.push(e.slice(i, s)), i = void 0;
      continue;
    }
    o = s;
  }
  return r;
}
function* bgt(e) {
  let t = 0, n = 0;
  const r = e.length;
  for (; n < r; ) {
    let i = 1;
    switch (e[n]) {
      case tTe:
      case "-":
        ++n, yield [t, n, !1], t = n;
        break;
      case " ":
        for (yield [t, n, !1]; e[++n] === " "; )
          ;
        t = n;
        break;
      case "\r":
        e[n + 1] === `
` && ++i;
      case `
`:
        yield [t, n, !0], n += i, t = n;
        break;
      default:
        ++n;
        break;
    }
  }
  yield [t, n, !0];
}
const Whe = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "‘": 31,
  "’": 31,
  "“": 47,
  "”": 47,
  "…": 82
};
function mJ(e, t = 0, n = e.length) {
  let r = 0;
  for (let i = t; i < n; i = vN(e, i))
    r += Whe[e[i]] ?? (lTe(e, i) ? 120 : Whe.e);
  return r;
}
function yJ(e, t = 0, n = e.length) {
  let r = 0;
  for (let i = t; i < n; i = vN(e, i))
    r += lTe(e, i) ? 200 : 100;
  return r;
}
function aTe({ monospace: e, lineWidth: t, textOverflow: n }) {
  if (n != null || t == 1 / 0)
    return (o) => o.split(/\r\n?|\n/g);
  const r = e ? yJ : mJ, i = t * 100;
  return (o) => vgt(o, i, r);
}
function sTe({ monospace: e, lineWidth: t, textOverflow: n }) {
  if (n == null || t == 1 / 0)
    return (o) => o;
  const r = e ? yJ : mJ, i = t * 100;
  switch (n) {
    case "clip-start":
      return (o) => Ghe(o, i, r, "");
    case "clip-end":
      return (o) => qhe(o, i, r, "");
    case "ellipsis-start":
      return (o) => Ghe(o, i, r, RT);
    case "ellipsis-middle":
      return (o) => xgt(o, i, r, RT);
    case "ellipsis-end":
      return (o) => qhe(o, i, r, RT);
  }
}
const RT = "…";
function wC(e, t, n, r) {
  const i = [];
  let o = 0;
  for (let a = 0, s = 0, u = e.length; a < u; a = s) {
    s = vN(e, a);
    const l = n(e, a, s);
    if (o + l > t) {
      for (o += r; o > t && a > 0; )
        s = a, a = i.pop(), o -= n(e, a, s);
      return [a, t - o];
    }
    o += l, i.push(a);
  }
  return [-1, 0];
}
function qhe(e, t, n, r) {
  e = e.trim();
  const i = n(r), [o] = wC(e, t, n, i);
  return o < 0 ? e : e.slice(0, o).trimEnd() + r;
}
function xgt(e, t, n, r) {
  e = e.trim();
  const i = n(e);
  if (i <= t)
    return e;
  const o = n(r) / 2, [a, s] = wC(e, t / 2, n, o), [u] = wC(e, i - t / 2 - s + o, n, -o);
  return u < 0 ? r : e.slice(0, a).trimEnd() + r + e.slice(vN(e, u)).trimStart();
}
function Ghe(e, t, n, r) {
  e = e.trim();
  const i = n(e);
  if (i <= t)
    return e;
  const o = n(r), [a] = wC(e, i - t + o, n, -o);
  return a < 0 ? r : r + e.slice(vN(e, a)).trimStart();
}
const gG = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy, Qhe = /\p{Extended_Pictographic}/uy;
function vN(e, t) {
  return t += wgt(e, t) ? 2 : 1, Egt(e, t) && (t = gG.lastIndex), _gt(e, t) ? vN(e, t + 1) : t;
}
function uTe(e, t) {
  return e.charCodeAt(t) < 128;
}
function wgt(e, t) {
  const n = e.charCodeAt(t);
  if (n >= 55296 && n < 56320) {
    const r = e.charCodeAt(t + 1);
    return r >= 56320 && r < 57344;
  }
  return !1;
}
function _gt(e, t) {
  return e.charCodeAt(t) === 8205;
}
function Egt(e, t) {
  return uTe(e, t) ? !1 : (gG.lastIndex = t, gG.test(e));
}
function lTe(e, t) {
  return uTe(e, t) ? !1 : (Qhe.lastIndex = t, Qhe.test(e));
}
const cTe = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
}, fTe = 3.5, Sgt = fTe * 5, dTe = {
  draw(e, t, n) {
    const r = t * n / Sgt;
    e.moveTo(0, 0), e.lineTo(0, -t), e.moveTo(-r, r - t), e.lineTo(0, -t), e.lineTo(r, r - t);
  }
}, hTe = {
  draw(e, t, n) {
    e.moveTo(-n, 0), e.lineTo(0, -t), e.lineTo(n, 0);
  }
}, Mgt = /* @__PURE__ */ new Map([
  ["arrow", dTe],
  ["spike", hTe]
]);
function Tgt(e) {
  return e && typeof e.draw == "function";
}
function Cgt(e) {
  if (Tgt(e))
    return e;
  const t = Mgt.get(`${e}`.toLowerCase());
  if (t)
    return t;
  throw new Error(`invalid shape: ${e}`);
}
class c6 extends Co {
  constructor(t, n = {}) {
    const { x: r, y: i, r: o = fTe, length: a, rotate: s, shape: u = dTe, anchor: l = "middle", frameAnchor: f } = n, [h, p] = ns(a, 12), [g, y] = ns(s, 0);
    super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        length: { value: h, scale: "length", optional: !0 },
        rotate: { value: g, optional: !0 }
      },
      n,
      cTe
    ), this.r = +o, this.length = p, this.rotate = y, this.shape = Cgt(u), this.anchor = Sp(l, "anchor", ["start", "middle", "end"]), this.frameAnchor = Y$(f);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, length: f, rotate: h } = r, { length: p, rotate: g, anchor: y, shape: b, r: _ } = this, [S, C] = ov(this, i);
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a, y: l && s }).call(
      (A) => A.selectAll().data(t).enter().append("path").call(Xo, this).attr(
        "transform",
        u6`translate(${u ? (O) => u[O] : S},${l ? (O) => l[O] : C})${h ? (O) => ` rotate(${h[O]})` : g ? ` rotate(${g})` : ""}${y === "start" ? "" : y === "end" ? f ? (O) => ` translate(0,${f[O]})` : ` translate(0,${p})` : f ? (O) => ` translate(0,${f[O] / 2})` : ` translate(0,${p / 2})`}`
      ).attr(
        "d",
        f ? (O) => {
          const R = H0();
          return b.draw(R, f[O], _), R;
        } : (() => {
          const O = H0();
          return b.draw(O, p, _), O;
        })()
      ).call(Qs, this, r)
    ).node();
  }
}
function pTe(e, t = {}) {
  let { x: n, y: r, ...i } = t;
  return t.frameAnchor === void 0 && ([n, r] = em(n, r)), new c6(e, { ...i, x: n, y: r });
}
function gTe(e, t = {}) {
  const { x: n = Wn, ...r } = t;
  return new c6(e, { ...r, x: n });
}
function mTe(e, t = {}) {
  const { y: n = Wn, ...r } = t;
  return new c6(e, { ...r, y: n });
}
function Ngt(e, t = {}) {
  const {
    shape: n = hTe,
    stroke: r = cTe.stroke,
    strokeWidth: i = 1,
    fill: o = r,
    fillOpacity: a = 0.3,
    anchor: s = "start",
    ...u
  } = t;
  return pTe(e, { ...u, shape: n, stroke: r, strokeWidth: i, fill: o, fillOpacity: a, anchor: s });
}
function kw(e, t) {
  return arguments.length < 2 && !rv(e) && (t = e, e = null), t === void 0 && (t = {}), [e, t];
}
function f6({ anchor: e } = {}, t) {
  return e === void 0 ? t[0] : Sp(e, "anchor", t);
}
function yTe(e) {
  return f6(e, ["left", "right"]);
}
function vTe(e) {
  return f6(e, ["right", "left"]);
}
function bTe(e) {
  return f6(e, ["bottom", "top"]);
}
function xTe(e) {
  return f6(e, ["top", "bottom"]);
}
function vJ() {
  const [e, t] = kw(...arguments);
  return ETe("y", yTe(t), e, t);
}
function wTe() {
  const [e, t] = kw(...arguments);
  return ETe("fy", vTe(t), e, t);
}
function bJ() {
  const [e, t] = kw(...arguments);
  return STe("x", bTe(t), e, t);
}
function _Te() {
  const [e, t] = kw(...arguments);
  return STe("fx", xTe(t), e, t);
}
function ETe(e, t, n, {
  color: r = "currentColor",
  opacity: i = 1,
  stroke: o = r,
  strokeOpacity: a = i,
  strokeWidth: s = 1,
  fill: u = r,
  fillOpacity: l = i,
  textAnchor: f,
  textStroke: h,
  textStrokeOpacity: p,
  textStrokeWidth: g,
  tickSize: y = e === "y" ? 6 : 0,
  tickPadding: b,
  tickRotate: _,
  x: S,
  margin: C,
  marginTop: A = C === void 0 ? 20 : C,
  marginRight: O = C === void 0 ? t === "right" ? 40 : 0 : C,
  marginBottom: R = C === void 0 ? 20 : C,
  marginLeft: j = C === void 0 ? t === "left" ? 40 : 0 : C,
  label: $,
  labelAnchor: z,
  labelArrow: W,
  labelOffset: Y,
  ...V
}) {
  return y = ti(y), b = ti(b), _ = ti(_), z !== void 0 && (z = Sp(z, "labelAnchor", ["center", "top", "bottom"])), W = ITe(W), Vg(
    y && !Ba(o) ? Dgt(e, t, n, {
      stroke: o,
      strokeOpacity: a,
      strokeWidth: s,
      tickSize: y,
      tickPadding: b,
      tickRotate: _,
      x: S,
      ...V
    }) : null,
    Ba(u) ? null : Ogt(e, t, n, {
      fill: u,
      fillOpacity: l,
      stroke: h,
      strokeOpacity: p,
      strokeWidth: g,
      textAnchor: f,
      tickSize: y,
      tickPadding: b,
      tickRotate: _,
      x: S,
      marginTop: A,
      marginRight: O,
      marginBottom: R,
      marginLeft: j,
      ...V
    }),
    !Ba(u) && $ !== null ? xC(
      [],
      RTe({ fill: u, fillOpacity: l, ...V }, function(ee, K, Q, q, te) {
        const X = q[e], { marginTop: Z, marginRight: se, marginBottom: H, marginLeft: ie } = e === "y" && te.inset || te, he = z ?? (X.bandwidth ? "center" : "top"), ye = Y ?? (t === "right" ? se : ie) - 3;
        return he === "center" ? (this.textAnchor = void 0, this.lineAnchor = t === "right" ? "bottom" : "top", this.frameAnchor = t, this.rotate = -90) : (this.textAnchor = t === "right" ? "end" : "start", this.lineAnchor = he, this.frameAnchor = `${he}-${t}`, this.rotate = 0), this.dy = he === "top" ? 3 - Z : he === "bottom" ? H - 3 : 0, this.dx = t === "right" ? ye : -ye, this.ariaLabel = `${e}-axis label`, {
          facets: [[0]],
          channels: { text: { value: [PTe(e, X, { anchor: t, label: $, labelAnchor: he, labelArrow: W })] } }
        };
      })
    ) : null
  );
}
function STe(e, t, n, {
  color: r = "currentColor",
  opacity: i = 1,
  stroke: o = r,
  strokeOpacity: a = i,
  strokeWidth: s = 1,
  fill: u = r,
  fillOpacity: l = i,
  textAnchor: f,
  textStroke: h,
  textStrokeOpacity: p,
  textStrokeWidth: g,
  tickSize: y = e === "x" ? 6 : 0,
  tickPadding: b,
  tickRotate: _,
  y: S,
  margin: C,
  marginTop: A = C === void 0 ? t === "top" ? 30 : 0 : C,
  marginRight: O = C === void 0 ? 20 : C,
  marginBottom: R = C === void 0 ? t === "bottom" ? 30 : 0 : C,
  marginLeft: j = C === void 0 ? 20 : C,
  label: $,
  labelAnchor: z,
  labelArrow: W,
  labelOffset: Y,
  ...V
}) {
  return y = ti(y), b = ti(b), _ = ti(_), z !== void 0 && (z = Sp(z, "labelAnchor", ["center", "left", "right"])), W = ITe(W), Vg(
    y && !Ba(o) ? Agt(e, t, n, {
      stroke: o,
      strokeOpacity: a,
      strokeWidth: s,
      tickSize: y,
      tickPadding: b,
      tickRotate: _,
      y: S,
      ...V
    }) : null,
    Ba(u) ? null : Rgt(e, t, n, {
      fill: u,
      fillOpacity: l,
      stroke: h,
      strokeOpacity: p,
      strokeWidth: g,
      textAnchor: f,
      tickSize: y,
      tickPadding: b,
      tickRotate: _,
      y: S,
      marginTop: A,
      marginRight: O,
      marginBottom: R,
      marginLeft: j,
      ...V
    }),
    !Ba(u) && $ !== null ? xC(
      [],
      RTe({ fill: u, fillOpacity: l, ...V }, function(ee, K, Q, q, te) {
        const X = q[e], { marginTop: Z, marginRight: se, marginBottom: H, marginLeft: ie } = e === "x" && te.inset || te, he = z ?? (X.bandwidth ? "center" : "right"), ye = Y ?? (t === "top" ? Z : H) - 3;
        return he === "center" ? (this.frameAnchor = t, this.textAnchor = void 0) : (this.frameAnchor = `${t}-${he}`, this.textAnchor = he === "right" ? "end" : "start"), this.lineAnchor = t, this.dy = t === "top" ? -ye : ye, this.dx = he === "right" ? se - 3 : he === "left" ? 3 - ie : 0, this.ariaLabel = `${e}-axis label`, {
          facets: [[0]],
          channels: { text: { value: [PTe(e, X, { anchor: t, label: $, labelAnchor: he, labelArrow: W })] } }
        };
      })
    ) : null
  );
}
function Dgt(e, t, n, {
  strokeWidth: r = 1,
  strokeLinecap: i = null,
  strokeLinejoin: o = null,
  facetAnchor: a = t + (e === "y" ? "-empty" : ""),
  frameAnchor: s = t,
  tickSize: u,
  inset: l = 0,
  insetLeft: f = l,
  insetRight: h = l,
  dx: p = 0,
  y: g = e === "y" ? void 0 : null,
  ...y
}) {
  return bN(mTe, e, `${e}-axis tick`, n, {
    strokeWidth: r,
    strokeLinecap: i,
    strokeLinejoin: o,
    facetAnchor: a,
    frameAnchor: s,
    y: g,
    ...y,
    dx: t === "left" ? +p - Ju + +f : +p + Ju - h,
    anchor: "start",
    length: u,
    shape: t === "left" ? Pgt : Igt
  });
}
function Agt(e, t, n, {
  strokeWidth: r = 1,
  strokeLinecap: i = null,
  strokeLinejoin: o = null,
  facetAnchor: a = t + (e === "x" ? "-empty" : ""),
  frameAnchor: s = t,
  tickSize: u,
  inset: l = 0,
  insetTop: f = l,
  insetBottom: h = l,
  dy: p = 0,
  x: g = e === "x" ? void 0 : null,
  ...y
}) {
  return bN(gTe, e, `${e}-axis tick`, n, {
    strokeWidth: r,
    strokeLinejoin: o,
    strokeLinecap: i,
    facetAnchor: a,
    frameAnchor: s,
    x: g,
    ...y,
    dy: t === "bottom" ? +p - Ju - h : +p + Ju + +f,
    anchor: "start",
    length: u,
    shape: t === "bottom" ? kgt : $gt
  });
}
function Ogt(e, t, n, {
  facetAnchor: r = t + (e === "y" ? "-empty" : ""),
  frameAnchor: i = t,
  tickSize: o,
  tickRotate: a = 0,
  tickPadding: s = Math.max(3, 9 - o) + (Math.abs(a) > 60 ? 4 * Math.cos(a * KL) : 0),
  tickFormat: u,
  text: l = typeof u == "function" ? u : void 0,
  textAnchor: f = Math.abs(a) > 60 ? "middle" : t === "left" ? "end" : "start",
  lineAnchor: h = a > 60 ? "top" : a < -60 ? "bottom" : "middle",
  fontVariant: p,
  inset: g = 0,
  insetLeft: y = g,
  insetRight: b = g,
  dx: _ = 0,
  y: S = e === "y" ? void 0 : null,
  ...C
}) {
  return bN(
    iTe,
    e,
    `${e}-axis tick label`,
    n,
    {
      facetAnchor: r,
      frameAnchor: i,
      text: l === void 0 ? null : l,
      textAnchor: f,
      lineAnchor: h,
      fontVariant: p,
      rotate: a,
      y: S,
      ...C,
      dx: t === "left" ? +_ - o - s + +y : +_ + +o + +s - b
    },
    function(A, O, R, j) {
      p === void 0 && (this.fontVariant = $Te(A)), l === void 0 && (j.text = kTe(A, O, R, u, t));
    }
  );
}
function Rgt(e, t, n, {
  facetAnchor: r = t + (e === "x" ? "-empty" : ""),
  frameAnchor: i = t,
  tickSize: o,
  tickRotate: a = 0,
  tickPadding: s = Math.max(3, 9 - o) + (Math.abs(a) >= 10 ? 4 * Math.cos(a * KL) : 0),
  tickFormat: u,
  text: l = typeof u == "function" ? u : void 0,
  textAnchor: f = Math.abs(a) >= 10 ? a < 0 ^ t === "bottom" ? "start" : "end" : "middle",
  lineAnchor: h = Math.abs(a) >= 10 ? "middle" : t === "bottom" ? "top" : "bottom",
  fontVariant: p,
  inset: g = 0,
  insetTop: y = g,
  insetBottom: b = g,
  dy: _ = 0,
  x: S = e === "x" ? void 0 : null,
  ...C
}) {
  return bN(
    rTe,
    e,
    `${e}-axis tick label`,
    n,
    {
      facetAnchor: r,
      frameAnchor: i,
      text: l === void 0 ? null : l,
      textAnchor: f,
      lineAnchor: h,
      fontVariant: p,
      rotate: a,
      x: S,
      ...C,
      dy: t === "bottom" ? +_ + +o + +s - b : +_ - o - s + +y
    },
    function(A, O, R, j) {
      p === void 0 && (this.fontVariant = $Te(A)), l === void 0 && (j.text = kTe(A, O, R, u, t));
    }
  );
}
function MTe() {
  const [e, t] = kw(...arguments);
  return DTe("y", yTe(t), e, t);
}
function TTe() {
  const [e, t] = kw(...arguments);
  return DTe("fy", vTe(t), e, t);
}
function CTe() {
  const [e, t] = kw(...arguments);
  return ATe("x", bTe(t), e, t);
}
function NTe() {
  const [e, t] = kw(...arguments);
  return ATe("fx", xTe(t), e, t);
}
function DTe(e, t, n, {
  y: r = e === "y" ? void 0 : null,
  x: i = null,
  x1: o = t === "left" ? i : null,
  x2: a = t === "right" ? i : null,
  ...s
}) {
  return bN(aw, e, `${e}-grid`, n, { y: r, x1: o, x2: a, ...OTe(s) });
}
function ATe(e, t, n, {
  x: r = e === "x" ? void 0 : null,
  y: i = null,
  y1: o = t === "top" ? i : null,
  y2: a = t === "bottom" ? i : null,
  ...s
}) {
  return bN(ow, e, `${e}-grid`, n, { x: r, y1: o, y2: a, ...OTe(s) });
}
function OTe({
  color: e = "currentColor",
  opacity: t = 0.1,
  stroke: n = e,
  strokeOpacity: r = t,
  strokeWidth: i = 1,
  ...o
}) {
  return { stroke: n, strokeOpacity: r, strokeWidth: i, ...o };
}
function RTe({
  fill: e,
  fillOpacity: t,
  fontFamily: n,
  fontSize: r,
  fontStyle: i,
  fontWeight: o,
  monospace: a,
  pointerEvents: s,
  shapeRendering: u,
  clip: l = !1
}, f) {
  return [, e] = Df(e), [, t] = ns(t), {
    facet: "super",
    x: null,
    y: null,
    fill: e,
    fillOpacity: t,
    fontFamily: n,
    fontSize: r,
    fontStyle: i,
    fontWeight: o,
    monospace: a,
    pointerEvents: s,
    shapeRendering: u,
    clip: l,
    initializer: f
  };
}
function bN(e, t, n, r, i, o) {
  let a;
  function s(f, h, p, g, y, b) {
    const _ = f == null && (t === "fx" || t === "fy"), { [t]: S } = g;
    if (!S)
      throw new Error(`missing scale: ${t}`);
    let { ticks: C, tickSpacing: A, interval: O } = i;
    if (cJ(S) && typeof C == "string" && (O = C, C = void 0), f == null) {
      if (rv(C))
        f = Af(C);
      else if (S.ticks)
        if (C !== void 0)
          f = S.ticks(C);
        else if (O = gN(O === void 0 ? S.interval : O, S.type), O !== void 0) {
          const [j, $] = Zu(S.domain());
          f = O.range(j, O.offset(O.floor($)));
        } else {
          const [j, $] = Zu(S.range());
          C = ($ - j) / (A === void 0 ? t === "x" ? 80 : 35 : A), f = S.ticks(C);
        }
      else
        f = S.domain();
      t === "y" || t === "x" ? h = [_b(f)] : a[t] = { scale: t, value: Wn };
    }
    o == null || o.call(this, S, f, C, a);
    const R = Object.fromEntries(
      Object.entries(a).map(([j, $]) => [j, { ...$, value: Qr(f, $.value) }])
    );
    return _ && (h = b.filterFacets(f, R)), { data: f, facets: h, channels: R };
  }
  const u = Of(i).initializer, l = e(r, Of({ ...i, initializer: s }, u));
  return r == null ? (a = l.channels, l.channels = {}) : a = {}, l.ariaLabel = n, l.clip === void 0 && (l.clip = !1), l;
}
function kTe(e, t, n, r, i) {
  return { value: ZL(e, t, n, r, i) };
}
function ZL(e, t, n, r, i) {
  return r === void 0 && cJ(e) ? Jdt(e, t, n, i) : e.tickFormat ? e.tickFormat(rv(n) ? null : n, r) : r === void 0 ? Kdt(e.interval) ? mC("%Y") : Zdt(e.interval) ? z$("%Y") : J0 : typeof r == "string" ? (mp(e.domain()) ? mC : hN)(r) : Bd(r);
}
const kgt = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(0, t);
  }
}, $gt = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(0, -t);
  }
}, Pgt = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(-t, 0);
  }
}, Igt = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(t, 0);
  }
};
function $Te(e) {
  return e.bandwidth && !e.interval ? void 0 : "tabular-nums";
}
function jgt(e) {
  return Math.sign(bC(e.domain())) * Math.sign(bC(e.range()));
}
function PTe(e, t, { anchor: n, label: r = t.label, labelAnchor: i, labelArrow: o } = {}) {
  if (!(r == null || r.inferred && Lgt(t) && /^(date|time|year)$/i.test(r))) {
    if (r = String(r), o === "auto" && (o = (!t.bandwidth || t.interval) && !/[↑↓→←]/.test(r)), !o)
      return r;
    if (o === !0) {
      const a = jgt(t);
      a && (o = /x$/.test(e) || i === "center" ? /x$/.test(e) === a < 0 ? "left" : "right" : a < 0 ? "up" : "down");
    }
    switch (o) {
      case "left":
        return `← ${r}`;
      case "right":
        return `${r} →`;
      case "up":
        return n === "right" ? `${r} ↑` : `↑ ${r}`;
      case "down":
        return n === "right" ? `${r} ↓` : `↓ ${r}`;
    }
    return r;
  }
}
function ITe(e = "auto") {
  return Ba(e) ? !1 : typeof e == "boolean" ? e : Sp(e, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function Lgt(e) {
  return cJ(e) || e.interval != null;
}
function Xhe(e, t) {
  if (t == null)
    return t;
  const n = e(t);
  if (!n)
    throw new Error(`scale not found: ${t}`);
  return n;
}
function zgt(e, { opacity: t, ...n } = {}) {
  if (!r2(e) && !PMe(e))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${e.type})`);
  return jTe(
    e,
    n,
    (r, i, o, a) => r.append("svg").attr("width", o).attr("height", a).attr("fill", i.scale).attr("fill-opacity", ns(t)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function Fgt(e, {
  fill: t = ((l) => (l = e.hint) == null ? void 0 : l.fill)() !== void 0 ? e.hint.fill : "none",
  fillOpacity: n = 1,
  stroke: r = ((f) => (f = e.hint) == null ? void 0 : f.stroke)() !== void 0 ? e.hint.stroke : Ba(t) ? "currentColor" : "none",
  strokeOpacity: i = 1,
  strokeWidth: o = 1.5,
  r: a = 4.5,
  ...s
} = {}, u) {
  const [h, p] = Df(t), [g, y] = Df(r), b = Xhe(u, h), _ = Xhe(u, g), S = a * a * Math.PI;
  return n = ns(n)[1], i = ns(i)[1], o = ns(o)[1], jTe(
    e,
    s,
    (C, A, O, R) => C.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", O).attr("height", R).attr("fill", h === "color" ? (j) => b.scale(j) : p).attr("fill-opacity", n).attr("stroke", g === "color" ? (j) => _.scale(j) : y).attr("stroke-opacity", i).attr("stroke-width", o).append("path").attr("d", (j) => {
      const $ = H0();
      return e.scale(j).draw($, S), $;
    })
  );
}
function jTe(e, t = {}, n) {
  let {
    columns: r,
    tickFormat: i,
    fontVariant: o = FMe(e),
    // TODO label,
    swatchSize: a = 15,
    swatchWidth: s = a,
    swatchHeight: u = a,
    marginLeft: l = 0,
    className: f,
    style: h,
    width: p
  } = t;
  const g = n6(t);
  f = iJ(f), typeof i != "function" && (i = ZL(e.scale, e.domain, void 0, i));
  const y = Yi("div", g).attr(
    "class",
    `${f}-swatches ${f}-swatches-${r != null ? "columns" : "wrap"}`
  );
  let b;
  return r != null ? (b = `.${f}-swatches-columns .${f}-swatch {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
.${f}-swatches-columns .${f}-swatch::before {
  flex-shrink: 0;
}
.${f}-swatches-columns .${f}-swatch-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`, y.style("columns", r).selectAll().data(e.domain).enter().append("div").attr("class", `${f}-swatch`).call(n, e, s, u).call(
    (_) => _.append("div").attr("class", `${f}-swatch-label`).attr("title", i).text(i)
  )) : (b = `.${f}-swatches-wrap {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
.${f}-swatches-wrap .${f}-swatch {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`, y.selectAll().data(e.domain).enter().append("span").attr("class", `${f}-swatch`).call(n, e, s, u).append(function() {
    return this.ownerDocument.createTextNode(i.apply(this, arguments));
  })), y.call(
    (_) => _.insert("style", "*").text(
      `.${f}-swatches {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
.${f}-swatch > svg {
  margin-right: 0.5em;
  overflow: visible;
}
${b}`
    )
  ).style("margin-left", l ? `${+l}px` : null).style("width", p === void 0 ? null : `${+p}px`).style("font-variant", ja(o, "normal")).call(oJ, h).node();
}
const JL = /* @__PURE__ */ new Map([
  ["symbol", Fgt],
  ["color", LTe],
  ["opacity", Ygt]
]);
function Bgt(e = {}) {
  for (const [t, n] of JL) {
    const r = e[t];
    if (tS(r)) {
      const i = n6(e);
      let o;
      if (t === "symbol") {
        const { fill: a, stroke: s = a === void 0 && tS(e.color) ? "color" : void 0 } = e;
        o = { fill: a, stroke: s };
      }
      return n(
        hG(t, r, o),
        xJ(i, r, e),
        (a) => tS(e[a]) ? hG(a, e[a]) : null
      );
    }
  }
  throw new Error("unknown legend type; no scale found");
}
function Ugt(e, t, n = {}) {
  return (r, i) => {
    if (!JL.has(r))
      throw new Error(`unknown legend type: ${r}`);
    if (r in e)
      return JL.get(r)(e[r], xJ(t, n[r], i), (o) => e[o]);
  };
}
function xJ({ className: e, ...t }, { label: n, ticks: r, tickFormat: i } = {}, o) {
  return hht(o, { className: e, ...t }, { label: n, ticks: r, tickFormat: i });
}
function LTe(e, { legend: t = !0, ...n }) {
  if (t === !0 && (t = e.type === "ordinal" ? "swatches" : "ramp"), e.domain !== void 0)
    switch (`${t}`.toLowerCase()) {
      case "swatches":
        return zgt(e, n);
      case "ramp":
        return ugt(e, n);
      default:
        throw new Error(`unknown legend type: ${t}`);
    }
}
function Ygt({ type: e, interpolate: t, ...n }, { legend: r = !0, color: i = Cf(0, 0, 0), ...o }) {
  if (!t)
    throw new Error(`${e} opacity scales are not supported`);
  if (r === !0 && (r = "ramp"), `${r}`.toLowerCase() !== "ramp")
    throw new Error(`${r} opacity legends are not supported`);
  return LTe({ type: e, ...n, interpolate: Hgt(i) }, { legend: r, ...o });
}
function Hgt(e) {
  const { r: t, g: n, b: r } = Cf(e) || Cf(0, 0, 0);
  return (i) => `rgba(${t},${n},${r},${i})`;
}
function Vgt(e, t, n) {
  const r = [];
  for (const [i, o] of JL) {
    const a = n[i];
    if (a != null && a.legend && i in e) {
      const s = o(e[i], xJ(t, e[i], a), (u) => e[u]);
      s != null && r.push(s);
    }
  }
  return r;
}
const Wgt = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor",
  clip: !1
}, qgt = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square",
  clip: !1
};
class zTe extends Co {
  constructor(t = {}) {
    const {
      anchor: n = null,
      inset: r = 0,
      insetTop: i = r,
      insetRight: o = r,
      insetBottom: a = r,
      insetLeft: s = r,
      rx: u,
      ry: l
    } = t;
    super(RR, void 0, t, n == null ? Wgt : qgt), this.anchor = IZ(n, "anchor", ["top", "right", "bottom", "left"]), this.insetTop = ti(i), this.insetRight = ti(o), this.insetBottom = ti(a), this.insetLeft = ti(s), this.rx = ti(u), this.ry = ti(l);
  }
  render(t, n, r, i, o) {
    const { marginTop: a, marginRight: s, marginBottom: u, marginLeft: l, width: f, height: h } = i, { anchor: p, insetTop: g, insetRight: y, insetBottom: b, insetLeft: _, rx: S, ry: C } = this, A = l + _, O = f - s - y, R = a + g, j = h - u - b;
    return Yi(p ? "svg:line" : "svg:rect", o).datum(0).call(sa, this, i, o).call(Xo, this).call(Qs, this, r).call(To, this, {}).call(
      p === "left" ? ($) => $.attr("x1", A).attr("x2", A).attr("y1", R).attr("y2", j) : p === "right" ? ($) => $.attr("x1", O).attr("x2", O).attr("y1", R).attr("y2", j) : p === "top" ? ($) => $.attr("x1", A).attr("x2", O).attr("y1", R).attr("y2", R) : p === "bottom" ? ($) => $.attr("x1", A).attr("x2", O).attr("y1", j).attr("y2", j) : ($) => $.attr("x", A).attr("y", R).attr("width", O - A).attr("height", j - R).attr("rx", S).attr("ry", C)
    ).node();
  }
}
function wJ(e) {
  return new zTe(e);
}
const FH = {
  ariaLabel: "tip",
  fill: "white",
  stroke: "currentColor"
}, Ggt = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel"]);
class FTe extends Co {
  constructor(t, n = {}) {
    n.tip && (n = { ...n, tip: !1 }), n.title === void 0 && rv(t) && Z2e(t) && (n = { ...n, title: Wn });
    const {
      x: r,
      y: i,
      x1: o,
      x2: a,
      y1: s,
      y2: u,
      anchor: l,
      monospace: f,
      fontFamily: h = f ? "ui-monospace, monospace" : void 0,
      fontSize: p,
      fontStyle: g,
      fontVariant: y,
      fontWeight: b,
      lineHeight: _ = 1,
      lineWidth: S = 20,
      frameAnchor: C,
      textAnchor: A = "start",
      textOverflow: O,
      textPadding: R = 8,
      title: j,
      pointerSize: $ = 12,
      pathFilter: z = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = n;
    super(
      t,
      {
        x: { value: o != null && a != null ? null : r, scale: "x", optional: !0 },
        // ignore midpoint
        y: { value: s != null && u != null ? null : i, scale: "y", optional: !0 },
        // ignore midpoint
        x1: { value: o, scale: "x", optional: a == null },
        y1: { value: s, scale: "y", optional: u == null },
        x2: { value: a, scale: "x", optional: o == null },
        y2: { value: u, scale: "y", optional: s == null },
        title: { value: j, optional: !0 }
        // filter: defined
      },
      n,
      FH
    ), this.anchor = J2e(l, "anchor"), this.previousAnchor = this.anchor ?? "top-left", this.frameAnchor = Y$(C), this.textAnchor = ja(A, "middle"), this.textPadding = +R, this.pointerSize = +$, this.pathFilter = Ll(z), this.lineHeight = +_, this.lineWidth = +S, this.textOverflow = nTe(O), this.monospace = !!f, this.fontFamily = Ll(h), this.fontSize = ti(p), this.fontStyle = Ll(g), this.fontVariant = Ll(y), this.fontWeight = Ll(b);
    for (const W in FH)
      W in this.channels && (this[W] = FH[W]);
    this.splitLines = aTe(this), this.clipLine = sTe(this);
  }
  render(t, n, r, i, o) {
    const a = this, { x: s, y: u, fx: l, fy: f } = n, { ownerSVGElement: h, document: p } = o, { anchor: g, monospace: y, lineHeight: b, lineWidth: _ } = this, { textPadding: S, pointerSize: C, pathFilter: A } = this, { marginTop: O, marginLeft: R } = i, j = Zgt(r), { x1: $, y1: z, x2: W, y2: Y, x: V = $ ?? W, y: ee = z ?? Y } = r, K = l ? l(t.fx) - R : 0, Q = f ? f(t.fy) - O : 0, [q, te] = ov(this, i), X = LMe(r, q), Z = zMe(r, te), se = y ? yJ : mJ, H = se(RT), ie = l && ZL(l), he = f && ZL(f);
    function* ye(ke, Me) {
      if ("title" in ke) {
        const we = ke.title.value[Me];
        for (const Ye of a.splitLines(J0(we)))
          yield { name: "", value: a.clipLine(Ye) };
        return;
      }
      for (const we in ke) {
        if (we === "x1" && "x2" in ke || we === "y1" && "y2" in ke)
          continue;
        const Ye = ke[we], ze = Ye.value[Me];
        if (!(!Dc(ze) && Ye.scale == null))
          if (we === "x2" && "x1" in ke)
            yield { name: Zhe(n, ke.x1, Ye, "x"), value: Khe(ke.x1, Ye, Me) };
          else if (we === "y2" && "y1" in ke)
            yield { name: Zhe(n, ke.y1, Ye, "y"), value: Khe(ke.y1, Ye, Me) };
          else {
            const fe = Ye.scale, Qe = { name: mG(n, Ye, we), value: J0(ze) };
            (fe === "color" || fe === "opacity") && (Qe[fe] = r[we][Me]), yield Qe;
          }
      }
      t.fi != null && l && (yield { name: String(l.label ?? "fx"), value: ie(t.fx) }), t.fi != null && f && (yield { name: String(f.label ?? "fy"), value: he(t.fy) });
    }
    const _e = Yi("svg:g", o).call(sa, this, i, o).call(oTe, this).call(To, this, { x: V && s, y: ee && u }).call(
      (ke) => ke.selectAll().data(t).enter().append("g").attr("transform", (Me) => `translate(${Math.round(X(Me))},${Math.round(Z(Me))})`).call(Xo, this).call((Me) => Me.append("path").attr("filter", A)).call(
        (Me) => Me.append("text").each(function(we) {
          const Ye = Ix(this);
          this.setAttribute("fill", "currentColor"), this.setAttribute("fill-opacity", 1), this.setAttribute("stroke", "none");
          const ze = /* @__PURE__ */ new Set();
          for (const fe of ye(j, we)) {
            const Qe = fe.name;
            Qe && ze.has(Qe) || (ze.add(Qe), Ne(Ye, fe));
          }
        })
      )
    );
    function Ne(ke, { name: Me, value: we, color: Ye, opacity: ze }) {
      const fe = Ye != null || ze != null;
      let Qe, $e = _ * 100;
      const [pt] = wC(Me, $e, se, H);
      if (pt >= 0)
        Me = Me.slice(0, pt).trimEnd() + RT, Qe = we.trim(), we = "";
      else {
        (Me || !we && !fe) && (we = " " + we);
        const [Ot] = wC(we, $e - se(Me), se, H);
        Ot >= 0 && (we = we.slice(0, Ot).trimEnd() + RT, Qe = we.trim());
      }
      const _t = ke.append("tspan").attr("x", 0).attr("dy", `${b}em`).text("​");
      Me && _t.append("tspan").attr("font-weight", "bold").text(Me), we && _t.append(() => p.createTextNode(we)), fe && _t.append("tspan").text(" ■").attr("fill", Ye).attr("fill-opacity", ze).style("user-select", "none"), Qe && _t.append("title").text(Qe);
    }
    function Oe() {
      const { width: ke, height: Me } = i.facet ?? i;
      _e.selectChildren().each(function(we) {
        let { x: Ye, width: ze, height: fe } = this.getBBox();
        ze = Math.round(ze), fe = Math.round(fe);
        let Qe = g;
        if (Qe === void 0) {
          Qe = a.previousAnchor;
          const _t = X(we) + K, Ot = Z(we) + Q, mn = _t + ze + S * 2 < ke, jr = _t - ze - S * 2 > 0, tn = Ot + fe + C + S * 2 + 7 < Me, Zt = Ot - fe - C - S * 2 > 0, qn = (/-left$/.test(Qe) ? mn || !jr : mn && !jr) ? "left" : "right", fn = (/^top-/.test(Qe) ? tn || !Zt : tn && !Zt) ? "top" : "bottom";
          Qe = a.previousAnchor = `${fn}-${qn}`;
        }
        const $e = this.firstChild, pt = this.lastChild;
        if ($e.setAttribute("d", Kgt(Qe, C, S, ze, fe)), Ye)
          for (const _t of pt.childNodes)
            _t.setAttribute("x", -Ye);
        pt.setAttribute("y", `${+Qgt(Qe, pt.childNodes.length, b).toFixed(6)}em`), pt.setAttribute("transform", `translate(${Xgt(Qe, C, S, ze, fe)})`);
      });
    }
    return h.isConnected ? Promise.resolve().then(Oe) : typeof requestAnimationFrame < "u" && requestAnimationFrame(Oe), _e.node();
  }
}
function BTe(e, { x: t, y: n, ...r } = {}) {
  return r.frameAnchor === void 0 && ([t, n] = em(t, n)), new FTe(e, { ...r, x: t, y: n });
}
function Qgt(e, t, n) {
  return /^top(?:-|$)/.test(e) ? 0.94 - n : -0.29 - t * n;
}
function Xgt(e, t, n, r, i) {
  switch (e) {
    case "middle":
      return [-r / 2, i / 2];
    case "top-left":
      return [n, t + n];
    case "top":
      return [-r / 2, t / 2 + n];
    case "top-right":
      return [-r - n, t + n];
    case "right":
      return [-t / 2 - r - n, i / 2];
    case "bottom-left":
      return [n, -t - n];
    case "bottom":
      return [-r / 2, -t / 2 - n];
    case "bottom-right":
      return [-r - n, -t - n];
    case "left":
      return [n + t / 2, i / 2];
  }
}
function Kgt(e, t, n, r, i) {
  const o = r + n * 2, a = i + n * 2;
  switch (e) {
    case "middle":
      return `M${-o / 2},${-a / 2}h${o}v${a}h${-o}z`;
    case "top-left":
      return `M0,0l${t},${t}h${o - t}v${a}h${-o}z`;
    case "top":
      return `M0,0l${t / 2},${t / 2}h${(o - t) / 2}v${a}h${-o}v${-a}h${(o - t) / 2}z`;
    case "top-right":
      return `M0,0l${-t},${t}h${t - o}v${a}h${o}z`;
    case "right":
      return `M0,0l${-t / 2},${-t / 2}v${t / 2 - a / 2}h${-o}v${a}h${o}v${t / 2 - a / 2}z`;
    case "bottom-left":
      return `M0,0l${t},${-t}h${o - t}v${-a}h${-o}z`;
    case "bottom":
      return `M0,0l${t / 2},${-t / 2}h${(o - t) / 2}v${-a}h${-o}v${a}h${(o - t) / 2}z`;
    case "bottom-right":
      return `M0,0l${-t},${-t}h${t - o}v${-a}h${o}z`;
    case "left":
      return `M0,0l${t / 2},${-t / 2}v${t / 2 - a / 2}h${o}v${a}h${-o}v${t / 2 - a / 2}z`;
  }
}
function Zgt({ channels: e }) {
  const t = {};
  for (const n in e) {
    if (Ggt.has(n))
      continue;
    const r = cMe(e, n);
    r && (t[n] = r);
  }
  return t;
}
function Khe(e, t, n) {
  var r;
  return (r = t.hint) != null && r.length ? `${J0(t.value[n] - e.value[n])}` : `${J0(e.value[n])}–${J0(t.value[n])}`;
}
function Zhe(e, t, n, r) {
  const i = mG(e, t, r), o = mG(e, n, r);
  return i === o ? i : `${i}–${o}`;
}
function mG(e, t, n) {
  var r;
  return String(((r = e[t.scale]) == null ? void 0 : r.label) ?? (t == null ? void 0 : t.label) ?? n);
}
function _J(e = {}) {
  var se;
  const { facet: t, style: n, title: r, subtitle: i, caption: o, ariaLabel: a, ariaDescription: s } = e, u = iJ(e.className), l = e.marks === void 0 ? [] : epe(e.marks);
  l.push(...amt(l));
  const f = imt(t, e), h = /* @__PURE__ */ new Map();
  for (const H of l) {
    const ie = tpe(H, f, e);
    ie && h.set(H, ie);
  }
  const p = /* @__PURE__ */ new Map();
  f && ZA(p, [f], e), ZA(p, h, e);
  const g = epe(smt(l, p, e));
  for (const H of g) {
    const ie = tpe(H, f, e);
    ie && h.set(H, ie);
  }
  l.unshift(...g);
  let y = Gpt(p, e);
  if (y !== void 0) {
    const H = f ? LH(y, f) : void 0;
    for (const he of l) {
      if (he.facet === null || he.facet === "super")
        continue;
      const ye = h.get(he);
      ye !== void 0 && (ye.facetsIndex = he.fx != null || he.fy != null ? LH(y, ye) : H);
    }
    const ie = /* @__PURE__ */ new Set();
    for (const { facetsIndex: he } of h.values())
      he == null || he.forEach((ye, _e) => {
        (ye == null ? void 0 : ye.length) > 0 && ie.add(_e);
      });
    y.forEach(
      0 < ie.size && ie.size < y.length ? (he, ye) => he.empty = !ie.has(ye) : (he) => he.empty = !1
    );
    for (const he of l)
      if (he.facet === "exclude") {
        const ye = h.get(he);
        ye !== void 0 && (ye.facetsIndex = Kpt(ye.facetsIndex));
      }
  }
  for (const H of ba.keys())
    tS(e[H]) && H !== "fx" && H !== "fy" && p.set(H, []);
  const b = /* @__PURE__ */ new Map();
  for (const H of l) {
    if (b.has(H))
      throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex: ie, channels: he } = h.get(H) ?? {}, { data: ye, facets: _e, channels: Ne } = H.initialize(ie, he, e);
    EJ(Ne, e), b.set(H, { data: ye, facets: _e, channels: Ne });
  }
  const _ = dG(ZA(p, b, e), e), S = jhe(_), C = Wpt(_, l, e);
  Lpt(_, C);
  const { fx: A, fy: O } = S, R = A || O ? OMe(_, C) : C, j = A || O ? pmt(S, C) : C, $ = n6(e), z = $.document, W = NF("svg").call(z.documentElement);
  let Y = W;
  $.ownerSVGElement = W, $.className = u, $.projection = Zht(e, R), $.filterFacets = (H, ie) => LH(y, { channels: ie, groups: fJ(H, ie) }), $.getMarkState = (H) => {
    const ie = b.get(H), he = h.get(H);
    return { ...ie, channels: { ...ie.channels, ...he == null ? void 0 : he.channels } };
  }, $.dispatchValue = (H) => {
    Y.value !== H && (Y.value = H, Y.dispatchEvent(new Event("input", { bubbles: !0 })));
  };
  const V = /* @__PURE__ */ new Set();
  for (const [H, ie] of b)
    if (H.initializer != null) {
      const he = H.facet === "super" ? j : R, ye = H.initializer(ie.data, ie.facets, ie.channels, S, he, $);
      if (ye.data !== void 0 && (ie.data = ye.data), ye.facets !== void 0 && (ie.facets = ye.facets), ye.channels !== void 0) {
        const { fx: _e, fy: Ne, ...Oe } = ye.channels;
        rmt(Oe), Object.assign(ie.channels, Oe);
        for (const ke of Object.values(Oe)) {
          const { scale: Me } = ke;
          Me != null && !ght(ba.get(Me)) && (UTe(ke, e), V.add(Me));
        }
        (_e != null || Ne != null) && h.set(H, !0);
      }
    }
  if (V.size) {
    const H = /* @__PURE__ */ new Map();
    ZA(H, b, e, (ye) => V.has(ye)), ZA(p, b, e, (ye) => V.has(ye));
    const ie = hmt(dG(H, e), _), he = jhe(ie);
    Object.assign(_, ie), Object.assign(S, he);
  }
  let ee, K;
  y !== void 0 && (ee = { x: A == null ? void 0 : A.domain(), y: O == null ? void 0 : O.domain() }, y = Qpt(y, ee), K = Xpt(A, O, C));
  for (const [H, ie] of b)
    ie.values = H.scale(ie.channels, S, $);
  const { width: Q, height: q } = C;
  Ix(W).attr("class", u).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", Q).attr("height", q).attr("viewBox", `0 0 ${Q} ${q}`).attr("aria-label", a).attr("aria-description", s).call(
    (H) => (
      // Warning: if you edit this, change defaultClassName.
      H.append("style").text(
        `.${u} {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
.${u} text,
.${u} tspan {
  white-space: pre;
}`
      )
    )
  ).call(oJ, n);
  for (const H of l) {
    const { channels: ie, values: he, facets: ye } = b.get(H);
    if (y === void 0 || H.facet === "super") {
      let _e = null;
      if (ye && (_e = ye[0], _e = H.filter(_e, ie, he), _e.length === 0))
        continue;
      const Ne = H.render(_e, S, he, j, $);
      if (Ne == null)
        continue;
      W.appendChild(Ne);
    } else {
      let _e;
      for (const Ne of y) {
        if (!(((se = H.facetAnchor) == null ? void 0 : se.call(H, y, ee, Ne)) ?? !Ne.empty))
          continue;
        let Oe = null;
        if (ye) {
          const Me = h.has(H);
          if (Oe = ye[Me ? Ne.i : 0], Oe = H.filter(Oe, ie, he), Oe.length === 0)
            continue;
          !Me && Oe === ye[0] && (Oe = nS(Oe)), Oe.fx = Ne.x, Oe.fy = Ne.y, Oe.fi = Ne.i;
        }
        const ke = H.render(Oe, S, he, R, $);
        if (ke != null) {
          (_e ?? (_e = Ix(W).append("g"))).append(() => ke).datum(Ne);
          for (const Me of ["aria-label", "aria-description", "aria-hidden", "transform"])
            ke.hasAttribute(Me) && (_e.attr(Me, ke.getAttribute(Me)), ke.removeAttribute(Me));
        }
      }
      _e == null || _e.selectChildren().attr("transform", K);
    }
  }
  const te = Vgt(_, $, e), { figure: X = r != null || i != null || o != null || te.length > 0 } = e;
  X && (Y = z.createElement("figure"), Y.className = `${u}-figure`, Y.style.maxWidth = "initial", r != null && Y.append(Jhe(z, r, "h2")), i != null && Y.append(Jhe(z, i, "h3")), Y.append(...te, W), o != null && Y.append(Jgt(z, o))), Y.scale = Vpt(_), Y.legend = Ugt(_, $, e);
  const Z = Uht();
  return Z > 0 && Ix(W).append("text").attr("x", Q).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("⚠️").append("title").text(`${Z.toLocaleString("en-US")} warning${Z === 1 ? "" : "s"}. Please check the console.`), Y;
}
function Jhe(e, t, n) {
  if (t.ownerDocument)
    return t;
  const r = e.createElement(n);
  return r.append(e.createTextNode(t)), r;
}
function Jgt(e, t) {
  const n = e.createElement("figcaption");
  return n.append(t.ownerDocument ? t : e.createTextNode(t)), n;
}
function emt({ marks: e = [], ...t } = {}) {
  return _J({ ...t, marks: [...e, this] });
}
Co.prototype.plot = emt;
function epe(e) {
  return e.flat(1 / 0).filter((t) => t != null).map(tmt);
}
function tmt(e) {
  return typeof e.render == "function" ? e : new nmt(e);
}
let nmt = class extends Co {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("invalid mark; missing render function");
    super(), this.render = t;
  }
  render() {
  }
};
function EJ(e, t) {
  for (const n in e)
    UTe(e[n], t);
  return e;
}
function UTe(e, t) {
  const { scale: n, transform: r = !0 } = e;
  if (n == null || !r)
    return;
  const {
    type: i,
    percent: o,
    interval: a,
    transform: s = o ? (u) => u * 100 : K2e(a, i)
  } = t[n] ?? {};
  s != null && (e.value = jo(e.value, s), e.transform = !1);
}
function rmt(e) {
  for (const t in e)
    sMe(t, e[t]);
}
function ZA(e, t, n, r = rht) {
  var i, o;
  for (const { channels: a } of t.values())
    for (const s in a) {
      const u = a[s], { scale: l } = u;
      if (l != null && r(l))
        if (l === "projection") {
          if (!tpt(n)) {
            const f = ((i = n.x) == null ? void 0 : i.domain) === void 0, h = ((o = n.y) == null ? void 0 : o.domain) === void 0;
            if (f || h) {
              const [p, g] = rpt(u);
              f && BH(e, "x", p), h && BH(e, "y", g);
            }
          }
        } else
          BH(e, l, u);
    }
  return e;
}
function BH(e, t, n) {
  const r = e.get(t);
  r !== void 0 ? r.push(n) : e.set(t, [n]);
}
function imt(e, t) {
  if (e == null)
    return;
  const { x: n, y: r } = e;
  if (n == null && r == null)
    return;
  const i = Af(e.data);
  if (i == null)
    throw new Error("missing facet data");
  const o = {};
  n != null && (o.fx = Lk(i, { value: n, scale: "fx" })), r != null && (o.fy = Lk(i, { value: r, scale: "fy" })), EJ(o, t);
  const a = fJ(i, o);
  return { channels: o, groups: a, data: e.data };
}
function tpe(e, t, n) {
  var u;
  if (e.facet === null || e.facet === "super")
    return;
  const { fx: r, fy: i } = e;
  if (r != null || i != null) {
    const l = Af(e.data ?? r ?? i);
    if (l === void 0)
      throw new Error(`missing facet data in ${e.ariaLabel}`);
    if (l === null)
      return;
    const f = {};
    return r != null && (f.fx = Lk(l, { value: r, scale: "fx" })), i != null && (f.fy = Lk(l, { value: i, scale: "fy" })), EJ(f, n), { channels: f, groups: fJ(l, f) };
  }
  if (t === void 0)
    return;
  const { channels: o, groups: a, data: s } = t;
  if (e.facet !== "auto" || e.data === s)
    return { channels: o, groups: a };
  s.length > 0 && (a.size > 1 || a.size === 1 && o.fx && o.fy && [...a][0][1].size > 1) && ((u = Af(e.data)) == null ? void 0 : u.length) === s.length && Lx(
    `Warning: the ${e.ariaLabel} mark appears to use faceted data, but isn’t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
  );
}
function omt(e, t = {}) {
  return Of({ ...t, x: null, y: null }, (n, r, i, o, a, s) => s.getMarkState(e));
}
function amt(e) {
  const t = [];
  for (const n of e) {
    const r = n.tip;
    if (r) {
      const o = (r === "x" ? pJ : r === "y" ? gJ : hJ)(omt(n));
      o.title = null, t.push(BTe(n.data, o));
    }
  }
  return t;
}
function smt(e, t, n) {
  let {
    projection: r,
    x: i = {},
    y: o = {},
    fx: a = {},
    fy: s = {},
    axis: u,
    grid: l,
    facet: f = {},
    facet: { axis: h = u, grid: p } = f,
    x: { axis: g = u, grid: y = g === null ? null : l } = i,
    y: { axis: b = u, grid: _ = b === null ? null : l } = o,
    fx: { axis: S = h, grid: C = S === null ? null : p } = a,
    fy: { axis: A = h, grid: O = A === null ? null : p } = s
  } = n;
  (r || !tS(i) && !npe("x", e)) && (g = y = null), (r || !tS(o) && !npe("y", e)) && (b = _ = null), t.has("fx") || (S = C = null), t.has("fy") || (A = O = null), g === void 0 && (g = !l3(e, "x")), b === void 0 && (b = !l3(e, "y")), S === void 0 && (S = !l3(e, "fx")), A === void 0 && (A = !l3(e, "fy")), g === !0 && (g = "bottom"), b === !0 && (b = "left"), S === !0 && (S = g === "top" || g === null ? "bottom" : "top"), A === !0 && (A = b === "right" || b === null ? "left" : "right");
  const R = [];
  return u3(R, O, TTe, s), s3(R, A, wTe, "right", "left", f, s), u3(R, C, NTe, a), s3(R, S, _Te, "top", "bottom", f, a), u3(R, _, MTe, o), s3(R, b, vJ, "left", "right", n, o), u3(R, y, CTe, i), s3(R, g, bJ, "bottom", "top", n, i), R;
}
function s3(e, t, n, r, i, o, a) {
  if (!t)
    return;
  const s = umt(t);
  a = lmt(s ? r : t, o, a);
  const { line: u } = a;
  (n === vJ || n === bJ) && u && !vC(u) && e.push(wJ(cmt(a))), e.push(n(a)), s && e.push(n({ ...a, anchor: i, label: null }));
}
function u3(e, t, n, r) {
  !t || vC(t) || e.push(n(fmt(t, r)));
}
function umt(e) {
  return /^\s*both\s*$/i.test(e);
}
function lmt(e, t, {
  line: n = t.line,
  ticks: r,
  tickSize: i,
  tickSpacing: o,
  tickPadding: a,
  tickFormat: s,
  tickRotate: u,
  fontVariant: l,
  ariaLabel: f,
  ariaDescription: h,
  label: p = t.label,
  labelAnchor: g,
  labelArrow: y = t.labelArrow,
  labelOffset: b
}) {
  return {
    anchor: e,
    line: n,
    ticks: r,
    tickSize: i,
    tickSpacing: o,
    tickPadding: a,
    tickFormat: s,
    tickRotate: u,
    fontVariant: l,
    ariaLabel: f,
    ariaDescription: h,
    label: p,
    labelAnchor: g,
    labelArrow: y,
    labelOffset: b
  };
}
function cmt(e) {
  const { anchor: t, line: n } = e;
  return { anchor: t, facetAnchor: t + "-empty", stroke: n === !0 ? void 0 : n };
}
function fmt(e, {
  stroke: t = U$(e) ? e : void 0,
  ticks: n = dmt(e) ? e : void 0,
  tickSpacing: r,
  ariaLabel: i,
  ariaDescription: o
}) {
  return {
    stroke: t,
    ticks: n,
    tickSpacing: r,
    ariaLabel: i,
    ariaDescription: o
  };
}
function dmt(e) {
  switch (typeof e) {
    case "number":
      return !0;
    case "string":
      return !U$(e);
  }
  return rv(e) || typeof (e == null ? void 0 : e.range) == "function";
}
function l3(e, t) {
  const n = `${t}-axis `;
  return e.some((r) => {
    var i;
    return (i = r.ariaLabel) == null ? void 0 : i.startsWith(n);
  });
}
function npe(e, t) {
  for (const n of t)
    for (const r in n.channels) {
      const { scale: i } = n.channels[r];
      if (i === e || i === "projection")
        return !0;
    }
  return !1;
}
function hmt(e, t) {
  for (const n in e) {
    const r = e[n], i = t[n];
    r.label === void 0 && i && (r.label = i.label);
  }
  return e;
}
function pmt({ fx: e, fy: t }, n) {
  const { marginTop: r, marginRight: i, marginBottom: o, marginLeft: a, width: s, height: u } = lJ(n), l = e && rpe(e), f = t && rpe(t);
  return {
    marginTop: t ? f[0] : r,
    marginRight: e ? s - l[1] : i,
    marginBottom: t ? u - f[1] : o,
    marginLeft: e ? l[0] : a,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: n.marginTop,
      marginRight: n.marginRight,
      marginBottom: n.marginBottom,
      marginLeft: n.marginLeft
    },
    width: s,
    height: u
  };
}
function rpe(e) {
  const t = e.domain();
  let n = e(t[0]), r = e(t[t.length - 1]);
  return r < n && ([n, r] = [r, n]), [n, r + e.bandwidth()];
}
const gmt = /* @__PURE__ */ new Map([
  ["basis", Awe],
  ["basis-closed", Rwe],
  ["basis-open", $we],
  ["bundle", Iwe],
  ["bump-x", mrt],
  ["bump-y", yrt],
  ["cardinal", jwe],
  ["cardinal-closed", Lwe],
  ["cardinal-open", zwe],
  ["catmull-rom", Bwe],
  ["catmull-rom-closed", Ywe],
  ["catmull-rom-open", Vwe],
  ["linear", sN],
  ["linear-closed", qwe],
  ["monotone-x", Xwe],
  ["monotone-y", Kwe],
  ["natural", Jwe],
  ["step", e_e],
  ["step-after", n_e],
  ["step-before", t_e]
]);
function SJ(e = sN, t) {
  if (typeof e == "function")
    return e;
  const n = gmt.get(`${e}`.toLowerCase());
  if (!n)
    throw new Error(`unknown curve: ${e}`);
  if (t !== void 0) {
    if ("beta" in n)
      return n.beta(t);
    if ("tension" in n)
      return n.tension(t);
    if ("alpha" in n)
      return n.alpha(t);
  }
  return n;
}
function YTe(e = _C, t) {
  return typeof e != "function" && `${e}`.toLowerCase() === "auto" ? _C : SJ(e, t);
}
function _C(e) {
  return sN(e);
}
function bx(e = { y: "count" }, t = {}) {
  [e, t] = NJ(e, t);
  const { x: n, y: r } = t;
  return CJ(e5(n, t, Wn), null, null, r, e, q$(t));
}
function xx(e = { x: "count" }, t = {}) {
  [e, t] = NJ(e, t);
  const { x: n, y: r } = t;
  return CJ(null, e5(r, t, Wn), n, null, e, G$(t));
}
function $E(e = { fill: "count" }, t = {}) {
  [e, t] = NJ(e, t);
  const { x: n, y: r } = mmt(t);
  return CJ(n, r, null, null, e, q$(G$(t)));
}
function HTe(e, t, n = {}) {
  return (n == null ? void 0 : n.interval) == null ? n : e({ [t]: (n == null ? void 0 : n.reduce) === void 0 ? eJ : n.reduce, filter: null }, n);
}
function MJ(e = {}) {
  return HTe(bx, "y", mN(e, "x"));
}
function TJ(e = {}) {
  return HTe(xx, "x", mN(e, "y"));
}
function CJ(e, t, n, r, {
  data: i = JZ,
  // TODO avoid materializing when unused?
  filter: o = QL,
  // return only non-empty bins by default
  sort: a,
  reverse: s,
  ...u
  // output channel definitions
} = {}, l = {}) {
  e = ipe(e), t = ipe(t), u = ymt(u, l), i = GTe(i, Wn), a = a == null ? void 0 : WTe("sort", a, l), o = o == null ? void 0 : qTe("filter", o, l), n != null && Mx(u, "x", "x1", "x2") && (n = null), r != null && Mx(u, "y", "y1", "y2") && (r = null);
  const [f, h] = pf(e), [p, g] = pf(e), [y, b] = pf(t), [_, S] = pf(t), [C, A] = n != null ? [n, "x"] : r != null ? [r, "y"] : [], [O, R] = pf(C), {
    x: j,
    y: $,
    z,
    fill: W,
    stroke: Y,
    x1: V,
    x2: ee,
    // consumed if x is an output
    y1: K,
    y2: Q,
    // consumed if y is an output
    domain: q,
    cumulative: te,
    thresholds: X,
    interval: Z,
    ...se
  } = l, [H, ie] = pf(z), [he] = Df(W), [ye] = Df(Y), [_e, Ne] = pf(he), [Oe, ke] = pf(ye);
  return {
    ..."z" in l && { z: H || z },
    ..."fill" in l && { fill: _e || W },
    ..."stroke" in l && { stroke: Oe || Y },
    ...iv(se, (Me, we, Ye) => {
      const ze = GL(Qr(Me, C), Ye == null ? void 0 : Ye[A]), fe = Qr(Me, z), Qe = Qr(Me, he), $e = Qr(Me, ye), pt = ZZ(u, { z: fe, fill: Qe, stroke: $e }), _t = [], Ot = [], mn = ze && R([]), jr = fe && ie([]), tn = Qe && Ne([]), Zt = $e && ke([]), qn = e && h([]), fn = e && g([]), gr = t && b([]), Zn = t && S([]), xr = wmt(e == null ? void 0 : e(Me), t == null ? void 0 : t(Me));
      let Un = 0;
      for (const Qt of u)
        Qt.initialize(Me);
      a && a.initialize(Me), o && o.initialize(Me);
      for (const Qt of we) {
        const Ut = [];
        for (const er of u)
          er.scope("facet", Qt);
        a && a.scope("facet", Qt), o && o.scope("facet", Qt);
        for (const [er, We] of OT(Qt, pt))
          for (const [ht, Ft] of OT(We, ze))
            for (const [_n, Dn] of xr(Ft))
              if (!(o && !o.reduce(_n, Dn))) {
                Ut.push(Un++), Ot.push(i.reduceIndex(_n, Me, Dn)), ze && mn.push(ht), fe && jr.push(pt === fe ? er : fe[_n[0]]), Qe && tn.push(pt === Qe ? er : Qe[_n[0]]), $e && Zt.push(pt === $e ? er : $e[_n[0]]), qn && (qn.push(Dn.x1), fn.push(Dn.x2)), gr && (gr.push(Dn.y1), Zn.push(Dn.y2));
                for (const di of u)
                  di.reduce(_n, Dn);
                a && a.reduce(_n);
              }
        _t.push(Ut);
      }
      return oMe(_t, a, s), { data: Ot, facets: _t };
    }),
    ...!Mx(u, "x") && (f ? { x1: f, x2: p, x: qL(f, p) } : { x: j, x1: V, x2: ee }),
    ...!Mx(u, "y") && (y ? { y1: y, y2: _, y: qL(y, _) } : { y: $, y1: K, y2: Q }),
    ...O && { [A]: O },
    ...Object.fromEntries(u.map(({ name: Me, output: we }) => [Me, we]))
  };
}
function NJ({ cumulative: e, domain: t, thresholds: n, interval: r, ...i }, o) {
  return [i, { cumulative: e, domain: t, thresholds: n, interval: r, ...o }];
}
function e5(e, { cumulative: t, domain: n, thresholds: r, interval: i }, o) {
  return e = { ...B$(e) }, e.domain === void 0 && (e.domain = n), e.cumulative === void 0 && (e.cumulative = t), e.thresholds === void 0 && (e.thresholds = r), e.interval === void 0 && (e.interval = i), e.value === void 0 && (e.value = o), e.thresholds = VTe(e.thresholds, e.interval), e;
}
function mmt(e) {
  let { x: t, y: n } = e;
  return t = e5(t, e), n = e5(n, e), [t.value, n.value] = em(t.value, n.value), { x: t, y: n };
}
function ipe(e) {
  if (e == null)
    return;
  const { value: t, cumulative: n, domain: r = Zu, thresholds: i } = e, o = (a) => {
    let s = Qr(a, t), u;
    if (mp(s) || bmt(i)) {
      s = jo(s, W2e, Float64Array);
      let [f, h] = typeof r == "function" ? r(s) : r, p = typeof i == "function" && !zO(i) ? i(s, f, h) : i;
      typeof p == "number" && (p = ESe(f, h, p)), zO(p) && (r === Zu && (f = p.floor(f), h = p.offset(p.floor(h))), p = p.range(f, p.offset(h))), u = p;
    } else {
      s = xf(s);
      let [f, h] = typeof r == "function" ? r(s) : r, p = typeof i == "function" && !zO(i) ? i(s, f, h) : i;
      if (typeof p == "number")
        if (r === Zu) {
          let g = Mk(f, h, p);
          if (isFinite(g))
            if (g > 0) {
              let y = Math.round(f / g), b = Math.round(h / g);
              y * g <= f || --y, b * g > h || ++b;
              let _ = b - y + 1;
              p = new Float64Array(_);
              for (let S = 0; S < _; ++S)
                p[S] = (y + S) * g;
            } else if (g < 0) {
              g = -g;
              let y = Math.round(f * g), b = Math.round(h * g);
              y / g <= f || --y, b / g > h || ++b;
              let _ = b - y + 1;
              p = new Float64Array(_);
              for (let S = 0; S < _; ++S)
                p[S] = (y + S) / g;
            } else
              p = [f];
          else
            p = [f];
        } else
          p = Kx(f, h, p);
      else
        zO(p) && (r === Zu && (f = p.floor(f), h = p.offset(p.floor(h))), p = p.range(f, p.offset(h)));
      u = p;
    }
    const l = [];
    if (u.length === 1)
      l.push([u[0], u[0]]);
    else
      for (let f = 1; f < u.length; ++f)
        l.push([u[f - 1], u[f]]);
    return l.bin = (n < 0 ? Emt : n > 0 ? _mt : DJ)(l, u, s), l;
  };
  return o.label = Eb(t), o;
}
function VTe(e, t, n = ope) {
  if (e === void 0)
    return t === void 0 ? n : gN(t);
  if (typeof e == "string") {
    switch (e.toLowerCase()) {
      case "freedman-diaconis":
        return Zrt;
      case "scott":
        return g_e;
      case "sturges":
        return VK;
      case "auto":
        return ope;
    }
    return H2e(e);
  }
  return e;
}
function ymt(e, t) {
  return QZ(e, t, WTe);
}
function WTe(e, t, n) {
  return XZ(e, t, n, qTe);
}
function qTe(e, t, n) {
  return KZ(e, t, n, GTe);
}
function GTe(e, t) {
  return t6(e, t, vmt);
}
function vmt(e) {
  switch (`${e}`.toLowerCase()) {
    case "x":
      return Smt;
    case "x1":
      return Tmt;
    case "x2":
      return Cmt;
    case "y":
      return Mmt;
    case "y1":
      return Nmt;
    case "y2":
      return Dmt;
  }
  throw new Error(`invalid bin reduce: ${e}`);
}
function ope(e, t, n) {
  return Math.min(200, g_e(e, t, n));
}
function bmt(e) {
  return xmt(e) || rv(e) && mp(e);
}
function xmt(e) {
  return zO(e) && typeof e == "function" && e() instanceof Date;
}
function zO(e) {
  return typeof (e == null ? void 0 : e.range) == "function";
}
function wmt(e, t) {
  return e && t ? function* (n) {
    const r = e.bin(n);
    for (const [i, [o, a]] of e.entries()) {
      const s = t.bin(r[i]);
      for (const [u, [l, f]] of t.entries())
        yield [s[u], { x1: o, y1: l, x2: a, y2: f }];
    }
  } : e ? function* (n) {
    const r = e.bin(n);
    for (const [i, [o, a]] of e.entries())
      yield [r[i], { x1: o, x2: a }];
  } : function* (n) {
    const r = t.bin(n);
    for (const [i, [o, a]] of t.entries())
      yield [r[i], { y1: o, y2: a }];
  };
}
function DJ(e, t, n) {
  return t = xf(t), (r) => {
    var o;
    const i = e.map(() => []);
    for (const a of r)
      (o = i[uN(t, n[a]) - 1]) == null || o.push(a);
    return i;
  };
}
function _mt(e, t, n) {
  const r = DJ(e, t, n);
  return (i) => {
    const o = r(i);
    for (let a = 1, s = o.length; a < s; ++a) {
      const u = o[a - 1], l = o[a];
      for (const f of u)
        l.push(f);
    }
    return o;
  };
}
function Emt(e, t, n) {
  const r = DJ(e, t, n);
  return (i) => {
    const o = r(i);
    for (let a = o.length - 2; a >= 0; --a) {
      const s = o[a + 1], u = o[a];
      for (const l of s)
        u.push(l);
    }
    return o;
  };
}
function QTe(e, t) {
  const n = (+e + +t) / 2;
  return e instanceof Date ? new Date(n) : n;
}
const Smt = {
  reduceIndex(e, t, { x1: n, x2: r }) {
    return QTe(n, r);
  }
}, Mmt = {
  reduceIndex(e, t, { y1: n, y2: r }) {
    return QTe(n, r);
  }
}, Tmt = {
  reduceIndex(e, t, { x1: n }) {
    return n;
  }
}, Cmt = {
  reduceIndex(e, t, { x2: n }) {
    return n;
  }
}, Nmt = {
  reduceIndex(e, t, { y1: n }) {
    return n;
  }
}, Dmt = {
  reduceIndex(e, t, { y2: n }) {
    return n;
  }
};
function AJ(e = {}) {
  return q2e(e) ? e : { ...e, x: Wn };
}
function OJ(e = {}) {
  return G2e(e) ? e : { ...e, y: Wn };
}
function XTe(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = xN(e));
  const { y1: n, y: r = n, x: i, ...o } = t, [a, s, u, l] = wN(r, i, "y", "x", e, o);
  return { ...a, y1: n, y: s, x1: u, x2: l, x: qL(u, l) };
}
function Amt(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = xN(e));
  const { y1: n, y: r = n, x: i } = t, [o, a, s] = wN(r, i, "y", "x", e, t);
  return { ...o, y1: n, y: a, x: s };
}
function Omt(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = xN(e));
  const { y1: n, y: r = n, x: i } = t, [o, a, , s] = wN(r, i, "y", "x", e, t);
  return { ...o, y1: n, y: a, x: s };
}
function KTe(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = xN(e));
  const { x1: n, x: r = n, y: i, ...o } = t, [a, s, u, l] = wN(r, i, "x", "y", e, o);
  return { ...a, x1: n, x: s, y1: u, y2: l, y: qL(u, l) };
}
function Rmt(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = xN(e));
  const { x1: n, x: r = n, y: i } = t, [o, a, s] = wN(r, i, "x", "y", e, t);
  return { ...o, x1: n, x: a, y: s };
}
function kmt(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = xN(e));
  const { x1: n, x: r = n, y: i } = t, [o, a, , s] = wN(r, i, "x", "y", e, t);
  return { ...o, x1: n, x: a, y: s };
}
function RJ({ x: e, x1: t, x2: n, ...r } = {}) {
  return r = mN(r, "y"), t === void 0 && n === void 0 ? XTe({ x: e, ...r }) : ([t, n] = Q2e(e, t, n), { ...r, x1: t, x2: n });
}
function kJ({ y: e, y1: t, y2: n, ...r } = {}) {
  return r = mN(r, "x"), t === void 0 && n === void 0 ? KTe({ y: e, ...r }) : ([t, n] = Q2e(e, t, n), { ...r, y1: t, y2: n });
}
function xN(e) {
  const { offset: t, order: n, reverse: r, ...i } = e;
  return [{ offset: t, order: n, reverse: r }, i];
}
const $mt = { length: !0 };
function wN(e, t = kZ, n, r, { offset: i, order: o, reverse: a }, s) {
  if (t === null)
    throw new Error(`stack requires ${r}`);
  const u = Ow(s), [l, f] = pf(e), [h, p] = Cd(t), [g, y] = Cd(t);
  return h.hint = g.hint = $mt, i = Pmt(i), o = Lmt(o, i, r), [
    iv(s, (b, _, S) => {
      const C = e == null ? void 0 : f(GL(Qr(b, e), S == null ? void 0 : S[n])), A = Qr(b, t, Float64Array), O = Qr(b, u), R = o && o(b, C, A, O), j = b.length, $ = p(new Float64Array(j)), z = y(new Float64Array(j)), W = [];
      for (const Y of _) {
        const V = C ? Array.from(xb(Y, (ee) => C[ee]).values()) : [Y];
        if (R)
          for (const ee of V)
            ee.sort(R);
        for (const ee of V) {
          let K = 0, Q = 0;
          a && ee.reverse();
          for (const q of ee) {
            const te = A[q];
            te < 0 ? K = z[q] = ($[q] = K) + te : te > 0 ? Q = z[q] = ($[q] = Q) + te : z[q] = $[q] = Q;
          }
        }
        W.push(V);
      }
      return i && i(W, $, z, O), { data: b, facets: _ };
    }),
    l,
    h,
    g
  ];
}
function Pmt(e) {
  if (e != null) {
    if (typeof e == "function")
      return e;
    switch (`${e}`.toLowerCase()) {
      case "expand":
      case "normalize":
        return Imt;
      case "center":
      case "silhouette":
        return jmt;
      case "wiggle":
        return JTe;
    }
    throw new Error(`unknown offset: ${e}`);
  }
}
function ZTe(e, t) {
  let n = 0, r = 0;
  for (const i of e) {
    const o = t[i];
    o < n && (n = o), o > r && (r = o);
  }
  return [n, r];
}
function Imt(e, t, n) {
  for (const r of e)
    for (const i of r) {
      const [o, a] = ZTe(i, n);
      for (const s of i) {
        const u = 1 / (a - o || 1);
        t[s] = u * (t[s] - o), n[s] = u * (n[s] - o);
      }
    }
}
function jmt(e, t, n) {
  for (const r of e) {
    for (const i of r) {
      const [o, a] = ZTe(i, n);
      for (const s of i) {
        const u = (a + o) / 2;
        t[s] -= u, n[s] -= u;
      }
    }
    eCe(r, t, n);
  }
  tCe(e, t, n);
}
function JTe(e, t, n, r) {
  for (const i of e) {
    const o = new ES();
    let a = 0;
    for (const s of i) {
      let u = -1;
      const l = s.map((g) => Math.abs(n[g] - t[g])), f = s.map((g) => {
        u = r ? r[g] : ++u;
        const y = n[g] - t[g], b = o.has(u) ? y - o.get(u) : 0;
        return o.set(u, y), b;
      }), h = [0, ...Vrt(f)];
      for (const g of s)
        t[g] += a, n[g] += a;
      const p = fp(l);
      p && (a -= fp(l, (g, y) => (f[y] / 2 + h[y]) * g) / p);
    }
    eCe(i, t, n);
  }
  tCe(e, t, n);
}
function eCe(e, t, n) {
  const r = Oc(e, (i) => Oc(i, (o) => t[o]));
  for (const i of e)
    for (const o of i)
      t[o] -= r, n[o] -= r;
}
function tCe(e, t, n) {
  const r = e.length;
  if (r === 1)
    return;
  const i = e.map((s) => s.flat()), o = i.map((s) => (Oc(s, (u) => t[u]) + Ha(s, (u) => n[u])) / 2), a = Oc(o);
  for (let s = 0; s < r; s++) {
    const u = a - o[s];
    for (const l of i[s])
      t[l] += u, n[l] += u;
  }
}
function Lmt(e, t, n) {
  if (e === void 0 && t === JTe)
    return ape(gp);
  if (e != null) {
    if (typeof e == "string") {
      const r = e.startsWith("-"), i = r ? VL : gp;
      switch ((r ? e.slice(1) : e).toLowerCase()) {
        case "value":
        case n:
          return zmt(i);
        case "z":
          return Fmt(i);
        case "sum":
          return Bmt(i);
        case "appearance":
          return Umt(i);
        case "inside-out":
          return ape(i);
      }
      return spe(V2e(e));
    }
    if (typeof e == "function")
      return (e.length === 1 ? spe : Ymt)(e);
    if (Array.isArray(e))
      return Hmt(e);
    throw new Error(`invalid order: ${e}`);
  }
}
function zmt(e) {
  return (t, n, r) => (i, o) => e(r[i], r[o]);
}
function Fmt(e) {
  return (t, n, r, i) => (o, a) => e(i[o], i[a]);
}
function Bmt(e) {
  return d6(
    e,
    (t, n, r, i) => HK(
      _b(t),
      (o) => fp(o, (a) => r[a]),
      (o) => i[o]
    )
  );
}
function Umt(e) {
  return d6(
    e,
    (t, n, r, i) => HK(
      _b(t),
      (o) => n[WK(o, (a) => r[a])],
      (o) => i[o]
    )
  );
}
function ape(e) {
  return d6(e, (t, n, r, i) => {
    const o = _b(t), a = HK(
      o,
      (h) => n[WK(h, (p) => r[p])],
      (h) => i[h]
    ), s = NT(
      o,
      (h) => fp(h, (p) => r[p]),
      (h) => i[h]
    ), u = [], l = [];
    let f = 0;
    for (const h of a)
      f < 0 ? (f += s.get(h), u.push(h)) : (f -= s.get(h), l.push(h));
    return l.reverse().concat(u);
  });
}
function spe(e) {
  return (t) => {
    const n = Qr(t, e);
    return (r, i) => gp(n[r], n[i]);
  };
}
function Ymt(e) {
  return (t) => (n, r) => e(t[n], t[r]);
}
function Hmt(e) {
  return d6(gp, () => e);
}
function d6(e, t) {
  return (n, r, i, o) => {
    if (!o)
      throw new Error("missing channel: z");
    const a = new ES(t(n, r, i, o).map((s, u) => [s, u]));
    return (s, u) => e(a.get(o[s]), a.get(o[u]));
  };
}
const Vmt = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class h6 extends Co {
  constructor(t, n = {}) {
    const { x1: r, y1: i, x2: o, y2: a, z: s, curve: u, tension: l } = n;
    super(
      t,
      {
        x1: { value: r, scale: "x" },
        y1: { value: i, scale: "y" },
        x2: { value: o, scale: "x", optional: !0 },
        y2: { value: a, scale: "y", optional: !0 },
        z: { value: Ow(n), optional: !0 }
      },
      n,
      Vmt
    ), this.z = s, this.curve = SJ(u, l);
  }
  filter(t) {
    return t;
  }
  render(t, n, r, i, o) {
    const { x1: a, y1: s, x2: u = a, y2: l = s } = r;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, n, 0, 0).call(
      (f) => f.selectAll().data(hMe(t, [a, s, u, l], this, r)).enter().append("path").call(Xo, this).call(XL, this, r).attr(
        "d",
        M$().curve(this.curve).defined((h) => h >= 0).x0((h) => a[h]).y0((h) => s[h]).x1((h) => u[h]).y1((h) => l[h])
      )
    ).node();
  }
}
function Wmt(e, t) {
  return t === void 0 ? EC(e, { x: F$, y: Pk }) : new h6(e, t);
}
function Fk(e, t) {
  const { y: n = zf, ...r } = TJ(t);
  return new h6(e, RJ(AJ({ ...r, y1: n, y2: void 0 })));
}
function EC(e, t) {
  const { x: n = zf, ...r } = MJ(t);
  return new h6(e, kJ(OJ({ ...r, x1: n, x2: void 0 })));
}
const qmt = {
  ariaLabel: "link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
class nCe extends Co {
  constructor(t, n = {}) {
    const { x1: r, y1: i, x2: o, y2: a, curve: s, tension: u } = n;
    super(
      t,
      {
        x1: { value: r, scale: "x" },
        y1: { value: i, scale: "y" },
        x2: { value: o, scale: "x", optional: !0 },
        y2: { value: a, scale: "y", optional: !0 }
      },
      n,
      qmt
    ), this.curve = YTe(s, u), yN(this, n);
  }
  project(t, n, r) {
    this.curve !== _C && super.project(t, n, r);
  }
  render(t, n, r, i, o) {
    const { x1: a, y1: s, x2: u = a, y2: l = s } = r, { curve: f } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call(
      (h) => h.selectAll().data(t).enter().append("path").call(Xo, this).attr(
        "d",
        f === _C && o.projection ? Gmt(o.projection, a, s, u, l) : (p) => {
          const g = H0(), y = f(g);
          return y.lineStart(), y.point(a[p], s[p]), y.point(u[p], l[p]), y.lineEnd(), g;
        }
      ).call(Qs, this, r).call(W$, this, r, o)
    ).node();
  }
}
function Gmt(e, t, n, r, i) {
  const o = Cw(e);
  return t = xf(t), n = xf(n), r = xf(r), i = xf(i), (a) => o({
    type: "LineString",
    coordinates: [
      [t[a], n[a]],
      [r[a], i[a]]
    ]
  });
}
function rCe(e, { x: t, x1: n, x2: r, y: i, y1: o, y2: a, ...s } = {}) {
  return [n, r] = t5(t, n, r), [o, a] = t5(i, o, a), new nCe(e, { ...s, x1: n, x2: r, y1: o, y2: a });
}
function t5(e, t, n) {
  if (e === void 0) {
    if (t === void 0) {
      if (n !== void 0)
        return [n];
    } else if (n === void 0)
      return [t];
  } else {
    if (t === void 0)
      return n === void 0 ? [e] : [e, n];
    if (n === void 0)
      return [e, t];
  }
  return [t, n];
}
const Qmt = {
  ariaLabel: "arrow",
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeMiterlimit: 1,
  strokeWidth: 1.5
};
class iCe extends Co {
  constructor(t, n = {}) {
    const {
      x1: r,
      y1: i,
      x2: o,
      y2: a,
      bend: s = 0,
      headAngle: u = 60,
      headLength: l = 8,
      // Disable the arrow with headLength = 0; or, use Plot.link.
      inset: f = 0,
      insetStart: h = f,
      insetEnd: p = f,
      sweep: g
    } = n;
    super(
      t,
      {
        x1: { value: r, scale: "x" },
        y1: { value: i, scale: "y" },
        x2: { value: o, scale: "x", optional: !0 },
        y2: { value: a, scale: "y", optional: !0 }
      },
      n,
      Qmt
    ), this.bend = s === !0 ? 22.5 : Math.max(-90, Math.min(90, s)), this.headAngle = +u, this.headLength = +l, this.insetStart = +h, this.insetEnd = +p, this.sweep = Xmt(g);
  }
  render(t, n, r, i, o) {
    const { x1: a, y1: s, x2: u = a, y2: l = s, SW: f } = r, { strokeWidth: h, bend: p, headAngle: g, headLength: y, insetStart: b, insetEnd: _ } = this, S = f ? (O) => f[O] : Bd(h === void 0 ? 1 : h), C = g * KL / 2, A = y / 1.5;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call(
      (O) => O.selectAll().data(t).enter().append("path").call(Xo, this).attr("d", (R) => {
        let j = a[R], $ = s[R], z = u[R], W = l[R];
        const Y = Math.hypot(z - j, W - $);
        if (Y <= b + _)
          return null;
        let V = Math.atan2(W - $, z - j);
        const ee = Math.min(A * S(R), Y / 3), K = this.sweep(j, $, z, W) * p * KL, Q = Math.hypot(Y / Math.tan(K), Y) / 2;
        if (b || _)
          if (Q < 1e5) {
            const _e = Math.sign(K), [Ne, Oe] = Kmt([j, $], [z, W], Q, _e);
            if (b && ([j, $] = upe([Ne, Oe, Q], [j, $, b], -_e * Math.sign(b))), _) {
              const [ke, Me] = upe([Ne, Oe, Q], [z, W, _], _e * Math.sign(_));
              V += Math.atan2(Me - Oe, ke - Ne) - Math.atan2(W - Oe, z - Ne), z = ke, W = Me;
            }
          } else {
            const _e = z - j, Ne = W - $, Oe = Math.hypot(_e, Ne);
            b && (j += _e / Oe * b, $ += Ne / Oe * b), _ && (z -= _e / Oe * _, W -= Ne / Oe * _);
          }
        const q = V + K, te = q + C, X = q - C, Z = z - ee * Math.cos(te), se = W - ee * Math.sin(te), H = z - ee * Math.cos(X), ie = W - ee * Math.sin(X), he = Q < 1e5 ? `A${Q},${Q} 0,0,${K > 0 ? 1 : 0} ` : "L", ye = ee ? `M${Z},${se}L${z},${W}L${H},${ie}` : "";
        return `M${j},${$}${he}${z},${W}${ye}`;
      }).call(Qs, this, r)
    ).node();
  }
}
function Xmt(e = 1) {
  if (typeof e == "number")
    return Bd(Math.sign(e));
  if (typeof e == "function")
    return (t, n, r, i) => Math.sign(e(t, n, r, i));
  switch (Sp(e, "sweep", ["+x", "-x", "+y", "-y"])) {
    case "+x":
      return (t, n, r) => Go(t, r);
    case "-x":
      return (t, n, r) => _S(t, r);
    case "+y":
      return (t, n, r, i) => Go(n, i);
    case "-y":
      return (t, n, r, i) => _S(n, i);
  }
}
function Kmt([e, t], [n, r], i, o) {
  const a = n - e, s = r - t, u = Math.hypot(a, s), l = o * Math.sqrt(i * i - u * u / 4) / u;
  return [(e + n) / 2 - s * l, (t + r) / 2 + a * l];
}
function upe([e, t, n], [r, i, o], a) {
  const s = r - e, u = i - t, l = Math.hypot(s, u), f = (s * s + u * u - o * o + n * n) / (2 * l), h = a * Math.sqrt(n * n - f * f);
  return [e + (s * f + u * h) / l, t + (u * f - s * h) / l];
}
function Zmt(e, { x: t, x1: n, x2: r, y: i, y1: o, y2: a, ...s } = {}) {
  return [n, r] = t5(t, n, r), [o, a] = t5(i, o, a), new iCe(e, { ...s, x1: n, x2: r, y1: o, y2: a });
}
class $J extends Co {
  constructor(t, n, r = {}, i) {
    super(t, n, r, i);
    const { inset: o = 0, insetTop: a = o, insetRight: s = o, insetBottom: u = o, insetLeft: l = o, rx: f, ry: h } = r;
    this.insetTop = ti(a), this.insetRight = ti(s), this.insetBottom = ti(u), this.insetLeft = ti(l), this.rx = ja(f, "auto"), this.ry = ja(h, "auto");
  }
  render(t, n, r, i, o) {
    const { rx: a, ry: s } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(this._transform, this, n).call(
      (u) => u.selectAll().data(t).enter().append("rect").call(Xo, this).attr("x", this._x(n, r, i)).attr("width", this._width(n, r, i)).attr("y", this._y(n, r, i)).attr("height", this._height(n, r, i)).call(Fn, "rx", a).call(Fn, "ry", s).call(Qs, this, r)
    ).node();
  }
  _x(t, { x: n }, { marginLeft: r }) {
    const { insetLeft: i } = this;
    return n ? (o) => n[o] + i : r + i;
  }
  _y(t, { y: n }, { marginTop: r }) {
    const { insetTop: i } = this;
    return n ? (o) => n[o] + i : r + i;
  }
  _width({ x: t }, { x: n }, { marginRight: r, marginLeft: i, width: o }) {
    const { insetLeft: a, insetRight: s } = this, u = n && t ? t.bandwidth() : o - r - i;
    return Math.max(0, u - a - s);
  }
  _height({ y: t }, { y: n }, { marginTop: r, marginBottom: i, height: o }) {
    const { insetTop: a, insetBottom: s } = this, u = n && t ? t.bandwidth() : o - r - i;
    return Math.max(0, u - a - s);
  }
}
const oCe = {
  ariaLabel: "bar"
};
class aCe extends $J {
  constructor(t, n = {}) {
    const { x1: r, x2: i, y: o } = n;
    super(
      t,
      {
        x1: { value: r, scale: "x" },
        x2: { value: i, scale: "x" },
        y: { value: o, scale: "y", type: "band", optional: !0 }
      },
      n,
      oCe
    );
  }
  _transform(t, n, { x: r }) {
    t.call(To, n, { x: r }, 0, 0);
  }
  _x({ x: t }, { x1: n, x2: r }, { marginLeft: i }) {
    const { insetLeft: o } = this;
    return ep(t) ? i + o : (a) => Math.min(n[a], r[a]) + o;
  }
  _width({ x: t }, { x1: n, x2: r }, { marginRight: i, marginLeft: o, width: a }) {
    const { insetLeft: s, insetRight: u } = this;
    return ep(t) ? a - i - o - s - u : (l) => Math.max(0, Math.abs(r[l] - n[l]) - s - u);
  }
}
class sCe extends $J {
  constructor(t, n = {}) {
    const { x: r, y1: i, y2: o } = n;
    super(
      t,
      {
        y1: { value: i, scale: "y" },
        y2: { value: o, scale: "y" },
        x: { value: r, scale: "x", type: "band", optional: !0 }
      },
      n,
      oCe
    );
  }
  _transform(t, n, { y: r }) {
    t.call(To, n, { y: r }, 0, 0);
  }
  _y({ y: t }, { y1: n, y2: r }, { marginTop: i }) {
    const { insetTop: o } = this;
    return ep(t) ? i + o : (a) => Math.min(n[a], r[a]) + o;
  }
  _height({ y: t }, { y1: n, y2: r }, { marginTop: i, marginBottom: o, height: a }) {
    const { insetTop: s, insetBottom: u } = this;
    return ep(t) ? a - i - o - s - u : (l) => Math.max(0, Math.abs(r[l] - n[l]) - s - u);
  }
}
function HE(e, t = {}) {
  return GF(t) || (t = { ...t, y: zf, x2: Wn }), new aCe(e, RJ(qMe(AJ(t))));
}
function VE(e, t = {}) {
  return GF(t) || (t = { ...t, x: zf, y2: Wn }), new sCe(e, kJ(GMe(OJ(t))));
}
const Jmt = {
  ariaLabel: "cell"
};
class p6 extends $J {
  constructor(t, { x: n, y: r, ...i } = {}) {
    super(
      t,
      {
        x: { value: n, scale: "x", type: "band", optional: !0 },
        y: { value: r, scale: "y", type: "band", optional: !0 }
      },
      i,
      Jmt
    );
  }
  _transform(t, n) {
    t.call(To, n, {}, 0, 0);
  }
}
function gT(e, { x: t, y: n, ...r } = {}) {
  return [t, n] = em(t, n), new p6(e, { ...r, x: t, y: n });
}
function eyt(e, { x: t = zf, fill: n, stroke: r, ...i } = {}) {
  return n === void 0 && Df(r)[0] === void 0 && (n = Wn), new p6(e, { ...i, x: t, fill: n, stroke: r });
}
function tyt(e, { y: t = zf, fill: n, stroke: r, ...i } = {}) {
  return n === void 0 && Df(r)[0] === void 0 && (n = Wn), new p6(e, { ...i, y: t, fill: n, stroke: r });
}
const nyt = {
  ariaLabel: "dot",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5
};
function PJ(e) {
  return e.sort === void 0 && e.reverse === void 0 ? rMe({ channel: "-r" }, e) : e;
}
class g6 extends Co {
  constructor(t, n = {}) {
    const { x: r, y: i, r: o, rotate: a, symbol: s = oC, frameAnchor: u } = n, [l, f] = ns(a, 0), [h, p] = vht(s), [g, y] = ns(o, h == null ? 3 : 4.5);
    super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        r: { value: g, scale: "r", filter: Z0, optional: !0 },
        rotate: { value: l, optional: !0 },
        symbol: { value: h, scale: "auto", optional: !0 }
      },
      PJ(n),
      nyt
    ), this.r = y, this.rotate = f, this.symbol = p, this.frameAnchor = Y$(u);
    const { channels: b } = this, { symbol: _ } = b;
    if (_) {
      const { fill: S, stroke: C } = b;
      _.hint = {
        fill: S ? S.value === _.value ? "color" : "currentColor" : this.fill,
        stroke: C ? C.value === _.value ? "color" : "currentColor" : this.stroke
      };
    }
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, r: f, rotate: h, symbol: p } = r, { r: g, rotate: y, symbol: b } = this, [_, S] = ov(this, i), C = b === oC, A = f ? void 0 : g * g * Math.PI;
    return qF(g) && (t = []), Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a, y: l && s }).call(
      (O) => O.selectAll().data(t).enter().append(C ? "circle" : "path").call(Xo, this).call(
        C ? (R) => {
          R.attr("cx", u ? (j) => u[j] : _).attr("cy", l ? (j) => l[j] : S).attr("r", f ? (j) => f[j] : g);
        } : (R) => {
          R.attr(
            "transform",
            u6`translate(${u ? (j) => u[j] : _},${l ? (j) => l[j] : S})${h ? (j) => ` rotate(${h[j]})` : y ? ` rotate(${y})` : ""}`
          ).attr(
            "d",
            f && p ? (j) => {
              const $ = H0();
              return p[j].draw($, f[j] * f[j] * Math.PI), $;
            } : f ? (j) => {
              const $ = H0();
              return b.draw($, f[j] * f[j] * Math.PI), $;
            } : p ? (j) => {
              const $ = H0();
              return p[j].draw($, A), $;
            } : (() => {
              const j = H0();
              return b.draw(j, A), j;
            })()
          );
        }
      ).call(Qs, this, r)
    ).node();
  }
}
function $w(e, { x: t, y: n, ...r } = {}) {
  return r.frameAnchor === void 0 && ([t, n] = em(t, n)), new g6(e, { ...r, x: t, y: n });
}
function ryt(e, { x: t = Wn, ...n } = {}) {
  return new g6(e, XMe({ ...n, x: t }));
}
function iyt(e, { y: t = Wn, ...n } = {}) {
  return new g6(e, QMe({ ...n, y: t }));
}
function oyt(e, t) {
  return $w(e, { ...t, symbol: "circle" });
}
function ayt(e, t) {
  return $w(e, { ...t, symbol: "hexagon" });
}
const syt = {
  ariaLabel: "line",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class m6 extends Co {
  constructor(t, n = {}) {
    const { x: r, y: i, z: o, curve: a, tension: s } = n;
    super(
      t,
      {
        x: { value: r, scale: "x" },
        y: { value: i, scale: "y" },
        z: { value: Ow(n), optional: !0 }
      },
      n,
      syt
    ), this.z = o, this.curve = YTe(a, s), yN(this, n);
  }
  filter(t) {
    return t;
  }
  project(t, n, r) {
    this.curve !== _C && super.project(t, n, r);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = r, { curve: u } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call(
      (l) => l.selectAll().data(hMe(t, [a, s], this, r)).enter().append("path").call(Xo, this).call(XL, this, r).call(dgt, this, r, o).attr(
        "d",
        u === _C && o.projection ? uyt(o.projection, a, s) : IK().curve(u).defined((f) => f >= 0).x((f) => a[f]).y((f) => s[f])
      )
    ).node();
  }
}
function uyt(e, t, n) {
  const r = Cw(e);
  return t = xf(t), n = xf(n), (i) => {
    let o = [];
    const a = [o];
    for (const s of i)
      s === -1 ? (o = [], a.push(o)) : o.push([t[s], n[s]]);
    return r({ type: "MultiLineString", coordinates: a });
  };
}
function IJ(e, { x: t, y: n, ...r } = {}) {
  return [t, n] = em(t, n), new m6(e, { ...r, x: t, y: n });
}
function Bk(e, { x: t = Wn, y: n = zf, ...r } = {}) {
  return new m6(e, TJ({ ...r, x: t, y: n }));
}
function Uk(e, { x: t = zf, y: n = Wn, ...r } = {}) {
  return new m6(e, MJ({ ...r, x: t, y: n }));
}
const lyt = {
  ariaLabel: "rect"
};
class y6 extends Co {
  constructor(t, n = {}) {
    const {
      x1: r,
      y1: i,
      x2: o,
      y2: a,
      inset: s = 0,
      insetTop: u = s,
      insetRight: l = s,
      insetBottom: f = s,
      insetLeft: h = s,
      rx: p,
      ry: g
    } = n;
    super(
      t,
      {
        x1: { value: r, scale: "x", optional: !0 },
        y1: { value: i, scale: "y", optional: !0 },
        x2: { value: o, scale: "x", optional: !0 },
        y2: { value: a, scale: "y", optional: !0 }
      },
      n,
      lyt
    ), this.insetTop = ti(u), this.insetRight = ti(l), this.insetBottom = ti(f), this.insetLeft = ti(h), this.rx = ja(p, "auto"), this.ry = ja(g, "auto");
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x1: u, y1: l, x2: f, y2: h } = r, { marginTop: p, marginRight: g, marginBottom: y, marginLeft: b, width: _, height: S } = i, { projection: C } = o, { insetTop: A, insetRight: O, insetBottom: R, insetLeft: j, rx: $, ry: z } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && f && a, y: l && h && s }, 0, 0).call(
      (W) => W.selectAll().data(t).enter().append("rect").call(Xo, this).attr(
        "x",
        u && f && (C || !ep(a)) ? (Y) => Math.min(u[Y], f[Y]) + j : b + j
      ).attr(
        "y",
        l && h && (C || !ep(s)) ? (Y) => Math.min(l[Y], h[Y]) + A : p + A
      ).attr(
        "width",
        u && f && (C || !ep(a)) ? (Y) => Math.max(0, Math.abs(f[Y] - u[Y]) - j - O) : _ - g - b - O - j
      ).attr(
        "height",
        l && h && (C || !ep(s)) ? (Y) => Math.max(0, Math.abs(l[Y] - h[Y]) - A - R) : S - p - y - A - R
      ).call(Fn, "rx", $).call(Fn, "ry", z).call(Qs, this, r)
    ).node();
  }
}
function jJ(e, t) {
  return new y6(e, VMe(WMe(t)));
}
function n5(e, t = {}) {
  return GF(t) || (t = { ...t, y: zf, x2: Wn, interval: 1 }), new y6(e, RJ(WMe(AJ(t))));
}
function r5(e, t = {}) {
  return GF(t) || (t = { ...t, x: zf, y2: Wn, interval: 1 }), new y6(e, kJ(VMe(OJ(t))));
}
function uCe(e, t) {
  t = fyt(t);
  const { x: n, y: r, color: i, size: o } = t, a = c3(e, n), s = c3(e, r), u = c3(e, i), l = c3(e, o);
  let {
    fx: f,
    fy: h,
    x: { value: p, reduce: g, zero: y, ...b },
    y: { value: _, reduce: S, zero: C, ...A },
    color: { value: O, color: R, reduce: j },
    size: { value: $, reduce: z },
    // TODO constant radius?
    mark: W
  } = t;
  if (g === void 0 && (g = S == null && p == null && $ == null && _ != null ? "count" : null), S === void 0 && (S = g == null && _ == null && $ == null && p != null ? "count" : null), z === void 0 && $ == null && j == null && g == null && S == null && (p == null || $a(a)) && (_ == null || $a(s)) && (z = "count"), y === void 0 && (y = f3(g) ? !0 : void 0), C === void 0 && (C = f3(S) ? !0 : void 0), p == null && _ == null)
    throw new Error("must specify x or y");
  if (g != null && _ == null)
    throw new Error("reducing x requires y");
  if (S != null && p == null)
    throw new Error("reducing y requires x");
  W === void 0 && (W = $ != null || z != null ? "dot" : f3(g) || f3(S) || j != null ? "bar" : p != null && _ != null ? $a(a) || $a(s) || g == null && S == null && !JA(a) && !JA(s) ? "dot" : "line" : p != null || _ != null ? "rule" : null);
  let Y, V, ee;
  switch (W) {
    case "dot":
      ee = $w, V = "stroke";
      break;
    case "line":
      ee = a && s || g != null || S != null ? C || S != null || a && JA(a) ? Uk : y || g != null || s && JA(s) ? Bk : IJ : a ? Bk : Uk, V = "stroke", cpe(u) && (Y = null);
      break;
    case "area":
      ee = !(C || S != null) && (y || g != null || s && JA(s)) ? Fk : EC, V = "fill", cpe(u) && (Y = null);
      break;
    case "rule":
      ee = a ? ow : aw, V = "stroke";
      break;
    case "bar":
      ee = g != null ? $a(s) ? lpe(g) && a && $a(a) ? gT : HE : n5 : S != null ? $a(a) ? lpe(S) && s && $a(s) ? gT : VE : r5 : j != null || z != null ? a && $a(a) && s && $a(s) ? gT : a && $a(a) ? VE : s && $a(s) ? HE : jJ : a && pT(a) && !(s && pT(s)) ? HE : s && pT(s) && !(a && pT(a)) ? VE : gT, V = "fill";
      break;
    default:
      throw new Error(`invalid mark: ${W}`);
  }
  let K = {
    fx: f,
    fy: h,
    x: a ?? void 0,
    // treat null x as undefined for implicit stack
    y: s ?? void 0,
    // treat null y as undefined for implicit stack
    [V]: u ?? R,
    z: Y,
    r: l ?? void 0,
    // treat null size as undefined for default constant radius
    tip: !0
  }, Q, q = { [V]: j ?? void 0, r: z ?? void 0 };
  if (g != null && S != null)
    throw new Error("cannot reduce both x and y");
  return S != null ? (q.y = S, Q = $a(a) ? Ik : bx) : g != null ? (q.x = g, Q = $a(s) ? jk : xx) : (j != null || z != null) && (a && s ? Q = $a(a) && $a(s) ? GZ : $a(a) ? xx : $a(s) ? bx : $E : a ? Q = $a(a) ? Ik : bx : s && (Q = $a(s) ? jk : xx)), (Q === $E || Q === bx) && (K.x = { value: a, ...b }), (Q === $E || Q === xx) && (K.y = { value: s, ...A }), y === void 0 && (y = a && !(Q === $E || Q === bx) && (ee === HE || ee === Fk || ee === n5 || ee === aw)), C === void 0 && (C = s && !(Q === $E || Q === xx) && (ee === VE || ee === EC || ee === r5 || ee === ow)), {
    fx: f ?? null,
    fy: h ?? null,
    x: {
      value: p ?? null,
      reduce: g ?? null,
      zero: !!y,
      ...b
    },
    y: {
      value: _ ?? null,
      reduce: S ?? null,
      zero: !!C,
      ...A
    },
    color: {
      value: O ?? null,
      reduce: j ?? null,
      ...R !== void 0 && { color: R }
    },
    size: {
      value: $ ?? null,
      reduce: z ?? null
    },
    mark: W,
    markImpl: fpe[ee],
    markOptions: K,
    transformImpl: fpe[Q],
    transformOptions: q,
    colorMode: V
  };
}
function cyt(e, t) {
  const n = uCe(e, t), {
    fx: r,
    fy: i,
    x: { zero: o },
    y: { zero: a },
    markOptions: s,
    transformOptions: u,
    colorMode: l
  } = n, f = yG[n.markImpl], h = yG[n.transformImpl], p = r != null || i != null ? wJ({ strokeOpacity: 0.1 }) : null, g = [o ? ow([0]) : null, a ? aw([0]) : null], y = f(e, h ? h(u, s) : s);
  return l === "stroke" ? Vg(p, g, y) : Vg(p, y, g);
}
function JA(e) {
  let t, n;
  for (const r of e) {
    if (r == null)
      continue;
    if (t === void 0) {
      t = r;
      continue;
    }
    const i = Math.sign(Go(t, r));
    if (i) {
      if (n !== void 0 && i !== n)
        return !1;
      t = r, n = i;
    }
  }
  return !0;
}
function fyt({ x: e, y: t, color: n, size: r, fx: i, fy: o, mark: a } = {}) {
  return Ey(e) || (e = YM(e)), Ey(t) || (t = YM(t)), Ey(n) || (n = U$(n) ? { color: n } : YM(n)), Ey(r) || (r = YM(r)), Ey(i) && ({ value: i } = YM(i)), Ey(o) && ({ value: o } = YM(o)), a != null && (a = `${a}`.toLowerCase()), { x: e, y: t, color: n, size: r, fx: i, fy: o, mark: a };
}
function c3(e, t) {
  const n = Qr(e, t.value);
  return n && (n.label = Eb(t.value)), n;
}
function YM(e) {
  return dyt(e) ? { reduce: e } : { value: e };
}
function f3(e) {
  return /^(?:distinct|count|sum|proportion)$/i.test(e);
}
function lpe(e) {
  return /^(?:first|last|mode)$/i.test(e);
}
function dyt(e) {
  if (e == null)
    return !1;
  if (typeof e.reduceIndex == "function" || typeof e.reduce == "function" && Jg(e) || /^p\d{2}$/i.test(e))
    return !0;
  switch (`${e}`.toLowerCase()) {
    case "first":
    case "last":
    case "count":
    case "distinct":
    case "sum":
    case "proportion":
    case "proportion-facet":
    case "deviation":
    case "min":
    case "min-index":
    case "max":
    case "max-index":
    case "mean":
    case "median":
    case "variance":
    case "mode":
      return !0;
  }
  return !1;
}
function cpe(e) {
  return e ? new Xx(e).size > e.length >> 1 : !1;
}
const yG = {
  dot: $w,
  line: IJ,
  lineX: Bk,
  lineY: Uk,
  areaX: Fk,
  areaY: EC,
  ruleX: ow,
  ruleY: aw,
  barX: HE,
  barY: VE,
  rect: jJ,
  rectX: n5,
  rectY: r5,
  cell: gT,
  bin: $E,
  binX: bx,
  binY: xx,
  group: GZ,
  groupX: Ik,
  groupY: jk
}, fpe = Object.fromEntries(Object.entries(yG).map(([e, t]) => [t, e]));
function LJ(e, t = {}) {
  let { x: n, x1: r, x2: i } = t;
  n === void 0 && r === void 0 && i === void 0 && (t = { ...t, x: n = Wn });
  const o = {};
  return n != null && (o.x = e), r != null && (o.x1 = e), i != null && (o.x2 = e), fb(o, t);
}
function zJ(e, t = {}) {
  let { y: n, y1: r, y2: i } = t;
  n === void 0 && r === void 0 && i === void 0 && (t = { ...t, y: n = Wn });
  const o = {};
  return n != null && (o.y = e), r != null && (o.y1 = e), i != null && (o.y2 = e), fb(o, t);
}
function fb(e = {}, t = {}) {
  const n = Ow(t), r = Object.entries(e).map(([i, o]) => {
    const a = X2e(i, t);
    if (a == null)
      throw new Error(`missing channel: ${i}`);
    const [s, u] = Cd(a);
    return { key: i, input: a, output: s, setOutput: u, map: hyt(o) };
  });
  return {
    ...iv(t, (i, o) => {
      const a = Qr(i, n), s = r.map(({ input: l }) => Qr(i, l)), u = r.map(({ setOutput: l }) => l(new Array(i.length)));
      for (const l of o)
        for (const f of a ? xb(l, (h) => a[h]).values() : [l])
          r.forEach(({ map: h }, p) => h.mapIndex(f, s[p], u[p]));
      return { data: i, facets: o };
    }),
    ...Object.fromEntries(r.map(({ key: i, output: o }) => [i, o]))
  };
}
function hyt(e) {
  if (e == null)
    throw new Error("missing map");
  if (typeof e.mapIndex == "function")
    return e;
  if (typeof e.map == "function" && Jg(e))
    return pyt(e);
  if (typeof e == "function")
    return UH(LZ(e));
  switch (`${e}`.toLowerCase()) {
    case "cumsum":
      return myt;
    case "rank":
      return UH((t, n) => y_e(t, (r) => n[r]));
    case "quantile":
      return UH((t, n) => gyt(t, (r) => n[r]));
  }
  throw new Error(`invalid map: ${e}`);
}
function pyt(e) {
  return console.warn("deprecated map interface; implement mapIndex instead."), { mapIndex: e.map.bind(e) };
}
function gyt(e, t) {
  const n = MF(e, t) - 1;
  return y_e(e, t).map((r) => r / n);
}
function UH(e) {
  return {
    mapIndex(t, n, r) {
      const i = e(t, n);
      if (i.length !== t.length)
        throw new Error("map function returned a mismatched length");
      for (let o = 0, a = t.length; o < a; ++o)
        r[t[o]] = i[o];
    }
  };
}
const myt = {
  mapIndex(e, t, n) {
    let r = 0;
    for (const i of e)
      n[i] = r += t[i];
  }
};
function yyt(e = {}, t) {
  return arguments.length === 1 && (t = e), LJ(v6(e), t);
}
function vyt(e = {}, t) {
  return arguments.length === 1 && (t = e), zJ(v6(e), t);
}
function v6(e = {}) {
  typeof e == "number" && (e = { k: e });
  let { k: t, reduce: n, shift: r, anchor: i, strict: o } = e;
  if (i === void 0 && r !== void 0 && (i = xyt(r), Lx(`Warning: the shift option is deprecated; please use anchor "${i}" instead.`)), !((t = Math.floor(t)) > 0))
    throw new Error(`invalid k: ${t}`);
  return wyt(n)(t, byt(i, t), o);
}
function byt(e = "middle", t) {
  switch (`${e}`.toLowerCase()) {
    case "middle":
      return t - 1 >> 1;
    case "start":
      return 0;
    case "end":
      return t - 1;
  }
  throw new Error(`invalid anchor: ${e}`);
}
function xyt(e) {
  switch (`${e}`.toLowerCase()) {
    case "centered":
      return "middle";
    case "leading":
      return "start";
    case "trailing":
      return "end";
  }
  throw new Error(`invalid shift: ${e}`);
}
function wyt(e = "mean") {
  if (typeof e == "string") {
    if (/^p\d{2}$/i.test(e))
      return d3($Z(e));
    switch (e.toLowerCase()) {
      case "deviation":
        return d3(lN);
      case "max":
        return h3((t, n) => Ha(t, (r) => n[r]));
      case "mean":
        return _yt;
      case "median":
        return d3(Jx);
      case "min":
        return h3((t, n) => Oc(t, (r) => n[r]));
      case "mode":
        return h3((t, n) => m_e(t, (r) => n[r]));
      case "sum":
        return lCe;
      case "variance":
        return d3(BK);
      case "difference":
        return Myt;
      case "ratio":
        return Tyt;
      case "first":
        return Cyt;
      case "last":
        return Nyt;
    }
  }
  if (typeof e != "function")
    throw new Error(`invalid reduce: ${e}`);
  return h3(LZ(e));
}
function d3(e) {
  return (t, n, r) => r ? {
    mapIndex(i, o, a) {
      const s = (l) => o[l] == null ? NaN : +o[l];
      let u = 0;
      for (let l = 0; l < t - 1; ++l)
        isNaN(s(l)) && ++u;
      for (let l = 0, f = i.length - t + 1; l < f; ++l)
        isNaN(s(l + t - 1)) && ++u, a[i[l + n]] = u === 0 ? e(nS(i, l, l + t), s) : NaN, isNaN(s(l)) && --u;
    }
  } : {
    mapIndex(i, o, a) {
      const s = (u) => o[u] == null ? NaN : +o[u];
      for (let u = -n; u < 0; ++u)
        a[i[u + n]] = e(nS(i, 0, u + t), s);
      for (let u = 0, l = i.length - n; u < l; ++u)
        a[i[u + n]] = e(nS(i, u, u + t), s);
    }
  };
}
function h3(e) {
  return (t, n, r) => r ? {
    mapIndex(i, o, a) {
      let s = 0;
      for (let u = 0; u < t - 1; ++u)
        s += Dc(o[i[u]]);
      for (let u = 0, l = i.length - t + 1; u < l; ++u)
        s += Dc(o[i[u + t - 1]]), s === t && (a[i[u + n]] = e(nS(i, u, u + t), o)), s -= Dc(o[i[u]]);
    }
  } : {
    mapIndex(i, o, a) {
      for (let s = -n; s < 0; ++s)
        a[i[s + n]] = e(nS(i, 0, s + t), o);
      for (let s = 0, u = i.length - n; s < u; ++s)
        a[i[s + n]] = e(nS(i, s, s + t), o);
    }
  };
}
function lCe(e, t, n) {
  return n ? {
    mapIndex(r, i, o) {
      let a = 0, s = 0;
      for (let u = 0; u < e - 1; ++u) {
        const l = i[r[u]];
        l === null || isNaN(l) ? ++a : s += +l;
      }
      for (let u = 0, l = r.length - e + 1; u < l; ++u) {
        const f = i[r[u]], h = i[r[u + e - 1]];
        h === null || isNaN(h) ? ++a : s += +h, o[r[u + t]] = a === 0 ? s : NaN, f === null || isNaN(f) ? --a : s -= +f;
      }
    }
  } : {
    mapIndex(r, i, o) {
      let a = 0;
      const s = r.length;
      for (let u = 0, l = Math.min(s, e - t - 1); u < l; ++u)
        a += +i[r[u]] || 0;
      for (let u = -t, l = s - t; u < l; ++u)
        a += +i[r[u + e - 1]] || 0, o[r[u + t]] = a, a -= +i[r[u]] || 0;
    }
  };
}
function _yt(e, t, n) {
  if (n) {
    const r = lCe(e, t, n);
    return {
      mapIndex(i, o, a) {
        r.mapIndex(i, o, a);
        for (let s = 0, u = i.length - e + 1; s < u; ++s)
          a[i[s + t]] /= e;
      }
    };
  } else
    return {
      mapIndex(r, i, o) {
        let a = 0, s = 0;
        const u = r.length;
        for (let l = 0, f = Math.min(u, e - t - 1); l < f; ++l) {
          let h = i[r[l]];
          h !== null && !isNaN(h = +h) && (a += h, ++s);
        }
        for (let l = -t, f = u - t; l < f; ++l) {
          let h = i[r[l + e - 1]], p = i[r[l]];
          h !== null && !isNaN(h = +h) && (a += h, ++s), o[r[l + t]] = a / s, p !== null && !isNaN(p = +p) && (a -= p, --s);
        }
      }
    };
}
function Eyt(e, t, n, r) {
  for (let i = n + r; n < i; ++n) {
    const o = e[t[n]];
    if (Dc(o))
      return o;
  }
}
function Syt(e, t, n, r) {
  for (let i = n + r - 1; i >= n; --i) {
    const o = e[t[i]];
    if (Dc(o))
      return o;
  }
}
function cCe(e, t, n, r) {
  for (let i = n + r; n < i; ++n) {
    let o = e[t[n]];
    if (o !== null && !isNaN(o = +o))
      return o;
  }
}
function fCe(e, t, n, r) {
  for (let i = n + r - 1; i >= n; --i) {
    let o = e[t[i]];
    if (o !== null && !isNaN(o = +o))
      return o;
  }
}
function Myt(e, t, n) {
  return n ? {
    mapIndex(r, i, o) {
      for (let a = 0, s = r.length - e; a < s; ++a) {
        const u = i[r[a]], l = i[r[a + e - 1]];
        o[r[a + t]] = u === null || l === null ? NaN : l - u;
      }
    }
  } : {
    mapIndex(r, i, o) {
      for (let a = -t, s = r.length - e + t + 1; a < s; ++a)
        o[r[a + t]] = fCe(i, r, a, e) - cCe(i, r, a, e);
    }
  };
}
function Tyt(e, t, n) {
  return n ? {
    mapIndex(r, i, o) {
      for (let a = 0, s = r.length - e; a < s; ++a) {
        const u = i[r[a]], l = i[r[a + e - 1]];
        o[r[a + t]] = u === null || l === null ? NaN : l / u;
      }
    }
  } : {
    mapIndex(r, i, o) {
      for (let a = -t, s = r.length - e + t + 1; a < s; ++a)
        o[r[a + t]] = fCe(i, r, a, e) / cCe(i, r, a, e);
    }
  };
}
function Cyt(e, t, n) {
  return n ? {
    mapIndex(r, i, o) {
      for (let a = 0, s = r.length - e; a < s; ++a)
        o[r[a + t]] = i[r[a]];
    }
  } : {
    mapIndex(r, i, o) {
      for (let a = -t, s = r.length - e + t + 1; a < s; ++a)
        o[r[a + t]] = Eyt(i, r, a, e);
    }
  };
}
function Nyt(e, t, n) {
  return n ? {
    mapIndex(r, i, o) {
      for (let a = 0, s = r.length - e; a < s; ++a)
        o[r[a + t]] = i[r[a + e - 1]];
    }
  } : {
    mapIndex(r, i, o) {
      for (let a = -t, s = r.length - e + t + 1; a < s; ++a)
        o[r[a + t]] = Syt(i, r, a, e);
    }
  };
}
const eb = {
  n: 20,
  k: 2,
  color: "currentColor",
  opacity: 0.2,
  strict: !0,
  anchor: "end"
};
function Dyt(e, {
  x: t = Wn,
  y: n,
  k: r = eb.k,
  color: i = eb.color,
  opacity: o = eb.opacity,
  fill: a = i,
  fillOpacity: s = o,
  stroke: u = i,
  strokeOpacity: l,
  strokeWidth: f,
  ...h
} = {}) {
  return Vg(
    Ba(a) ? null : Fk(
      e,
      fb(
        { x1: rS({ k: -r, ...h }), x2: rS({ k: r, ...h }) },
        { x1: t, x2: t, y: n, fill: a, fillOpacity: s, ...h }
      )
    ),
    Ba(u) ? null : Bk(e, fb({ x: rS(h) }, { x: t, y: n, stroke: u, strokeOpacity: l, strokeWidth: f, ...h }))
  );
}
function Ayt(e, {
  x: t,
  y: n = Wn,
  k: r = eb.k,
  color: i = eb.color,
  opacity: o = eb.opacity,
  fill: a = i,
  fillOpacity: s = o,
  stroke: u = i,
  strokeOpacity: l,
  strokeWidth: f,
  ...h
} = {}) {
  return Vg(
    Ba(a) ? null : EC(
      e,
      fb(
        { y1: rS({ k: -r, ...h }), y2: rS({ k: r, ...h }) },
        { x: t, y1: n, y2: n, fill: a, fillOpacity: s, ...h }
      )
    ),
    Ba(u) ? null : Uk(e, fb({ y: rS(h) }, { x: t, y: n, stroke: u, strokeOpacity: l, strokeWidth: f, ...h }))
  );
}
function rS({ n: e = eb.n, k: t = 0, strict: n = eb.strict, anchor: r = eb.anchor } = {}) {
  return v6({ k: e, reduce: (i) => T$(i) + t * (lN(i) || 0), strict: n, anchor: r });
}
const Oyt = {
  ariaLabel: "tick",
  fill: null,
  stroke: "currentColor"
};
class dCe extends Co {
  constructor(t, n, r) {
    super(t, n, r, Oyt), yN(this, r);
  }
  render(t, n, r, i, o) {
    return Yi("svg:g", o).call(sa, this, i, o).call(this._transform, this, n).call(
      (a) => a.selectAll().data(t).enter().append("line").call(Xo, this).attr("x1", this._x1(n, r, i)).attr("x2", this._x2(n, r, i)).attr("y1", this._y1(n, r, i)).attr("y2", this._y2(n, r, i)).call(Qs, this, r).call(W$, this, r, o)
    ).node();
  }
}
class hCe extends dCe {
  constructor(t, n = {}) {
    const { x: r, y: i, inset: o = 0, insetTop: a = o, insetBottom: s = o } = n;
    super(
      t,
      {
        x: { value: r, scale: "x" },
        y: { value: i, scale: "y", type: "band", optional: !0 }
      },
      n
    ), this.insetTop = ti(a), this.insetBottom = ti(s);
  }
  _transform(t, n, { x: r }) {
    t.call(To, n, { x: r }, Ju, 0);
  }
  _x1(t, { x: n }) {
    return (r) => n[r];
  }
  _x2(t, { x: n }) {
    return (r) => n[r];
  }
  _y1({ y: t }, { y: n }, { marginTop: r }) {
    const { insetTop: i } = this;
    return n && t ? (o) => n[o] + i : r + i;
  }
  _y2({ y: t }, { y: n }, { height: r, marginBottom: i }) {
    const { insetBottom: o } = this;
    return n && t ? (a) => n[a] + t.bandwidth() - o : r - i - o;
  }
}
class pCe extends dCe {
  constructor(t, n = {}) {
    const { x: r, y: i, inset: o = 0, insetRight: a = o, insetLeft: s = o } = n;
    super(
      t,
      {
        y: { value: i, scale: "y" },
        x: { value: r, scale: "x", type: "band", optional: !0 }
      },
      n
    ), this.insetRight = ti(a), this.insetLeft = ti(s);
  }
  _transform(t, n, { y: r }) {
    t.call(To, n, { y: r }, 0, Ju);
  }
  _x1({ x: t }, { x: n }, { marginLeft: r }) {
    const { insetLeft: i } = this;
    return n && t ? (o) => n[o] + i : r + i;
  }
  _x2({ x: t }, { x: n }, { width: r, marginRight: i }) {
    const { insetRight: o } = this;
    return n && t ? (a) => n[a] + t.bandwidth() - o : r - i - o;
  }
  _y1(t, { y: n }) {
    return (r) => n[r];
  }
  _y2(t, { y: n }) {
    return (r) => n[r];
  }
}
function gCe(e, { x: t = Wn, ...n } = {}) {
  return new hCe(e, { ...n, x: t });
}
function mCe(e, { y: t = Wn, ...n } = {}) {
  return new pCe(e, { ...n, y: t });
}
function Ryt(e, {
  x: t = Wn,
  y: n = null,
  fill: r = "#ccc",
  fillOpacity: i,
  stroke: o = "currentColor",
  strokeOpacity: a,
  strokeWidth: s = 2,
  sort: u,
  ...l
} = {}) {
  const f = n != null ? jk : qZ;
  return Vg(
    aw(e, f({ x1: FJ, x2: BJ }, { x: t, y: n, stroke: o, strokeOpacity: a, ...l })),
    HE(e, f({ x1: "p25", x2: "p75" }, { x: t, y: n, fill: r, fillOpacity: i, ...l })),
    gCe(e, f({ x: "p50" }, { x: t, y: n, stroke: o, strokeOpacity: a, strokeWidth: s, sort: u, ...l })),
    $w(e, fb({ x: yCe }, { x: t, y: n, z: n, stroke: o, strokeOpacity: a, ...l }))
  );
}
function kyt(e, {
  y: t = Wn,
  x: n = null,
  fill: r = "#ccc",
  fillOpacity: i,
  stroke: o = "currentColor",
  strokeOpacity: a,
  strokeWidth: s = 2,
  sort: u,
  ...l
} = {}) {
  const f = n != null ? Ik : qZ;
  return Vg(
    ow(e, f({ y1: FJ, y2: BJ }, { x: n, y: t, stroke: o, strokeOpacity: a, ...l })),
    VE(e, f({ y1: "p25", y2: "p75" }, { x: n, y: t, fill: r, fillOpacity: i, ...l })),
    mCe(e, f({ y: "p50" }, { x: n, y: t, stroke: o, strokeOpacity: a, strokeWidth: s, sort: u, ...l })),
    $w(e, fb({ y: yCe }, { x: n, y: t, z: n, stroke: o, strokeOpacity: a, ...l }))
  );
}
function yCe(e) {
  const t = FJ(e), n = BJ(e);
  return e.map((r) => r < t || r > n ? r : NaN);
}
function FJ(e) {
  const t = vCe(e) * 2.5 - bCe(e) * 1.5;
  return Oc(e, (n) => n >= t ? n : NaN);
}
function BJ(e) {
  const t = bCe(e) * 2.5 - vCe(e) * 1.5;
  return Ha(e, (n) => n <= t ? n : NaN);
}
function vCe(e) {
  return Wy(e, 0.25);
}
function bCe(e) {
  return Wy(e, 0.75);
}
const $yt = {
  ariaLabel: "raster",
  stroke: null,
  pixelSize: 1
};
function HM(e, t) {
  const n = +e;
  if (isNaN(n))
    throw new Error(`invalid ${t}: ${e}`);
  return n;
}
function dpe(e, t) {
  const n = Math.floor(e);
  if (isNaN(n))
    throw new Error(`invalid ${t}: ${e}`);
  return n;
}
class xCe extends Co {
  constructor(t, n, r = {}, i) {
    let {
      width: o,
      height: a,
      x: s,
      y: u,
      x1: l = s == null ? 0 : void 0,
      y1: f = u == null ? 0 : void 0,
      x2: h = s == null ? o : void 0,
      y2: p = u == null ? a : void 0,
      pixelSize: g = i.pixelSize,
      blur: y = 0,
      interpolate: b
    } = r;
    if (o != null && (o = dpe(o, "width")), a != null && (a = dpe(a, "height")), l != null && (l = HM(l, "x1")), f != null && (f = HM(f, "y1")), h != null && (h = HM(h, "x2")), p != null && (p = HM(p, "y2")), s == null && (l == null || h == null))
      throw new Error("missing x");
    if (u == null && (f == null || p == null))
      throw new Error("missing y");
    t != null && o != null && a != null && (s === void 0 && l != null && h != null && (s = Yyt(l, h, o)), u === void 0 && f != null && p != null && (u = Hyt(f, p, o, a))), super(
      t,
      {
        x: { value: s, scale: "x", optional: !0 },
        y: { value: u, scale: "y", optional: !0 },
        x1: { value: l == null ? null : [l], scale: "x", optional: !0, filter: null },
        y1: { value: f == null ? null : [f], scale: "y", optional: !0, filter: null },
        x2: { value: h == null ? null : [h], scale: "x", optional: !0, filter: null },
        y2: { value: p == null ? null : [p], scale: "y", optional: !0, filter: null },
        ...n
      },
      r,
      i
    ), this.width = o, this.height = a, this.pixelSize = HM(g, "pixelSize"), this.blur = HM(y, "blur"), this.interpolate = s == null || u == null ? null : Iyt(b);
  }
}
class wCe extends xCe {
  constructor(t, n = {}) {
    const { imageRendering: r } = n;
    if (t == null) {
      const { fill: i, fillOpacity: o } = n;
      ns(o)[0] !== void 0 && (n = vG("fillOpacity", n)), Df(i)[0] !== void 0 && (n = vG("fill", n));
    }
    super(t, void 0, n, $yt), this.imageRendering = ja(r, "auto");
  }
  // Ignore the color scale, so the fill channel is returned unscaled.
  scale(t, { color: n, ...r }, i) {
    return super.scale(t, r, i);
  }
  render(t, n, r, i, o) {
    var q;
    const a = n[(q = r.channels.fill) == null ? void 0 : q.scale] ?? ((te) => te), { x: s, y: u } = r, { document: l } = o, [f, h, p, g] = ECe(r, i, o), y = p - f, b = g - h, { pixelSize: _, width: S = Math.round(Math.abs(y) / _), height: C = Math.round(Math.abs(b) / _) } = this, A = S * C;
    let { fill: O, fillOpacity: R } = r, j = 0;
    if (this.interpolate) {
      const te = S / y, X = C / b, Z = jo(s, (H) => (H - f) * te, Float64Array), se = jo(u, (H) => (H - h) * X, Float64Array);
      O && (O = this.interpolate(t, S, C, Z, se, O)), R && (R = this.interpolate(t, S, C, Z, se, R));
    } else
      this.data == null && t && (j = t.fi * A);
    const $ = l.createElement("canvas");
    $.width = S, $.height = C;
    const z = $.getContext("2d"), W = z.createImageData(S, C), Y = W.data;
    let { r: V, g: ee, b: K } = Cf(this.fill) ?? { r: 0, g: 0, b: 0 }, Q = (this.fillOpacity ?? 1) * 255;
    for (let te = 0; te < A; ++te) {
      const X = te << 2;
      if (O) {
        const Z = a(O[te + j]);
        if (Z == null) {
          Y[X + 3] = 0;
          continue;
        }
        ({ r: V, g: ee, b: K } = Cf(Z));
      }
      R && (Q = R[te + j] * 255), Y[X + 0] = V, Y[X + 1] = ee, Y[X + 2] = K, Y[X + 3] = Q;
    }
    return this.blur > 0 && jrt(W, this.blur), z.putImageData(W, 0, 0), Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call(
      (te) => te.append("image").attr("transform", `translate(${f},${h}) scale(${Math.sign(p - f)},${Math.sign(g - h)})`).attr("width", Math.abs(y)).attr("height", Math.abs(b)).attr("preserveAspectRatio", "none").call(Fn, "image-rendering", this.imageRendering).call(Xo, this).attr("xlink:href", $.toDataURL())
    ).node();
  }
}
function _Ce(e, t, n) {
  arguments.length < 3 && (n = t, t = null);
  let { x: r, y: i, [e]: o, ...a } = n;
  return r === void 0 && i === void 0 && uht(t) && (r = F$, i = Pk, o === void 0 && (o = iht)), [t, { ...a, x: r, y: i, [e]: o }];
}
function Pyt() {
  const [e, t] = _Ce("fill", ...arguments);
  return new wCe(
    e,
    e == null || t.fill !== void 0 || t.fillOpacity !== void 0 ? t : { ...t, fill: Wn }
  );
}
function ECe({ x1: e, y1: t, x2: n, y2: r }, i, { projection: o }) {
  const { width: a, height: s, marginTop: u, marginRight: l, marginBottom: f, marginLeft: h } = i;
  return [
    e && o == null ? e[0] : h,
    t && o == null ? t[0] : u,
    n && o == null ? n[0] : a - l,
    r && o == null ? r[0] : s - f
  ];
}
function SCe({ x1: e, y1: t, x2: n, y2: r }, i, o, a) {
  const s = {};
  return e && (s.x1 = e), t && (s.y1 = t), n && (s.x2 = n), r && (s.y2 = r), ECe(tJ(s, i), o, a);
}
function vG(e, t = {}) {
  const { [e]: n } = t;
  if (typeof n != "function")
    throw new Error(`invalid ${e}: not a function`);
  return Of({ ...t, [e]: void 0 }, function(r, i, o, a, s, u) {
    const { x: l, y: f } = a;
    if (!l)
      throw new Error("missing scale: x");
    if (!f)
      throw new Error("missing scale: y");
    const [h, p, g, y] = SCe(o, a, s, u), b = g - h, _ = y - p, { pixelSize: S } = this, { width: C = Math.round(Math.abs(b) / S), height: A = Math.round(Math.abs(_) / S) } = t, O = new Array(C * A * (i ? i.length : 1)), R = b / C, j = _ / A;
    let $ = 0;
    for (const z of i ?? [void 0])
      for (let W = 0.5; W < A; ++W)
        for (let Y = 0.5; Y < C; ++Y, ++$)
          O[$] = n(l.invert(h + Y * R), f.invert(p + W * j), z);
    return { data: O, facets: i, channels: { [e]: { value: O, scale: "auto" } } };
  });
}
function Iyt(e) {
  if (typeof e == "function")
    return e;
  if (e == null)
    return bG;
  switch (`${e}`.toLowerCase()) {
    case "none":
      return bG;
    case "nearest":
      return TCe;
    case "barycentric":
      return MCe();
    case "random-walk":
      return CCe();
  }
  throw new Error(`invalid interpolate: ${e}`);
}
function bG(e, t, n, r, i, o) {
  const a = new Array(t * n);
  for (const s of e)
    r[s] < 0 || r[s] >= t || i[s] < 0 || i[s] >= n || (a[Math.floor(i[s]) * t + Math.floor(r[s])] = o[s]);
  return a;
}
function MCe({ random: e = gZ(42) } = {}) {
  return (t, n, r, i, o, a) => {
    const { points: s, triangles: u, hull: l } = wb.from(
      t,
      (g) => i[g],
      (g) => o[g]
    ), f = new a.constructor(n * r).fill(NaN), h = new Uint8Array(n * r), p = Uyt(a, e);
    for (let g = 0; g < u.length; g += 3) {
      const y = u[g], b = u[g + 1], _ = u[g + 2], S = s[2 * y], C = s[2 * b], A = s[2 * _], O = s[2 * y + 1], R = s[2 * b + 1], j = s[2 * _ + 1], $ = Math.min(S, C, A), z = Math.max(S, C, A), W = Math.min(O, R, j), Y = Math.max(O, R, j), V = (R - j) * (S - A) + (O - j) * (A - C);
      if (!V)
        continue;
      const ee = a[t[y]], K = a[t[b]], Q = a[t[_]];
      for (let q = Math.floor($); q < z; ++q)
        for (let te = Math.floor(W); te < Y; ++te) {
          if (q < 0 || q >= n || te < 0 || te >= r)
            continue;
          const X = q + 0.5, Z = te + 0.5, se = ((R - j) * (X - A) + (Z - j) * (A - C)) / V;
          if (se < 0)
            continue;
          const H = ((j - O) * (X - A) + (Z - j) * (S - A)) / V;
          if (H < 0)
            continue;
          const ie = 1 - se - H;
          if (ie < 0)
            continue;
          const he = q + n * te;
          f[he] = p(ee, se, K, H, Q, ie, q, te), h[he] = 1;
        }
    }
    return jyt(f, h, i, o, a, n, r, l, t, p), f;
  };
}
function jyt(e, t, n, r, i, o, a, s, u, l) {
  n = Float64Array.from(s, (g) => n[u[g]]), r = Float64Array.from(s, (g) => r[u[g]]), i = Array.from(s, (g) => i[u[g]]);
  const f = n.length, h = Array.from({ length: f }, (g, y) => zyt(y, n, r));
  let p = 0;
  for (let g = 0; g < a; ++g) {
    const y = g + 0.5;
    for (let b = 0; b < o; ++b) {
      const _ = b + o * g;
      if (!t[_]) {
        const S = b + 0.5;
        for (let C = 0; C < f; ++C) {
          const A = (f + p + (C % 2 ? (C + 1) / 2 : -C / 2)) % f;
          if (h[A](S, y)) {
            const O = Lyt(n.at(A - 1), r.at(A - 1), n[A], r[A], S, y);
            e[_] = l(i.at(A - 1), O, i[A], 1 - O, i[A], 0, b, g), p = A;
            break;
          }
        }
      }
    }
  }
}
function Lyt(e, t, n, r, i, o) {
  const a = n - e, s = r - t, u = a * (n - i) + s * (r - o), l = a * (i - e) + s * (o - t);
  return u > 0 && l > 0 ? u / (u + l) : +(u > l);
}
function eO(e, t, n, r) {
  return e * r - n * t;
}
function zyt(e, t, n) {
  const r = t.length, i = t.at(e - 2), o = n.at(e - 2), a = t.at(e - 1), s = n.at(e - 1), u = t[e], l = n[e], f = t.at(e + 1 - r), h = n.at(e + 1 - r), p = a - u, g = s - l, y = i - a, b = o - s, _ = u - f, S = l - h, C = Math.hypot(p, g), A = Math.hypot(y, b), O = Math.hypot(_, S);
  return (R, j) => {
    const $ = R - a, z = j - s, W = R - u, Y = j - l;
    return eO($, z, W, Y) > -1e-6 && eO($, z, p, g) * A - eO($, z, y, b) * C > -1e-6 && eO(W, Y, _, S) * C - eO(W, Y, p, g) * O <= 0;
  };
}
function TCe(e, t, n, r, i, o) {
  const a = new o.constructor(t * n), s = wb.from(
    e,
    (f) => r[f],
    (f) => i[f]
  );
  let u, l;
  for (let f = 0.5, h = 0; f < n; ++f) {
    l = u;
    for (let p = 0.5; p < t; ++p, ++h)
      l = s.find(p, f, l), p === 0.5 && (u = l), a[h] = o[e[l]];
  }
  return a;
}
function CCe({ random: e = gZ(42), minDistance: t = 0.5, maxSteps: n = 2 } = {}) {
  return (r, i, o, a, s, u) => {
    const l = new u.constructor(i * o), f = wb.from(
      r,
      (y) => a[y],
      (y) => s[y]
    );
    let h, p, g;
    for (let y = 0.5, b = 0; y < o; ++y) {
      p = h;
      for (let _ = 0.5; _ < i; ++_, ++b) {
        let S = _, C = y;
        g = p = f.find(S, C, p), _ === 0.5 && (h = p);
        let A, O = 0;
        for (; (A = Math.hypot(a[r[g]] - S, s[r[g]] - C)) > t && O < n; ) {
          const R = e(_, y, O) * 2 * Math.PI;
          S += Math.cos(R) * A, C += Math.sin(R) * A, g = f.find(S, C, g), ++O;
        }
        l[b] = u[r[g]];
      }
    }
    return l;
  };
}
function Fyt(e, t, n, r, i, o) {
  return t * e + r * n + o * i;
}
function Byt(e) {
  return (t, n, r, i, o, a, s, u) => {
    const l = e(s, u);
    return l < n ? t : l < n + i ? r : o;
  };
}
function Uyt(e, t) {
  return pT(e) || mp(e) ? Fyt : Byt(t);
}
function Yyt(e, t, n) {
  return {
    transform(r) {
      const i = r.length, o = new Float64Array(i), a = (t - e) / n, s = e + a / 2;
      for (let u = 0; u < i; ++u)
        o[u] = u % n * a + s;
      return o;
    }
  };
}
function Hyt(e, t, n, r) {
  return {
    transform(i) {
      const o = i.length, a = new Float64Array(o), s = (t - e) / r, u = e + s / 2;
      for (let l = 0; l < o; ++l)
        a[l] = Math.floor(l / n) % r * s + u;
      return a;
    }
  };
}
const hpe = {
  ariaLabel: "contour",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1,
  pixelSize: 2
};
let NCe = class extends xCe {
  constructor(t, { smooth: n = !0, value: r, ...i } = {}) {
    const o = dMe({}, i, hpe);
    if (r === void 0) {
      for (const s in o)
        if (o[s].value != null) {
          if (r !== void 0)
            throw new Error("ambiguous contour value");
          r = i[s], i[s] = "value";
        }
    }
    if (r != null) {
      const s = { transform: (u) => u.map((l) => l.value), label: Eb(r) };
      for (const u in o)
        i[u] === "value" && (i[u] = s);
    }
    if (t == null) {
      if (r == null)
        throw new Error("missing contour value");
      i = vG("value", { value: r, ...i }), r = null;
    } else {
      let { interpolate: s } = i;
      r === void 0 && (r = Wn), s === void 0 && (i.interpolate = "nearest");
    }
    super(t, { value: { value: r, optional: !0 } }, Vyt(i), hpe);
    const a = { geometry: { value: Wn } };
    for (const s in this.channels) {
      const u = this.channels[s], { scale: l } = u;
      l === "x" || l === "y" || s === "value" || (a[s] = u, delete this.channels[s]);
    }
    this.contourChannels = a, this.smooth = !!n;
  }
  filter(t, { x: n, y: r, value: i, ...o }, a) {
    return super.filter(t, o, a);
  }
  render(t, n, r, i, o) {
    const { geometry: a } = r, s = Cw();
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call((u) => {
      u.selectAll().data(t).enter().append("path").call(Xo, this).attr("d", (l) => s(a[l])).call(Qs, this, r);
    }).node();
  }
};
function Vyt({ thresholds: e, interval: t, ...n }) {
  return e = VTe(e, t, VK), Of(n, function(r, i, o, a, s, u) {
    const [l, f, h, p] = SCe(o, a, s, u), g = h - l, y = p - f, { pixelSize: b, width: _ = Math.round(Math.abs(g) / b), height: S = Math.round(Math.abs(y) / b) } = this, C = _ / g, A = S / y, O = o.value.value, R = [];
    if (this.interpolate) {
      const { x: Y, y: V } = r6(o, a, u), ee = jo(Y, (te) => (te - l) * C, Float64Array), K = jo(V, (te) => (te - f) * A, Float64Array), Q = [o.x, o.y, o.value], q = [ee, K, O];
      for (const te of i) {
        const X = this.filter(te, Q, q);
        R.push(this.interpolate(X, _, S, ee, K, O));
      }
    } else if (i) {
      const Y = _ * S, V = i.length;
      for (let ee = 0; ee < V; ++ee)
        R.push(O.slice(ee * Y, ee * Y + Y));
    } else
      R.push(O);
    if (this.blur > 0)
      for (const Y of R)
        o_e({ data: Y, width: _, height: S }, this.blur);
    const j = Wyt(e, O, ...Gyt(R));
    if (j === null)
      throw new Error(`unsupported thresholds: ${e}`);
    const { contour: $ } = Pq().size([_, S]).smooth(this.smooth), z = [], W = [];
    for (const Y of R)
      W.push(qo(z.length, z.push(...jo(j, (V) => $(Y, V)))));
    for (const { coordinates: Y } of z)
      for (const V of Y)
        for (const ee of V)
          for (const K of ee)
            K[0] = K[0] / C + l, K[1] = K[1] / A + f;
    return {
      data: z,
      facets: W,
      channels: aMe(this.contourChannels, z)
    };
  });
}
function Wyt(e, t, n, r) {
  if (typeof (e == null ? void 0 : e.range) == "function")
    return e.range(e.floor(n), r);
  if (typeof e == "function" && (e = e(t, n, r)), typeof e != "number")
    return Af(e);
  const i = Kx(...d_e(n, r, e), e);
  for (; i[i.length - 1] >= r; )
    i.pop();
  for (; i[1] < n; )
    i.shift();
  return i;
}
function qyt() {
  return new NCe(..._Ce("value", ...arguments));
}
function Gyt(e) {
  return [Oc(e, (t) => Oc(t, ppe)), Ha(e, (t) => Ha(t, ppe))];
}
function ppe(e) {
  return isFinite(e) ? e : NaN;
}
function Qyt(e, t) {
  return UJ(hJ, e, t);
}
function Xyt(e, t = {}) {
  return UJ(pJ, e, t);
}
function Kyt(e, t = {}) {
  return UJ(gJ, e, t);
}
function UJ(e, t, n = {}) {
  const { x: r, y: i, maxRadius: o } = n, a = e({ px: r, py: i, maxRadius: o }), s = [];
  r != null && s.push(ow(t, gpe("x", { ...a, inset: -6 }, n))), i != null && s.push(aw(t, gpe("y", { ...a, inset: -6 }, n))), r != null && s.push(xC(t, mpe("x", { ...a, dy: 9, frameAnchor: "bottom", lineAnchor: "top" }, n))), i != null && s.push(xC(t, mpe("y", { ...a, dx: -9, frameAnchor: "left", textAnchor: "end" }, n)));
  for (const u of s)
    u.ariaLabel = `crosshair ${u.ariaLabel}`;
  return Vg(...s);
}
function DCe(e, { channels: t, ...n }, { facet: r, facetAnchor: i, fx: o, fy: a, [e]: s, channels: u, transform: l, initializer: f }) {
  return {
    ...n,
    facet: r,
    facetAnchor: i,
    fx: o,
    fy: a,
    [e]: s,
    channels: { ...t, ...u },
    transform: l,
    initializer: Zyt(e, f)
  };
}
function Zyt(e, t) {
  return t == null ? t : function(n, r, { x: i, y: o, px: a, py: s, ...u }, ...l) {
    const { channels: { x: f, y: h, ...p } = {}, ...g } = t.call(this, n, r, { ...u, x: a, y: s }, ...l);
    return {
      channels: {
        ...p,
        ...f && { px: f, ...e === "x" && { x: f } },
        ...h && { py: h, ...e === "y" && { y: h } }
      },
      ...g
    };
  };
}
function gpe(e, t, n) {
  const {
    color: r = "currentColor",
    opacity: i = 0.2,
    ruleStroke: o = r,
    ruleStrokeOpacity: a = i,
    ruleStrokeWidth: s
  } = n;
  return {
    ...DCe(e, t, n),
    stroke: o,
    strokeOpacity: a,
    strokeWidth: s
  };
}
function mpe(e, t, n) {
  const {
    color: r = "currentColor",
    textFill: i = r,
    textFillOpacity: o,
    textStroke: a = "white",
    textStrokeOpacity: s,
    textStrokeWidth: u = 5
  } = n;
  return {
    ...DCe(e, t, Jyt(e, n)),
    fill: i,
    fillOpacity: o,
    stroke: a,
    strokeOpacity: s,
    strokeWidth: u
  };
}
function Jyt(e, t) {
  return Of(t, (n, r, i) => {
    var o;
    return { channels: { text: { value: (o = cMe(i, e)) == null ? void 0 : o.value } } };
  });
}
const evt = {
  ariaLabel: "delaunay link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
}, tvt = {
  ariaLabel: "delaunay mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
}, nvt = {
  ariaLabel: "hull",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeMiterlimit: 1
}, rvt = {
  ariaLabel: "voronoi",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
}, ivt = {
  ariaLabel: "voronoi mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
class ovt extends Co {
  constructor(t, n = {}) {
    const { x: r, y: i, z: o, curve: a, tension: s } = n;
    super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        z: { value: o, optional: !0 }
      },
      n,
      evt
    ), this.curve = SJ(a, s), yN(this, n);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, z: f } = r, { curve: h } = this, [p, g] = ov(this, i), y = u ? (C) => u[C] : Bd(p), b = l ? (C) => l[C] : Bd(g), _ = this;
    function S(C) {
      let A = -1;
      const O = [], R = {};
      for (const Q in r)
        R[Q] = [];
      const j = [], $ = [], z = [], W = [];
      function Y(Q, q) {
        Q = C[Q], q = C[q], O.push(++A), j[A] = y(Q), z[A] = b(Q), $[A] = y(q), W[A] = b(q);
        for (const te in r)
          R[te].push(r[te][q]);
      }
      const { halfedges: V, hull: ee, triangles: K } = wb.from(C, y, b);
      for (let Q = 0; Q < V.length; ++Q) {
        const q = V[Q];
        q > Q && Y(K[Q], K[q]);
      }
      for (let Q = 0; Q < ee.length; ++Q)
        Y(ee[Q], ee[(Q + 1) % ee.length]);
      Ix(this).selectAll().data(O).enter().append("path").call(Xo, _).attr("d", (Q) => {
        const q = H0(), te = h(q);
        return te.lineStart(), te.point(j[Q], z[Q]), te.point($[Q], W[Q]), te.lineEnd(), q;
      }).call(Qs, _, R).call(W$, _, R, o);
    }
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a, y: l && s }).call(
      f ? (C) => C.selectAll().data(xb(t, (A) => f[A]).values()).enter().append("g").each(S) : (C) => C.datum(t).each(S)
    ).node();
  }
}
class YJ extends Co {
  constructor(t, n = {}, r, i = ({ z: o }) => o) {
    const { x: o, y: a } = n;
    super(
      t,
      {
        x: { value: o, scale: "x", optional: !0 },
        y: { value: a, scale: "y", optional: !0 },
        z: { value: i(n), optional: !0 }
      },
      n,
      r
    );
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, z: f } = r, [h, p] = ov(this, i), g = u ? (S) => u[S] : Bd(h), y = l ? (S) => l[S] : Bd(p), b = this;
    function _(S) {
      const C = wb.from(S, g, y);
      Ix(this).append("path").datum(S[0]).call(Xo, b).attr("d", b._render(C, i)).call(Qs, b, r);
    }
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a, y: l && s }).call(
      f ? (S) => S.selectAll().data(xb(t, (C) => f[C]).values()).enter().append("g").each(_) : (S) => S.datum(t).each(_)
    ).node();
  }
}
class avt extends YJ {
  constructor(t, n = {}) {
    super(t, n, tvt), this.fill = "none";
  }
  _render(t) {
    return t.render();
  }
}
class svt extends YJ {
  constructor(t, n = {}) {
    super(t, n, nvt, Ow);
  }
  _render(t) {
    return t.renderHull();
  }
}
let uvt = class extends Co {
  constructor(t, n = {}) {
    const { x: r, y: i, z: o } = n;
    super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        z: { value: o, optional: !0 }
      },
      n,
      rvt
    );
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, z: f } = r, [h, p] = ov(this, i), g = u ? (S) => u[S] : Bd(h), y = l ? (S) => l[S] : Bd(p), b = this;
    function _(S) {
      const C = wb.from(S, g, y), A = ACe(C, i);
      Ix(this).selectAll().data(S).enter().append("path").call(Xo, b).attr("d", (O, R) => A.renderCell(R)).call(Qs, b, r);
    }
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a, y: l && s }).call(
      f ? (S) => S.selectAll().data(xb(t, (C) => f[C]).values()).enter().append("g").each(_) : (S) => S.datum(t).each(_)
    ).node();
  }
};
class lvt extends YJ {
  constructor(t, n) {
    super(t, n, ivt), this.fill = "none";
  }
  _render(t, n) {
    return ACe(t, n).render();
  }
}
function ACe(e, t) {
  const { width: n, height: r, marginTop: i, marginRight: o, marginBottom: a, marginLeft: s } = t;
  return e.voronoi([s, i, n - o, r - a]);
}
function Q$(e, t, { x: n, y: r, ...i } = {}) {
  return [n, r] = em(n, r), new e(t, { ...i, x: n, y: r });
}
function cvt(e, t) {
  return Q$(ovt, e, t);
}
function fvt(e, t) {
  return Q$(avt, e, t);
}
function dvt(e, t) {
  return Q$(svt, e, t);
}
function hvt(e, t) {
  return Q$(uvt, e, t);
}
function pvt(e, t) {
  return Q$(lvt, e, t);
}
const gvt = {
  ariaLabel: "density",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
let OCe = class extends Co {
  constructor(t, { x: n, y: r, z: i, weight: o, fill: a, stroke: s, ...u } = {}) {
    const l = ype(a) && (a = "currentColor", !0), f = ype(s) && (s = "currentColor", !0);
    super(
      t,
      {
        x: { value: n, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        z: { value: Ow({ z: i, fill: a, stroke: s }), optional: !0 },
        weight: { value: o, optional: !0 }
      },
      vvt({ ...u, fill: a, stroke: s }, l, f),
      gvt
    ), l && (this.fill = void 0), f && (this.stroke = void 0), this.z = i;
  }
  filter(t) {
    return t;
  }
  render(t, n, r, i, o) {
    const { contours: a } = r, s = Cw();
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, {}).call(
      (u) => u.selectAll().data(t).enter().append("path").call(Xo, this).call(Qs, this, r).attr("d", (l) => s(a[l]))
    ).node();
  }
};
function mvt(e, { x: t, y: n, ...r } = {}) {
  return [t, n] = em(t, n), new OCe(e, { ...r, x: t, y: n });
}
const yvt = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
function vvt(e, t, n) {
  let { bandwidth: i, thresholds: o } = e;
  return i = i === void 0 ? 20 : +i, o = o === void 0 ? 20 : typeof (o == null ? void 0 : o[Symbol.iterator]) == "function" ? xf(o) : +o, Of(e, function(a, s, u, l, f, h) {
    var K;
    const p = u.weight ? xf(u.weight.value) : null, g = (K = u.z) == null ? void 0 : K.value, { z: y } = this, [b, _] = ov(this, f), { width: S, height: C } = f, { x: A, y: O } = r6(u, l, h), R = Object.fromEntries(
      Object.entries(u).filter(([Q]) => !yvt.has(Q)).map(([Q, q]) => [Q, { ...q, value: [] }])
    ), j = t && [], $ = n && [], z = eut().x(A ? (Q) => A[Q] : b).y(O ? (Q) => O[Q] : _).weight(p ? (Q) => p[Q] : 1).size([S, C]).bandwidth(i), W = [];
    for (const Q of s) {
      const q = [];
      W.push(q);
      for (const te of g ? rJ(Q, g, y) : [Q]) {
        const X = z.contours(te);
        q.push([te, X]);
      }
    }
    let Y = o;
    if (!(Y instanceof yC)) {
      let Q = 0;
      for (const q of W)
        for (const [, te] of q) {
          const X = te.max;
          X > Q && (Q = X);
        }
      Y = Float64Array.from({ length: o - 1 }, (q, te) => Q * 100 * (te + 1) / o);
    }
    const V = [], ee = [];
    for (const Q of W) {
      const q = [];
      V.push(q);
      for (const [te, X] of Q)
        for (const Z of Y) {
          q.push(ee.length), ee.push(X(Z / 100)), j && j.push(Z), $ && $.push(Z);
          for (const se in R)
            R[se].value.push(u[se].value[te[0]]);
        }
    }
    return j && j.push(0), $ && $.push(0), {
      data: a,
      facets: V,
      channels: {
        ...R,
        ...j && { fill: { value: j, scale: "color" } },
        ...$ && { stroke: { value: $, scale: "color" } },
        contours: { value: ee }
      }
    };
  });
}
function ype(e) {
  return /^density$/i.test(e);
}
const bvt = {
  ariaLabel: "geo",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class RCe extends Co {
  constructor(t, n = {}) {
    const [r, i] = ns(n.r, 3);
    super(
      t,
      {
        geometry: { value: n.geometry, scale: "projection" },
        r: { value: r, scale: "r", filter: Z0, optional: !0 }
      },
      PJ(n),
      bvt
    ), this.r = i;
  }
  render(t, n, r, i, o) {
    const { geometry: a, r: s } = r, u = Cw(o.projection ?? xvt(n)), { r: l } = this;
    return qF(l) ? t = [] : l !== void 0 && u.pointRadius(l), Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call((f) => {
      f.selectAll().data(t).enter().append("path").call(Xo, this).attr("d", s ? (h) => u.pointRadius(s[h])(a[h]) : (h) => u(a[h])).call(Qs, this, r);
    }).node();
  }
}
function xvt({ x: e, y: t }) {
  if (e || t)
    return e ?? (e = (n) => n), t ?? (t = (n) => n), jL({
      point(n, r) {
        this.stream.point(e(n), t(r));
      }
    });
}
function HJ(e, { geometry: t = Wn, ...n } = {}) {
  switch (e == null ? void 0 : e.type) {
    case "FeatureCollection":
      e = e.features;
      break;
    case "GeometryCollection":
      e = e.geometries;
      break;
    case "Feature":
    case "LineString":
    case "MultiLineString":
    case "MultiPoint":
    case "MultiPolygon":
    case "Point":
    case "Polygon":
    case "Sphere":
      e = [e];
      break;
  }
  return new RCe(e, { geometry: t, ...n });
}
function wvt({ strokeWidth: e = 1.5, ...t } = {}) {
  return HJ({ type: "Sphere" }, { strokeWidth: e, ...t });
}
function _vt({ strokeOpacity: e = 0.1, ...t } = {}) {
  return HJ(Nlt(), { strokeOpacity: e, ...t });
}
const kR = 0.5, $R = 0;
function Evt(e = { fill: "count" }, { binWidth: t, ...n } = {}) {
  const { z: r } = n;
  return t = t === void 0 ? 20 : ti(t), e = QZ(e, n), Mx(e, "fill") && (n.channels = { ...n.channels, fill: { value: [] } }), n.symbol === void 0 && (n.symbol = "hexagon"), n.r === void 0 && !Mx(e, "r") && (n.r = t / 2), Of(n, (i, o, a, s, u, l) => {
    let { x: f, y: h, z: p, fill: g, stroke: y, symbol: b } = a;
    if (f === void 0)
      throw new Error("missing channel: x");
    if (h === void 0)
      throw new Error("missing channel: y");
    ({ x: f, y: h } = r6(a, s, l)), p = p ? p.value : Qr(i, r), g = g == null ? void 0 : g.value, y = y == null ? void 0 : y.value, b = b == null ? void 0 : b.value;
    const _ = ZZ(e, { z: p, fill: g, stroke: y, symbol: b }), S = p && [], C = g && [], A = y && [], O = b && [], R = [], j = [], $ = [];
    let z = -1;
    for (const ee of e)
      ee.initialize(i);
    for (const ee of o) {
      const K = [];
      for (const Q of e)
        Q.scope("facet", ee);
      for (const [Q, q] of OT(ee, _))
        for (const te of Svt(q, f, h, t)) {
          K.push(++z), j.push(te.x), $.push(te.y), p && S.push(_ === p ? Q : p[te[0]]), g && C.push(_ === g ? Q : g[te[0]]), y && A.push(_ === y ? Q : y[te[0]]), b && O.push(_ === b ? Q : b[te[0]]);
          for (const X of e)
            X.reduce(te);
        }
      R.push(K);
    }
    const W = a.x.scale, Y = a.y.scale, V = {
      x: { value: j, source: s[W] ? { value: jo(j, s[W].invert), scale: W } : null },
      y: { value: $, source: s[Y] ? { value: jo($, s[Y].invert), scale: Y } : null },
      ...p && { z: { value: S } },
      ...g && { fill: { value: C, scale: "auto" } },
      ...y && { stroke: { value: A, scale: "auto" } },
      ...b && { symbol: { value: O, scale: "auto" } },
      ...Object.fromEntries(
        e.map(({ name: ee, output: K }) => [
          ee,
          {
            scale: "auto",
            label: K.label,
            radius: ee === "r" ? t / 2 : void 0,
            value: K.transform()
          }
        ])
      )
    };
    return { data: i, facets: R, channels: V };
  });
}
function Svt(e, t, n, r) {
  const i = r * (1.5 / tMe), o = /* @__PURE__ */ new Map();
  for (const a of e) {
    let s = t[a], u = n[a];
    if (isNaN(s) || isNaN(u))
      continue;
    let l = Math.round(u = (u - $R) / i), f = Math.round(s = (s - kR) / r - (l & 1) / 2), h = u - l;
    if (Math.abs(h) * 3 > 1) {
      let y = s - f, b = f + (s < f ? -1 : 1) / 2, _ = l + (u < l ? -1 : 1), S = s - b, C = u - _;
      y * y + h * h > S * S + C * C && (f = b + (l & 1 ? 1 : -1) / 2, l = _);
    }
    const p = `${f},${l}`;
    let g = o.get(p);
    g === void 0 && (o.set(p, g = []), g.x = (f + (l & 1) / 2) * r + kR, g.y = l * i + $R), g.push(a);
  }
  return o.values();
}
const Mvt = {
  ariaLabel: "hexgrid",
  fill: "none",
  stroke: "currentColor",
  strokeOpacity: 0.1
};
function Tvt(e) {
  return new kCe(e);
}
class kCe extends Co {
  constructor({ binWidth: t = 20, clip: n = !0, ...r } = {}) {
    super(RR, void 0, { clip: n, ...r }, Mvt), this.binWidth = ti(t);
  }
  render(t, n, r, i, o) {
    const { binWidth: a } = this, { marginTop: s, marginRight: u, marginBottom: l, marginLeft: f, width: h, height: p } = i, g = f - kR, y = h - u - kR, b = s - $R, _ = p - l - $R, S = a / 2, C = S * nMe, A = C / 2, O = S * 2, R = C * 1.5, j = Math.floor(g / O), $ = Math.ceil(y / O), z = Math.floor((b + A) / R), W = Math.ceil((_ - A) / R) + 1, Y = `m0,${rx(-C)}l${rx(S)},${rx(A)}v${rx(C)}l${rx(-S)},${rx(A)}`;
    let V = Y;
    for (let ee = z; ee < W; ++ee)
      for (let K = j; K < $; ++K)
        V += `M${rx(K * O + (ee & 1) * S)},${rx(ee * R)}${Y}`;
    return Yi("svg:g", o).datum(0).call(sa, this, i, o).call(To, this, {}, Ju + kR, Ju + $R).call((ee) => ee.append("path").call(Xo, this).call(Qs, this, r).attr("d", V)).node();
  }
}
function rx(e) {
  return Math.round(e * 1e3) / 1e3;
}
const Cvt = {
  ariaLabel: "image",
  fill: null,
  stroke: null
};
function Nvt(e) {
  return /^\.*\//.test(e);
}
function Dvt(e) {
  return /^(blob|data|file|http|https):/i.test(e);
}
function Avt(e) {
  return typeof e == "string" && (Nvt(e) || Dvt(e)) ? [void 0, e] : [e, void 0];
}
let $Ce = class extends Co {
  constructor(t, n = {}) {
    let { x: r, y: i, r: o, width: a, height: s, rotate: u, src: l, preserveAspectRatio: f, crossOrigin: h, frameAnchor: p, imageRendering: g } = n;
    o == null && (o = void 0), o === void 0 && a === void 0 && s === void 0 ? a = s = 16 : a === void 0 && s !== void 0 ? a = s : s === void 0 && a !== void 0 && (s = a);
    const [y, b] = Avt(l), [_, S] = ns(o), [C, A] = ns(a, S !== void 0 ? S * 2 : void 0), [O, R] = ns(s, S !== void 0 ? S * 2 : void 0), [j, $] = ns(u, 0);
    super(
      t,
      {
        x: { value: r, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        r: { value: _, scale: "r", filter: Z0, optional: !0 },
        width: { value: C, filter: Z0, optional: !0 },
        height: { value: O, filter: Z0, optional: !0 },
        rotate: { value: j, optional: !0 },
        src: { value: y, optional: !0 }
      },
      PJ(n),
      Cvt
    ), this.src = b, this.width = A, this.rotate = $, this.height = R, this.r = S, this.preserveAspectRatio = ja(f, "xMidYMid"), this.crossOrigin = Ll(h), this.frameAnchor = Y$(p), this.imageRendering = ja(g, "auto");
  }
  render(t, n, r, i, o) {
    const { x: a, y: s } = n, { x: u, y: l, width: f, height: h, r: p, rotate: g, src: y } = r, { r: b, width: _, height: S, rotate: C } = this, [A, O] = ov(this, i);
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, { x: u && a, y: l && s }).call(
      (R) => R.selectAll().data(t).enter().append("image").call(Xo, this).attr("x", vpe(u, f, p, A, _, b)).attr("y", vpe(l, h, p, O, S, b)).attr("width", f ? (j) => f[j] : _ !== void 0 ? _ : p ? (j) => p[j] * 2 : b * 2).attr("height", h ? (j) => h[j] : S !== void 0 ? S : p ? (j) => p[j] * 2 : b * 2).attr("transform", g ? (j) => `rotate(${g[j]})` : C ? `rotate(${C})` : null).attr("transform-origin", g || C ? u6`${u ? (j) => u[j] : A}px ${l ? (j) => l[j] : O}px` : null).call(Fn, "href", y ? (j) => y[j] : this.src).call(Fn, "preserveAspectRatio", this.preserveAspectRatio).call(Fn, "crossorigin", this.crossOrigin).call(Fn, "image-rendering", this.imageRendering).call(Fn, "clip-path", p ? (j) => `circle(${p[j]}px)` : b !== void 0 ? `circle(${b}px)` : null).call(Qs, this, r)
    ).node();
  }
};
function vpe(e, t, n, r, i, o) {
  return t && e ? (a) => e[a] - t[a] / 2 : t ? (a) => r - t[a] / 2 : e && i !== void 0 ? (a) => e[a] - i / 2 : i !== void 0 ? r - i / 2 : n && e ? (a) => e[a] - n[a] : n ? (a) => r - n[a] : e ? (a) => e[a] - o : r - o;
}
function Ovt(e, { x: t, y: n, ...r } = {}) {
  return r.frameAnchor === void 0 && ([t, n] = em(t, n)), new $Ce(e, { ...r, x: t, y: n });
}
function Rvt(e, t, n) {
  var r = 1e-8, i = t - 1, o = n - 1, a = 0, s, u, l, f, h, p, g, y, b, _, S;
  if (e <= 0)
    return 0;
  if (e >= 1)
    return 1;
  for (t >= 1 && n >= 1 ? (l = e < 0.5 ? e : 1 - e, f = Math.sqrt(-2 * Math.log(l)), g = (2.30753 + f * 0.27061) / (1 + f * (0.99229 + f * 0.04481)) - f, e < 0.5 && (g = -g), y = (g * g - 3) / 6, b = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), _ = g * Math.sqrt(y + b) / b - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (y + 5 / 6 - 2 / (3 * b)), g = t / (t + n * Math.exp(2 * _))) : (s = Math.log(t / (t + n)), u = Math.log(n / (t + n)), f = Math.exp(t * s) / t, h = Math.exp(n * u) / n, _ = f + h, e < f / _ ? g = Math.pow(t * _ * e, 1 / t) : g = 1 - Math.pow(n * _ * (1 - e), 1 / n)), S = -kT(t) - kT(n) + kT(t + n); a < 10; a++) {
    if (g === 0 || g === 1)
      return g;
    if (p = kvt(g, t, n) - e, f = Math.exp(i * Math.log(g) + o * Math.log(1 - g) + S), h = p / f, g -= f = h / (1 - 0.5 * Math.min(1, h * (i / g - o / (1 - g)))), g <= 0 && (g = 0.5 * (g + f)), g >= 1 && (g = 0.5 * (g + f + 1)), Math.abs(f) < r * g && a > 0)
      break;
  }
  return g;
}
function kvt(e, t, n) {
  var r = e === 0 || e === 1 ? 0 : Math.exp(kT(t + n) - kT(t) - kT(n) + t * Math.log(e) + n * Math.log(1 - e));
  return e < 0 || e > 1 ? !1 : e < (t + 1) / (t + n + 2) ? r * bpe(e, t, n) / t : 1 - r * bpe(1 - e, n, t) / n;
}
function bpe(e, t, n) {
  var r = 1e-30, i = 1, o = t + n, a = t + 1, s = t - 1, u = 1, l = 1 - o * e / a, f, h, p, g;
  for (Math.abs(l) < r && (l = r), l = 1 / l, g = l; i <= 100 && (f = 2 * i, h = i * (n - i) * e / ((s + f) * (t + f)), l = 1 + h * l, Math.abs(l) < r && (l = r), u = 1 + h / u, Math.abs(u) < r && (u = r), l = 1 / l, g *= l * u, h = -(t + i) * (o + i) * e / ((t + f) * (a + f)), l = 1 + h * l, Math.abs(l) < r && (l = r), u = 1 + h / u, Math.abs(u) < r && (u = r), l = 1 / l, p = l * u, g *= p, !(Math.abs(p - 1) < 3e-7)); i++)
    ;
  return g;
}
function kT(e) {
  var t = 0, n = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ], r = 1.000000000190015, i, o, a;
  for (a = (o = i = e) + 5.5, a -= (i + 0.5) * Math.log(a); t < 6; t++)
    r += n[t] / ++o;
  return Math.log(2.506628274631 * r / i) - a;
}
function $vt(e, t) {
  var n = Rvt(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
  return n = Math.sqrt(t * (1 - n) / n), e > 0.5 ? n : -n;
}
const Pvt = {
  ariaLabel: "linear-regression",
  fill: "currentColor",
  fillOpacity: 0.1,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class PCe extends Co {
  constructor(t, n = {}) {
    const { x: r, y: i, z: o, ci: a = 0.95, precision: s = 4 } = n;
    if (super(
      t,
      {
        x: { value: r, scale: "x" },
        y: { value: i, scale: "y" },
        z: { value: Ow(n), optional: !0 }
      },
      n,
      Pvt
    ), this.z = o, this.ci = +a, this.precision = +s, !(0 <= this.ci && this.ci < 1))
      throw new Error(`invalid ci; not in [0, 1): ${a}`);
    if (!(this.precision > 0))
      throw new Error(`invalid precision: ${s}`);
  }
  render(t, n, r, i, o) {
    const { x: a, y: s, z: u } = r, { ci: l } = this;
    return Yi("svg:g", o).call(sa, this, i, o).call(To, this, n).call(
      (f) => f.selectAll().data(u ? rJ(t, u, this.z) : [t]).enter().call(
        (h) => h.append("path").attr("fill", "none").call(Xo, this).call(XL, this, { ...r, fill: null, fillOpacity: null }).attr("d", (p) => this._renderLine(p, a, s)).call(
          l && !vC(this.fill) ? (p) => p.select(Ivt).attr("stroke", "none").call(Xo, this).call(XL, this, {
            ...r,
            stroke: null,
            strokeOpacity: null,
            strokeWidth: null
          }).attr("d", (g) => this._renderBand(g, a, s)) : () => {
          }
        )
      )
    ).node();
  }
}
function Ivt() {
  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(SS.svg, "path"), this);
}
class jvt extends PCe {
  constructor(t, n) {
    super(t, n);
  }
  _renderBand(t, n, r) {
    const { ci: i, precision: o } = this, [a, s] = Zu(t, (f) => r[f]), u = i5(t, r, n), l = ICe(t, r, n, (1 - i) / 2, u);
    return M$().y((f) => f).x0((f) => l(f, -1)).x1((f) => l(f, 1))(qo(a, s - o / 2, o).concat(s));
  }
  _renderLine(t, n, r) {
    const [i, o] = Zu(t, (s) => r[s]), a = i5(t, r, n);
    return `M${a(i)},${i}L${a(o)},${o}`;
  }
}
class Lvt extends PCe {
  constructor(t, n) {
    super(t, n);
  }
  _renderBand(t, n, r) {
    const { ci: i, precision: o } = this, [a, s] = Zu(t, (f) => n[f]), u = i5(t, n, r), l = ICe(t, n, r, (1 - i) / 2, u);
    return M$().x((f) => f).y0((f) => l(f, -1)).y1((f) => l(f, 1))(qo(a, s - o / 2, o).concat(s));
  }
  _renderLine(t, n, r) {
    const [i, o] = Zu(t, (s) => n[s]), a = i5(t, n, r);
    return `M${i},${a(i)}L${o},${a(o)}`;
  }
}
function zvt(e, { y: t = zf, x: n = Wn, stroke: r, fill: i = Ba(r) ? "currentColor" : r, ...o } = {}) {
  return new jvt(e, TJ({ ...o, x: n, y: t, fill: i, stroke: r }));
}
function Fvt(e, { x: t = zf, y: n = Wn, stroke: r, fill: i = Ba(r) ? "currentColor" : r, ...o } = {}) {
  return new Lvt(e, MJ({ ...o, x: t, y: n, fill: i, stroke: r }));
}
function i5(e, t, n) {
  let r = 0, i = 0, o = 0, a = 0;
  for (const f of e) {
    const h = t[f], p = n[f];
    r += h, i += p, o += h * p, a += h * h;
  }
  const s = e.length, u = (s * o - r * i) / (s * a - r * r), l = (i - u * r) / s;
  return (f) => u * f + l;
}
function ICe(e, t, n, r, i) {
  const o = fp(e, (f) => t[f]) / e.length;
  let a = 0, s = 0;
  for (const f of e)
    a += (t[f] - o) ** 2, s += (n[f] - i(t[f])) ** 2;
  const u = Math.sqrt(s / (e.length - 2)), l = $vt(r, e.length - 2);
  return (f, h) => {
    const p = i(f), g = u * Math.sqrt(1 / e.length + (f - o) ** 2 / a);
    return p + h * l * g;
  };
}
function xG({
  path: e = Wn,
  // the delimited path
  delimiter: t,
  // how the path is separated
  frameAnchor: n,
  treeLayout: r = Ok,
  treeSort: i,
  treeSeparation: o,
  treeAnchor: a,
  treeFilter: s,
  ...u
} = {}) {
  a = VJ(a), i = LCe(i), s != null && (s = wG(s)), n === void 0 && (n = a.frameAnchor);
  const l = zCe(t), f = VCe(u, wG), [h, p] = Cd(), [g, y] = Cd();
  return {
    x: h,
    y: g,
    frameAnchor: n,
    ...iv(u, (b, _) => {
      const S = l(Qr(b, e)), C = p([]), A = y([]);
      let O = -1;
      const R = [], j = [], $ = BL().path((W) => S[W]), z = r();
      z.nodeSize && z.nodeSize([1, 1]), z.separation && o !== void 0 && z.separation(o ?? kZ);
      for (const W of f)
        W[o5] = W[YCe]([]);
      for (const W of _) {
        const Y = [], V = $(W.filter((ee) => S[ee] != null)).each((ee) => ee.data = b[ee.data]);
        i != null && V.sort(i), z(V);
        for (const ee of V.descendants())
          if (!(s != null && !s(ee))) {
            Y.push(++O), R[O] = ee.data, a.position(ee, O, C, A);
            for (const K of f)
              K[o5][O] = K[HCe](ee);
          }
        j.push(Y);
      }
      return { data: R, facets: j };
    }),
    ...Object.fromEntries(f)
  };
}
function jCe({
  path: e = Wn,
  // the delimited path
  delimiter: t,
  // how the path is separated
  curve: n = "bump-x",
  stroke: r = "#555",
  strokeWidth: i = 1.5,
  strokeOpacity: o = 0.5,
  treeLayout: a = Ok,
  treeSort: s,
  treeSeparation: u,
  treeAnchor: l,
  treeFilter: f,
  ...h
} = {}) {
  l = VJ(l), s = LCe(s), f != null && (f = wpe(f)), h = { curve: n, stroke: r, strokeWidth: i, strokeOpacity: o, ...h };
  const p = zCe(t), g = VCe(h, wpe), [y, b] = Cd(), [_, S] = Cd(), [C, A] = Cd(), [O, R] = Cd();
  return {
    x1: y,
    x2: _,
    y1: C,
    y2: O,
    ...iv(h, (j, $) => {
      const z = p(Qr(j, e)), W = b([]), Y = S([]), V = A([]), ee = R([]);
      let K = -1;
      const Q = [], q = [], te = BL().path((Z) => z[Z]), X = a();
      X.nodeSize && X.nodeSize([1, 1]), X.separation && u !== void 0 && X.separation(u ?? kZ);
      for (const Z of g)
        Z[o5] = Z[YCe]([]);
      for (const Z of $) {
        const se = [], H = te(Z.filter((ie) => z[ie] != null)).each((ie) => ie.data = j[ie.data]);
        s != null && H.sort(s), X(H);
        for (const { source: ie, target: he } of H.links())
          if (!(f != null && !f(he, ie))) {
            se.push(++K), Q[K] = he.data, l.position(ie, K, W, V), l.position(he, K, Y, ee);
            for (const ye of g)
              ye[o5][K] = ye[HCe](he, ie);
          }
        q.push(se);
      }
      return { data: Q, facets: q };
    }),
    ...Object.fromEntries(g)
  };
}
function VJ(e = "left") {
  switch (`${e}`.trim().toLowerCase()) {
    case "left":
      return Bvt;
    case "right":
      return Uvt;
  }
  throw new Error(`invalid tree anchor: ${e}`);
}
const Bvt = {
  frameAnchor: "left",
  dx: 6,
  position({ x: e, y: t }, n, r, i) {
    r[n] = t, i[n] = -e;
  }
}, Uvt = {
  frameAnchor: "right",
  dx: -6,
  position({ x: e, y: t }, n, r, i) {
    r[n] = -t, i[n] = -e;
  }
};
function LCe(e) {
  return e == null || typeof e == "function" ? e : `${e}`.trim().toLowerCase().startsWith("node:") ? xpe(wG(e)) : xpe(Yvt(e));
}
function xpe(e) {
  return (t, n) => gp(e(t), e(n));
}
function Yvt(e) {
  return (t) => {
    var n;
    return (n = t.data) == null ? void 0 : n[e];
  };
}
function zCe(e = "/") {
  return `${e}` == "/" ? (t) => t : (t) => t.map(Hvt(e, "/"));
}
function Hvt(e, t) {
  return e = new RegExp(Vvt(e), "g"), (n) => n == null ? null : `${n}`.replace(e, t);
}
function Vvt(e) {
  return `${e}`.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
function FCe(e) {
  return Jg(e) && typeof e.node == "function";
}
function Wvt(e) {
  return Jg(e) && typeof e.link == "function";
}
function wG(e) {
  if (FCe(e))
    return e.node;
  if (e = `${e}`.trim().toLowerCase(), !!e.startsWith("node:")) {
    switch (e) {
      case "node:name":
        return EG;
      case "node:path":
        return _G;
      case "node:internal":
        return BCe;
      case "node:external":
        return UCe;
      case "node:depth":
        return SG;
      case "node:height":
        return MG;
    }
    throw new Error(`invalid node value: ${e}`);
  }
}
function wpe(e) {
  if (FCe(e))
    return e.node;
  if (Wvt(e))
    return e.link;
  if (e = `${e}`.trim().toLowerCase(), !(!e.startsWith("node:") && !e.startsWith("parent:"))) {
    switch (e) {
      case "parent:name":
        return p3(EG);
      case "parent:path":
        return p3(_G);
      case "parent:depth":
        return p3(SG);
      case "parent:height":
        return p3(MG);
      case "node:name":
        return EG;
      case "node:path":
        return _G;
      case "node:internal":
        return BCe;
      case "node:external":
        return UCe;
      case "node:depth":
        return SG;
      case "node:height":
        return MG;
    }
    throw new Error(`invalid link value: ${e}`);
  }
}
function _G(e) {
  return e.id;
}
function EG(e) {
  return qvt(e.id);
}
function SG(e) {
  return e.depth;
}
function MG(e) {
  return e.height;
}
function BCe(e) {
  return !!e.children;
}
function UCe(e) {
  return !e.children;
}
function p3(e) {
  return (t, n) => n == null ? void 0 : e(n);
}
function qvt(e) {
  let t = e.length;
  for (; --t > 0 && !Gvt(e, t); )
    ;
  return e.slice(t + 1);
}
function Gvt(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if (!(n & 1))
      return !0;
  }
  return !1;
}
const YCe = 2, HCe = 3, o5 = 4;
function VCe(e, t) {
  const n = [];
  for (const r in e) {
    const i = e[r], o = t(i);
    o !== void 0 && n.push([r, ...Cd(i), o]);
  }
  return n;
}
function WCe(e, {
  fill: t,
  stroke: n,
  strokeWidth: r,
  strokeOpacity: i,
  strokeLinejoin: o,
  strokeLinecap: a,
  strokeMiterlimit: s,
  strokeDasharray: u,
  strokeDashoffset: l,
  marker: f,
  markerStart: h = f,
  markerEnd: p = f,
  dot: g = Ba(h) && Ba(p),
  text: y = "node:name",
  textStroke: b = "white",
  title: _ = "node:path",
  dx: S,
  dy: C,
  textAnchor: A,
  treeLayout: O = Ok,
  textLayout: R = O === Ok || O === hZ ? "mirrored" : "normal",
  tip: j,
  ...$
} = {}) {
  if (S === void 0 && (S = VJ($.treeAnchor).dx), A !== void 0)
    throw new Error("textAnchor is not a configurable tree option");
  R = Sp(R, "textLayout", ["mirrored", "normal"]);
  function z(W) {
    return xC(
      e,
      xG({
        treeLayout: O,
        text: y,
        fill: t === void 0 ? "currentColor" : t,
        stroke: b,
        dx: S,
        dy: C,
        title: _,
        ...W,
        ...$
      })
    );
  }
  return Vg(
    rCe(
      e,
      jCe({
        treeLayout: O,
        markerStart: h,
        markerEnd: p,
        stroke: n !== void 0 ? n : t === void 0 ? "node:internal" : t,
        strokeWidth: r,
        strokeOpacity: i,
        strokeLinejoin: o,
        strokeLinecap: a,
        strokeMiterlimit: s,
        strokeDasharray: u,
        strokeDashoffset: l,
        ...$
      })
    ),
    g ? $w(e, xG({ treeLayout: O, fill: t === void 0 ? "node:internal" : t, title: _, tip: j, ...$ })) : null,
    y != null ? R === "mirrored" ? [
      z({ textAnchor: "start", treeFilter: "node:external" }),
      z({ textAnchor: "end", treeFilter: "node:internal", dx: -S })
    ] : z() : null
  );
}
function Qvt(e, t) {
  return WCe(e, { ...t, treeLayout: hZ });
}
function Xvt({ geometry: e = Wn, ...t } = {}) {
  return Of({ ...t, x: null, y: null }, (n, r, i, o, a, { projection: s }) => {
    const u = Qr(n, e), l = u.length, f = new Float64Array(l), h = new Float64Array(l), p = Cw(s);
    for (let g = 0; g < l; ++g)
      [f[g], h[g]] = p.centroid(u[g]);
    return {
      data: n,
      facets: r,
      channels: {
        x: { value: f, scale: s == null ? "x" : null, source: null },
        y: { value: h, scale: s == null ? "y" : null, source: null }
      }
    };
  });
}
function Kvt({ geometry: e = Wn, ...t } = {}) {
  let n;
  return {
    ...t,
    x: { transform: (r) => Float64Array.from(n = Qr(Qr(r, e), mlt), ([i]) => i) },
    y: { transform: () => Float64Array.from(n, ([, r]) => r) }
  };
}
function Zvt(e, t, n, r, i) {
  for (var o = i + 1; r <= i; ) {
    var a = r + i >>> 1, s = e[a], u = n !== void 0 ? n(s, t) : s - t;
    u >= 0 ? (o = a, i = a - 1) : r = a + 1;
  }
  return o;
}
function Jvt(e, t, n, r, i) {
  for (var o = i + 1; r <= i; ) {
    var a = r + i >>> 1, s = e[a], u = n !== void 0 ? n(s, t) : s - t;
    u > 0 ? (o = a, i = a - 1) : r = a + 1;
  }
  return o;
}
function e0t(e, t, n, r, i) {
  for (var o = r - 1; r <= i; ) {
    var a = r + i >>> 1, s = e[a], u = n !== void 0 ? n(s, t) : s - t;
    u < 0 ? (o = a, r = a + 1) : i = a - 1;
  }
  return o;
}
function t0t(e, t, n, r, i) {
  for (var o = r - 1; r <= i; ) {
    var a = r + i >>> 1, s = e[a], u = n !== void 0 ? n(s, t) : s - t;
    u <= 0 ? (o = a, r = a + 1) : i = a - 1;
  }
  return o;
}
function n0t(e, t, n, r, i) {
  for (; r <= i; ) {
    var o = r + i >>> 1, a = e[o], s = n !== void 0 ? n(a, t) : a - t;
    if (s === 0)
      return o;
    s <= 0 ? r = o + 1 : i = o - 1;
  }
  return -1;
}
function tO(e, t, n, r, i, o) {
  return typeof n == "function" ? o(e, t, n, r === void 0 ? 0 : r | 0, i === void 0 ? e.length - 1 : i | 0) : o(e, t, void 0, n === void 0 ? 0 : n | 0, r === void 0 ? e.length - 1 : r | 0);
}
var r0t = {
  ge: function(e, t, n, r, i) {
    return tO(e, t, n, r, i, Zvt);
  },
  gt: function(e, t, n, r, i) {
    return tO(e, t, n, r, i, Jvt);
  },
  lt: function(e, t, n, r, i) {
    return tO(e, t, n, r, i, e0t);
  },
  le: function(e, t, n, r, i) {
    return tO(e, t, n, r, i, t0t);
  },
  eq: function(e, t, n, r, i) {
    return tO(e, t, n, r, i, n0t);
  }
}, a5 = r0t, mT = 0, ME = 1, cj = 2, i0t = a0t;
function WJ(e, t, n, r, i) {
  this.mid = e, this.left = t, this.right = n, this.leftPoints = r, this.rightPoints = i, this.count = (t ? t.count : 0) + (n ? n.count : 0) + r.length;
}
var X$ = WJ.prototype;
function YH(e, t) {
  e.mid = t.mid, e.left = t.left, e.right = t.right, e.leftPoints = t.leftPoints, e.rightPoints = t.rightPoints, e.count = t.count;
}
function qCe(e, t) {
  var n = SC(t);
  e.mid = n.mid, e.left = n.left, e.right = n.right, e.leftPoints = n.leftPoints, e.rightPoints = n.rightPoints, e.count = n.count;
}
function _pe(e, t) {
  var n = e.intervals([]);
  n.push(t), qCe(e, n);
}
function Epe(e, t) {
  var n = e.intervals([]), r = n.indexOf(t);
  return r < 0 ? mT : (n.splice(r, 1), qCe(e, n), ME);
}
X$.intervals = function(e) {
  return e.push.apply(e, this.leftPoints), this.left && this.left.intervals(e), this.right && this.right.intervals(e), e;
};
X$.insert = function(e) {
  var t = this.count - this.leftPoints.length;
  if (this.count += 1, e[1] < this.mid)
    this.left ? 4 * (this.left.count + 1) > 3 * (t + 1) ? _pe(this, e) : this.left.insert(e) : this.left = SC([e]);
  else if (e[0] > this.mid)
    this.right ? 4 * (this.right.count + 1) > 3 * (t + 1) ? _pe(this, e) : this.right.insert(e) : this.right = SC([e]);
  else {
    var n = a5.ge(this.leftPoints, e, qJ), r = a5.ge(this.rightPoints, e, GJ);
    this.leftPoints.splice(n, 0, e), this.rightPoints.splice(r, 0, e);
  }
};
X$.remove = function(e) {
  var t = this.count - this.leftPoints;
  if (e[1] < this.mid) {
    if (!this.left)
      return mT;
    var n = this.right ? this.right.count : 0;
    if (4 * n > 3 * (t - 1))
      return Epe(this, e);
    var r = this.left.remove(e);
    return r === cj ? (this.left = null, this.count -= 1, ME) : (r === ME && (this.count -= 1), r);
  } else if (e[0] > this.mid) {
    if (!this.right)
      return mT;
    var i = this.left ? this.left.count : 0;
    if (4 * i > 3 * (t - 1))
      return Epe(this, e);
    var r = this.right.remove(e);
    return r === cj ? (this.right = null, this.count -= 1, ME) : (r === ME && (this.count -= 1), r);
  } else {
    if (this.count === 1)
      return this.leftPoints[0] === e ? cj : mT;
    if (this.leftPoints.length === 1 && this.leftPoints[0] === e) {
      if (this.left && this.right) {
        for (var o = this, a = this.left; a.right; )
          o = a, a = a.right;
        if (o === this)
          a.right = this.right;
        else {
          var s = this.left, r = this.right;
          o.count -= a.count, o.right = a.left, a.left = s, a.right = r;
        }
        YH(this, a), this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
      } else
        this.left ? YH(this, this.left) : YH(this, this.right);
      return ME;
    }
    for (var s = a5.ge(this.leftPoints, e, qJ); s < this.leftPoints.length && this.leftPoints[s][0] === e[0]; ++s)
      if (this.leftPoints[s] === e) {
        this.count -= 1, this.leftPoints.splice(s, 1);
        for (var r = a5.ge(this.rightPoints, e, GJ); r < this.rightPoints.length && this.rightPoints[r][1] === e[1]; ++r)
          if (this.rightPoints[r] === e)
            return this.rightPoints.splice(r, 1), ME;
      }
    return mT;
  }
};
function GCe(e, t, n) {
  for (var r = 0; r < e.length && e[r][0] <= t; ++r) {
    var i = n(e[r]);
    if (i)
      return i;
  }
}
function QCe(e, t, n) {
  for (var r = e.length - 1; r >= 0 && e[r][1] >= t; --r) {
    var i = n(e[r]);
    if (i)
      return i;
  }
}
function XCe(e, t) {
  for (var n = 0; n < e.length; ++n) {
    var r = t(e[n]);
    if (r)
      return r;
  }
}
X$.queryPoint = function(e, t) {
  if (e < this.mid) {
    if (this.left) {
      var n = this.left.queryPoint(e, t);
      if (n)
        return n;
    }
    return GCe(this.leftPoints, e, t);
  } else if (e > this.mid) {
    if (this.right) {
      var n = this.right.queryPoint(e, t);
      if (n)
        return n;
    }
    return QCe(this.rightPoints, e, t);
  } else
    return XCe(this.leftPoints, t);
};
X$.queryInterval = function(e, t, n) {
  if (e < this.mid && this.left) {
    var r = this.left.queryInterval(e, t, n);
    if (r)
      return r;
  }
  if (t > this.mid && this.right) {
    var r = this.right.queryInterval(e, t, n);
    if (r)
      return r;
  }
  return t < this.mid ? GCe(this.leftPoints, t, n) : e > this.mid ? QCe(this.rightPoints, e, n) : XCe(this.leftPoints, n);
};
function o0t(e, t) {
  return e - t;
}
function qJ(e, t) {
  var n = e[0] - t[0];
  return n || e[1] - t[1];
}
function GJ(e, t) {
  var n = e[1] - t[1];
  return n || e[0] - t[0];
}
function SC(e) {
  if (e.length === 0)
    return null;
  for (var t = [], n = 0; n < e.length; ++n)
    t.push(e[n][0], e[n][1]);
  t.sort(o0t);
  for (var r = t[t.length >> 1], i = [], o = [], a = [], n = 0; n < e.length; ++n) {
    var s = e[n];
    s[1] < r ? i.push(s) : r < s[0] ? o.push(s) : a.push(s);
  }
  var u = a, l = a.slice();
  return u.sort(qJ), l.sort(GJ), new WJ(
    r,
    SC(i),
    SC(o),
    u,
    l
  );
}
function TG(e) {
  this.root = e;
}
var _N = TG.prototype;
_N.insert = function(e) {
  this.root ? this.root.insert(e) : this.root = new WJ(e[0], null, null, [e], [e]);
};
_N.remove = function(e) {
  if (this.root) {
    var t = this.root.remove(e);
    return t === cj && (this.root = null), t !== mT;
  }
  return !1;
};
_N.queryPoint = function(e, t) {
  if (this.root)
    return this.root.queryPoint(e, t);
};
_N.queryInterval = function(e, t, n) {
  if (e <= t && this.root)
    return this.root.queryInterval(e, t, n);
};
Object.defineProperty(_N, "count", {
  get: function() {
    return this.root ? this.root.count : 0;
  }
});
Object.defineProperty(_N, "intervals", {
  get: function() {
    return this.root ? this.root.intervals([]) : [];
  }
});
function a0t(e) {
  return !e || e.length === 0 ? new TG(null) : new TG(SC(e));
}
const s0t = /* @__PURE__ */ KC(i0t), u0t = ({ marginLeft: e }) => [1, e], l0t = ({ width: e, marginRight: t }) => [-1, e - t], c0t = ({ width: e, marginLeft: t, marginRight: n }) => [0, (t + e - n) / 2], f0t = ({ marginTop: e }) => [1, e], d0t = ({ height: e, marginBottom: t }) => [-1, e - t], h0t = ({ height: e, marginTop: t, marginBottom: n }) => [0, (t + e - n) / 2];
function KCe(e) {
  return typeof e == "string" ? { anchor: e } : e;
}
function p0t(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = ZCe(e));
  let { anchor: n = "left", padding: r = 1, r: i = t.r } = KCe(e);
  switch (`${n}`.toLowerCase()) {
    case "left":
      n = u0t;
      break;
    case "right":
      n = l0t;
      break;
    case "middle":
      n = c0t;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${n}`);
  }
  return JCe("x", "y", n, ti(r), i, t);
}
function g0t(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = ZCe(e));
  let { anchor: n = "bottom", padding: r = 1, r: i = t.r } = KCe(e);
  switch (`${n}`.toLowerCase()) {
    case "top":
      n = f0t;
      break;
    case "bottom":
      n = d0t;
      break;
    case "middle":
      n = h0t;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${n}`);
  }
  return JCe("y", "x", n, ti(r), i, t);
}
function ZCe(e) {
  const { anchor: t, padding: n, ...r } = e, { r: i } = r;
  return [{ anchor: t, padding: n, r: i }, r];
}
function JCe(e, t, n, r, i, o) {
  if (i != null && typeof i != "number") {
    let { channels: a, sort: s, reverse: u } = o;
    a = FZ(a), (a == null ? void 0 : a.r) === void 0 && (o = { ...o, channels: { ...a, r: { value: i, scale: "r" } } }), s === void 0 && u === void 0 && (o.sort = { channel: "-r" });
  }
  return Of(o, function(a, s, u, l, f, h) {
    let { [t]: p, r: g } = u;
    if (!u[t])
      throw new Error(`missing channel: ${t}`);
    ({ [t]: p } = r6(u, l, h));
    const y = g ? void 0 : i !== void 0 ? ti(i) : this.r !== void 0 ? this.r : 3;
    g && (g = Qr(g.value, l[g.scale] || Wn, Float64Array));
    let [b, _] = n(f);
    const S = b ? y0t : m0t, C = new Float64Array(p.length), A = g ? (O) => g[O] : () => y;
    for (let O of s) {
      const R = s0t();
      O = O.filter(g ? ($) => WL(p[$]) && Z0(g[$]) : ($) => WL(p[$]));
      const j = new Float64Array(2 * O.length + 2);
      for (const $ of O) {
        const z = A($), W = b ? z + r : 0, Y = p[$] - z, V = p[$] + z;
        let ee = 2;
        R.queryInterval(Y - r, V + r, ([, , Q]) => {
          const q = C[Q] - W, te = p[$] - p[Q], X = r + (g ? g[$] + g[Q] : 2 * y), Z = Math.sqrt(X * X - te * te);
          j[ee++] = q - Z, j[ee++] = q + Z;
        });
        let K = j.slice(0, ee);
        b && (K = K.filter((Q) => Q >= 0));
        e:
          for (const Q of K.sort(S)) {
            for (let q = 0; q < ee; q += 2)
              if (j[q] + 1e-6 < Q && Q < j[q + 1] - 1e-6)
                continue e;
            C[$] = Q + W;
            break;
          }
        R.insert([Y, V, $]);
      }
    }
    b || (b = 1);
    for (const O of s)
      for (const R of O)
        C[R] = C[R] * b + _;
    return {
      data: a,
      facets: s,
      channels: {
        [e]: { value: C, source: null },
        // don’t show in tooltip
        [t]: { value: p, source: u[t] },
        ...g && { r: { value: g, source: u.r } }
      }
    };
  });
}
function m0t(e, t) {
  return Math.abs(e) - Math.abs(t);
}
function y0t(e, t) {
  return e - t;
}
function v0t(e, t) {
  return arguments.length === 1 && ({ basis: e, ...t } = e), LJ(QJ(e), t);
}
function b0t(e, t) {
  return arguments.length === 1 && ({ basis: e, ...t } = e), zJ(QJ(e), t);
}
function QJ(e) {
  if (e === void 0)
    return Spe;
  if (typeof e == "function")
    return b6(LZ(e));
  if (/^p\d{2}$/i.test(e))
    return EN($Z(e));
  switch (`${e}`.toLowerCase()) {
    case "deviation":
      return _0t;
    case "first":
      return Spe;
    case "last":
      return w0t;
    case "max":
      return E0t;
    case "mean":
      return S0t;
    case "median":
      return M0t;
    case "min":
      return T0t;
    case "sum":
      return C0t;
    case "extent":
      return x0t;
  }
  throw new Error(`invalid basis: ${e}`);
}
function b6(e) {
  return {
    mapIndex(t, n, r) {
      const i = +e(t, n);
      for (const o of t)
        r[o] = n[o] === null ? NaN : n[o] / i;
    }
  };
}
function EN(e) {
  return b6((t, n) => e(t, (r) => n[r]));
}
const x0t = {
  mapIndex(e, t, n) {
    const [r, i] = Zu(e, (a) => t[a]), o = i - r;
    for (const a of e)
      n[a] = t[a] === null ? NaN : (t[a] - r) / o;
  }
}, Spe = b6((e, t) => {
  for (let n = 0; n < e.length; ++n) {
    const r = t[e[n]];
    if (Dc(r))
      return r;
  }
}), w0t = b6((e, t) => {
  for (let n = e.length - 1; n >= 0; --n) {
    const r = t[e[n]];
    if (Dc(r))
      return r;
  }
}), _0t = {
  mapIndex(e, t, n) {
    const r = T$(e, (o) => t[o]), i = lN(e, (o) => t[o]);
    for (const o of e)
      n[o] = t[o] === null ? NaN : i ? (t[o] - r) / i : 0;
  }
}, E0t = EN(Ha), S0t = EN(T$), M0t = EN(Jx), T0t = EN(Oc), C0t = EN(fp);
function N0t(e, t = {}) {
  if (typeof e == "string")
    switch (e.toLowerCase()) {
      case "first":
        return eNe(t);
      case "last":
        return tNe(t);
    }
  if (typeof e == "function")
    return sw(null, e, t);
  let n, r;
  for (n in e) {
    if (r !== void 0)
      throw new Error("ambiguous selector; multiple inputs");
    r = D0t(e[n]);
  }
  if (r === void 0)
    throw new Error(`invalid selector: ${e}`);
  return sw(n, r, t);
}
function D0t(e) {
  if (typeof e == "function")
    return e;
  switch (`${e}`.toLowerCase()) {
    case "min":
      return XJ;
    case "max":
      return KJ;
  }
  throw new Error(`unknown selector: ${e}`);
}
function eNe(e) {
  return sw(null, $0t, e);
}
function tNe(e) {
  return sw(null, P0t, e);
}
function A0t(e) {
  return sw("x", XJ, e);
}
function O0t(e) {
  return sw("y", XJ, e);
}
function R0t(e) {
  return sw("x", KJ, e);
}
function k0t(e) {
  return sw("y", KJ, e);
}
function* $0t(e) {
  yield e[0];
}
function* P0t(e) {
  yield e[e.length - 1];
}
function* XJ(e, t) {
  yield nit(e, (n) => t[n]);
}
function* KJ(e, t) {
  yield WK(e, (n) => t[n]);
}
function sw(e, t, n) {
  if (e != null) {
    if (n[e] == null)
      throw new Error(`missing channel: ${e}`);
    e = n[e];
  }
  const r = Ow(n);
  return iv(n, (i, o) => {
    const a = Qr(i, r), s = Qr(i, e), u = [];
    for (const l of o) {
      const f = [];
      for (const h of a ? xb(l, (p) => a[p]).values() : [l])
        for (const p of t(h, s))
          f.push(p);
      u.push(f);
    }
    return { data: i, facets: u };
  });
}
const Mpe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Area: h6,
  Arrow: iCe,
  BarX: aCe,
  BarY: sCe,
  Cell: p6,
  Contour: NCe,
  Density: OCe,
  Dot: g6,
  Frame: zTe,
  Geo: RCe,
  Hexgrid: kCe,
  Image: $Ce,
  Line: m6,
  Link: nCe,
  Mark: Co,
  Raster: wCe,
  Rect: y6,
  RuleX: ZMe,
  RuleY: JMe,
  Text: l6,
  TickX: hCe,
  TickY: pCe,
  Tip: FTe,
  Vector: c6,
  area: Wmt,
  areaX: Fk,
  areaY: EC,
  arrow: Zmt,
  auto: cyt,
  autoSpec: uCe,
  axisFx: _Te,
  axisFy: wTe,
  axisX: bJ,
  axisY: vJ,
  barX: HE,
  barY: VE,
  bin: $E,
  binX: bx,
  binY: xx,
  bollinger: rS,
  bollingerX: Dyt,
  bollingerY: Ayt,
  boxX: Ryt,
  boxY: kyt,
  cell: gT,
  cellX: eyt,
  cellY: tyt,
  centroid: Xvt,
  circle: oyt,
  cluster: Qvt,
  column: Cd,
  contour: qyt,
  crosshair: Qyt,
  crosshairX: Xyt,
  crosshairY: Kyt,
  delaunayLink: cvt,
  delaunayMesh: fvt,
  density: mvt,
  dodgeX: p0t,
  dodgeY: g0t,
  dot: $w,
  dotX: ryt,
  dotY: iyt,
  filter: bht,
  formatIsoDate: fMe,
  formatMonth: zht,
  formatWeekday: Fht,
  frame: wJ,
  geo: HJ,
  geoCentroid: Kvt,
  graticule: _vt,
  gridFx: NTe,
  gridFy: TTe,
  gridX: CTe,
  gridY: MTe,
  group: GZ,
  groupX: Ik,
  groupY: jk,
  groupZ: qZ,
  hexagon: ayt,
  hexbin: Evt,
  hexgrid: Tvt,
  hull: dvt,
  identity: Wn,
  image: Ovt,
  indexOf: zf,
  initializer: Of,
  interpolateNearest: TCe,
  interpolateNone: bG,
  interpolatorBarycentric: MCe,
  interpolatorRandomWalk: CCe,
  legend: Bgt,
  line: IJ,
  lineX: Bk,
  lineY: Uk,
  linearRegressionX: zvt,
  linearRegressionY: Fvt,
  link: rCe,
  map: fb,
  mapX: LJ,
  mapY: zJ,
  marks: Vg,
  normalize: QJ,
  normalizeX: v0t,
  normalizeY: b0t,
  plot: _J,
  pointer: hJ,
  pointerX: pJ,
  pointerY: gJ,
  raster: Pyt,
  rect: jJ,
  rectX: n5,
  rectY: r5,
  reverse: xht,
  ruleX: ow,
  ruleY: aw,
  scale: Hpt,
  select: N0t,
  selectFirst: eNe,
  selectLast: tNe,
  selectMaxX: R0t,
  selectMaxY: k0t,
  selectMinX: A0t,
  selectMinY: O0t,
  shuffle: wht,
  sort: rMe,
  sphere: wvt,
  spike: Ngt,
  stackX: XTe,
  stackX1: Amt,
  stackX2: Omt,
  stackY: KTe,
  stackY1: Rmt,
  stackY2: kmt,
  text: xC,
  textX: rTe,
  textY: iTe,
  tickX: gCe,
  tickY: mCe,
  tip: BTe,
  transform: iv,
  tree: WCe,
  treeLink: jCe,
  treeNode: xG,
  valueof: Qr,
  vector: pTe,
  vectorX: gTe,
  vectorY: mTe,
  voronoi: hvt,
  voronoiMesh: pvt,
  window: v6,
  windowX: yyt,
  windowY: vyt
}, Symbol.toStringTag, { value: "Module" })), I0t = (e, t, n) => {
  const r = ar.get(t, `data[${e}].namespace`, "");
  return ar.get(n, `${r}.records`, []);
}, j0t = (e) => (n) => n[e._functionCall](...e._args.map((r) => r)), s5 = (e, t, n) => {
  if (e && e._call) {
    const r = e._args.map((i) => Array.isArray(i) ? i : s5(i));
    if (e._dataPrefix) {
      const i = I0t(
        e._dataIndex,
        t,
        n
      );
      return Mpe[e._call](i, ...r);
    } else
      return Mpe[e._call](...r);
  } else {
    if (e && e._functionCall)
      return j0t(e);
    if (e && typeof e == "object") {
      const r = Object.entries(e), i = {};
      return r.forEach((o) => {
        o[1] && typeof o[1] == "object" ? i[o[0]] = s5(o[1]) : i[o[0]] = o[1];
      }), i;
    } else
      return e;
  }
}, L0t = (e, t, n) => e.reduce((r, i) => (i[0] === "marks" ? r[i[0]] = i[1].map(
  (o) => s5(o, t, n)
) : typeof i[1] == "object" ? r[i[0]] = s5(
  i[1],
  t,
  n
) : r[i[0]] = i[1], r), {}), z0t = (e, t) => {
  const n = ar.get(e, "data.namespace"), r = ar.get(t, `${n}.records`, []);
  return {
    ...e,
    data: {
      values: r
    }
  };
}, F0t = "_plotChart_zb835_1", B0t = {
  plotChart: F0t
}, U0t = ({
  id: e,
  style: t = {},
  content: n,
  chartConfig: r
}) => {
  const i = ae.useContext(tv), o = ae.useRef(), a = typeof r == "string" ? JSON.parse(r) : r;
  if (n.title.markdown === "#Multi-nested marks Chart") {
    const f = (h) => h.temp_max - h.temp_min;
    a.marks[1]._args[0].fill = (/* @__PURE__ */ new Date()).getUTCMonth(), a.marks[1]._args[0].y = f, a.marks[2]._args[0]._args[0].y = f, a.marks[3]._args[0]._args[0].y = f;
  }
  const s = /* @__PURE__ */ new Date();
  n.title.markdown === "#Seattle temperature temporal heatmap" && (a.marks[0]._args[0]._args[1].x = (f) => s.getUTCDate(), a.marks[0]._args[0]._args[1].y = (f) => s.getUTCMonth()), n.title.markdown === "#Sorted heatmap" && (a.marks[0]._args[0]._args[1].x = (f) => s.getUTCHours());
  const u = Object.entries(a), l = L0t(u, n, i);
  return ae.useEffect(() => {
    const f = _J(l);
    return o.current.append(f), () => f.remove();
  }, [l]), /* @__PURE__ */ pe.jsxs("div", { id: `plot-chart-${e}`, className: B0t.plotChart, children: [
    /* @__PURE__ */ pe.jsx(JS, { contentTitle: n.title, style: t }),
    /* @__PURE__ */ pe.jsx(
      "div",
      {
        ref: o
      }
    )
  ] });
}, Y0t = "_layoutListWrapper_1xid9_1", H0t = "_divider_1xid9_9", V0t = "_wordCloudWrapper_1xid9_17", HH = {
  layoutListWrapper: Y0t,
  divider: H0t,
  wordCloudWrapper: V0t
};
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var W0t = globalThis && globalThis.__extends || function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i)
        i.hasOwnProperty(o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), q0t = Object.prototype.hasOwnProperty;
function CG(e, t) {
  return q0t.call(e, t);
}
function NG(e) {
  if (Array.isArray(e)) {
    for (var t = new Array(e.length), n = 0; n < t.length; n++)
      t[n] = "" + n;
    return t;
  }
  if (Object.keys)
    return Object.keys(e);
  var r = [];
  for (var i in e)
    CG(e, i) && r.push(i);
  return r;
}
function Nd(e) {
  switch (typeof e) {
    case "object":
      return JSON.parse(JSON.stringify(e));
    case "undefined":
      return null;
    default:
      return e;
  }
}
function DG(e) {
  for (var t = 0, n = e.length, r; t < n; ) {
    if (r = e.charCodeAt(t), r >= 48 && r <= 57) {
      t++;
      continue;
    }
    return !1;
  }
  return !0;
}
function TE(e) {
  return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
function nNe(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
function AG(e) {
  if (e === void 0)
    return !0;
  if (e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = e.length; t < n; t++)
        if (AG(e[t]))
          return !0;
    } else if (typeof e == "object") {
      for (var r = NG(e), i = r.length, o = 0; o < i; o++)
        if (AG(e[r[o]]))
          return !0;
    }
  }
  return !1;
}
function Tpe(e, t) {
  var n = [e];
  for (var r in t) {
    var i = typeof t[r] == "object" ? JSON.stringify(t[r], null, 2) : t[r];
    typeof i < "u" && n.push(r + ": " + i);
  }
  return n.join(`
`);
}
var rNe = (
  /** @class */
  function(e) {
    W0t(t, e);
    function t(n, r, i, o, a) {
      var s = this.constructor, u = e.call(this, Tpe(n, { name: r, index: i, operation: o, tree: a })) || this;
      return u.name = r, u.index = i, u.operation = o, u.tree = a, Object.setPrototypeOf(u, s.prototype), u.message = Tpe(n, { name: r, index: i, operation: o, tree: a }), u;
    }
    return t;
  }(Error)
), La = rNe, G0t = Nd, yT = {
  add: function(e, t, n) {
    return e[t] = this.value, { newDocument: n };
  },
  remove: function(e, t, n) {
    var r = e[t];
    return delete e[t], { newDocument: n, removed: r };
  },
  replace: function(e, t, n) {
    var r = e[t];
    return e[t] = this.value, { newDocument: n, removed: r };
  },
  move: function(e, t, n) {
    var r = u5(n, this.path);
    r && (r = Nd(r));
    var i = iS(n, { op: "remove", path: this.from }).removed;
    return iS(n, { op: "add", path: this.path, value: i }), { newDocument: n, removed: r };
  },
  copy: function(e, t, n) {
    var r = u5(n, this.from);
    return iS(n, { op: "add", path: this.path, value: Nd(r) }), { newDocument: n };
  },
  test: function(e, t, n) {
    return { newDocument: n, test: Yk(e[t], this.value) };
  },
  _get: function(e, t, n) {
    return this.value = e[t], { newDocument: n };
  }
}, Q0t = {
  add: function(e, t, n) {
    return DG(t) ? e.splice(t, 0, this.value) : e[t] = this.value, { newDocument: n, index: t };
  },
  remove: function(e, t, n) {
    var r = e.splice(t, 1);
    return { newDocument: n, removed: r[0] };
  },
  replace: function(e, t, n) {
    var r = e[t];
    return e[t] = this.value, { newDocument: n, removed: r };
  },
  move: yT.move,
  copy: yT.copy,
  test: yT.test,
  _get: yT._get
};
function u5(e, t) {
  if (t == "")
    return e;
  var n = { op: "_get", path: t };
  return iS(e, n), n.value;
}
function iS(e, t, n, r, i, o) {
  if (n === void 0 && (n = !1), r === void 0 && (r = !0), i === void 0 && (i = !0), o === void 0 && (o = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : l5(t, 0)), t.path === "") {
    var a = { newDocument: e };
    if (t.op === "add")
      return a.newDocument = t.value, a;
    if (t.op === "replace")
      return a.newDocument = t.value, a.removed = e, a;
    if (t.op === "move" || t.op === "copy")
      return a.newDocument = u5(e, t.from), t.op === "move" && (a.removed = e), a;
    if (t.op === "test") {
      if (a.test = Yk(e, t.value), a.test === !1)
        throw new La("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
      return a.newDocument = e, a;
    } else {
      if (t.op === "remove")
        return a.removed = e, a.newDocument = null, a;
      if (t.op === "_get")
        return t.value = e, a;
      if (n)
        throw new La("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", o, t, e);
      return a;
    }
  } else {
    r || (e = Nd(e));
    var s = t.path || "", u = s.split("/"), l = e, f = 1, h = u.length, p = void 0, g = void 0, y = void 0;
    for (typeof n == "function" ? y = n : y = l5; ; ) {
      if (g = u[f], g && g.indexOf("~") != -1 && (g = nNe(g)), i && (g == "__proto__" || g == "prototype" && f > 0 && u[f - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && p === void 0 && (l[g] === void 0 ? p = u.slice(0, f).join("/") : f == h - 1 && (p = t.path), p !== void 0 && y(t, 0, e, p)), f++, Array.isArray(l)) {
        if (g === "-")
          g = l.length;
        else {
          if (n && !DG(g))
            throw new La("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", o, t, e);
          DG(g) && (g = ~~g);
        }
        if (f >= h) {
          if (n && t.op === "add" && g > l.length)
            throw new La("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", o, t, e);
          var a = Q0t[t.op].call(t, l, g, e);
          if (a.test === !1)
            throw new La("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
          return a;
        }
      } else if (f >= h) {
        var a = yT[t.op].call(t, l, g, e);
        if (a.test === !1)
          throw new La("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
        return a;
      }
      if (l = l[g], n && f < h && (!l || typeof l != "object"))
        throw new La("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", o, t, e);
    }
  }
}
function x6(e, t, n, r, i) {
  if (r === void 0 && (r = !0), i === void 0 && (i = !0), n && !Array.isArray(t))
    throw new La("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  r || (e = Nd(e));
  for (var o = new Array(t.length), a = 0, s = t.length; a < s; a++)
    o[a] = iS(e, t[a], n, !0, i, a), e = o[a].newDocument;
  return o.newDocument = e, o;
}
function X0t(e, t, n) {
  var r = iS(e, t);
  if (r.test === !1)
    throw new La("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
  return r.newDocument;
}
function l5(e, t, n, r) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new La("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
  if (yT[e.op]) {
    if (typeof e.path != "string")
      throw new La("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
    if (e.path.indexOf("/") !== 0 && e.path.length > 0)
      throw new La('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
    if ((e.op === "move" || e.op === "copy") && typeof e.from != "string")
      throw new La("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0)
      throw new La("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && AG(e.value))
      throw new La("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
    if (n) {
      if (e.op == "add") {
        var i = e.path.split("/").length, o = r.split("/").length;
        if (i !== o + 1 && i !== o)
          throw new La("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
      } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
        if (e.path !== r)
          throw new La("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
      } else if (e.op === "move" || e.op === "copy") {
        var a = { op: "_get", path: e.from, value: void 0 }, s = iNe([a], n);
        if (s && s.name === "OPERATION_PATH_UNRESOLVABLE")
          throw new La("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
      }
    }
  } else
    throw new La("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
}
function iNe(e, t, n) {
  try {
    if (!Array.isArray(e))
      throw new La("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (t)
      x6(Nd(t), Nd(e), n || !0);
    else {
      n = n || l5;
      for (var r = 0; r < e.length; r++)
        n(e[r], r, t, void 0);
    }
  } catch (i) {
    if (i instanceof La)
      return i;
    throw i;
  }
}
function Yk(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    var n = Array.isArray(e), r = Array.isArray(t), i, o, a;
    if (n && r) {
      if (o = e.length, o != t.length)
        return !1;
      for (i = o; i-- !== 0; )
        if (!Yk(e[i], t[i]))
          return !1;
      return !0;
    }
    if (n != r)
      return !1;
    var s = Object.keys(e);
    if (o = s.length, o !== Object.keys(t).length)
      return !1;
    for (i = o; i-- !== 0; )
      if (!t.hasOwnProperty(s[i]))
        return !1;
    for (i = o; i-- !== 0; )
      if (a = s[i], !Yk(e[a], t[a]))
        return !1;
    return !0;
  }
  return e !== e && t !== t;
}
const K0t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JsonPatchError: La,
  _areEquals: Yk,
  applyOperation: iS,
  applyPatch: x6,
  applyReducer: X0t,
  deepClone: G0t,
  getValueByPointer: u5,
  validate: iNe,
  validator: l5
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
var ZJ = /* @__PURE__ */ new WeakMap(), Z0t = (
  /** @class */
  function() {
    function e(t) {
      this.observers = /* @__PURE__ */ new Map(), this.obj = t;
    }
    return e;
  }()
), J0t = (
  /** @class */
  function() {
    function e(t, n) {
      this.callback = t, this.observer = n;
    }
    return e;
  }()
);
function ebt(e) {
  return ZJ.get(e);
}
function tbt(e, t) {
  return e.observers.get(t);
}
function nbt(e, t) {
  e.observers.delete(t.callback);
}
function rbt(e, t) {
  t.unobserve();
}
function ibt(e, t) {
  var n = [], r, i = ebt(e);
  if (!i)
    i = new Z0t(e), ZJ.set(e, i);
  else {
    var o = tbt(i, t);
    r = o && o.observer;
  }
  if (r)
    return r;
  if (r = {}, i.value = Nd(e), t) {
    r.callback = t, r.next = null;
    var a = function() {
      OG(r);
    }, s = function() {
      clearTimeout(r.next), r.next = setTimeout(a);
    };
    typeof window < "u" && (window.addEventListener("mouseup", s), window.addEventListener("keyup", s), window.addEventListener("mousedown", s), window.addEventListener("keydown", s), window.addEventListener("change", s));
  }
  return r.patches = n, r.object = e, r.unobserve = function() {
    OG(r), clearTimeout(r.next), nbt(i, r), typeof window < "u" && (window.removeEventListener("mouseup", s), window.removeEventListener("keyup", s), window.removeEventListener("mousedown", s), window.removeEventListener("keydown", s), window.removeEventListener("change", s));
  }, i.observers.set(t, new J0t(t, r)), r;
}
function OG(e, t) {
  t === void 0 && (t = !1);
  var n = ZJ.get(e.object);
  JJ(n.value, e.object, e.patches, "", t), e.patches.length && x6(n.value, e.patches);
  var r = e.patches;
  return r.length > 0 && (e.patches = [], e.callback && e.callback(r)), r;
}
function JJ(e, t, n, r, i) {
  if (t !== e) {
    typeof t.toJSON == "function" && (t = t.toJSON());
    for (var o = NG(t), a = NG(e), s = !1, u = a.length - 1; u >= 0; u--) {
      var l = a[u], f = e[l];
      if (CG(t, l) && !(t[l] === void 0 && f !== void 0 && Array.isArray(t) === !1)) {
        var h = t[l];
        typeof f == "object" && f != null && typeof h == "object" && h != null && Array.isArray(f) === Array.isArray(h) ? JJ(f, h, n, r + "/" + TE(l), i) : f !== h && (i && n.push({ op: "test", path: r + "/" + TE(l), value: Nd(f) }), n.push({ op: "replace", path: r + "/" + TE(l), value: Nd(h) }));
      } else
        Array.isArray(e) === Array.isArray(t) ? (i && n.push({ op: "test", path: r + "/" + TE(l), value: Nd(f) }), n.push({ op: "remove", path: r + "/" + TE(l) }), s = !0) : (i && n.push({ op: "test", path: r, value: e }), n.push({ op: "replace", path: r, value: t }));
    }
    if (!(!s && o.length == a.length))
      for (var u = 0; u < o.length; u++) {
        var l = o[u];
        !CG(e, l) && t[l] !== void 0 && n.push({ op: "add", path: r + "/" + TE(l), value: Nd(t[l]) });
      }
  }
}
function obt(e, t, n) {
  n === void 0 && (n = !1);
  var r = [];
  return JJ(e, t, r, "", n), r;
}
const abt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: obt,
  generate: OG,
  observe: ibt,
  unobserve: rbt
}, Symbol.toStringTag, { value: "Module" }));
Object.assign({}, K0t, abt, {
  JsonPatchError: rNe,
  deepClone: Nd,
  escapePathComponent: TE,
  unescapePathComponent: nNe
});
var sbt = /("(?:[^\\"]|\\.)*")|[:,]/g, ubt = function(t, n) {
  var r, i, o;
  return n = n || {}, r = JSON.stringify(
    [1],
    void 0,
    n.indent === void 0 ? 2 : n.indent
  ).slice(2, -3), i = r === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, o = n.replacer, function a(s, u, l) {
    var f, h, p, g, y, b, _, S, C, A, O, R;
    if (s && typeof s.toJSON == "function" && (s = s.toJSON()), O = JSON.stringify(s, o), O === void 0)
      return O;
    if (_ = i - u.length - l, O.length <= _ && (C = O.replace(
      sbt,
      function(j, $) {
        return $ || j + " ";
      }
    ), C.length <= _))
      return C;
    if (o != null && (s = JSON.parse(O), o = void 0), typeof s == "object" && s !== null) {
      if (S = u + r, p = [], h = 0, Array.isArray(s))
        for (A = "[", f = "]", _ = s.length; h < _; h++)
          p.push(
            a(s[h], S, h === _ - 1 ? 0 : 1) || "null"
          );
      else
        for (A = "{", f = "}", b = Object.keys(s), _ = b.length; h < _; h++)
          g = b[h], y = JSON.stringify(g) + ": ", R = a(
            s[g],
            S,
            y.length + (h === _ - 1 ? 0 : 1)
          ), R !== void 0 && p.push(y + R);
      if (p.length > 0)
        return [A, r + p.join(`,
` + S), f].join(
          `
` + u
        );
    }
    return O;
  }(t, "", 0);
};
const VH = /* @__PURE__ */ KC(ubt);
function Ff(e, t, n) {
  return e.fields = t || [], e.fname = n, e;
}
function Va(e) {
  return e == null ? null : e.fname;
}
function Yl(e) {
  return e == null ? null : e.fields;
}
function oNe(e) {
  return e.length === 1 ? lbt(e[0]) : cbt(e);
}
const lbt = (e) => function(t) {
  return t[e];
}, cbt = (e) => {
  const t = e.length;
  return function(n) {
    for (let r = 0; r < t; ++r)
      n = n[e[r]];
    return n;
  };
};
function tt(e) {
  throw Error(e);
}
function av(e) {
  const t = [], n = e.length;
  let r = null, i = 0, o = "", a, s, u;
  e = e + "";
  function l() {
    t.push(o + e.substring(a, s)), o = "", a = s + 1;
  }
  for (a = s = 0; s < n; ++s)
    if (u = e[s], u === "\\")
      o += e.substring(a, s++), a = s;
    else if (u === r)
      l(), r = null, i = -1;
    else {
      if (r)
        continue;
      a === i && u === '"' || a === i && u === "'" ? (a = s + 1, r = u) : u === "." && !i ? s > a ? l() : a = s + 1 : u === "[" ? (s > a && l(), i = a = s + 1) : u === "]" && (i || tt("Access path missing open bracket: " + e), i > 0 && l(), i = 0, a = s + 1);
    }
  return i && tt("Access path missing closing bracket: " + e), r && tt("Access path missing closing quote: " + e), s > a && (s++, l()), t;
}
function yp(e, t, n) {
  const r = av(e);
  return e = r.length === 1 ? r[0] : e, Ff((n && n.get || oNe)(r), [e], t || e);
}
const K$ = yp("id"), ql = Ff((e) => e, [], "identity"), wx = Ff(() => 0, [], "zero"), SN = Ff(() => 1, [], "one"), vp = Ff(() => !0, [], "true"), ax = Ff(() => !1, [], "false");
function fbt(e, t, n) {
  const r = [t].concat([].slice.call(n));
  console[e].apply(console, r);
}
const aNe = 0, eee = 1, tee = 2, sNe = 3, uNe = 4;
function nee(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fbt, r = e || aNe;
  return {
    level(i) {
      return arguments.length ? (r = +i, this) : r;
    },
    error() {
      return r >= eee && n(t || "error", "ERROR", arguments), this;
    },
    warn() {
      return r >= tee && n(t || "warn", "WARN", arguments), this;
    },
    info() {
      return r >= sNe && n(t || "log", "INFO", arguments), this;
    },
    debug() {
      return r >= uNe && n(t || "log", "DEBUG", arguments), this;
    }
  };
}
var nt = Array.isArray;
function Pt(e) {
  return e === Object(e);
}
const Cpe = (e) => e !== "__proto__";
function MN() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t.reduce((r, i) => {
    for (const o in i)
      if (o === "signals")
        r.signals = dbt(r.signals, i.signals);
      else {
        const a = o === "legend" ? {
          layout: 1
        } : o === "style" ? !0 : null;
        TN(r, o, i[o], a);
      }
    return r;
  }, {});
}
function TN(e, t, n, r) {
  if (!Cpe(t))
    return;
  let i, o;
  if (Pt(n) && !nt(n)) {
    o = Pt(e[t]) ? e[t] : e[t] = {};
    for (i in n)
      r && (r === !0 || r[i]) ? TN(o, i, n[i]) : Cpe(i) && (o[i] = n[i]);
  } else
    e[t] = n;
}
function dbt(e, t) {
  if (e == null)
    return t;
  const n = {}, r = [];
  function i(o) {
    n[o.name] || (n[o.name] = 1, r.push(o));
  }
  return t.forEach(i), e.forEach(i), r;
}
function ri(e) {
  return e[e.length - 1];
}
function Fl(e) {
  return e == null || e === "" ? null : +e;
}
const lNe = (e) => (t) => e * Math.exp(t), cNe = (e) => (t) => Math.log(e * t), fNe = (e) => (t) => Math.sign(t) * Math.log1p(Math.abs(t / e)), dNe = (e) => (t) => Math.sign(t) * Math.expm1(Math.abs(t)) * e, c5 = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
function w6(e, t, n, r) {
  const i = n(e[0]), o = n(ri(e)), a = (o - i) * t;
  return [r(i - a), r(o - a)];
}
function hNe(e, t) {
  return w6(e, t, Fl, ql);
}
function pNe(e, t) {
  var n = Math.sign(e[0]);
  return w6(e, t, cNe(n), lNe(n));
}
function gNe(e, t, n) {
  return w6(e, t, c5(n), c5(1 / n));
}
function mNe(e, t, n) {
  return w6(e, t, fNe(n), dNe(n));
}
function _6(e, t, n, r, i) {
  const o = r(e[0]), a = r(ri(e)), s = t != null ? r(t) : (o + a) / 2;
  return [i(s + (o - s) * n), i(s + (a - s) * n)];
}
function ree(e, t, n) {
  return _6(e, t, n, Fl, ql);
}
function iee(e, t, n) {
  const r = Math.sign(e[0]);
  return _6(e, t, n, cNe(r), lNe(r));
}
function f5(e, t, n, r) {
  return _6(e, t, n, c5(r), c5(1 / r));
}
function oee(e, t, n, r) {
  return _6(e, t, n, fNe(r), dNe(r));
}
function yNe(e) {
  return 1 + ~~(new Date(e).getMonth() / 3);
}
function vNe(e) {
  return 1 + ~~(new Date(e).getUTCMonth() / 3);
}
function Rt(e) {
  return e != null ? nt(e) ? e : [e] : [];
}
function bNe(e, t, n) {
  let r = e[0], i = e[1], o;
  return i < r && (o = i, i = r, r = o), o = i - r, o >= n - t ? [t, n] : [r = Math.min(Math.max(r, t), n - o), r + o];
}
function pr(e) {
  return typeof e == "function";
}
const hbt = "descending";
function aee(e, t, n) {
  n = n || {}, t = Rt(t) || [];
  const r = [], i = [], o = {}, a = n.comparator || pbt;
  return Rt(e).forEach((s, u) => {
    s != null && (r.push(t[u] === hbt ? -1 : 1), i.push(s = pr(s) ? s : yp(s, null, n)), (Yl(s) || []).forEach((l) => o[l] = 1));
  }), i.length === 0 ? null : Ff(a(i, r), Object.keys(o));
}
const E6 = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0), pbt = (e, t) => e.length === 1 ? gbt(e[0], t[0]) : mbt(e, t, e.length), gbt = (e, t) => function(n, r) {
  return E6(e(n), e(r)) * t;
}, mbt = (e, t, n) => (t.push(0), function(r, i) {
  let o, a = 0, s = -1;
  for (; a === 0 && ++s < n; )
    o = e[s], a = E6(o(r), o(i));
  return a * t[s];
});
function Gl(e) {
  return pr(e) ? e : () => e;
}
function see(e, t) {
  let n;
  return (r) => {
    n && clearTimeout(n), n = setTimeout(() => (t(r), n = null), e);
  };
}
function hr(e) {
  for (let t, n, r = 1, i = arguments.length; r < i; ++r) {
    t = arguments[r];
    for (n in t)
      e[n] = t[n];
  }
  return e;
}
function Gy(e, t) {
  let n = 0, r, i, o, a;
  if (e && (r = e.length))
    if (t == null) {
      for (i = e[n]; n < r && (i == null || i !== i); i = e[++n])
        ;
      for (o = a = i; n < r; ++n)
        i = e[n], i != null && (i < o && (o = i), i > a && (a = i));
    } else {
      for (i = t(e[n]); n < r && (i == null || i !== i); i = t(e[++n]))
        ;
      for (o = a = i; n < r; ++n)
        i = t(e[n]), i != null && (i < o && (o = i), i > a && (a = i));
    }
  return [o, a];
}
function xNe(e, t) {
  const n = e.length;
  let r = -1, i, o, a, s, u;
  if (t == null) {
    for (; ++r < n; )
      if (o = e[r], o != null && o >= o) {
        i = a = o;
        break;
      }
    if (r === n)
      return [-1, -1];
    for (s = u = r; ++r < n; )
      o = e[r], o != null && (i > o && (i = o, s = r), a < o && (a = o, u = r));
  } else {
    for (; ++r < n; )
      if (o = t(e[r], r, e), o != null && o >= o) {
        i = a = o;
        break;
      }
    if (r === n)
      return [-1, -1];
    for (s = u = r; ++r < n; )
      o = t(e[r], r, e), o != null && (i > o && (i = o, s = r), a < o && (a = o, u = r));
  }
  return [s, u];
}
const ybt = Object.prototype.hasOwnProperty;
function wn(e, t) {
  return ybt.call(e, t);
}
const g3 = {};
function CN(e) {
  let t = {}, n;
  function r(o) {
    return wn(t, o) && t[o] !== g3;
  }
  const i = {
    size: 0,
    empty: 0,
    object: t,
    has: r,
    get(o) {
      return r(o) ? t[o] : void 0;
    },
    set(o, a) {
      return r(o) || (++i.size, t[o] === g3 && --i.empty), t[o] = a, this;
    },
    delete(o) {
      return r(o) && (--i.size, ++i.empty, t[o] = g3), this;
    },
    clear() {
      i.size = i.empty = 0, i.object = t = {};
    },
    test(o) {
      return arguments.length ? (n = o, i) : n;
    },
    clean() {
      const o = {};
      let a = 0;
      for (const s in t) {
        const u = t[s];
        u !== g3 && (!n || !n(u)) && (o[s] = u, ++a);
      }
      i.size = a, i.empty = 0, i.object = t = o;
    }
  };
  return e && Object.keys(e).forEach((o) => {
    i.set(o, e[o]);
  }), i;
}
function wNe(e, t, n, r, i, o) {
  if (!n && n !== 0)
    return o;
  const a = +n;
  let s = e[0], u = ri(e), l;
  u < s && (l = s, s = u, u = l), l = Math.abs(t - s);
  const f = Math.abs(u - t);
  return l < f && l <= a ? r : f <= a ? i : o;
}
function Tt(e, t, n) {
  const r = e.prototype = Object.create(t.prototype);
  return Object.defineProperty(r, "constructor", {
    value: e,
    writable: !0,
    enumerable: !0,
    configurable: !0
  }), hr(r, n);
}
function vT(e, t, n, r) {
  let i = t[0], o = t[t.length - 1], a;
  return i > o && (a = i, i = o, o = a), n = n === void 0 || n, r = r === void 0 || r, (n ? i <= e : i < e) && (r ? e <= o : e < o);
}
function Pw(e) {
  return typeof e == "boolean";
}
function zx(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function _Ne(e) {
  return e && pr(e[Symbol.iterator]);
}
function pi(e) {
  return typeof e == "number";
}
function ENe(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function kt(e) {
  return typeof e == "string";
}
function uee(e, t, n) {
  e && (e = t ? Rt(e).map((s) => s.replace(/\\(.)/g, "$1")) : Rt(e));
  const r = e && e.length, i = n && n.get || oNe, o = (s) => i(t ? [s] : av(s));
  let a;
  if (!r)
    a = function() {
      return "";
    };
  else if (r === 1) {
    const s = o(e[0]);
    a = function(u) {
      return "" + s(u);
    };
  } else {
    const s = e.map(o);
    a = function(u) {
      let l = "" + s[0](u), f = 0;
      for (; ++f < r; )
        l += "|" + s[f](u);
      return l;
    };
  }
  return Ff(a, e, "key");
}
function SNe(e, t) {
  const n = e[0], r = ri(e), i = +t;
  return i ? i === 1 ? r : n + i * (r - n) : n;
}
const vbt = 1e4;
function MNe(e) {
  e = +e || vbt;
  let t, n, r;
  const i = () => {
    t = {}, n = {}, r = 0;
  }, o = (a, s) => (++r > e && (n = t, t = {}, r = 1), t[a] = s);
  return i(), {
    clear: i,
    has: (a) => wn(t, a) || wn(n, a),
    get: (a) => wn(t, a) ? t[a] : wn(n, a) ? o(a, n[a]) : void 0,
    set: (a, s) => wn(t, a) ? t[a] = s : o(a, s)
  };
}
function TNe(e, t, n, r) {
  const i = t.length, o = n.length;
  if (!o)
    return t;
  if (!i)
    return n;
  const a = r || new t.constructor(i + o);
  let s = 0, u = 0, l = 0;
  for (; s < i && u < o; ++l)
    a[l] = e(t[s], n[u]) > 0 ? n[u++] : t[s++];
  for (; s < i; ++s, ++l)
    a[l] = t[s];
  for (; u < o; ++u, ++l)
    a[l] = n[u];
  return a;
}
function FO(e, t) {
  let n = "";
  for (; --t >= 0; )
    n += e;
  return n;
}
function CNe(e, t, n, r) {
  const i = n || " ", o = e + "", a = t - o.length;
  return a <= 0 ? o : r === "left" ? FO(i, a) + o : r === "center" ? FO(i, ~~(a / 2)) + o + FO(i, Math.ceil(a / 2)) : o + FO(i, a);
}
function Z$(e) {
  return e && ri(e) - e[0] || 0;
}
function Et(e) {
  return nt(e) ? "[" + e.map(Et) + "]" : Pt(e) || kt(e) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : e;
}
function lee(e) {
  return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e;
}
const bbt = (e) => pi(e) || zx(e) ? e : Date.parse(e);
function cee(e, t) {
  return t = t || bbt, e == null || e === "" ? null : t(e);
}
function fee(e) {
  return e == null || e === "" ? null : e + "";
}
function Wg(e) {
  const t = {}, n = e.length;
  for (let r = 0; r < n; ++r)
    t[e[r]] = !0;
  return t;
}
function NNe(e, t, n, r) {
  const i = r ?? "…", o = e + "", a = o.length, s = Math.max(0, t - i.length);
  return a <= t ? o : n === "left" ? i + o.slice(a - s) : n === "center" ? o.slice(0, Math.ceil(s / 2)) + i + o.slice(a - ~~(s / 2)) : o.slice(0, s) + i;
}
function fx(e, t, n) {
  if (e)
    if (t) {
      const r = e.length;
      for (let i = 0; i < r; ++i) {
        const o = t(e[i]);
        o && n(o, i, e);
      }
    } else
      e.forEach(n);
}
function xbt(e) {
  return e;
}
function wbt(e) {
  if (e == null)
    return xbt;
  var t, n, r = e.scale[0], i = e.scale[1], o = e.translate[0], a = e.translate[1];
  return function(s, u) {
    u || (t = n = 0);
    var l = 2, f = s.length, h = new Array(f);
    for (h[0] = (t += s[0]) * r + o, h[1] = (n += s[1]) * i + a; l < f; )
      h[l] = s[l], ++l;
    return h;
  };
}
function _bt(e, t) {
  for (var n, r = e.length, i = r - t; i < --r; )
    n = e[i], e[i++] = e[r], e[r] = n;
}
function Ebt(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return Npe(e, n);
  }) } : Npe(e, t);
}
function Npe(e, t) {
  var n = t.id, r = t.bbox, i = t.properties == null ? {} : t.properties, o = DNe(e, t);
  return n == null && r == null ? { type: "Feature", properties: i, geometry: o } : r == null ? { type: "Feature", id: n, properties: i, geometry: o } : { type: "Feature", id: n, bbox: r, properties: i, geometry: o };
}
function DNe(e, t) {
  var n = wbt(e.transform), r = e.arcs;
  function i(f, h) {
    h.length && h.pop();
    for (var p = r[f < 0 ? ~f : f], g = 0, y = p.length; g < y; ++g)
      h.push(n(p[g], g));
    f < 0 && _bt(h, y);
  }
  function o(f) {
    return n(f);
  }
  function a(f) {
    for (var h = [], p = 0, g = f.length; p < g; ++p)
      i(f[p], h);
    return h.length < 2 && h.push(h[0]), h;
  }
  function s(f) {
    for (var h = a(f); h.length < 4; )
      h.push(h[0]);
    return h;
  }
  function u(f) {
    return f.map(s);
  }
  function l(f) {
    var h = f.type, p;
    switch (h) {
      case "GeometryCollection":
        return { type: h, geometries: f.geometries.map(l) };
      case "Point":
        p = o(f.coordinates);
        break;
      case "MultiPoint":
        p = f.coordinates.map(o);
        break;
      case "LineString":
        p = a(f.arcs);
        break;
      case "MultiLineString":
        p = f.arcs.map(a);
        break;
      case "Polygon":
        p = u(f.arcs);
        break;
      case "MultiPolygon":
        p = f.arcs.map(u);
        break;
      default:
        return null;
    }
    return { type: h, coordinates: p };
  }
  return l(t);
}
function Sbt(e, t) {
  var n = {}, r = {}, i = {}, o = [], a = -1;
  t.forEach(function(l, f) {
    var h = e.arcs[l < 0 ? ~l : l], p;
    h.length < 3 && !h[1][0] && !h[1][1] && (p = t[++a], t[a] = l, t[f] = p);
  }), t.forEach(function(l) {
    var f = s(l), h = f[0], p = f[1], g, y;
    if (g = i[h])
      if (delete i[g.end], g.push(l), g.end = p, y = r[p]) {
        delete r[y.start];
        var b = y === g ? g : g.concat(y);
        r[b.start = g.start] = i[b.end = y.end] = b;
      } else
        r[g.start] = i[g.end] = g;
    else if (g = r[p])
      if (delete r[g.start], g.unshift(l), g.start = h, y = i[h]) {
        delete i[y.end];
        var _ = y === g ? g : y.concat(g);
        r[_.start = y.start] = i[_.end = g.end] = _;
      } else
        r[g.start] = i[g.end] = g;
    else
      g = [l], r[g.start = h] = i[g.end = p] = g;
  });
  function s(l) {
    var f = e.arcs[l < 0 ? ~l : l], h = f[0], p;
    return e.transform ? (p = [0, 0], f.forEach(function(g) {
      p[0] += g[0], p[1] += g[1];
    })) : p = f[f.length - 1], l < 0 ? [p, h] : [h, p];
  }
  function u(l, f) {
    for (var h in l) {
      var p = l[h];
      delete f[p.start], delete p.start, delete p.end, p.forEach(function(g) {
        n[g < 0 ? ~g : g] = 1;
      }), o.push(p);
    }
  }
  return u(i, r), u(r, i), t.forEach(function(l) {
    n[l < 0 ? ~l : l] || o.push([l]);
  }), o;
}
function Mbt(e) {
  return DNe(e, Tbt.apply(this, arguments));
}
function Tbt(e, t, n) {
  var r, i, o;
  if (arguments.length > 1)
    r = Cbt(e, t, n);
  else
    for (i = 0, r = new Array(o = e.arcs.length); i < o; ++i)
      r[i] = i;
  return { type: "MultiLineString", arcs: Sbt(e, r) };
}
function Cbt(e, t, n) {
  var r = [], i = [], o;
  function a(h) {
    var p = h < 0 ? ~h : h;
    (i[p] || (i[p] = [])).push({ i: h, g: o });
  }
  function s(h) {
    h.forEach(a);
  }
  function u(h) {
    h.forEach(s);
  }
  function l(h) {
    h.forEach(u);
  }
  function f(h) {
    switch (o = h, h.type) {
      case "GeometryCollection":
        h.geometries.forEach(f);
        break;
      case "LineString":
        s(h.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        u(h.arcs);
        break;
      case "MultiPolygon":
        l(h.arcs);
        break;
    }
  }
  return f(t), i.forEach(n == null ? function(h) {
    r.push(h[0].i);
  } : function(h) {
    n(h[0].g, h[h.length - 1].g) && r.push(h[0].i);
  }), r;
}
const rl = "year", Rf = "quarter", Hl = "month", Ys = "week", kf = "date", zl = "day", Qy = "dayofyear", Ud = "hours", Yd = "minutes", bp = "seconds", qg = "milliseconds", dee = [rl, Rf, Hl, Ys, kf, zl, Qy, Ud, Yd, bp, qg], WH = dee.reduce((e, t, n) => (e[t] = 1 + n, e), {});
function hee(e) {
  const t = Rt(e).slice(), n = {};
  return t.length || tt("Missing time unit."), t.forEach((i) => {
    wn(WH, i) ? n[i] = 1 : tt(`Invalid time unit: ${i}.`);
  }), (n[Ys] || n[zl] ? 1 : 0) + (n[Rf] || n[Hl] || n[kf] ? 1 : 0) + (n[Qy] ? 1 : 0) > 1 && tt(`Incompatible time units: ${e}`), t.sort((i, o) => WH[i] - WH[o]), t;
}
const Nbt = {
  [rl]: "%Y ",
  [Rf]: "Q%q ",
  [Hl]: "%b ",
  [kf]: "%d ",
  [Ys]: "W%U ",
  [zl]: "%a ",
  [Qy]: "%j ",
  [Ud]: "%H:00",
  [Yd]: "00:%M",
  [bp]: ":%S",
  [qg]: ".%L",
  [`${rl}-${Hl}`]: "%Y-%m ",
  [`${rl}-${Hl}-${kf}`]: "%Y-%m-%d ",
  [`${Ud}-${Yd}`]: "%H:%M"
};
function ANe(e, t) {
  const n = hr({}, Nbt, t), r = hee(e), i = r.length;
  let o = "", a = 0, s, u;
  for (a = 0; a < i; )
    for (s = r.length; s > a; --s)
      if (u = r.slice(a, s).join("-"), n[u] != null) {
        o += n[u], a = s;
        break;
      }
  return o.trim();
}
const PE = /* @__PURE__ */ new Date();
function pee(e) {
  return PE.setFullYear(e), PE.setMonth(0), PE.setDate(1), PE.setHours(0, 0, 0, 0), PE;
}
function ONe(e) {
  return kNe(new Date(e));
}
function RNe(e) {
  return RG(new Date(e));
}
function kNe(e) {
  return Fy.count(pee(e.getFullYear()) - 1, e);
}
function RG(e) {
  return nw.count(pee(e.getFullYear()) - 1, e);
}
function kG(e) {
  return pee(e).getDay();
}
function Dbt(e, t, n, r, i, o, a) {
  if (0 <= e && e < 100) {
    const s = new Date(-1, t, n, r, i, o, a);
    return s.setFullYear(e), s;
  }
  return new Date(e, t, n, r, i, o, a);
}
function $Ne(e) {
  return INe(new Date(e));
}
function PNe(e) {
  return $G(new Date(e));
}
function INe(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return jx.count(t - 1, e);
}
function $G(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return rw.count(t - 1, e);
}
function PG(e) {
  return PE.setTime(Date.UTC(e, 0, 1)), PE.getUTCDay();
}
function Abt(e, t, n, r, i, o, a) {
  if (0 <= e && e < 100) {
    const s = new Date(Date.UTC(-1, t, n, r, i, o, a));
    return s.setUTCFullYear(n.y), s;
  }
  return new Date(Date.UTC(e, t, n, r, i, o, a));
}
function jNe(e, t, n, r, i) {
  const o = t || 1, a = ri(e), s = (S, C, A) => (A = A || S, Obt(n[A], r[A], S === a && o, C)), u = /* @__PURE__ */ new Date(), l = Wg(e), f = l[rl] ? s(rl) : Gl(2012), h = l[Hl] ? s(Hl) : l[Rf] ? s(Rf) : wx, p = l[Ys] && l[zl] ? s(zl, 1, Ys + zl) : l[Ys] ? s(Ys, 1) : l[zl] ? s(zl, 1) : l[kf] ? s(kf, 1) : l[Qy] ? s(Qy, 1) : SN, g = l[Ud] ? s(Ud) : wx, y = l[Yd] ? s(Yd) : wx, b = l[bp] ? s(bp) : wx, _ = l[qg] ? s(qg) : wx;
  return function(S) {
    u.setTime(+S);
    const C = f(u);
    return i(C, h(u), p(u, C), g(u), y(u), b(u), _(u));
  };
}
function Obt(e, t, n, r) {
  const i = n <= 1 ? e : r ? (o, a) => r + n * Math.floor((e(o, a) - r) / n) : (o, a) => n * Math.floor(e(o, a) / n);
  return t ? (o, a) => t(i(o, a), a) : i;
}
function MC(e, t, n) {
  return t + e * 7 - (n + 6) % 7;
}
const Rbt = {
  [rl]: (e) => e.getFullYear(),
  [Rf]: (e) => Math.floor(e.getMonth() / 3),
  [Hl]: (e) => e.getMonth(),
  [kf]: (e) => e.getDate(),
  [Ud]: (e) => e.getHours(),
  [Yd]: (e) => e.getMinutes(),
  [bp]: (e) => e.getSeconds(),
  [qg]: (e) => e.getMilliseconds(),
  [Qy]: (e) => kNe(e),
  [Ys]: (e) => RG(e),
  [Ys + zl]: (e, t) => MC(RG(e), e.getDay(), kG(t)),
  [zl]: (e, t) => MC(1, e.getDay(), kG(t))
}, kbt = {
  [Rf]: (e) => 3 * e,
  [Ys]: (e, t) => MC(e, 0, kG(t))
};
function LNe(e, t) {
  return jNe(e, t || 1, Rbt, kbt, Dbt);
}
const $bt = {
  [rl]: (e) => e.getUTCFullYear(),
  [Rf]: (e) => Math.floor(e.getUTCMonth() / 3),
  [Hl]: (e) => e.getUTCMonth(),
  [kf]: (e) => e.getUTCDate(),
  [Ud]: (e) => e.getUTCHours(),
  [Yd]: (e) => e.getUTCMinutes(),
  [bp]: (e) => e.getUTCSeconds(),
  [qg]: (e) => e.getUTCMilliseconds(),
  [Qy]: (e) => INe(e),
  [Ys]: (e) => $G(e),
  [zl]: (e, t) => MC(1, e.getUTCDay(), PG(t)),
  [Ys + zl]: (e, t) => MC($G(e), e.getUTCDay(), PG(t))
}, Pbt = {
  [Rf]: (e) => 3 * e,
  [Ys]: (e, t) => MC(e, 0, PG(t))
};
function zNe(e, t) {
  return jNe(e, t || 1, $bt, Pbt, Abt);
}
const Ibt = {
  [rl]: hp,
  [Rf]: pC.every(3),
  [Hl]: pC,
  [Ys]: nw,
  [kf]: Fy,
  [zl]: Fy,
  [Qy]: Fy,
  [Ud]: j$,
  [Yd]: P$,
  [bp]: kg,
  [qg]: hC
}, jbt = {
  [rl]: pp,
  [Rf]: gC.every(3),
  [Hl]: gC,
  [Ys]: rw,
  [kf]: jx,
  [zl]: jx,
  [Qy]: jx,
  [Ud]: L$,
  [Yd]: I$,
  [bp]: kg,
  [qg]: hC
};
function NN(e) {
  return Ibt[e];
}
function DN(e) {
  return jbt[e];
}
function FNe(e, t, n) {
  return e ? e.offset(t, n) : void 0;
}
function BNe(e, t, n) {
  return FNe(NN(e), t, n);
}
function UNe(e, t, n) {
  return FNe(DN(e), t, n);
}
function YNe(e, t, n, r) {
  return e ? e.range(t, n, r) : void 0;
}
function HNe(e, t, n, r) {
  return YNe(NN(e), t, n, r);
}
function VNe(e, t, n, r) {
  return YNe(DN(e), t, n, r);
}
const BO = 1e3, UO = BO * 60, YO = UO * 60, S6 = YO * 24, Lbt = S6 * 7, Dpe = S6 * 30, IG = S6 * 365, WNe = [rl, Hl, kf, Ud, Yd, bp, qg], HO = WNe.slice(0, -1), VO = HO.slice(0, -1), WO = VO.slice(0, -1), zbt = WO.slice(0, -1), Fbt = [rl, Ys], Ape = [rl, Hl], qNe = [rl], nO = [[HO, 1, BO], [HO, 5, 5 * BO], [HO, 15, 15 * BO], [HO, 30, 30 * BO], [VO, 1, UO], [VO, 5, 5 * UO], [VO, 15, 15 * UO], [VO, 30, 30 * UO], [WO, 1, YO], [WO, 3, 3 * YO], [WO, 6, 6 * YO], [WO, 12, 12 * YO], [zbt, 1, S6], [Fbt, 1, Lbt], [Ape, 1, Dpe], [Ape, 3, 3 * Dpe], [qNe, 1, IG]];
function GNe(e) {
  const t = e.extent, n = e.maxbins || 40, r = Math.abs(Z$(t)) / n;
  let i = Qx((s) => s[2]).right(nO, r), o, a;
  return i === nO.length ? (o = qNe, a = Zx(t[0] / IG, t[1] / IG, n)) : i ? (i = nO[r / nO[i - 1][2] < nO[i][2] / r ? i - 1 : i], o = i[0], a = i[1]) : (o = WNe, a = Math.max(Zx(t[0], t[1], n), 1)), {
    units: o,
    step: a
  };
}
function qO(e) {
  const t = {};
  return (n) => t[n] || (t[n] = e(n));
}
function Bbt(e, t) {
  return (n) => {
    const r = e(n), i = r.indexOf(t);
    if (i < 0)
      return r;
    let o = Ubt(r, i);
    const a = o < r.length ? r.slice(o) : "";
    for (; --o > i; )
      if (r[o] !== "0") {
        ++o;
        break;
      }
    return r.slice(0, o) + a;
  };
}
function Ubt(e, t) {
  let n = e.lastIndexOf("e"), r;
  if (n > 0)
    return n;
  for (n = e.length; --n > t; )
    if (r = e.charCodeAt(n), r >= 48 && r <= 57)
      return n + 1;
}
function QNe(e) {
  const t = qO(e.format), n = e.formatPrefix;
  return {
    format: t,
    formatPrefix: n,
    formatFloat(r) {
      const i = CS(r || ",");
      if (i.precision == null) {
        switch (i.precision = 12, i.type) {
          case "%":
            i.precision -= 2;
            break;
          case "e":
            i.precision -= 1;
            break;
        }
        return Bbt(
          t(i),
          // number format
          t(".1f")(1)[1]
          // decimal point character
        );
      } else
        return t(i);
    },
    formatSpan(r, i, o, a) {
      a = CS(a ?? ",f");
      const s = Zx(r, i, o), u = Math.max(Math.abs(r), Math.abs(i));
      let l;
      if (a.precision == null)
        switch (a.type) {
          case "s":
            return isNaN(l = vEe(s, u)) || (a.precision = l), n(a, u);
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            isNaN(l = bEe(s, u)) || (a.precision = l - (a.type === "e"));
            break;
          }
          case "f":
          case "%": {
            isNaN(l = yEe(s)) || (a.precision = l - (a.type === "%") * 2);
            break;
          }
        }
      return t(a);
    }
  };
}
let jG;
XNe();
function XNe() {
  return jG = QNe({
    format: hN,
    formatPrefix: sZ
  });
}
function KNe(e) {
  return QNe(mEe(e));
}
function d5(e) {
  return arguments.length ? jG = KNe(e) : jG;
}
function Ope(e, t, n) {
  n = n || {}, Pt(n) || tt(`Invalid time multi-format specifier: ${n}`);
  const r = t(bp), i = t(Yd), o = t(Ud), a = t(kf), s = t(Ys), u = t(Hl), l = t(Rf), f = t(rl), h = e(n[qg] || ".%L"), p = e(n[bp] || ":%S"), g = e(n[Yd] || "%I:%M"), y = e(n[Ud] || "%I %p"), b = e(n[kf] || n[zl] || "%a %d"), _ = e(n[Ys] || "%b %d"), S = e(n[Hl] || "%B"), C = e(n[Rf] || "%B"), A = e(n[rl] || "%Y");
  return (O) => (r(O) < O ? h : i(O) < O ? p : o(O) < O ? g : a(O) < O ? y : u(O) < O ? s(O) < O ? b : _ : f(O) < O ? l(O) < O ? S : C : A)(O);
}
function ZNe(e) {
  const t = qO(e.format), n = qO(e.utcFormat);
  return {
    timeFormat: (r) => kt(r) ? t(r) : Ope(t, NN, r),
    utcFormat: (r) => kt(r) ? n(r) : Ope(n, DN, r),
    timeParse: qO(e.parse),
    utcParse: qO(e.utcParse)
  };
}
let LG;
JNe();
function JNe() {
  return LG = ZNe({
    format: z$,
    parse: DSe,
    utcFormat: mC,
    utcParse: ASe
  });
}
function eDe(e) {
  return ZNe(SSe(e));
}
function Hk(e) {
  return arguments.length ? LG = eDe(e) : LG;
}
const zG = (e, t) => hr({}, e, t);
function tDe(e, t) {
  const n = e ? KNe(e) : d5(), r = t ? eDe(t) : Hk();
  return zG(n, r);
}
function gee(e, t) {
  const n = arguments.length;
  return n && n !== 2 && tt("defaultLocale expects either zero or two arguments."), n ? zG(d5(e), Hk(t)) : zG(d5(), Hk());
}
function Ybt() {
  return XNe(), JNe(), gee();
}
const Hbt = /^(data:|([A-Za-z]+:)?\/\/)/, Vbt = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, Wbt = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, Rpe = "file://";
function qbt(e, t) {
  return (n) => ({
    options: n || {},
    sanitize: Qbt,
    load: Gbt,
    fileAccess: !!t,
    file: Xbt(t),
    http: Zbt(e)
  });
}
async function Gbt(e, t) {
  const n = await this.sanitize(e, t), r = n.href;
  return n.localFile ? this.file(r) : this.http(r, t);
}
async function Qbt(e, t) {
  t = hr({}, this.options, t);
  const n = this.fileAccess, r = {
    href: null
  };
  let i, o, a;
  const s = Vbt.test(e.replace(Wbt, ""));
  (e == null || typeof e != "string" || !s) && tt("Sanitize failure, invalid URI: " + Et(e));
  const u = Hbt.test(e);
  return (a = t.baseURL) && !u && (!e.startsWith("/") && !a.endsWith("/") && (e = "/" + e), e = a + e), o = (i = e.startsWith(Rpe)) || t.mode === "file" || t.mode !== "http" && !u && n, i ? e = e.slice(Rpe.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), o = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(r, "localFile", {
    value: !!o
  }), r.href = e, t.target && (r.target = t.target + ""), t.rel && (r.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (r.crossOrigin = t.crossOrigin + ""), r;
}
function Xbt(e) {
  return e ? (t) => new Promise((n, r) => {
    e.readFile(t, (i, o) => {
      i ? r(i) : n(o);
    });
  }) : Kbt;
}
async function Kbt() {
  tt("No file system access.");
}
function Zbt(e) {
  return e ? async function(t, n) {
    const r = hr({}, this.options.http, n), i = n && n.response, o = await e(t, r);
    return o.ok ? pr(o[i]) ? o[i]() : o.text() : tt(o.status + "" + o.statusText);
  } : Jbt;
}
async function Jbt() {
  tt("No HTTP fetch method available.");
}
const e1t = (e) => e != null && e === e, t1t = (e) => e === "true" || e === "false" || e === !0 || e === !1, n1t = (e) => !Number.isNaN(Date.parse(e)), nDe = (e) => !Number.isNaN(+e) && !(e instanceof Date), r1t = (e) => nDe(e) && Number.isInteger(+e), FG = {
  boolean: lee,
  integer: Fl,
  number: Fl,
  date: cee,
  string: fee,
  unknown: ql
}, m3 = [t1t, r1t, nDe, n1t], i1t = ["boolean", "integer", "number", "date"];
function rDe(e, t) {
  if (!e || !e.length)
    return "unknown";
  const n = e.length, r = m3.length, i = m3.map((o, a) => a + 1);
  for (let o = 0, a = 0, s, u; o < n; ++o)
    for (u = t ? e[o][t] : e[o], s = 0; s < r; ++s)
      if (i[s] && e1t(u) && !m3[s](u) && (i[s] = 0, ++a, a === m3.length))
        return "string";
  return i1t[i.reduce((o, a) => o === 0 ? a : o, 0) - 1];
}
function iDe(e, t) {
  return t.reduce((n, r) => (n[r] = rDe(e, r), n), {});
}
function kpe(e) {
  const t = function(n, r) {
    const i = {
      delimiter: e
    };
    return mee(n, r ? hr(r, i) : i);
  };
  return t.responseType = "text", t;
}
function mee(e, t) {
  return t.header && (e = t.header.map(Et).join(t.delimiter) + `
` + e), Sut(t.delimiter).parse(e + "");
}
mee.responseType = "text";
function o1t(e) {
  return typeof Buffer == "function" && pr(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1;
}
function yee(e, t) {
  const n = t && t.property ? yp(t.property) : ql;
  return Pt(e) && !o1t(e) ? a1t(n(e), t) : n(JSON.parse(e));
}
yee.responseType = "json";
function a1t(e, t) {
  return !nt(e) && _Ne(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
}
const s1t = {
  interior: (e, t) => e !== t,
  exterior: (e, t) => e === t
};
function oDe(e, t) {
  let n, r, i, o;
  return e = yee(e, t), t && t.feature ? (n = Ebt, i = t.feature) : t && t.mesh ? (n = Mbt, i = t.mesh, o = s1t[t.filter]) : tt("Missing TopoJSON feature or mesh parameter."), r = (r = e.objects[i]) ? n(e, r, o) : tt("Invalid TopoJSON object: " + i), r && r.features || [r];
}
oDe.responseType = "json";
const fj = {
  dsv: mee,
  csv: kpe(","),
  tsv: kpe("	"),
  json: yee,
  topojson: oDe
};
function vee(e, t) {
  return arguments.length > 1 ? (fj[e] = t, this) : wn(fj, e) ? fj[e] : null;
}
function aDe(e) {
  const t = vee(e);
  return t && t.responseType || "text";
}
function sDe(e, t, n, r) {
  t = t || {};
  const i = vee(t.type || "json");
  return i || tt("Unknown data format type: " + t.type), e = i(e, t), t.parse && u1t(e, t.parse, n, r), wn(e, "columns") && delete e.columns, e;
}
function u1t(e, t, n, r) {
  if (!e.length)
    return;
  const i = Hk();
  n = n || i.timeParse, r = r || i.utcParse;
  let o = e.columns || Object.keys(e[0]), a, s, u, l, f, h;
  t === "auto" && (t = iDe(e, o)), o = Object.keys(t);
  const p = o.map((g) => {
    const y = t[g];
    let b, _;
    if (y && (y.startsWith("date:") || y.startsWith("utc:")))
      return b = y.split(/:(.+)?/, 2), _ = b[1], (_[0] === "'" && _[_.length - 1] === "'" || _[0] === '"' && _[_.length - 1] === '"') && (_ = _.slice(1, -1)), (b[0] === "utc" ? r : n)(_);
    if (!FG[y])
      throw Error("Illegal format pattern: " + g + ":" + y);
    return FG[y];
  });
  for (u = 0, f = e.length, h = o.length; u < f; ++u)
    for (a = e[u], l = 0; l < h; ++l)
      s = o[l], a[s] = p[l](a[s]);
}
const M6 = qbt(
  typeof fetch < "u" && fetch,
  // use built-in fetch API
  null
  // no file system access
);
function T6(e) {
  const t = e || ql, n = [], r = {};
  return n.add = (i) => {
    const o = t(i);
    return r[o] || (r[o] = 1, n.push(i)), n;
  }, n.remove = (i) => {
    const o = t(i);
    if (r[o]) {
      r[o] = 0;
      const a = n.indexOf(i);
      a >= 0 && n.splice(a, 1);
    }
    return n;
  }, n;
}
async function dj(e, t) {
  try {
    await t(e);
  } catch (n) {
    e.error(n);
  }
}
const uDe = Symbol("vega_id");
let l1t = 1;
function C6(e) {
  return !!(e && bn(e));
}
function bn(e) {
  return e[uDe];
}
function lDe(e, t) {
  return e[uDe] = t, e;
}
function Ui(e) {
  const t = e === Object(e) ? e : {
    data: e
  };
  return bn(t) ? t : lDe(t, l1t++);
}
function bee(e) {
  return N6(e, Ui({}));
}
function N6(e, t) {
  for (const n in e)
    t[n] = e[n];
  return t;
}
function cDe(e, t) {
  return lDe(t, bn(e));
}
function i2(e, t) {
  return e ? t ? (n, r) => e(n, r) || bn(t(n)) - bn(t(r)) : (n, r) => e(n, r) || bn(n) - bn(r) : null;
}
function fDe(e) {
  return e && e.constructor === o2;
}
function o2() {
  const e = [], t = [], n = [], r = [], i = [];
  let o = null, a = !1;
  return {
    constructor: o2,
    insert(s) {
      const u = Rt(s), l = u.length;
      for (let f = 0; f < l; ++f)
        e.push(u[f]);
      return this;
    },
    remove(s) {
      const u = pr(s) ? r : t, l = Rt(s), f = l.length;
      for (let h = 0; h < f; ++h)
        u.push(l[h]);
      return this;
    },
    modify(s, u, l) {
      const f = {
        field: u,
        value: Gl(l)
      };
      return pr(s) ? (f.filter = s, i.push(f)) : (f.tuple = s, n.push(f)), this;
    },
    encode(s, u) {
      return pr(s) ? i.push({
        filter: s,
        field: u
      }) : n.push({
        tuple: s,
        field: u
      }), this;
    },
    clean(s) {
      return o = s, this;
    },
    reflow() {
      return a = !0, this;
    },
    pulse(s, u) {
      const l = {}, f = {};
      let h, p, g, y, b, _;
      for (h = 0, p = u.length; h < p; ++h)
        l[bn(u[h])] = 1;
      for (h = 0, p = t.length; h < p; ++h)
        b = t[h], l[bn(b)] = -1;
      for (h = 0, p = r.length; h < p; ++h)
        y = r[h], u.forEach((C) => {
          y(C) && (l[bn(C)] = -1);
        });
      for (h = 0, p = e.length; h < p; ++h)
        b = e[h], _ = bn(b), l[_] ? l[_] = 1 : s.add.push(Ui(e[h]));
      for (h = 0, p = u.length; h < p; ++h)
        b = u[h], l[bn(b)] < 0 && s.rem.push(b);
      function S(C, A, O) {
        O ? C[A] = O(C) : s.encode = A, a || (f[bn(C)] = C);
      }
      for (h = 0, p = n.length; h < p; ++h)
        g = n[h], b = g.tuple, y = g.field, _ = l[bn(b)], _ > 0 && (S(b, y, g.value), s.modifies(y));
      for (h = 0, p = i.length; h < p; ++h)
        g = i[h], y = g.filter, u.forEach((C) => {
          y(C) && l[bn(C)] > 0 && S(C, g.field, g.value);
        }), s.modifies(g.field);
      if (a)
        s.mod = t.length || r.length ? u.filter((C) => l[bn(C)] > 0) : u.slice();
      else
        for (_ in f)
          s.mod.push(f[_]);
      return (o || o == null && (t.length || r.length)) && s.clean(!0), s;
    }
  };
}
const hj = "_:mod:_";
function D6() {
  Object.defineProperty(this, hj, {
    writable: !0,
    value: {}
  });
}
D6.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(e, t, n, r) {
    const i = this, o = i[e], a = i[hj];
    return t != null && t >= 0 ? (o[t] !== n || r) && (o[t] = n, a[t + ":" + e] = -1, a[e] = -1) : (o !== n || r) && (i[e] = n, a[e] = nt(n) ? 1 + n.length : -1), i;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(e, t) {
    const n = this[hj];
    if (arguments.length) {
      if (nt(e)) {
        for (let r = 0; r < e.length; ++r)
          if (n[e[r]])
            return !0;
        return !1;
      }
    } else {
      for (const r in n)
        if (n[r])
          return !0;
      return !1;
    }
    return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    return this[hj] = {}, this;
  }
};
let c1t = 0;
const f1t = "pulse", d1t = new D6(), h1t = 1, p1t = 2;
function So(e, t, n, r) {
  this.id = ++c1t, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, r);
}
function $pe(e) {
  return function(t) {
    const n = this.flags;
    return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this);
  };
}
So.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = T6(K$));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(e) {
    return this.value !== e ? (this.value = e, 1) : 0;
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: $pe(h1t),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: $pe(p1t),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(e, t, n) {
    t = t !== !1;
    const r = this._argval = this._argval || new D6(), i = this._argops = this._argops || [], o = [];
    let a, s, u, l;
    const f = (h, p, g) => {
      g instanceof So ? (g !== this && (t && g.targets().add(this), o.push(g)), i.push({
        op: g,
        name: h,
        index: p
      })) : r.set(h, p, g);
    };
    for (a in e)
      if (s = e[a], a === f1t)
        Rt(s).forEach((h) => {
          h instanceof So ? h !== this && (h.targets().add(this), o.push(h)) : tt("Pulse parameters must be operator instances.");
        }), this.source = s;
      else if (nt(s))
        for (r.set(a, -1, Array(u = s.length)), l = 0; l < u; ++l)
          f(a, l, s[l]);
      else
        f(a, -1, s);
    return this.marshall().clear(), n && (i.initonly = !0), o;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(e) {
    const t = this._argval || d1t, n = this._argops;
    let r, i, o, a;
    if (n) {
      const s = n.length;
      for (i = 0; i < s; ++i)
        r = n[i], o = r.op, a = o.modified() && o.stamp === e, t.set(r.name, r.index, o.value, a);
      if (n.initonly) {
        for (i = 0; i < s; ++i)
          r = n[i], r.op.targets().remove(this);
        this._argops = null, this._update = null;
      }
    }
    return t;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const e = this._argops;
    let t, n, r, i;
    if (e)
      for (t = 0, n = e.length; t < n; ++t)
        r = e[t], i = r.op, i._targets && i._targets.remove(this);
    this.pulse = null, this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(e) {
    const t = this._update;
    if (t) {
      const n = this.marshall(e.stamp), r = t.call(this, n, e);
      if (n.clear(), r !== this.value)
        this.value = r;
      else if (!this.modified())
        return e.StopPropagation;
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e;
  }
};
function g1t(e, t, n, r) {
  let i = 1, o;
  return e instanceof So ? o = e : e && e.prototype instanceof So ? o = new e() : pr(e) ? o = new So(null, e) : (i = 0, o = new So(e, t)), this.rank(o), i && (r = n, n = t), n && this.connect(o, o.parameters(n, r)), this.touch(o), o;
}
function m1t(e, t) {
  const n = e.rank, r = t.length;
  for (let i = 0; i < r; ++i)
    if (n < t[i].rank) {
      this.rerank(e);
      return;
    }
}
let y1t = 0;
function A6(e, t, n) {
  this.id = ++y1t, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t);
}
function sx(e, t, n) {
  return new A6(e, t, n);
}
A6.prototype = {
  _filter: vp,
  _apply: ql,
  targets() {
    return this._targets || (this._targets = T6(K$));
  },
  consume(e) {
    return arguments.length ? (this._consume = !!e, this) : !!this._consume;
  },
  receive(e) {
    if (this._filter(e)) {
      const t = this.value = this._apply(e), n = this._targets, r = n ? n.length : 0;
      for (let i = 0; i < r; ++i)
        n[i].receive(t);
      this._consume && (e.preventDefault(), e.stopPropagation());
    }
  },
  filter(e) {
    const t = sx(e);
    return this.targets().add(t), t;
  },
  apply(e) {
    const t = sx(null, e);
    return this.targets().add(t), t;
  },
  merge() {
    const e = sx();
    this.targets().add(e);
    for (let t = 0, n = arguments.length; t < n; ++t)
      arguments[t].targets().add(e);
    return e;
  },
  throttle(e) {
    let t = -1;
    return this.filter(() => {
      const n = Date.now();
      return n - t > e ? (t = n, 1) : 0;
    });
  },
  debounce(e) {
    const t = sx();
    return this.targets().add(sx(null, null, see(e, (n) => {
      const r = n.dataflow;
      t.receive(n), r && r.run && r.run();
    }))), t;
  },
  between(e, t) {
    let n = !1;
    return e.targets().add(sx(null, null, () => n = !0)), t.targets().add(sx(null, null, () => n = !1)), this.filter(() => n);
  },
  detach() {
    this._filter = vp, this._targets = null;
  }
};
function v1t(e, t, n, r) {
  const i = this, o = sx(n, r), a = function(l) {
    l.dataflow = i;
    try {
      o.receive(l);
    } catch (f) {
      i.error(f);
    } finally {
      i.run();
    }
  };
  let s;
  typeof e == "string" && typeof document < "u" ? s = document.querySelectorAll(e) : s = Rt(e);
  const u = s.length;
  for (let l = 0; l < u; ++l)
    s[l].addEventListener(t, a);
  return o;
}
function b1t(e, t) {
  const n = this.locale();
  return sDe(e, t, n.timeParse, n.utcParse);
}
function x1t(e, t, n) {
  return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t));
}
async function w1t(e, t) {
  const n = this;
  let r = 0, i;
  try {
    i = await n.loader().load(e, {
      context: "dataflow",
      response: aDe(t && t.type)
    });
    try {
      i = n.parse(i, t);
    } catch (o) {
      r = -2, n.warn("Data ingestion failed", e, o);
    }
  } catch (o) {
    r = -1, n.warn("Loading failed", e, o);
  }
  return {
    data: i,
    status: r
  };
}
async function _1t(e, t, n) {
  const r = this, i = r._pending || E1t(r);
  i.requests += 1;
  const o = await r.request(t, n);
  return r.pulse(e, r.changeset().remove(vp).insert(o.data || [])), i.done(), o;
}
function E1t(e) {
  let t;
  const n = new Promise((r) => t = r);
  return n.requests = 0, n.done = () => {
    --n.requests === 0 && (e._pending = null, t(e));
  }, e._pending = n;
}
const S1t = {
  skip: !0
};
function M1t(e, t, n, r, i) {
  return (e instanceof So ? C1t : T1t)(this, e, t, n, r, i), this;
}
function T1t(e, t, n, r, i, o) {
  const a = hr({}, o, S1t);
  let s, u;
  pr(n) || (n = Gl(n)), r === void 0 ? s = (l) => e.touch(n(l)) : pr(r) ? (u = new So(null, r, i, !1), s = (l) => {
    u.evaluate(l);
    const f = n(l), h = u.value;
    fDe(h) ? e.pulse(f, h, o) : e.update(f, h, a);
  }) : s = (l) => e.update(n(l), r, a), t.apply(s);
}
function C1t(e, t, n, r, i, o) {
  if (r === void 0)
    t.targets().add(n);
  else {
    const a = o || {}, s = new So(null, N1t(n, r), i, !1);
    s.modified(a.force), s.rank = t.rank, t.targets().add(s), n && (s.skip(!0), s.value = n.value, s.targets().add(n), e.connect(n, [s]));
  }
}
function N1t(e, t) {
  return t = pr(t) ? t : Gl(t), e ? function(n, r) {
    const i = t(n, r);
    return e.skip() || (e.skip(i !== this.value).value = i), i;
  } : t;
}
function D1t(e) {
  e.rank = ++this._rank;
}
function A1t(e) {
  const t = [e];
  let n, r, i;
  for (; t.length; )
    if (this.rank(n = t.pop()), r = n._targets)
      for (i = r.length; --i >= 0; )
        t.push(n = r[i]), n === e && tt("Cycle detected in dataflow graph.");
}
const h5 = {}, xy = 1, dx = 2, j0 = 4, O1t = xy | dx, Ppe = xy | j0, VM = xy | dx | j0, Ipe = 8, rO = 16, jpe = 32, Lpe = 64;
function Fx(e, t, n) {
  this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null;
}
function qH(e, t) {
  const n = [];
  return fx(e, t, (r) => n.push(r)), n;
}
function zpe(e, t) {
  const n = {};
  return e.visit(t, (r) => {
    n[bn(r)] = 1;
  }), (r) => n[bn(r)] ? null : r;
}
function y3(e, t) {
  return e ? (n, r) => e(n, r) && t(n, r) : t;
}
Fx.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation: h5,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD: xy,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM: dx,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD: j0,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM: O1t,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD: Ppe,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL: VM,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW: Ipe,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE: rO,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE: jpe,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS: Lpe,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(e) {
    return new Fx(this.dataflow).init(this, e);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const e = this.fork(VM);
    return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(VM | rO);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let e = this;
    return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new Fx(this.dataflow).init(this), e.add = e.source, e.rem = []), e;
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(e, t) {
    const n = this;
    return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & Lpe) && (n.fields = e.fields), t & xy ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & dx ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & j0 ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & jpe ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(e) {
    this.dataflow.runAfter(e);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(e) {
    const t = e || VM;
    return t & xy && this.add.length || t & dx && this.rem.length || t & j0 && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(e) {
    if (e)
      return this.fork(VM).reflow();
    const t = this.add.length, n = this.source && this.source.length;
    return n && n !== t && (this.mod = this.source, t && this.filter(j0, zpe(this, xy))), this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(e) {
    return arguments.length ? (this.cleans = !!e, this) : this.cleans;
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(e) {
    const t = this.fields || (this.fields = {});
    return nt(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(e, t) {
    const n = this.fields;
    return (t || this.mod.length) && n ? arguments.length ? nt(e) ? e.some((r) => n[r]) : n[e] : !!n : !1;
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(e, t) {
    const n = this;
    return e & xy && (n.addF = y3(n.addF, t)), e & dx && (n.remF = y3(n.remF, t)), e & j0 && (n.modF = y3(n.modF, t)), e & rO && (n.srcF = y3(n.srcF, t)), n;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(e) {
    e = e || VM;
    const t = this;
    return e & xy && t.addF && (t.add = qH(t.add, t.addF), t.addF = null), e & dx && t.remF && (t.rem = qH(t.rem, t.remF), t.remF = null), e & j0 && t.modF && (t.mod = qH(t.mod, t.modF), t.modF = null), e & rO && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(e, t) {
    const n = this, r = t;
    if (e & rO)
      return fx(n.source, n.srcF, r), n;
    e & xy && fx(n.add, n.addF, r), e & dx && fx(n.rem, n.remF, r), e & j0 && fx(n.mod, n.modF, r);
    const i = n.source;
    if (e & Ipe && i) {
      const o = n.add.length + n.mod.length;
      o === i.length || (o ? fx(i, zpe(n, Ppe), r) : fx(i, n.srcF, r));
    }
    return n;
  }
};
function xee(e, t, n, r) {
  const i = this;
  let o = 0;
  this.dataflow = e, this.stamp = t, this.fields = null, this.encode = r || null, this.pulses = n;
  for (const a of n)
    if (a.stamp === t) {
      if (a.fields) {
        const s = i.fields || (i.fields = {});
        for (const u in a.fields)
          s[u] = 1;
      }
      a.changed(i.ADD) && (o |= i.ADD), a.changed(i.REM) && (o |= i.REM), a.changed(i.MOD) && (o |= i.MOD);
    }
  this.changes = o;
}
Tt(xee, Fx, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(e) {
    const t = new Fx(this.dataflow).init(this, e & this.NO_FIELDS);
    return e !== void 0 && (e & t.ADD && this.visit(t.ADD, (n) => t.add.push(n)), e & t.REM && this.visit(t.REM, (n) => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, (n) => t.mod.push(n))), t;
  },
  changed(e) {
    return this.changes & e;
  },
  modified(e) {
    const t = this, n = t.fields;
    return n && t.changes & t.MOD ? nt(e) ? e.some((r) => n[r]) : n[e] : 0;
  },
  filter() {
    tt("MultiPulse does not support filtering.");
  },
  materialize() {
    tt("MultiPulse does not support materialization.");
  },
  visit(e, t) {
    const n = this, r = n.pulses, i = r.length;
    let o = 0;
    if (e & n.SOURCE)
      for (; o < i; ++o)
        r[o].visit(e, t);
    else
      for (; o < i; ++o)
        r[o].stamp === n.stamp && r[o].visit(e, t);
    return n;
  }
});
async function R1t(e, t, n) {
  const r = this, i = [];
  if (r._pulse)
    return dDe(r);
  if (r._pending && await r._pending, t && await dj(r, t), !r._touched.length)
    return r.debug("Dataflow invoked, but nothing to do."), r;
  const o = ++r._clock;
  r._pulse = new Fx(r, o, e), r._touched.forEach((f) => r._enqueue(f, !0)), r._touched = T6(K$);
  let a = 0, s, u, l;
  try {
    for (; r._heap.size() > 0; ) {
      if (s = r._heap.pop(), s.rank !== s.qrank) {
        r._enqueue(s, !0);
        continue;
      }
      u = s.run(r._getPulse(s, e)), u.then ? u = await u : u.async && (i.push(u.async), u = h5), u !== h5 && s._targets && s._targets.forEach((f) => r._enqueue(f)), ++a;
    }
  } catch (f) {
    r._heap.clear(), l = f;
  }
  if (r._input = {}, r._pulse = null, r.debug(`Pulse ${o}: ${a} operators`), l && (r._postrun = [], r.error(l)), r._postrun.length) {
    const f = r._postrun.sort((h, p) => p.priority - h.priority);
    r._postrun = [];
    for (let h = 0; h < f.length; ++h)
      await dj(r, f[h].callback);
  }
  return n && await dj(r, n), i.length && Promise.all(i).then((f) => r.runAsync(null, () => {
    f.forEach((h) => {
      try {
        h(r);
      } catch (p) {
        r.error(p);
      }
    });
  })), r;
}
async function k1t(e, t, n) {
  for (; this._running; )
    await this._running;
  const r = () => this._running = null;
  return (this._running = this.evaluate(e, t, n)).then(r, r), this._running;
}
function $1t(e, t, n) {
  return this._pulse ? dDe(this) : (this.evaluate(e, t, n), this);
}
function P1t(e, t, n) {
  if (this._pulse || t)
    this._postrun.push({
      priority: n || 0,
      callback: e
    });
  else
    try {
      e(this);
    } catch (r) {
      this.error(r);
    }
}
function dDe(e) {
  return e.error("Dataflow already running. Use runAsync() to chain invocations."), e;
}
function I1t(e, t) {
  const n = e.stamp < this._clock;
  n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e));
}
function j1t(e, t) {
  const n = e.source, r = this._clock;
  return n && nt(n) ? new xee(this, r, n.map((i) => i.pulse), t) : this._input[e.id] || L1t(this._pulse, n && n.pulse);
}
function L1t(e, t) {
  return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== h5 && (e.source = t.source), e);
}
const wee = {
  skip: !1,
  force: !1
};
function z1t(e, t) {
  const n = t || wee;
  return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this;
}
function F1t(e, t, n) {
  const r = n || wee;
  return (e.set(t) || r.force) && this.touch(e, r), this;
}
function B1t(e, t, n) {
  this.touch(e, n || wee);
  const r = new Fx(this, this._clock + (this._pulse ? 0 : 1)), i = e.pulse && e.pulse.source || [];
  return r.target = e, this._input[e.id] = t.pulse(r, i), this;
}
function U1t(e) {
  let t = [];
  return {
    clear: () => t = [],
    size: () => t.length,
    peek: () => t[0],
    push: (n) => (t.push(n), hDe(t, 0, t.length - 1, e)),
    pop: () => {
      const n = t.pop();
      let r;
      return t.length ? (r = t[0], t[0] = n, Y1t(t, 0, e)) : r = n, r;
    }
  };
}
function hDe(e, t, n, r) {
  let i, o;
  const a = e[n];
  for (; n > t; ) {
    if (o = n - 1 >> 1, i = e[o], r(a, i) < 0) {
      e[n] = i, n = o;
      continue;
    }
    break;
  }
  return e[n] = a;
}
function Y1t(e, t, n) {
  const r = t, i = e.length, o = e[t];
  let a = (t << 1) + 1, s;
  for (; a < i; )
    s = a + 1, s < i && n(e[a], e[s]) >= 0 && (a = s), e[t] = e[a], t = a, a = (t << 1) + 1;
  return e[t] = o, hDe(e, r, t, n);
}
function $T() {
  this.logger(nee()), this.logLevel(eee), this._clock = 0, this._rank = 0, this._locale = gee();
  try {
    this._loader = M6();
  } catch {
  }
  this._touched = T6(K$), this._input = {}, this._pulse = null, this._heap = U1t((e, t) => e.qrank - t.qrank), this._postrun = [];
}
function iO(e) {
  return function() {
    return this._log[e].apply(this, arguments);
  };
}
$T.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(e) {
    return arguments.length ? (this._loader = e, this) : this._loader;
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(e) {
    return arguments.length ? (this._locale = e, this) : this._locale;
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(e) {
    return arguments.length ? (this._log = e, this) : this._log;
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: iO("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: iO("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: iO("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: iO("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: iO("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add: g1t,
  connect: m1t,
  rank: D1t,
  rerank: A1t,
  // OPERATOR UPDATES
  pulse: B1t,
  touch: z1t,
  update: F1t,
  changeset: o2,
  // DATA LOADING
  ingest: x1t,
  parse: b1t,
  preload: _1t,
  request: w1t,
  // EVENT HANDLING
  events: v1t,
  on: M1t,
  // PULSE PROPAGATION
  evaluate: R1t,
  run: $1t,
  runAsync: k1t,
  runAfter: P1t,
  _enqueue: I1t,
  _getPulse: j1t
};
function Ge(e, t) {
  So.call(this, e, null, t);
}
Tt(Ge, So, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then((n) => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(e) {
    const t = this.marshall(e.stamp), n = this.transform(t, e);
    return t.clear(), n;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
const TC = {};
function pDe(e) {
  const t = gDe(e);
  return t && t.Definition || null;
}
function gDe(e) {
  return e = e && e.toLowerCase(), wn(TC, e) ? TC[e] : null;
}
function* mDe(e, t) {
  if (t == null)
    for (let n of e)
      n != null && n !== "" && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let r of e)
      r = t(r, ++n, e), r != null && r !== "" && (r = +r) >= r && (yield r);
  }
}
function _ee(e, t, n) {
  const r = Float64Array.from(mDe(e, n));
  return r.sort(Go), t.map((i) => p_e(r, i));
}
function Eee(e, t) {
  return _ee(e, [0.25, 0.5, 0.75], t);
}
function See(e, t) {
  const n = e.length, r = lN(e, t), i = Eee(e, t), o = (i[2] - i[0]) / 1.34;
  return 1.06 * (Math.min(r, o) || r || Math.abs(i[0]) || 1) * Math.pow(n, -0.2);
}
function yDe(e) {
  const t = e.maxbins || 20, n = e.base || 10, r = Math.log(n), i = e.divide || [5, 2];
  let o = e.extent[0], a = e.extent[1], s, u, l, f, h, p;
  const g = e.span || a - o || Math.abs(o) || 1;
  if (e.step)
    s = e.step;
  else if (e.steps) {
    for (f = g / t, h = 0, p = e.steps.length; h < p && e.steps[h] < f; ++h)
      ;
    s = e.steps[Math.max(0, h - 1)];
  } else {
    for (u = Math.ceil(Math.log(t) / r), l = e.minstep || 0, s = Math.max(l, Math.pow(n, Math.round(Math.log(g) / r) - u)); Math.ceil(g / s) > t; )
      s *= n;
    for (h = 0, p = i.length; h < p; ++h)
      f = s / i[h], f >= l && g / f <= t && (s = f);
  }
  f = Math.log(s);
  const y = f >= 0 ? 0 : ~~(-f / r) + 1, b = Math.pow(n, -y - 1);
  return (e.nice || e.nice === void 0) && (f = Math.floor(o / s + b) * s, o = o < f ? f - s : f, a = Math.ceil(a / s) * s), {
    start: o,
    stop: a === o ? o + s : a,
    step: s
  };
}
var xp = Math.random;
function H1t(e) {
  xp = e;
}
function vDe(e, t, n, r) {
  if (!e.length)
    return [void 0, void 0];
  const i = Float64Array.from(mDe(e, r)), o = i.length, a = t;
  let s, u, l, f;
  for (l = 0, f = Array(a); l < a; ++l) {
    for (s = 0, u = 0; u < o; ++u)
      s += i[~~(xp() * o)];
    f[l] = s / o;
  }
  return f.sort(Go), [Wy(f, n / 2), Wy(f, 1 - n / 2)];
}
function bDe(e, t, n, r) {
  r = r || ((p) => p);
  const i = e.length, o = new Float64Array(i);
  let a = 0, s = 1, u = r(e[0]), l = u, f = u + t, h;
  for (; s < i; ++s) {
    if (h = r(e[s]), h >= f) {
      for (l = (u + l) / 2; a < s; ++a)
        o[a] = l;
      f = h + t, u = h;
    }
    l = h;
  }
  for (l = (u + l) / 2; a < s; ++a)
    o[a] = l;
  return n ? V1t(o, t + t / 4) : o;
}
function V1t(e, t) {
  const n = e.length;
  let r = 0, i = 1, o, a;
  for (; e[r] === e[i]; )
    ++i;
  for (; i < n; ) {
    for (o = i + 1; e[i] === e[o]; )
      ++o;
    if (e[i] - e[i - 1] < t) {
      for (a = i + (r + o - i - i >> 1); a < i; )
        e[a++] = e[i];
      for (; a > i; )
        e[a--] = e[r];
    }
    r = i, i = o;
  }
  return e;
}
function W1t(e) {
  return function() {
    return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647;
  };
}
function q1t(e, t) {
  t == null && (t = e, e = 0);
  let n, r, i;
  const o = {
    min(a) {
      return arguments.length ? (n = a || 0, i = r - n, o) : n;
    },
    max(a) {
      return arguments.length ? (r = a || 0, i = r - n, o) : r;
    },
    sample() {
      return n + Math.floor(i * xp());
    },
    pdf(a) {
      return a === Math.floor(a) && a >= n && a < r ? 1 / i : 0;
    },
    cdf(a) {
      const s = Math.floor(a);
      return s < n ? 0 : s >= r ? 1 : (s - n + 1) / i;
    },
    icdf(a) {
      return a >= 0 && a <= 1 ? n - 1 + Math.floor(a * i) : NaN;
    }
  };
  return o.min(e).max(t);
}
const xDe = Math.sqrt(2 * Math.PI), G1t = Math.SQRT2;
let oO = NaN;
function O6(e, t) {
  e = e || 0, t = t ?? 1;
  let n = 0, r = 0, i, o;
  if (oO === oO)
    n = oO, oO = NaN;
  else {
    do
      n = xp() * 2 - 1, r = xp() * 2 - 1, i = n * n + r * r;
    while (i === 0 || i > 1);
    o = Math.sqrt(-2 * Math.log(i) / i), n *= o, oO = r * o;
  }
  return e + n * t;
}
function Mee(e, t, n) {
  n = n ?? 1;
  const r = (e - (t || 0)) / n;
  return Math.exp(-0.5 * r * r) / (n * xDe);
}
function R6(e, t, n) {
  t = t || 0, n = n ?? 1;
  const r = (e - t) / n, i = Math.abs(r);
  let o;
  if (i > 37)
    o = 0;
  else {
    const a = Math.exp(-i * i / 2);
    let s;
    i < 7.07106781186547 ? (s = 0.0352624965998911 * i + 0.700383064443688, s = s * i + 6.37396220353165, s = s * i + 33.912866078383, s = s * i + 112.079291497871, s = s * i + 221.213596169931, s = s * i + 220.206867912376, o = a * s, s = 0.0883883476483184 * i + 1.75566716318264, s = s * i + 16.064177579207, s = s * i + 86.7807322029461, s = s * i + 296.564248779674, s = s * i + 637.333633378831, s = s * i + 793.826512519948, s = s * i + 440.413735824752, o = o / s) : (s = i + 0.65, s = i + 4 / s, s = i + 3 / s, s = i + 2 / s, s = i + 1 / s, o = a / s / 2.506628274631);
  }
  return r > 0 ? 1 - o : o;
}
function k6(e, t, n) {
  return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * G1t * Q1t(2 * e - 1);
}
function Q1t(e) {
  let t = -Math.log((1 - e) * (1 + e)), n;
  return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
}
function Tee(e, t) {
  let n, r;
  const i = {
    mean(o) {
      return arguments.length ? (n = o || 0, i) : n;
    },
    stdev(o) {
      return arguments.length ? (r = o ?? 1, i) : r;
    },
    sample: () => O6(n, r),
    pdf: (o) => Mee(o, n, r),
    cdf: (o) => R6(o, n, r),
    icdf: (o) => k6(o, n, r)
  };
  return i.mean(e).stdev(t);
}
function Cee(e, t) {
  const n = Tee();
  let r = 0;
  const i = {
    data(o) {
      return arguments.length ? (e = o, r = o ? o.length : 0, i.bandwidth(t)) : e;
    },
    bandwidth(o) {
      return arguments.length ? (t = o, !t && e && (t = See(e)), i) : t;
    },
    sample() {
      return e[~~(xp() * r)] + t * n.sample();
    },
    pdf(o) {
      let a = 0, s = 0;
      for (; s < r; ++s)
        a += n.pdf((o - e[s]) / t);
      return a / t / r;
    },
    cdf(o) {
      let a = 0, s = 0;
      for (; s < r; ++s)
        a += n.cdf((o - e[s]) / t);
      return a / r;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return i.data(e);
}
function Nee(e, t) {
  return e = e || 0, t = t ?? 1, Math.exp(e + O6() * t);
}
function Dee(e, t, n) {
  if (e <= 0)
    return 0;
  t = t || 0, n = n ?? 1;
  const r = (Math.log(e) - t) / n;
  return Math.exp(-0.5 * r * r) / (n * xDe * e);
}
function Aee(e, t, n) {
  return R6(Math.log(e), t, n);
}
function Oee(e, t, n) {
  return Math.exp(k6(e, t, n));
}
function wDe(e, t) {
  let n, r;
  const i = {
    mean(o) {
      return arguments.length ? (n = o || 0, i) : n;
    },
    stdev(o) {
      return arguments.length ? (r = o ?? 1, i) : r;
    },
    sample: () => Nee(n, r),
    pdf: (o) => Dee(o, n, r),
    cdf: (o) => Aee(o, n, r),
    icdf: (o) => Oee(o, n, r)
  };
  return i.mean(e).stdev(t);
}
function _De(e, t) {
  let n = 0, r;
  function i(a) {
    const s = [];
    let u = 0, l;
    for (l = 0; l < n; ++l)
      u += s[l] = a[l] == null ? 1 : +a[l];
    for (l = 0; l < n; ++l)
      s[l] /= u;
    return s;
  }
  const o = {
    weights(a) {
      return arguments.length ? (r = i(t = a || []), o) : t;
    },
    distributions(a) {
      return arguments.length ? (a ? (n = a.length, e = a) : (n = 0, e = []), o.weights(t)) : e;
    },
    sample() {
      const a = xp();
      let s = e[n - 1], u = r[0], l = 0;
      for (; l < n - 1; u += r[++l])
        if (a < u) {
          s = e[l];
          break;
        }
      return s.sample();
    },
    pdf(a) {
      let s = 0, u = 0;
      for (; u < n; ++u)
        s += r[u] * e[u].pdf(a);
      return s;
    },
    cdf(a) {
      let s = 0, u = 0;
      for (; u < n; ++u)
        s += r[u] * e[u].cdf(a);
      return s;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return o.distributions(e).weights(t);
}
function Ree(e, t) {
  return t == null && (t = e ?? 1, e = 0), e + (t - e) * xp();
}
function kee(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0;
}
function $ee(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t);
}
function Pee(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN;
}
function EDe(e, t) {
  let n, r;
  const i = {
    min(o) {
      return arguments.length ? (n = o || 0, i) : n;
    },
    max(o) {
      return arguments.length ? (r = o ?? 1, i) : r;
    },
    sample: () => Ree(n, r),
    pdf: (o) => kee(o, n, r),
    cdf: (o) => $ee(o, n, r),
    icdf: (o) => Pee(o, n, r)
  };
  return t == null && (t = e ?? 1, e = 0), i.min(e).max(t);
}
function Iee(e, t, n) {
  let r = 0, i = 0;
  for (const o of e) {
    const a = n(o);
    t(o) == null || a == null || isNaN(a) || (r += (a - r) / ++i);
  }
  return {
    coef: [r],
    predict: () => r,
    rSquared: 0
  };
}
function J$(e, t, n, r) {
  const i = r - e * e, o = Math.abs(i) < 1e-24 ? 0 : (n - e * t) / i;
  return [t - o * e, o];
}
function $6(e, t, n, r) {
  e = e.filter((g) => {
    let y = t(g), b = n(g);
    return y != null && (y = +y) >= y && b != null && (b = +b) >= b;
  }), r && e.sort((g, y) => t(g) - t(y));
  const i = e.length, o = new Float64Array(i), a = new Float64Array(i);
  let s = 0, u = 0, l = 0, f, h, p;
  for (p of e)
    o[s] = f = +t(p), a[s] = h = +n(p), ++s, u += (f - u) / s, l += (h - l) / s;
  for (s = 0; s < i; ++s)
    o[s] -= u, a[s] -= l;
  return [o, a, u, l];
}
function e4(e, t, n, r) {
  let i = -1, o, a;
  for (const s of e)
    o = t(s), a = n(s), o != null && (o = +o) >= o && a != null && (a = +a) >= a && r(o, a, ++i);
}
function AN(e, t, n, r, i) {
  let o = 0, a = 0;
  return e4(e, t, n, (s, u) => {
    const l = u - i(s), f = u - r;
    o += l * l, a += f * f;
  }), 1 - o / a;
}
function jee(e, t, n) {
  let r = 0, i = 0, o = 0, a = 0, s = 0;
  e4(e, t, n, (f, h) => {
    ++s, r += (f - r) / s, i += (h - i) / s, o += (f * h - o) / s, a += (f * f - a) / s;
  });
  const u = J$(r, i, o, a), l = (f) => u[0] + u[1] * f;
  return {
    coef: u,
    predict: l,
    rSquared: AN(e, t, n, i, l)
  };
}
function SDe(e, t, n) {
  let r = 0, i = 0, o = 0, a = 0, s = 0;
  e4(e, t, n, (f, h) => {
    ++s, f = Math.log(f), r += (f - r) / s, i += (h - i) / s, o += (f * h - o) / s, a += (f * f - a) / s;
  });
  const u = J$(r, i, o, a), l = (f) => u[0] + u[1] * Math.log(f);
  return {
    coef: u,
    predict: l,
    rSquared: AN(e, t, n, i, l)
  };
}
function MDe(e, t, n) {
  const [r, i, o, a] = $6(e, t, n);
  let s = 0, u = 0, l = 0, f = 0, h = 0, p, g, y;
  e4(e, t, n, (C, A) => {
    p = r[h++], g = Math.log(A), y = p * A, s += (A * g - s) / h, u += (y - u) / h, l += (y * g - l) / h, f += (p * y - f) / h;
  });
  const [b, _] = J$(u / a, s / a, l / a, f / a), S = (C) => Math.exp(b + _ * (C - o));
  return {
    coef: [Math.exp(b - _ * o), _],
    predict: S,
    rSquared: AN(e, t, n, a, S)
  };
}
function TDe(e, t, n) {
  let r = 0, i = 0, o = 0, a = 0, s = 0, u = 0;
  e4(e, t, n, (h, p) => {
    const g = Math.log(h), y = Math.log(p);
    ++u, r += (g - r) / u, i += (y - i) / u, o += (g * y - o) / u, a += (g * g - a) / u, s += (p - s) / u;
  });
  const l = J$(r, i, o, a), f = (h) => l[0] * Math.pow(h, l[1]);
  return l[0] = Math.exp(l[0]), {
    coef: l,
    predict: f,
    rSquared: AN(e, t, n, s, f)
  };
}
function Lee(e, t, n) {
  const [r, i, o, a] = $6(e, t, n), s = r.length;
  let u = 0, l = 0, f = 0, h = 0, p = 0, g, y, b, _;
  for (g = 0; g < s; )
    y = r[g], b = i[g++], _ = y * y, u += (_ - u) / g, l += (_ * y - l) / g, f += (_ * _ - f) / g, h += (y * b - h) / g, p += (_ * b - p) / g;
  const S = f - u * u, C = u * S - l * l, A = (p * u - h * l) / C, O = (h * S - p * l) / C, R = -A * u, j = ($) => ($ = $ - o, A * $ * $ + O * $ + R + a);
  return {
    coef: [R - O * o + A * o * o + a, O - 2 * A * o, A],
    predict: j,
    rSquared: AN(e, t, n, a, j)
  };
}
function CDe(e, t, n, r) {
  if (r === 0)
    return Iee(e, t, n);
  if (r === 1)
    return jee(e, t, n);
  if (r === 2)
    return Lee(e, t, n);
  const [i, o, a, s] = $6(e, t, n), u = i.length, l = [], f = [], h = r + 1;
  let p, g, y, b, _;
  for (p = 0; p < h; ++p) {
    for (y = 0, b = 0; y < u; ++y)
      b += Math.pow(i[y], p) * o[y];
    for (l.push(b), _ = new Float64Array(h), g = 0; g < h; ++g) {
      for (y = 0, b = 0; y < u; ++y)
        b += Math.pow(i[y], p + g);
      _[g] = b;
    }
    f.push(_);
  }
  f.push(l);
  const S = K1t(f), C = (A) => {
    A -= a;
    let O = s + S[0] + S[1] * A + S[2] * A * A;
    for (p = 3; p < h; ++p)
      O += S[p] * Math.pow(A, p);
    return O;
  };
  return {
    coef: X1t(h, S, -a, s),
    predict: C,
    rSquared: AN(e, t, n, s, C)
  };
}
function X1t(e, t, n, r) {
  const i = Array(e);
  let o, a, s, u;
  for (o = 0; o < e; ++o)
    i[o] = 0;
  for (o = e - 1; o >= 0; --o)
    for (s = t[o], u = 1, i[o] += s, a = 1; a <= o; ++a)
      u *= (o + 1 - a) / a, i[o - a] += s * Math.pow(n, a) * u;
  return i[0] += r, i;
}
function K1t(e) {
  const t = e.length - 1, n = [];
  let r, i, o, a, s;
  for (r = 0; r < t; ++r) {
    for (a = r, i = r + 1; i < t; ++i)
      Math.abs(e[r][i]) > Math.abs(e[r][a]) && (a = i);
    for (o = r; o < t + 1; ++o)
      s = e[o][r], e[o][r] = e[o][a], e[o][a] = s;
    for (i = r + 1; i < t; ++i)
      for (o = t; o >= r; o--)
        e[o][i] -= e[o][r] * e[r][i] / e[r][r];
  }
  for (i = t - 1; i >= 0; --i) {
    for (s = 0, o = i + 1; o < t; ++o)
      s += e[o][i] * n[o];
    n[i] = (e[t][i] - s) / e[i][i];
  }
  return n;
}
const Fpe = 2, Bpe = 1e-12;
function NDe(e, t, n, r) {
  const [i, o, a, s] = $6(e, t, n, !0), u = i.length, l = Math.max(2, ~~(r * u)), f = new Float64Array(u), h = new Float64Array(u), p = new Float64Array(u).fill(1);
  for (let g = -1; ++g <= Fpe; ) {
    const y = [0, l - 1];
    for (let _ = 0; _ < u; ++_) {
      const S = i[_], C = y[0], A = y[1], O = S - i[C] > i[A] - S ? C : A;
      let R = 0, j = 0, $ = 0, z = 0, W = 0;
      const Y = 1 / Math.abs(i[O] - S || 1);
      for (let K = C; K <= A; ++K) {
        const Q = i[K], q = o[K], te = Z1t(Math.abs(S - Q) * Y) * p[K], X = Q * te;
        R += te, j += X, $ += q * te, z += q * X, W += Q * X;
      }
      const [V, ee] = J$(j / R, $ / R, z / R, W / R);
      f[_] = V + ee * S, h[_] = Math.abs(o[_] - f[_]), J1t(i, _ + 1, y);
    }
    if (g === Fpe)
      break;
    const b = Jx(h);
    if (Math.abs(b) < Bpe)
      break;
    for (let _ = 0, S, C; _ < u; ++_)
      S = h[_] / (6 * b), p[_] = S >= 1 ? Bpe : (C = 1 - S * S) * C;
  }
  return ext(i, f, a, s);
}
function Z1t(e) {
  return (e = 1 - e * e * e) * e * e;
}
function J1t(e, t, n) {
  const r = e[t];
  let i = n[0], o = n[1] + 1;
  if (!(o >= e.length))
    for (; t > i && e[o] - r <= r - e[i]; )
      n[0] = ++i, n[1] = o, ++o;
}
function ext(e, t, n, r) {
  const i = e.length, o = [];
  let a = 0, s = 0, u = [], l;
  for (; a < i; ++a)
    l = e[a] + n, u[0] === l ? u[1] += (t[a] - u[1]) / ++s : (s = 0, u[1] += r, u = [l, t[a]], o.push(u));
  return u[1] += r, o;
}
const txt = 0.5 * Math.PI / 180;
function P6(e, t, n, r) {
  n = n || 25, r = Math.max(n, r || 200);
  const i = (b) => [b, e(b)], o = t[0], a = t[1], s = a - o, u = s / r, l = [i(o)], f = [];
  if (n === r) {
    for (let b = 1; b < r; ++b)
      l.push(i(o + b / n * s));
    return l.push(i(a)), l;
  } else {
    f.push(i(a));
    for (let b = n; --b > 0; )
      f.push(i(o + b / n * s));
  }
  let h = l[0], p = f[f.length - 1];
  const g = 1 / s, y = nxt(h[1], f);
  for (; p; ) {
    const b = i((h[0] + p[0]) / 2);
    b[0] - h[0] >= u && rxt(h, b, p, g, y) > txt ? f.push(b) : (h = p, l.push(p), f.pop()), p = f[f.length - 1];
  }
  return l;
}
function nxt(e, t) {
  let n = e, r = e;
  const i = t.length;
  for (let o = 0; o < i; ++o) {
    const a = t[o][1];
    a < n && (n = a), a > r && (r = a);
  }
  return 1 / (r - n);
}
function rxt(e, t, n, r, i) {
  const o = Math.atan2(i * (n[1] - e[1]), r * (n[0] - e[0])), a = Math.atan2(i * (t[1] - e[1]), r * (t[0] - e[0]));
  return Math.abs(o - a);
}
function ixt(e) {
  return (t) => {
    const n = e.length;
    let r = 1, i = String(e[0](t));
    for (; r < n; ++r)
      i += "|" + e[r](t);
    return i;
  };
}
function BG(e) {
  return !e || !e.length ? function() {
    return "";
  } : e.length === 1 ? e[0] : ixt(e);
}
function DDe(e, t, n) {
  return n || e + (t ? "_" + t : "");
}
const GH = () => {
}, oxt = {
  init: GH,
  add: GH,
  rem: GH,
  idx: 0
}, Vk = {
  values: {
    init: (e) => e.cell.store = !0,
    value: (e) => e.cell.data.values(),
    idx: -1
  },
  count: {
    value: (e) => e.cell.num
  },
  __count__: {
    value: (e) => e.missing + e.valid
  },
  missing: {
    value: (e) => e.missing
  },
  valid: {
    value: (e) => e.valid
  },
  sum: {
    init: (e) => e.sum = 0,
    value: (e) => e.valid ? e.sum : void 0,
    add: (e, t) => e.sum += +t,
    rem: (e, t) => e.sum -= t
  },
  product: {
    init: (e) => e.product = 1,
    value: (e) => e.valid ? e.product : void 0,
    add: (e, t) => e.product *= t,
    rem: (e, t) => e.product /= t
  },
  mean: {
    init: (e) => e.mean = 0,
    value: (e) => e.valid ? e.mean : void 0,
    add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
    rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
  },
  average: {
    value: (e) => e.valid ? e.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (e) => e.dev = 0,
    value: (e) => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
    add: (e, t) => e.dev += e.mean_d * (t - e.mean),
    rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (e) => e.valid > 1 ? e.dev / e.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (e) => e.cell.data.distinct(e.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (e) => e.cell.data.ci0(e.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (e) => e.cell.data.ci1(e.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (e) => e.cell.data.q2(e.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (e) => e.cell.data.q1(e.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (e) => e.cell.data.q3(e.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (e) => e.min = void 0,
    value: (e) => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
    add: (e, t) => {
      (t < e.min || e.min === void 0) && (e.min = t);
    },
    rem: (e, t) => {
      t <= e.min && (e.min = NaN);
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (e) => e.max = void 0,
    value: (e) => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
    add: (e, t) => {
      (t > e.max || e.max === void 0) && (e.max = t);
    },
    rem: (e, t) => {
      t >= e.max && (e.max = NaN);
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (e) => e.argmin = void 0,
    value: (e) => e.argmin || e.cell.data.argmin(e.get),
    add: (e, t, n) => {
      t < e.min && (e.argmin = n);
    },
    rem: (e, t) => {
      t <= e.min && (e.argmin = void 0);
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (e) => e.argmax = void 0,
    value: (e) => e.argmax || e.cell.data.argmax(e.get),
    add: (e, t, n) => {
      t > e.max && (e.argmax = n);
    },
    rem: (e, t) => {
      t >= e.max && (e.argmax = void 0);
    },
    req: ["max", "values"],
    idx: 3
  },
  exponential: {
    init: (e, t) => {
      e.exp = 0, e.exp_r = t;
    },
    value: (e) => e.valid ? e.exp * (1 - e.exp_r) / (1 - e.exp_r ** e.valid) : void 0,
    add: (e, t) => e.exp = e.exp_r * e.exp + t,
    rem: (e, t) => e.exp = (e.exp - t / e.exp_r ** (e.valid - 1)) / e.exp_r
  },
  exponentialb: {
    value: (e) => e.valid ? e.exp * (1 - e.exp_r) : void 0,
    req: ["exponential"],
    idx: 1
  }
}, t4 = Object.keys(Vk).filter((e) => e !== "__count__");
function axt(e, t) {
  return (n, r) => hr({
    name: e,
    aggregate_param: r,
    out: n || e
  }, oxt, t);
}
[...t4, "__count__"].forEach((e) => {
  Vk[e] = axt(e, Vk[e]);
});
function ADe(e, t, n) {
  return Vk[e](n, t);
}
function ODe(e, t) {
  return e.idx - t.idx;
}
function sxt(e) {
  const t = {};
  e.forEach((r) => t[r.name] = r);
  const n = (r) => {
    r.req && r.req.forEach((i) => {
      t[i] || n(t[i] = Vk[i]());
    });
  };
  return e.forEach(n), Object.values(t).sort(ODe);
}
function uxt() {
  this.valid = 0, this.missing = 0, this._ops.forEach((e) => e.aggregate_param == null ? e.init(this) : e.init(this, e.aggregate_param));
}
function lxt(e, t) {
  if (e == null || e === "") {
    ++this.missing;
    return;
  }
  e === e && (++this.valid, this._ops.forEach((n) => n.add(this, e, t)));
}
function cxt(e, t) {
  if (e == null || e === "") {
    --this.missing;
    return;
  }
  e === e && (--this.valid, this._ops.forEach((n) => n.rem(this, e, t)));
}
function fxt(e) {
  return this._out.forEach((t) => e[t.out] = t.value(this)), e;
}
function RDe(e, t) {
  const n = t || ql, r = sxt(e), i = e.slice().sort(ODe);
  function o(a) {
    this._ops = r, this._out = i, this.cell = a, this.init();
  }
  return o.prototype.init = uxt, o.prototype.add = lxt, o.prototype.rem = cxt, o.prototype.set = fxt, o.prototype.get = n, o.fields = e.map((a) => a.out), o;
}
function zee(e) {
  this._key = e ? yp(e) : bn, this.reset();
}
const al = zee.prototype;
al.reset = function() {
  this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
};
al.add = function(e) {
  this._add.push(e);
};
al.rem = function(e) {
  this._rem.push(e);
};
al.values = function() {
  if (this._get = null, this._rem.length === 0)
    return this._add;
  const e = this._add, t = this._rem, n = this._key, r = e.length, i = t.length, o = Array(r - i), a = {};
  let s, u, l;
  for (s = 0; s < i; ++s)
    a[n(t[s])] = 1;
  for (s = 0, u = 0; s < r; ++s)
    a[n(l = e[s])] ? a[n(l)] = 0 : o[u++] = l;
  return this._rem = [], this._add = o;
};
al.distinct = function(e) {
  const t = this.values(), n = {};
  let r = t.length, i = 0, o;
  for (; --r >= 0; )
    o = e(t[r]) + "", wn(n, o) || (n[o] = 1, ++i);
  return i;
};
al.extent = function(e) {
  if (this._get !== e || !this._ext) {
    const t = this.values(), n = xNe(t, e);
    this._ext = [t[n[0]], t[n[1]]], this._get = e;
  }
  return this._ext;
};
al.argmin = function(e) {
  return this.extent(e)[0] || {};
};
al.argmax = function(e) {
  return this.extent(e)[1] || {};
};
al.min = function(e) {
  const t = this.extent(e)[0];
  return t != null ? e(t) : void 0;
};
al.max = function(e) {
  const t = this.extent(e)[1];
  return t != null ? e(t) : void 0;
};
al.quartile = function(e) {
  return (this._get !== e || !this._q) && (this._q = Eee(this.values(), e), this._get = e), this._q;
};
al.q1 = function(e) {
  return this.quartile(e)[0];
};
al.q2 = function(e) {
  return this.quartile(e)[1];
};
al.q3 = function(e) {
  return this.quartile(e)[2];
};
al.ci = function(e) {
  return (this._get !== e || !this._ci) && (this._ci = vDe(this.values(), 1e3, 0.05, e), this._get = e), this._ci;
};
al.ci0 = function(e) {
  return this.ci(e)[0];
};
al.ci1 = function(e) {
  return this.ci(e)[1];
};
function uw(e) {
  Ge.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
}
uw.Definition = {
  type: "Aggregate",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: t4
  }, {
    name: "aggregate_params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "drop",
    type: "boolean",
    default: !0
  }, {
    name: "cross",
    type: "boolean",
    default: !1
  }, {
    name: "key",
    type: "field"
  }]
};
Tt(uw, Ge, {
  transform(e, t) {
    const n = this, r = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = e.modified();
    return n.stamp = r.stamp, n.value && (i || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = i ? n.init(e) : /* @__PURE__ */ Object.create(null), t.visit(t.SOURCE, (o) => n.add(o))) : (n.value = n.value || n.init(e), t.visit(t.REM, (o) => n.rem(o)), t.visit(t.ADD, (o) => n.add(o))), r.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && r.clean(!0).runAfter(() => this.clean()), n.changes(r);
  },
  cross() {
    const e = this, t = e.value, n = e._dnames, r = n.map(() => ({})), i = n.length;
    function o(s) {
      let u, l, f, h;
      for (u in s)
        for (f = s[u].tuple, l = 0; l < i; ++l)
          r[l][h = f[n[l]]] = h;
    }
    o(e._prev), o(t);
    function a(s, u, l) {
      const f = n[l], h = r[l++];
      for (const p in h) {
        const g = s ? s + "|" + p : p;
        u[f] = h[p], l < i ? a(g, u, l) : t[g] || e.cell(g, u);
      }
    }
    a("", {}, 0);
  },
  init(e) {
    const t = this._inputs = [], n = this._outputs = [], r = {};
    function i(C) {
      const A = Rt(Yl(C)), O = A.length;
      let R = 0, j;
      for (; R < O; ++R)
        r[j = A[R]] || (r[j] = 1, t.push(j));
    }
    this._dims = Rt(e.groupby), this._dnames = this._dims.map((C) => {
      const A = Va(C);
      return i(C), n.push(A), A;
    }), this.cellkey = e.key ? e.key : BG(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
    const o = e.fields || [null], a = e.ops || ["count"], s = e.aggregate_params || [null], u = e.as || [], l = o.length, f = {};
    let h, p, g, y, b, _, S;
    for (l !== a.length && tt("Unmatched number of fields and aggregate ops."), S = 0; S < l; ++S) {
      if (h = o[S], p = a[S], g = s[S] || null, h == null && p !== "count" && tt("Null aggregate field specified."), b = Va(h), _ = DDe(p, b, u[S]), n.push(_), p === "count") {
        this._counts.push(_);
        continue;
      }
      y = f[b], y || (i(h), y = f[b] = [], y.field = h, this._measures.push(y)), p !== "count" && (this._countOnly = !1), y.push(ADe(p, g, _));
    }
    return this._measures = this._measures.map((C) => RDe(C, C.field)), /* @__PURE__ */ Object.create(null);
  },
  // -- Cell Management -----
  cellkey: BG(),
  cell(e, t) {
    let n = this.value[e];
    return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n;
  },
  newcell(e, t) {
    const n = {
      key: e,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[e]),
      stamp: this.stamp,
      store: !1
    };
    if (!this._countOnly) {
      const r = this._measures, i = r.length;
      n.agg = Array(i);
      for (let o = 0; o < i; ++o)
        n.agg[o] = new r[o](n);
    }
    return n.store && (n.data = new zee()), n;
  },
  newtuple(e, t) {
    const n = this._dnames, r = this._dims, i = r.length, o = {};
    for (let a = 0; a < i; ++a)
      o[n[a]] = r[a](e);
    return t ? cDe(t.tuple, o) : Ui(o);
  },
  clean() {
    const e = this.value;
    for (const t in e)
      e[t].num === 0 && delete e[t];
  },
  // -- Process Tuples -----
  add(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num += 1, this._countOnly)
      return;
    n.store && n.data.add(e);
    const r = n.agg;
    for (let i = 0, o = r.length; i < o; ++i)
      r[i].add(r[i].get(e), e);
  },
  rem(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num -= 1, this._countOnly)
      return;
    n.store && n.data.rem(e);
    const r = n.agg;
    for (let i = 0, o = r.length; i < o; ++i)
      r[i].rem(r[i].get(e), e);
  },
  celltuple(e) {
    const t = e.tuple, n = this._counts;
    e.store && e.data.values();
    for (let r = 0, i = n.length; r < i; ++r)
      t[n[r]] = e.num;
    if (!this._countOnly) {
      const r = e.agg;
      for (let i = 0, o = r.length; i < o; ++i)
        r[i].set(t);
    }
    return t;
  },
  changes(e) {
    const t = this._adds, n = this._mods, r = this._prev, i = this._drop, o = e.add, a = e.rem, s = e.mod;
    let u, l, f, h;
    if (r)
      for (l in r)
        u = r[l], (!i || u.num) && a.push(u.tuple);
    for (f = 0, h = this._alen; f < h; ++f)
      o.push(this.celltuple(t[f])), t[f] = null;
    for (f = 0, h = this._mlen; f < h; ++f)
      u = n[f], (u.num === 0 && i ? a : s).push(this.celltuple(u)), n[f] = null;
    return this._alen = this._mlen = 0, this._prev = null, e;
  }
});
const dxt = 1e-14;
function Fee(e) {
  Ge.call(this, null, e);
}
Fee.Definition = {
  type: "Bin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "anchor",
    type: "number"
  }, {
    name: "maxbins",
    type: "number",
    default: 20
  }, {
    name: "base",
    type: "number",
    default: 10
  }, {
    name: "divide",
    type: "number",
    array: !0,
    default: [5, 2]
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "span",
    type: "number"
  }, {
    name: "step",
    type: "number"
  }, {
    name: "steps",
    type: "number",
    array: !0
  }, {
    name: "minstep",
    type: "number",
    default: 0
  }, {
    name: "nice",
    type: "boolean",
    default: !0
  }, {
    name: "name",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["bin0", "bin1"]
  }]
};
Tt(Fee, Ge, {
  transform(e, t) {
    const n = e.interval !== !1, r = this._bins(e), i = r.start, o = r.step, a = e.as || ["bin0", "bin1"], s = a[0], u = a[1];
    let l;
    return e.modified() ? (t = t.reflow(!0), l = t.SOURCE) : l = t.modified(Yl(e.field)) ? t.ADD_MOD : t.ADD, t.visit(l, n ? (f) => {
      const h = r(f);
      f[s] = h, f[u] = h == null ? null : i + o * (1 + (h - i) / o);
    } : (f) => f[s] = r(f)), t.modifies(n ? a : s);
  },
  _bins(e) {
    if (this.value && !e.modified())
      return this.value;
    const t = e.field, n = yDe(e), r = n.step;
    let i = n.start, o = i + Math.ceil((n.stop - i) / r) * r, a, s;
    (a = e.anchor) != null && (s = a - (i + r * Math.floor((a - i) / r)), i += s, o += s);
    const u = function(l) {
      let f = Fl(t(l));
      return f == null ? null : f < i ? -1 / 0 : f > o ? 1 / 0 : (f = Math.max(i, Math.min(f, o - r)), i + r * Math.floor(dxt + (f - i) / r));
    };
    return u.start = i, u.stop = n.stop, u.step = r, this.value = Ff(u, Yl(t), e.name || "bin_" + Va(t));
  }
});
function kDe(e, t, n) {
  const r = e;
  let i = t || [], o = n || [], a = {}, s = 0;
  return {
    add: (u) => o.push(u),
    remove: (u) => a[r(u)] = ++s,
    size: () => i.length,
    data: (u, l) => (s && (i = i.filter((f) => !a[r(f)]), a = {}, s = 0), l && u && i.sort(u), o.length && (i = u ? TNe(u, i, o.sort(u)) : i.concat(o), o = []), i)
  };
}
function Bee(e) {
  Ge.call(this, [], e);
}
Bee.Definition = {
  type: "Collect",
  metadata: {
    source: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }]
};
Tt(Bee, Ge, {
  transform(e, t) {
    const n = t.fork(t.ALL), r = kDe(bn, this.value, n.materialize(n.ADD).add), i = e.sort, o = t.changed() || i && (e.modified("sort") || t.modified(i.fields));
    return n.visit(n.REM, r.remove), this.modified(o), this.value = n.source = r.data(i2(i), o), t.source && t.source.root && (this.value.root = t.source.root), n;
  }
});
function $De(e) {
  So.call(this, null, hxt, e);
}
Tt($De, So);
function hxt(e) {
  return this.value && !e.modified() ? this.value : aee(e.fields, e.orders);
}
function Uee(e) {
  Ge.call(this, null, e);
}
Uee.Definition = {
  type: "CountPattern",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "case",
    type: "enum",
    values: ["upper", "lower", "mixed"],
    default: "mixed"
  }, {
    name: "pattern",
    type: "string",
    default: '[\\w"]+'
  }, {
    name: "stopwords",
    type: "string",
    default: ""
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["text", "count"]
  }]
};
function pxt(e, t, n) {
  switch (t) {
    case "upper":
      e = e.toUpperCase();
      break;
    case "lower":
      e = e.toLowerCase();
      break;
  }
  return e.match(n);
}
Tt(Uee, Ge, {
  transform(e, t) {
    const n = (h) => (p) => {
      for (var g = pxt(s(p), e.case, o) || [], y, b = 0, _ = g.length; b < _; ++b)
        a.test(y = g[b]) || h(y);
    }, r = this._parameterCheck(e, t), i = this._counts, o = this._match, a = this._stop, s = e.field, u = e.as || ["text", "count"], l = n((h) => i[h] = 1 + (i[h] || 0)), f = n((h) => i[h] -= 1);
    return r ? t.visit(t.SOURCE, l) : (t.visit(t.ADD, l), t.visit(t.REM, f)), this._finish(t, u);
  },
  _parameterCheck(e, t) {
    let n = !1;
    return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n;
  },
  _finish(e, t) {
    const n = this._counts, r = this._tuples || (this._tuples = {}), i = t[0], o = t[1], a = e.fork(e.NO_SOURCE | e.NO_FIELDS);
    let s, u, l;
    for (s in n)
      u = r[s], l = n[s] || 0, !u && l ? (r[s] = u = Ui({}), u[i] = s, u[o] = l, a.add.push(u)) : l === 0 ? (u && a.rem.push(u), n[s] = null, r[s] = null) : u[o] !== l && (u[o] = l, a.mod.push(u));
    return a.modifies(t);
  }
});
function Yee(e) {
  Ge.call(this, null, e);
}
Yee.Definition = {
  type: "Cross",
  metadata: {
    generates: !0
  },
  params: [{
    name: "filter",
    type: "expr"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["a", "b"]
  }]
};
Tt(Yee, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), r = e.as || ["a", "b"], i = r[0], o = r[1], a = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
    let s = this.value;
    return a ? (s && (n.rem = s), s = t.materialize(t.SOURCE).source, n.add = this.value = gxt(s, i, o, e.filter || vp)) : n.mod = s, n.source = this.value, n.modifies(r);
  }
});
function gxt(e, t, n, r) {
  for (var i = [], o = {}, a = e.length, s = 0, u, l; s < a; ++s)
    for (o[t] = l = e[s], u = 0; u < a; ++u)
      o[n] = e[u], r(o) && (i.push(Ui(o)), o = {}, o[t] = l);
  return i;
}
const Upe = {
  kde: Cee,
  mixture: _De,
  normal: Tee,
  lognormal: wDe,
  uniform: EDe
}, mxt = "distributions", Ype = "function", yxt = "field";
function PDe(e, t) {
  const n = e[Ype];
  wn(Upe, n) || tt("Unknown distribution function: " + n);
  const r = Upe[n]();
  for (const i in e)
    i === yxt ? r.data((e.from || t()).map(e[i])) : i === mxt ? r[i](e[i].map((o) => PDe(o, t))) : typeof r[i] === Ype && r[i](e[i]);
  return r;
}
function Hee(e) {
  Ge.call(this, null, e);
}
const IDe = [{
  key: {
    function: "normal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "lognormal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "uniform"
  },
  params: [{
    name: "min",
    type: "number",
    default: 0
  }, {
    name: "max",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "kde"
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "from",
    type: "data"
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }]
}], vxt = {
  key: {
    function: "mixture"
  },
  params: [{
    name: "distributions",
    type: "param",
    array: !0,
    params: IDe
  }, {
    name: "weights",
    type: "number",
    array: !0
  }]
};
Hee.Definition = {
  type: "Density",
  metadata: {
    generates: !0
  },
  params: [{
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "method",
    type: "string",
    default: "pdf",
    values: ["pdf", "cdf"]
  }, {
    name: "distribution",
    type: "param",
    params: IDe.concat(vxt)
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
Tt(Hee, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const r = PDe(e.distribution, bxt(t)), i = e.steps || e.minsteps || 25, o = e.steps || e.maxsteps || 200;
      let a = e.method || "pdf";
      a !== "pdf" && a !== "cdf" && tt("Invalid density method: " + a), !e.extent && !r.data && tt("Missing density extent parameter."), a = r[a];
      const s = e.as || ["value", "density"], u = e.extent || Gy(r.data()), l = P6(a, u, i, o).map((f) => {
        const h = {};
        return h[s[0]] = f[0], h[s[1]] = f[1], Ui(h);
      });
      this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
function bxt(e) {
  return () => e.materialize(e.SOURCE).source;
}
function jDe(e, t) {
  return e ? e.map((n, r) => t[r] || Va(n)) : null;
}
function Vee(e, t, n) {
  const r = [], i = (h) => h(u);
  let o, a, s, u, l, f;
  if (t == null)
    r.push(e.map(n));
  else
    for (o = {}, a = 0, s = e.length; a < s; ++a)
      u = e[a], l = t.map(i), f = o[l], f || (o[l] = f = [], f.dims = l, r.push(f)), f.push(n(u));
  return r;
}
const LDe = "bin";
function Wee(e) {
  Ge.call(this, null, e);
}
Wee.Definition = {
  type: "DotBin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "step",
    type: "number"
  }, {
    name: "smooth",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: LDe
  }]
};
const xxt = (e, t) => Z$(Gy(e, t)) / 30;
Tt(Wee, Ge, {
  transform(e, t) {
    if (this.value && !(e.modified() || t.changed()))
      return t;
    const n = t.materialize(t.SOURCE).source, r = Vee(t.source, e.groupby, ql), i = e.smooth || !1, o = e.field, a = e.step || xxt(n, o), s = i2((y, b) => o(y) - o(b)), u = e.as || LDe, l = r.length;
    let f = 1 / 0, h = -1 / 0, p = 0, g;
    for (; p < l; ++p) {
      const y = r[p].sort(s);
      g = -1;
      for (const b of bDe(y, a, i, o))
        b < f && (f = b), b > h && (h = b), y[++g][u] = b;
    }
    return this.value = {
      start: f,
      stop: h,
      step: a
    }, t.reflow(!0).modifies(u);
  }
});
function zDe(e) {
  So.call(this, null, wxt, e), this.modified(!0);
}
Tt(zDe, So);
function wxt(e) {
  const t = e.expr;
  return this.value && !e.modified("expr") ? this.value : Ff((n) => t(n, e), Yl(t), Va(t));
}
function qee(e) {
  Ge.call(this, [void 0, void 0], e);
}
qee.Definition = {
  type: "Extent",
  metadata: {},
  params: [{
    name: "field",
    type: "field",
    required: !0
  }]
};
Tt(qee, Ge, {
  transform(e, t) {
    const n = this.value, r = e.field, i = t.changed() || t.modified(r.fields) || e.modified("field");
    let o = n[0], a = n[1];
    if ((i || o == null) && (o = 1 / 0, a = -1 / 0), t.visit(i ? t.SOURCE : t.ADD, (s) => {
      const u = Fl(r(s));
      u != null && (u < o && (o = u), u > a && (a = u));
    }), !Number.isFinite(o) || !Number.isFinite(a)) {
      let s = Va(r);
      s && (s = ` for field "${s}"`), t.dataflow.warn(`Infinite extent${s}: [${o}, ${a}]`), o = a = void 0;
    }
    this.value = [o, a];
  }
});
function Gee(e, t) {
  So.call(this, e), this.parent = t, this.count = 0;
}
Tt(Gee, So, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(e) {
    return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(e) {
    this.count += 1, this.value.add.push(e);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(e) {
    this.count -= 1, this.value.rem.push(e);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(e) {
    this.value.mod.push(e);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(e) {
    this.value.init(e, e.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function I6(e) {
  Ge.call(this, {}, e), this._keys = CN();
  const t = this._targets = [];
  t.active = 0, t.forEach = (n) => {
    for (let r = 0, i = t.active; r < i; ++r)
      n(t[r], r, t);
  };
}
Tt(I6, Ge, {
  activate(e) {
    this._targets[this._targets.active++] = e;
  },
  // parent argument provided by PreFacet subclass
  subflow(e, t, n, r) {
    const i = this.value;
    let o = wn(i, e) && i[e], a, s;
    return o ? o.value.stamp < n.stamp && (o.init(n), this.activate(o)) : (s = r || (s = this._group[e]) && s.tuple, a = n.dataflow, o = new Gee(n.fork(n.NO_SOURCE), this), a.add(o).connect(t(a, e, s)), i[e] = o, this.activate(o)), o;
  },
  clean() {
    const e = this.value;
    let t = 0;
    for (const n in e)
      if (e[n].count === 0) {
        const r = e[n].detachSubflow;
        r && r(), delete e[n], ++t;
      }
    if (t) {
      const n = this._targets.filter((r) => r && r.count > 0);
      this.initTargets(n);
    }
  },
  initTargets(e) {
    const t = this._targets, n = t.length, r = e ? e.length : 0;
    let i = 0;
    for (; i < r; ++i)
      t[i] = e[i];
    for (; i < n && t[i] != null; ++i)
      t[i] = null;
    t.active = r;
  },
  transform(e, t) {
    const n = t.dataflow, r = e.key, i = e.subflow, o = this._keys, a = e.modified("key"), s = (u) => this.subflow(u, i, t);
    return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, (u) => {
      const l = bn(u), f = o.get(l);
      f !== void 0 && (o.delete(l), s(f).rem(u));
    }), t.visit(t.ADD, (u) => {
      const l = r(u);
      o.set(bn(u), l), s(l).add(u);
    }), a || t.modified(r.fields) ? t.visit(t.MOD, (u) => {
      const l = bn(u), f = o.get(l), h = r(u);
      f === h ? s(h).mod(u) : (o.set(l, h), s(f).rem(u), s(h).add(u));
    }) : t.changed(t.MOD) && t.visit(t.MOD, (u) => {
      s(o.get(bn(u))).mod(u);
    }), a && t.visit(t.REFLOW, (u) => {
      const l = bn(u), f = o.get(l), h = r(u);
      f !== h && (o.set(l, h), s(f).rem(u), s(h).add(u));
    }), t.clean() ? n.runAfter(() => {
      this.clean(), o.clean();
    }) : o.empty > n.cleanThreshold && n.runAfter(o.clean), t;
  }
});
function FDe(e) {
  So.call(this, null, _xt, e);
}
Tt(FDe, So);
function _xt(e) {
  return this.value && !e.modified() ? this.value : nt(e.name) ? Rt(e.name).map((t) => yp(t)) : yp(e.name, e.as);
}
function Qee(e) {
  Ge.call(this, CN(), e);
}
Qee.Definition = {
  type: "Filter",
  metadata: {
    changes: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }]
};
Tt(Qee, Ge, {
  transform(e, t) {
    const n = t.dataflow, r = this.value, i = t.fork(), o = i.add, a = i.rem, s = i.mod, u = e.expr;
    let l = !0;
    t.visit(t.REM, (h) => {
      const p = bn(h);
      r.has(p) ? r.delete(p) : a.push(h);
    }), t.visit(t.ADD, (h) => {
      u(h, e) ? o.push(h) : r.set(bn(h), 1);
    });
    function f(h) {
      const p = bn(h), g = u(h, e), y = r.get(p);
      g && y ? (r.delete(p), o.push(h)) : !g && !y ? (r.set(p, 1), a.push(h)) : l && g && !y && s.push(h);
    }
    return t.visit(t.MOD, f), e.modified() && (l = !1, t.visit(t.REFLOW, f)), r.empty > n.cleanThreshold && n.runAfter(r.clean), i;
  }
});
function Xee(e) {
  Ge.call(this, [], e);
}
Xee.Definition = {
  type: "Flatten",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "index",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
Tt(Xee, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), r = e.fields, i = jDe(r, e.as || []), o = e.index || null, a = i.length;
    return n.rem = this.value, t.visit(t.SOURCE, (s) => {
      const u = r.map((y) => y(s)), l = u.reduce((y, b) => Math.max(y, b.length), 0);
      let f = 0, h, p, g;
      for (; f < l; ++f) {
        for (p = bee(s), h = 0; h < a; ++h)
          p[i[h]] = (g = u[h][f]) == null ? null : g;
        o && (p[o] = f), n.add.push(p);
      }
    }), this.value = n.source = n.add, o && n.modifies(o), n.modifies(i);
  }
});
function Kee(e) {
  Ge.call(this, [], e);
}
Kee.Definition = {
  type: "Fold",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["key", "value"]
  }]
};
Tt(Kee, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), r = e.fields, i = r.map(Va), o = e.as || ["key", "value"], a = o[0], s = o[1], u = r.length;
    return n.rem = this.value, t.visit(t.SOURCE, (l) => {
      for (let f = 0, h; f < u; ++f)
        h = bee(l), h[a] = i[f], h[s] = r[f](l), n.add.push(h);
    }), this.value = n.source = n.add, n.modifies(o);
  }
});
function Zee(e) {
  Ge.call(this, null, e);
}
Zee.Definition = {
  type: "Formula",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }, {
    name: "as",
    type: "string",
    required: !0
  }, {
    name: "initonly",
    type: "boolean"
  }]
};
Tt(Zee, Ge, {
  transform(e, t) {
    const n = e.expr, r = e.as, i = e.modified(), o = e.initonly ? t.ADD : i ? t.SOURCE : t.modified(n.fields) || t.modified(r) ? t.ADD_MOD : t.ADD;
    return i && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(r), t.visit(o, (a) => a[r] = n(a, e));
  }
});
function BDe(e) {
  Ge.call(this, [], e);
}
Tt(BDe, Ge, {
  transform(e, t) {
    const n = t.fork(t.ALL), r = e.generator;
    let i = this.value, o = e.size - i.length, a, s, u;
    if (o > 0) {
      for (a = []; --o >= 0; )
        a.push(u = Ui(r(e))), i.push(u);
      n.add = n.add.length ? n.materialize(n.ADD).add.concat(a) : a;
    } else
      s = i.slice(0, -o), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(s) : s, i = i.slice(-o);
    return n.source = this.value = i, n;
  }
});
const v3 = {
  value: "value",
  median: Jx,
  mean: T$,
  min: Oc,
  max: Ha
}, Ext = [];
function Jee(e) {
  Ge.call(this, [], e);
}
Jee.Definition = {
  type: "Impute",
  metadata: {
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "keyvals",
    array: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "enum",
    default: "value",
    values: ["value", "mean", "median", "max", "min"]
  }, {
    name: "value",
    default: 0
  }]
};
function Sxt(e) {
  var t = e.method || v3.value, n;
  if (v3[t] == null)
    tt("Unrecognized imputation method: " + t);
  else
    return t === v3.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : v3[t];
}
function Mxt(e) {
  const t = e.field;
  return (n) => n ? t(n) : NaN;
}
Tt(Jee, Ge, {
  transform(e, t) {
    var n = t.fork(t.ALL), r = Sxt(e), i = Mxt(e), o = Va(e.field), a = Va(e.key), s = (e.groupby || []).map(Va), u = Txt(t.source, e.groupby, e.key, e.keyvals), l = [], f = this.value, h = u.domain.length, p, g, y, b, _, S, C, A, O, R;
    for (_ = 0, A = u.length; _ < A; ++_)
      for (p = u[_], y = p.values, g = NaN, C = 0; C < h; ++C)
        if (p[C] == null) {
          for (b = u.domain[C], R = {
            _impute: !0
          }, S = 0, O = y.length; S < O; ++S)
            R[s[S]] = y[S];
          R[a] = b, R[o] = Number.isNaN(g) ? g = r(p, i) : g, l.push(Ui(R));
        }
    return l.length && (n.add = n.materialize(n.ADD).add.concat(l)), f.length && (n.rem = n.materialize(n.REM).rem.concat(f)), this.value = l, n;
  }
});
function Txt(e, t, n, r) {
  var i = (S) => S(_), o = [], a = r ? r.slice() : [], s = {}, u = {}, l, f, h, p, g, y, b, _;
  for (a.forEach((S, C) => s[S] = C + 1), p = 0, b = e.length; p < b; ++p)
    _ = e[p], y = n(_), g = s[y] || (s[y] = a.push(y)), f = (l = t ? t.map(i) : Ext) + "", (h = u[f]) || (h = u[f] = [], o.push(h), h.values = l), h[g - 1] = _;
  return o.domain = a, o;
}
function ete(e) {
  uw.call(this, e);
}
ete.Definition = {
  type: "JoinAggregate",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: t4
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "key",
    type: "field"
  }]
};
Tt(ete, uw, {
  transform(e, t) {
    const n = this, r = e.modified();
    let i;
    return n.value && (r || t.modified(n._inputs, !0)) ? (i = n.value = r ? n.init(e) : {}, t.visit(t.SOURCE, (o) => n.add(o))) : (i = n.value = n.value || this.init(e), t.visit(t.REM, (o) => n.rem(o)), t.visit(t.ADD, (o) => n.add(o))), n.changes(), t.visit(t.SOURCE, (o) => {
      hr(o, i[n.cellkey(o)].tuple);
    }), t.reflow(r).modifies(this._outputs);
  },
  changes() {
    const e = this._adds, t = this._mods;
    let n, r;
    for (n = 0, r = this._alen; n < r; ++n)
      this.celltuple(e[n]), e[n] = null;
    for (n = 0, r = this._mlen; n < r; ++n)
      this.celltuple(t[n]), t[n] = null;
    this._alen = this._mlen = 0;
  }
});
function tte(e) {
  Ge.call(this, null, e);
}
tte.Definition = {
  type: "KDE",
  metadata: {
    generates: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "cumulative",
    type: "boolean",
    default: !1
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
Tt(tte, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const r = t.materialize(t.SOURCE).source, i = Vee(r, e.groupby, e.field), o = (e.groupby || []).map(Va), a = e.bandwidth, s = e.cumulative ? "cdf" : "pdf", u = e.as || ["value", "density"], l = [];
      let f = e.extent, h = e.steps || e.minsteps || 25, p = e.steps || e.maxsteps || 200;
      s !== "pdf" && s !== "cdf" && tt("Invalid density method: " + s), e.resolve === "shared" && (f || (f = Gy(r, e.field)), h = p = e.steps || p), i.forEach((g) => {
        const y = Cee(g, a)[s], b = e.counts ? g.length : 1, _ = f || Gy(g);
        P6(y, _, h, p).forEach((S) => {
          const C = {};
          for (let A = 0; A < o.length; ++A)
            C[o[A]] = g.dims[A];
          C[u[0]] = S[0], C[u[1]] = S[1] * b, l.push(Ui(C));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
function UDe(e) {
  So.call(this, null, Cxt, e);
}
Tt(UDe, So);
function Cxt(e) {
  return this.value && !e.modified() ? this.value : uee(e.fields, e.flat);
}
function YDe(e) {
  Ge.call(this, [], e), this._pending = null;
}
Tt(YDe, Ge, {
  transform(e, t) {
    const n = t.dataflow;
    return this._pending ? QH(this, t, this._pending) : Nxt(e) ? t.StopPropagation : e.values ? QH(this, t, n.parse(e.values, e.format)) : e.async ? {
      async: n.request(e.url, e.format).then((i) => (this._pending = Rt(i.data), (o) => o.touch(this)))
    } : n.request(e.url, e.format).then((r) => QH(this, t, Rt(r.data)));
  }
});
function Nxt(e) {
  return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"));
}
function QH(e, t, n) {
  n.forEach(Ui);
  const r = t.fork(t.NO_FIELDS & t.NO_SOURCE);
  return r.rem = e.value, e.value = r.source = r.add = n, e._pending = null, r.rem.length && r.clean(!0), r;
}
function nte(e) {
  Ge.call(this, {}, e);
}
nte.Definition = {
  type: "Lookup",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "index",
    type: "index",
    params: [{
      name: "from",
      type: "data",
      required: !0
    }, {
      name: "key",
      type: "field",
      required: !0
    }]
  }, {
    name: "values",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0
  }, {
    name: "default",
    default: null
  }]
};
Tt(nte, Ge, {
  transform(e, t) {
    const n = e.fields, r = e.index, i = e.values, o = e.default == null ? null : e.default, a = e.modified(), s = n.length;
    let u = a ? t.SOURCE : t.ADD, l = t, f = e.as, h, p, g;
    return i ? (p = i.length, s > 1 && !f && tt('Multi-field lookup requires explicit "as" parameter.'), f && f.length !== s * p && tt('The "as" parameter has too few output field names.'), f = f || i.map(Va), h = function(y) {
      for (var b = 0, _ = 0, S, C; b < s; ++b)
        if (C = r.get(n[b](y)), C == null)
          for (S = 0; S < p; ++S, ++_)
            y[f[_]] = o;
        else
          for (S = 0; S < p; ++S, ++_)
            y[f[_]] = i[S](C);
    }) : (f || tt("Missing output field names."), h = function(y) {
      for (var b = 0, _; b < s; ++b)
        _ = r.get(n[b](y)), y[f[b]] = _ ?? o;
    }), a ? l = t.reflow(!0) : (g = n.some((y) => t.modified(y.fields)), u |= g ? t.MOD : 0), t.visit(u, h), l.modifies(f);
  }
});
function HDe(e) {
  So.call(this, null, Dxt, e);
}
Tt(HDe, So);
function Dxt(e) {
  if (this.value && !e.modified())
    return this.value;
  const t = e.extents, n = t.length;
  let r = 1 / 0, i = -1 / 0, o, a;
  for (o = 0; o < n; ++o)
    a = t[o], a[0] < r && (r = a[0]), a[1] > i && (i = a[1]);
  return [r, i];
}
function VDe(e) {
  So.call(this, null, Axt, e);
}
Tt(VDe, So);
function Axt(e) {
  return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), []);
}
function WDe(e) {
  Ge.call(this, null, e);
}
Tt(WDe, Ge, {
  transform(e, t) {
    return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function rte(e) {
  uw.call(this, e);
}
rte.Definition = {
  type: "Pivot",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "value",
    type: "field",
    required: !0
  }, {
    name: "op",
    type: "enum",
    values: t4,
    default: "sum"
  }, {
    name: "limit",
    type: "number",
    default: 0
  }, {
    name: "key",
    type: "field"
  }]
};
Tt(rte, uw, {
  _transform: uw.prototype.transform,
  transform(e, t) {
    return this._transform(Oxt(e, t), t);
  }
});
function Oxt(e, t) {
  const n = e.field, r = e.value, i = (e.op === "count" ? "__count__" : e.op) || "sum", o = Yl(n).concat(Yl(r)), a = kxt(n, e.limit || 0, t);
  return t.changed() && e.set("__pivot__", null, null, !0), {
    key: e.key,
    groupby: e.groupby,
    ops: a.map(() => i),
    fields: a.map((s) => Rxt(s, n, r, o)),
    as: a.map((s) => s + ""),
    modified: e.modified.bind(e)
  };
}
function Rxt(e, t, n, r) {
  return Ff((i) => t(i) === e ? n(i) : NaN, r, e + "");
}
function kxt(e, t, n) {
  const r = {}, i = [];
  return n.visit(n.SOURCE, (o) => {
    const a = e(o);
    r[a] || (r[a] = 1, i.push(a));
  }), i.sort(E6), t ? i.slice(0, t) : i;
}
function qDe(e) {
  I6.call(this, e);
}
Tt(qDe, I6, {
  transform(e, t) {
    const n = e.subflow, r = e.field, i = (o) => this.subflow(bn(o), n, t, o);
    return (e.modified("field") || r && t.modified(Yl(r))) && tt("PreFacet does not support field modification."), this.initTargets(), r ? (t.visit(t.MOD, (o) => {
      const a = i(o);
      r(o).forEach((s) => a.mod(s));
    }), t.visit(t.ADD, (o) => {
      const a = i(o);
      r(o).forEach((s) => a.add(Ui(s)));
    }), t.visit(t.REM, (o) => {
      const a = i(o);
      r(o).forEach((s) => a.rem(s));
    })) : (t.visit(t.MOD, (o) => i(o).mod(o)), t.visit(t.ADD, (o) => i(o).add(o)), t.visit(t.REM, (o) => i(o).rem(o))), t.clean() && t.runAfter(() => this.clean()), t;
  }
});
function ite(e) {
  Ge.call(this, null, e);
}
ite.Definition = {
  type: "Project",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }]
};
Tt(ite, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), r = e.fields, i = jDe(e.fields, e.as || []), o = r ? (s, u) => $xt(s, u, r, i) : N6;
    let a;
    return this.value ? a = this.value : (t = t.addAll(), a = this.value = {}), t.visit(t.REM, (s) => {
      const u = bn(s);
      n.rem.push(a[u]), a[u] = null;
    }), t.visit(t.ADD, (s) => {
      const u = o(s, Ui({}));
      a[bn(s)] = u, n.add.push(u);
    }), t.visit(t.MOD, (s) => {
      n.mod.push(o(s, a[bn(s)]));
    }), n;
  }
});
function $xt(e, t, n, r) {
  for (let i = 0, o = n.length; i < o; ++i)
    t[r[i]] = n[i](e);
  return t;
}
function GDe(e) {
  Ge.call(this, null, e);
}
Tt(GDe, Ge, {
  transform(e, t) {
    return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function ote(e) {
  Ge.call(this, null, e);
}
ote.Definition = {
  type: "Quantile",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "probs",
    type: "number",
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 0.01
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["prob", "value"]
  }]
};
const Pxt = 1e-14;
Tt(ote, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.as || ["prob", "value"];
    if (this.value && !e.modified() && !t.changed())
      return n.source = this.value, n;
    const i = t.materialize(t.SOURCE).source, o = Vee(i, e.groupby, e.field), a = (e.groupby || []).map(Va), s = [], u = e.step || 0.01, l = e.probs || qo(u / 2, 1 - Pxt, u), f = l.length;
    return o.forEach((h) => {
      const p = _ee(h, l);
      for (let g = 0; g < f; ++g) {
        const y = {};
        for (let b = 0; b < a.length; ++b)
          y[a[b]] = h.dims[b];
        y[r[0]] = l[g], y[r[1]] = p[g], s.push(Ui(y));
      }
    }), this.value && (n.rem = this.value), this.value = n.add = n.source = s, n;
  }
});
function QDe(e) {
  Ge.call(this, null, e);
}
Tt(QDe, Ge, {
  transform(e, t) {
    let n, r;
    return this.value ? r = this.value : (n = t = t.addAll(), r = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, (i) => {
      const o = bn(i);
      n.rem.push(r[o]), r[o] = null;
    }), t.visit(t.ADD, (i) => {
      const o = bee(i);
      r[bn(i)] = o, n.add.push(o);
    }), t.visit(t.MOD, (i) => {
      const o = r[bn(i)];
      for (const a in i)
        o[a] = i[a], n.modifies(a);
      n.mod.push(o);
    })), n;
  }
});
function ate(e) {
  Ge.call(this, [], e), this.count = 0;
}
ate.Definition = {
  type: "Sample",
  metadata: {},
  params: [{
    name: "size",
    type: "number",
    default: 1e3
  }]
};
Tt(ate, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), r = e.modified("size"), i = e.size, o = this.value.reduce((f, h) => (f[bn(h)] = 1, f), {});
    let a = this.value, s = this.count, u = 0;
    function l(f) {
      let h, p;
      a.length < i ? a.push(f) : (p = ~~((s + 1) * xp()), p < a.length && p >= u && (h = a[p], o[bn(h)] && n.rem.push(h), a[p] = f)), ++s;
    }
    if (t.rem.length && (t.visit(t.REM, (f) => {
      const h = bn(f);
      o[h] && (o[h] = -1, n.rem.push(f)), --s;
    }), a = a.filter((f) => o[bn(f)] !== -1)), (t.rem.length || r) && a.length < i && t.source && (u = s = a.length, t.visit(t.SOURCE, (f) => {
      o[bn(f)] || l(f);
    }), u = -1), r && a.length > i) {
      const f = a.length - i;
      for (let h = 0; h < f; ++h)
        o[bn(a[h])] = -1, n.rem.push(a[h]);
      a = a.slice(f);
    }
    return t.mod.length && t.visit(t.MOD, (f) => {
      o[bn(f)] && n.mod.push(f);
    }), t.add.length && t.visit(t.ADD, l), (t.add.length || u < 0) && (n.add = a.filter((f) => !o[bn(f)])), this.count = s, this.value = n.source = a, n;
  }
});
function ste(e) {
  Ge.call(this, null, e);
}
ste.Definition = {
  type: "Sequence",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "start",
    type: "number",
    required: !0
  }, {
    name: "stop",
    type: "number",
    required: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "as",
    type: "string",
    default: "data"
  }]
};
Tt(ste, Ge, {
  transform(e, t) {
    if (this.value && !e.modified())
      return;
    const n = t.materialize().fork(t.MOD), r = e.as || "data";
    return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = qo(e.start, e.stop, e.step || 1).map((i) => {
      const o = {};
      return o[r] = i, Ui(o);
    }), n.add = t.add.concat(this.value), n;
  }
});
function XDe(e) {
  Ge.call(this, null, e), this.modified(!0);
}
Tt(XDe, Ge, {
  transform(e, t) {
    return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function ute(e) {
  Ge.call(this, null, e);
}
const KDe = ["unit0", "unit1"];
ute.Definition = {
  type: "TimeUnit",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "units",
    type: "enum",
    values: dee,
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "maxbins",
    type: "number",
    default: 40
  }, {
    name: "extent",
    type: "date",
    array: !0
  }, {
    name: "timezone",
    type: "enum",
    default: "local",
    values: ["local", "utc"]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: KDe
  }]
};
Tt(ute, Ge, {
  transform(e, t) {
    const n = e.field, r = e.interval !== !1, i = e.timezone === "utc", o = this._floor(e, t), a = (i ? DN : NN)(o.unit).offset, s = e.as || KDe, u = s[0], l = s[1], f = o.step;
    let h = o.start || 1 / 0, p = o.stop || -1 / 0, g = t.ADD;
    return (e.modified() || t.changed(t.REM) || t.modified(Yl(n))) && (t = t.reflow(!0), g = t.SOURCE, h = 1 / 0, p = -1 / 0), t.visit(g, (y) => {
      const b = n(y);
      let _, S;
      b == null ? (y[u] = null, r && (y[l] = null)) : (y[u] = _ = S = o(b), r && (y[l] = S = a(_, f)), _ < h && (h = _), S > p && (p = S));
    }), o.start = h, o.stop = p, t.modifies(r ? s : u);
  },
  _floor(e, t) {
    const n = e.timezone === "utc", {
      units: r,
      step: i
    } = e.units ? {
      units: e.units,
      step: e.step || 1
    } : GNe({
      extent: e.extent || Gy(t.materialize(t.SOURCE).source, e.field),
      maxbins: e.maxbins
    }), o = hee(r), a = this.value || {}, s = (n ? zNe : LNe)(o, i);
    return s.unit = ri(o), s.units = o, s.step = i, s.start = a.start, s.stop = a.stop, this.value = s;
  }
});
function ZDe(e) {
  Ge.call(this, CN(), e);
}
Tt(ZDe, Ge, {
  transform(e, t) {
    const n = t.dataflow, r = e.field, i = this.value, o = (s) => i.set(r(s), s);
    let a = !0;
    return e.modified("field") || t.modified(r.fields) ? (i.clear(), t.visit(t.SOURCE, o)) : t.changed() ? (t.visit(t.REM, (s) => i.delete(r(s))), t.visit(t.ADD, o)) : a = !1, this.modified(a), i.empty > n.cleanThreshold && n.runAfter(i.clean), t.fork();
  }
});
function JDe(e) {
  Ge.call(this, null, e);
}
Tt(JDe, Ge, {
  transform(e, t) {
    (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(i2(e.sort)) : t.source).map(e.field));
  }
});
function Ixt(e, t, n, r) {
  const i = Wk[e](t, n);
  return {
    init: i.init || wx,
    update: function(o, a) {
      a[r] = i.next(o);
    }
  };
}
const Wk = {
  row_number: function() {
    return {
      next: (e) => e.index + 1
    };
  },
  rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, r = t.data;
        return n && t.compare(r[n - 1], r[n]) ? e = n + 1 : e;
      }
    };
  },
  dense_rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, r = t.data;
        return n && t.compare(r[n - 1], r[n]) ? ++e : e;
      }
    };
  },
  percent_rank: function() {
    const e = Wk.rank(), t = e.next;
    return {
      init: e.init,
      next: (n) => (t(n) - 1) / (n.data.length - 1)
    };
  },
  cume_dist: function() {
    let e;
    return {
      init: () => e = 0,
      next: (t) => {
        const n = t.data, r = t.compare;
        let i = t.index;
        if (e < i) {
          for (; i + 1 < n.length && !r(n[i], n[i + 1]); )
            ++i;
          e = i;
        }
        return (1 + e) / n.length;
      }
    };
  },
  ntile: function(e, t) {
    t = +t, t > 0 || tt("ntile num must be greater than zero.");
    const n = Wk.cume_dist(), r = n.next;
    return {
      init: n.init,
      next: (i) => Math.ceil(t * r(i))
    };
  },
  lag: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const r = n.index - t;
        return r >= 0 ? e(n.data[r]) : null;
      }
    };
  },
  lead: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const r = n.index + t, i = n.data;
        return r < i.length ? e(i[r]) : null;
      }
    };
  },
  first_value: function(e) {
    return {
      next: (t) => e(t.data[t.i0])
    };
  },
  last_value: function(e) {
    return {
      next: (t) => e(t.data[t.i1 - 1])
    };
  },
  nth_value: function(e, t) {
    return t = +t, t > 0 || tt("nth_value nth must be greater than zero."), {
      next: (n) => {
        const r = n.i0 + (t - 1);
        return r < n.i1 ? e(n.data[r]) : null;
      }
    };
  },
  prev_value: function(e) {
    let t;
    return {
      init: () => t = null,
      next: (n) => {
        const r = e(n.data[n.index]);
        return r != null ? t = r : t;
      }
    };
  },
  next_value: function(e) {
    let t, n;
    return {
      init: () => (t = null, n = -1),
      next: (r) => {
        const i = r.data;
        return r.index <= n ? t : (n = jxt(e, i, r.index)) < 0 ? (n = i.length, t = null) : t = e(i[n]);
      }
    };
  }
};
function jxt(e, t, n) {
  for (let r = t.length; n < r; ++n)
    if (e(t[n]) != null)
      return n;
  return -1;
}
const Lxt = Object.keys(Wk);
function eAe(e) {
  const t = Rt(e.ops), n = Rt(e.fields), r = Rt(e.params), i = Rt(e.aggregate_params), o = Rt(e.as), a = this.outputs = [], s = this.windows = [], u = {}, l = {}, f = [], h = [];
  let p = !0;
  function g(y) {
    Rt(Yl(y)).forEach((b) => u[b] = 1);
  }
  g(e.sort), t.forEach((y, b) => {
    const _ = n[b], S = r[b], C = i[b] || null, A = Va(_), O = DDe(y, A, o[b]);
    if (g(_), a.push(O), wn(Wk, y))
      s.push(Ixt(y, _, S, O));
    else {
      if (_ == null && y !== "count" && tt("Null aggregate field specified."), y === "count") {
        f.push(O);
        return;
      }
      p = !1;
      let R = l[A];
      R || (R = l[A] = [], R.field = _, h.push(R)), R.push(ADe(y, C, O));
    }
  }), (f.length || h.length) && (this.cell = zxt(h, f, p)), this.inputs = Object.keys(u);
}
const tAe = eAe.prototype;
tAe.init = function() {
  this.windows.forEach((e) => e.init()), this.cell && this.cell.init();
};
tAe.update = function(e, t) {
  const n = this.cell, r = this.windows, i = e.data, o = r && r.length;
  let a;
  if (n) {
    for (a = e.p0; a < e.i0; ++a)
      n.rem(i[a]);
    for (a = e.p1; a < e.i1; ++a)
      n.add(i[a]);
    n.set(t);
  }
  for (a = 0; a < o; ++a)
    r[a].update(e, t);
};
function zxt(e, t, n) {
  e = e.map((u) => RDe(u, u.field));
  const r = {
    num: 0,
    agg: null,
    store: !1,
    count: t
  };
  if (!n)
    for (var i = e.length, o = r.agg = Array(i), a = 0; a < i; ++a)
      o[a] = new e[a](r);
  if (r.store)
    var s = r.data = new zee();
  return r.add = function(u) {
    if (r.num += 1, !n) {
      s && s.add(u);
      for (let l = 0; l < i; ++l)
        o[l].add(o[l].get(u), u);
    }
  }, r.rem = function(u) {
    if (r.num -= 1, !n) {
      s && s.rem(u);
      for (let l = 0; l < i; ++l)
        o[l].rem(o[l].get(u), u);
    }
  }, r.set = function(u) {
    let l, f;
    for (s && s.values(), l = 0, f = t.length; l < f; ++l)
      u[t[l]] = r.num;
    if (!n)
      for (l = 0, f = o.length; l < f; ++l)
        o[l].set(u);
  }, r.init = function() {
    r.num = 0, s && s.reset();
    for (let u = 0; u < i; ++u)
      o[u].init();
  }, r;
}
function lte(e) {
  Ge.call(this, {}, e), this._mlen = 0, this._mods = [];
}
lte.Definition = {
  type: "Window",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: Lxt.concat(t4)
  }, {
    name: "params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "aggregate_params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "frame",
    type: "number",
    null: !0,
    array: !0,
    length: 2,
    default: [null, 0]
  }, {
    name: "ignorePeers",
    type: "boolean",
    default: !1
  }]
};
Tt(lte, Ge, {
  transform(e, t) {
    this.stamp = t.stamp;
    const n = e.modified(), r = i2(e.sort), i = BG(e.groupby), o = (s) => this.group(i(s));
    let a = this.state;
    (!a || n) && (a = this.state = new eAe(e)), n || t.modified(a.inputs) ? (this.value = {}, t.visit(t.SOURCE, (s) => o(s).add(s))) : (t.visit(t.REM, (s) => o(s).remove(s)), t.visit(t.ADD, (s) => o(s).add(s)));
    for (let s = 0, u = this._mlen; s < u; ++s)
      Fxt(this._mods[s], a, r, e);
    return this._mlen = 0, this._mods = [], t.reflow(n).modifies(a.outputs);
  },
  group(e) {
    let t = this.value[e];
    return t || (t = this.value[e] = kDe(bn), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
  }
});
function Fxt(e, t, n, r) {
  const i = r.sort, o = i && !r.ignorePeers, a = r.frame || [null, 0], s = e.data(n), u = s.length, l = o ? Qx(i) : null, f = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: s,
    compare: i || Gl(-1)
  };
  t.init();
  for (let h = 0; h < u; ++h)
    Bxt(f, a, h, u), o && Uxt(f, l), t.update(f, s[h]);
}
function Bxt(e, t, n, r) {
  e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? r : Math.min(r, n + Math.abs(t[1]) + 1), e.index = n;
}
function Uxt(e, t) {
  const n = e.i0, r = e.i1 - 1, i = e.compare, o = e.data, a = o.length - 1;
  n > 0 && !i(o[n], o[n - 1]) && (e.i0 = t.left(o, o[n])), r < a && !i(o[r], o[r + 1]) && (e.i1 = t.right(o, o[r]));
}
const Yxt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aggregate: uw,
  bin: Fee,
  collect: Bee,
  compare: $De,
  countpattern: Uee,
  cross: Yee,
  density: Hee,
  dotbin: Wee,
  expression: zDe,
  extent: qee,
  facet: I6,
  field: FDe,
  filter: Qee,
  flatten: Xee,
  fold: Kee,
  formula: Zee,
  generate: BDe,
  impute: Jee,
  joinaggregate: ete,
  kde: tte,
  key: UDe,
  load: YDe,
  lookup: nte,
  multiextent: HDe,
  multivalues: VDe,
  params: WDe,
  pivot: rte,
  prefacet: qDe,
  project: ite,
  proxy: GDe,
  quantile: ote,
  relay: QDe,
  sample: ate,
  sequence: ste,
  sieve: XDe,
  subflow: Gee,
  timeunit: ute,
  tupleindex: ZDe,
  values: JDe,
  window: lte
}, Symbol.toStringTag, { value: "Module" }));
function Bx(e, t) {
  if (typeof document < "u" && document.createElement) {
    const n = document.createElement("canvas");
    if (n && n.getContext)
      return n.width = e, n.height = t, n;
  }
  return null;
}
const Hxt = () => typeof Image < "u" ? Image : null;
function sv(e) {
  for (var t = e.length / 6 | 0, n = new Array(t), r = 0; r < t; )
    n[r] = "#" + e.slice(r * 6, ++r * 6);
  return n;
}
const Vxt = sv("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), Wxt = sv("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), qxt = sv("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), Gxt = sv("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"), Qxt = sv("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), Xxt = sv("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), Kxt = sv("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), Zxt = sv("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), Jxt = sv("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), ewt = sv("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
function cte(e, t, n) {
  const r = e - t + n * 2;
  return e ? r > 0 ? r : 1 : 0;
}
const twt = "identity", CC = "linear", db = "log", n4 = "pow", r4 = "sqrt", j6 = "symlog", OS = "time", RS = "utc", By = "sequential", ON = "diverging", NC = "quantile", L6 = "quantize", z6 = "threshold", fte = "ordinal", UG = "point", nAe = "band", dte = "bin-ordinal", Xs = "continuous", i4 = "discrete", o4 = "discretizing", Mp = "interpolating", hte = "temporal";
function nwt(e) {
  return function(t) {
    let n = t[0], r = t[1], i;
    return r < n && (i = n, n = r, r = i), [e.invert(n), e.invert(r)];
  };
}
function rwt(e) {
  return function(t) {
    const n = e.range();
    let r = t[0], i = t[1], o = -1, a, s, u, l;
    for (i < r && (s = r, r = i, i = s), u = 0, l = n.length; u < l; ++u)
      n[u] >= r && n[u] <= i && (o < 0 && (o = u), a = u);
    if (!(o < 0))
      return r = e.invertExtent(n[o]), i = e.invertExtent(n[a]), [r[0] === void 0 ? r[1] : r[0], i[1] === void 0 ? i[0] : i[1]];
  };
}
function pte() {
  const e = k$().unknown(void 0), t = e.domain, n = e.range;
  let r = [0, 1], i, o, a = !1, s = 0, u = 0, l = 0.5;
  delete e.unknown;
  function f() {
    const h = t().length, p = r[1] < r[0], g = r[1 - p], y = cte(h, s, u);
    let b = r[p - 0];
    i = (g - b) / (y || 1), a && (i = Math.floor(i)), b += (g - b - i * (h - s)) * l, o = i * (1 - s), a && (b = Math.round(b), o = Math.round(o));
    const _ = qo(h).map((S) => b + i * S);
    return n(p ? _.reverse() : _);
  }
  return e.domain = function(h) {
    return arguments.length ? (t(h), f()) : t();
  }, e.range = function(h) {
    return arguments.length ? (r = [+h[0], +h[1]], f()) : r.slice();
  }, e.rangeRound = function(h) {
    return r = [+h[0], +h[1]], a = !0, f();
  }, e.bandwidth = function() {
    return o;
  }, e.step = function() {
    return i;
  }, e.round = function(h) {
    return arguments.length ? (a = !!h, f()) : a;
  }, e.padding = function(h) {
    return arguments.length ? (u = Math.max(0, Math.min(1, h)), s = u, f()) : s;
  }, e.paddingInner = function(h) {
    return arguments.length ? (s = Math.max(0, Math.min(1, h)), f()) : s;
  }, e.paddingOuter = function(h) {
    return arguments.length ? (u = Math.max(0, Math.min(1, h)), f()) : u;
  }, e.align = function(h) {
    return arguments.length ? (l = Math.max(0, Math.min(1, h)), f()) : l;
  }, e.invertRange = function(h) {
    if (h[0] == null || h[1] == null)
      return;
    const p = r[1] < r[0], g = p ? n().reverse() : n(), y = g.length - 1;
    let b = +h[0], _ = +h[1], S, C, A;
    if (!(b !== b || _ !== _) && (_ < b && (A = b, b = _, _ = A), !(_ < g[0] || b > r[1 - p])))
      return S = Math.max(0, aL(g, b) - 1), C = b === _ ? S : aL(g, _) - 1, b - g[S] > o + 1e-10 && ++S, p && (A = S, S = y - C, C = y - A), S > C ? void 0 : t().slice(S, C + 1);
  }, e.invert = function(h) {
    const p = e.invertRange([h, h]);
    return p && p[0];
  }, e.copy = function() {
    return pte().domain(t()).range(r).round(a).paddingInner(s).paddingOuter(u).align(l);
  }, f();
}
function rAe(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return rAe(t());
  }, e;
}
function iwt() {
  return rAe(pte().paddingInner(1));
}
var owt = Array.prototype.map;
function awt(e) {
  return owt.call(e, Fl);
}
const swt = Array.prototype.slice;
function iAe() {
  let e = [], t = [];
  function n(r) {
    return r == null || r !== r ? void 0 : t[(uN(e, r) - 1) % t.length];
  }
  return n.domain = function(r) {
    return arguments.length ? (e = awt(r), n) : e.slice();
  }, n.range = function(r) {
    return arguments.length ? (t = swt.call(r), n) : t.slice();
  }, n.tickFormat = function(r, i) {
    return fSe(e[0], ri(e), r ?? 10, i);
  }, n.copy = function() {
    return iAe().domain(n.domain()).range(n.range());
  }, n;
}
const p5 = /* @__PURE__ */ new Map(), oAe = Symbol("vega_scale");
function aAe(e) {
  return e[oAe] = !0, e;
}
function uwt(e) {
  return e && e[oAe] === !0;
}
function lwt(e, t, n) {
  const r = function() {
    const o = t();
    return o.invertRange || (o.invertRange = o.invert ? nwt(o) : o.invertExtent ? rwt(o) : void 0), o.type = e, aAe(o);
  };
  return r.metadata = Wg(Rt(n)), r;
}
function Di(e, t, n) {
  return arguments.length > 1 ? (p5.set(e, lwt(e, t, n)), this) : sAe(e) ? p5.get(e) : void 0;
}
Di(twt, mZ);
Di(CC, BF, Xs);
Di(db, vZ, [Xs, db]);
Di(n4, UF, Xs);
Di(r4, Eft, Xs);
Di(j6, xZ, Xs);
Di(OS, OSe, [Xs, hte]);
Di(RS, RSe, [Xs, hte]);
Di(By, CZ, [Xs, Mp]);
Di(`${By}-${CC}`, CZ, [Xs, Mp]);
Di(`${By}-${db}`, kSe, [Xs, Mp, db]);
Di(`${By}-${n4}`, NZ, [Xs, Mp]);
Di(`${By}-${r4}`, Ddt, [Xs, Mp]);
Di(`${By}-${j6}`, $Se, [Xs, Mp]);
Di(`${ON}-${CC}`, DZ, [Xs, Mp]);
Di(`${ON}-${db}`, AZ, [Xs, Mp, db]);
Di(`${ON}-${n4}`, VF, [Xs, Mp]);
Di(`${ON}-${r4}`, Adt, [Xs, Mp]);
Di(`${ON}-${j6}`, OZ, [Xs, Mp]);
Di(NC, _Z, [o4, NC]);
Di(L6, hSe, o4);
Di(z6, EZ, o4);
Di(dte, iAe, [i4, o4]);
Di(fte, k$, i4);
Di(nAe, pte, i4);
Di(UG, iwt, i4);
function sAe(e) {
  return p5.has(e);
}
function a2(e, t) {
  const n = p5.get(e);
  return n && n.metadata[t];
}
function gte(e) {
  return a2(e, Xs);
}
function DC(e) {
  return a2(e, i4);
}
function YG(e) {
  return a2(e, o4);
}
function uAe(e) {
  return a2(e, db);
}
function cwt(e) {
  return a2(e, hte);
}
function lAe(e) {
  return a2(e, Mp);
}
function cAe(e) {
  return a2(e, NC);
}
const fwt = ["clamp", "base", "constant", "exponent"];
function fAe(e, t) {
  const n = t[0], r = ri(t) - n;
  return function(i) {
    return e(n + i * r);
  };
}
function F6(e, t, n) {
  return dN(mte(t || "rgb", n), e);
}
function dAe(e, t) {
  const n = new Array(t), r = t + 1;
  for (let i = 0; i < t; )
    n[i] = e(++i / r);
  return n;
}
function hAe(e, t, n) {
  const r = n - t;
  let i, o, a;
  return !r || !Number.isFinite(r) ? Gl(0.5) : (i = (o = e.type).indexOf("-"), o = i < 0 ? o : o.slice(i + 1), a = Di(o)().domain([t, n]).range([0, 1]), fwt.forEach((s) => e[s] ? a[s](e[s]()) : 0), a);
}
function mte(e, t) {
  const n = Cat[dwt(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function dwt(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const hwt = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, pwt = {
  accent: Wxt,
  category10: Vxt,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: qxt,
  observable10: Gxt,
  paired: Qxt,
  pastel1: Xxt,
  pastel2: Kxt,
  set1: Zxt,
  set2: Jxt,
  set3: ewt,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function pAe(e) {
  if (nt(e))
    return e;
  const t = e.length / 6 | 0, n = new Array(t);
  for (let r = 0; r < t; )
    n[r] = "#" + e.slice(r * 6, ++r * 6);
  return n;
}
function gAe(e, t) {
  for (const n in e)
    yte(n, t(e[n]));
}
const Hpe = {};
gAe(pwt, pAe);
gAe(hwt, (e) => F6(pAe(e)));
function yte(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (Hpe[e] = t, this) : Hpe[e];
}
const pj = "symbol", gwt = "discrete", mwt = "gradient", ywt = (e) => nt(e) ? e.map((t) => String(t)) : String(e), vwt = (e, t) => e[1] - t[1], bwt = (e, t) => t[1] - e[1];
function vte(e, t, n) {
  let r;
  return pi(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(Z$(e.domain()) / n || 1) + 1))), Pt(t) && (r = t.step, t = t.interval), kt(t) && (t = e.type === OS ? NN(t) : e.type == RS ? DN(t) : tt("Only time and utc scales accept interval strings."), r && (t = t.every(r))), t;
}
function mAe(e, t, n) {
  let r = e.range(), i = r[0], o = ri(r), a = vwt;
  if (i > o && (r = o, o = i, i = r, a = bwt), i = Math.floor(i), o = Math.ceil(o), t = t.map((s) => [s, e(s)]).filter((s) => i <= s[1] && s[1] <= o).sort(a).map((s) => s[0]), n > 0 && t.length > 1) {
    const s = [t[0], ri(t)];
    for (; t.length > n && t.length >= 3; )
      t = t.filter((u, l) => !(l % 2));
    t.length < 3 && (t = s);
  }
  return t;
}
function bte(e, t) {
  return e.bins ? mAe(e, e.bins, t) : e.ticks ? e.ticks(t) : e.domain();
}
function yAe(e, t, n, r, i, o) {
  const a = t.type;
  let s = ywt;
  if (a === OS || i === OS)
    s = e.timeFormat(r);
  else if (a === RS || i === RS)
    s = e.utcFormat(r);
  else if (uAe(a)) {
    const u = e.formatFloat(r);
    if (o || t.bins)
      s = u;
    else {
      const l = vAe(t, n, !1);
      s = (f) => l(f) ? u(f) : "";
    }
  } else if (t.tickFormat) {
    const u = t.domain();
    s = e.formatSpan(u[0], u[u.length - 1], n, r);
  } else
    r && (s = e.format(r));
  return s;
}
function vAe(e, t, n) {
  const r = bte(e, t), i = e.base(), o = Math.log(i), a = Math.max(1, i * t / r.length), s = (u) => {
    let l = u / Math.pow(i, Math.round(Math.log(u) / o));
    return l * i < i - 0.5 && (l *= i), l <= a;
  };
  return n ? r.filter(s) : s;
}
const HG = {
  [NC]: "quantiles",
  [L6]: "thresholds",
  [z6]: "domain"
}, bAe = {
  [NC]: "quantiles",
  [L6]: "domain"
};
function xAe(e, t) {
  return e.bins ? _wt(e.bins) : e.type === db ? vAe(e, t, !0) : HG[e.type] ? wwt(e[HG[e.type]]()) : bte(e, t);
}
function xwt(e, t, n) {
  const r = t[bAe[t.type]](), i = r.length;
  let o = i > 1 ? r[1] - r[0] : r[0], a;
  for (a = 1; a < i; ++a)
    o = Math.min(o, r[a] - r[a - 1]);
  return e.formatSpan(0, o, 3 * 10, n);
}
function wwt(e) {
  const t = [-1 / 0].concat(e);
  return t.max = 1 / 0, t;
}
function _wt(e) {
  const t = e.slice(0, -1);
  return t.max = ri(e), t;
}
const Ewt = (e) => HG[e.type] || e.bins;
function wAe(e, t, n, r, i, o, a) {
  const s = bAe[t.type] && o !== OS && o !== RS ? xwt(e, t, i) : yAe(e, t, n, i, o, a);
  return r === pj && Ewt(t) ? Swt(s) : r === gwt ? Mwt(s) : Twt(s);
}
const Swt = (e) => (t, n, r) => {
  const i = Vpe(r[n + 1], Vpe(r.max, 1 / 0)), o = Wpe(t, e), a = Wpe(i, e);
  return o && a ? o + " – " + a : a ? "< " + a : "≥ " + o;
}, Vpe = (e, t) => e ?? t, Mwt = (e) => (t, n) => n ? e(t) : null, Twt = (e) => (t) => e(t), Wpe = (e, t) => Number.isFinite(e) ? t(e) : null;
function Cwt(e) {
  const t = e.domain(), n = t.length - 1;
  let r = +t[0], i = +ri(t), o = i - r;
  if (e.type === z6) {
    const a = n ? o / n : 0.1;
    r -= a, i += a, o = i - r;
  }
  return (a) => (a - r) / o;
}
function Nwt(e, t, n, r) {
  const i = r || t.type;
  return kt(n) && cwt(i) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && i === OS ? e.timeFormat("%A, %d %B %Y, %X") : !n && i === RS ? e.utcFormat("%A, %d %B %Y, %X UTC") : wAe(e, t, 5, null, n, r, !0);
}
function _Ae(e, t, n) {
  n = n || {};
  const r = Math.max(3, n.maxlen || 7), i = Nwt(e, t, n.format, n.formatType);
  if (YG(t.type)) {
    const o = xAe(t).slice(1).map(i), a = o.length;
    return `${a} boundar${a === 1 ? "y" : "ies"}: ${o.join(", ")}`;
  } else if (DC(t.type)) {
    const o = t.domain(), a = o.length, s = a > r ? o.slice(0, r - 2).map(i).join(", ") + ", ending with " + o.slice(-1).map(i) : o.map(i).join(", ");
    return `${a} value${a === 1 ? "" : "s"}: ${s}`;
  } else {
    const o = t.domain();
    return `values from ${i(o[0])} to ${i(ri(o))}`;
  }
}
let EAe = 0;
function Dwt() {
  EAe = 0;
}
const g5 = "p_";
function xte(e) {
  return e && e.gradient;
}
function SAe(e, t, n) {
  const r = e.gradient;
  let i = e.id, o = r === "radial" ? g5 : "";
  return i || (i = e.id = "gradient_" + EAe++, r === "radial" ? (e.x1 = gy(e.x1, 0.5), e.y1 = gy(e.y1, 0.5), e.r1 = gy(e.r1, 0), e.x2 = gy(e.x2, 0.5), e.y2 = gy(e.y2, 0.5), e.r2 = gy(e.r2, 0.5), o = g5) : (e.x1 = gy(e.x1, 0), e.y1 = gy(e.y1, 0), e.x2 = gy(e.x2, 1), e.y2 = gy(e.y2, 0))), t[i] = e, "url(" + (n || "") + "#" + o + i + ")";
}
function gy(e, t) {
  return e ?? t;
}
function MAe(e, t) {
  var n = [], r;
  return r = {
    gradient: "linear",
    x1: e ? e[0] : 0,
    y1: e ? e[1] : 0,
    x2: t ? t[0] : 1,
    y2: t ? t[1] : 0,
    stops: n,
    stop: function(i, o) {
      return n.push({
        offset: i,
        color: o
      }), r;
    }
  };
}
const qpe = {
  basis: {
    curve: Awe
  },
  "basis-closed": {
    curve: Rwe
  },
  "basis-open": {
    curve: $we
  },
  bundle: {
    curve: Iwe,
    tension: "beta",
    value: 0.85
  },
  cardinal: {
    curve: jwe,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: zwe,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: Lwe,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: Bwe,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: Ywe,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: Vwe,
    tension: "alpha",
    value: 0.5
  },
  linear: {
    curve: sN
  },
  "linear-closed": {
    curve: qwe
  },
  monotone: {
    horizontal: Kwe,
    vertical: Xwe
  },
  natural: {
    curve: Jwe
  },
  step: {
    curve: e_e
  },
  "step-after": {
    curve: n_e
  },
  "step-before": {
    curve: t_e
  }
};
function wte(e, t, n) {
  var r = wn(qpe, e) && qpe[e], i = null;
  return r && (i = r.curve || r[t || "vertical"], r.tension && n != null && (i = i[r.tension](n))), i;
}
const Awt = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
}, Owt = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, Rwt = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, kwt = /^((\s+,?\s*)|(,\s*))/, $wt = /^[01]/;
function AC(e) {
  const t = [];
  return (e.match(Owt) || []).forEach((r) => {
    let i = r[0];
    const o = i.toLowerCase(), a = Awt[o], s = Pwt(o, a, r.slice(1).trim()), u = s.length;
    if (u < a || u && u % a !== 0)
      throw Error("Invalid SVG path, incorrect parameter count");
    if (t.push([i, ...s.slice(0, a)]), u !== a) {
      o === "m" && (i = i === "M" ? "L" : "l");
      for (let l = a; l < u; l += a)
        t.push([i, ...s.slice(l, l + a)]);
    }
  }), t;
}
function Pwt(e, t, n) {
  const r = [];
  for (let i = 0; t && i < n.length; )
    for (let o = 0; o < t; ++o) {
      const a = e === "a" && (o === 3 || o === 4) ? $wt : Rwt, s = n.slice(i).match(a);
      if (s === null)
        throw Error("Invalid SVG path, incorrect parameter type");
      i += s[0].length, r.push(+s[0]);
      const u = n.slice(i).match(kwt);
      u !== null && (i += u[0].length);
    }
  return r;
}
const lw = Math.PI / 180, Iwt = 1e-14, IE = Math.PI / 2, Ny = Math.PI * 2, WM = Math.sqrt(3) / 2;
var XH = {}, KH = {}, TAe = [].join;
function jwt(e, t, n, r, i, o, a, s, u) {
  const l = TAe.call(arguments);
  if (XH[l])
    return XH[l];
  const f = a * lw, h = Math.sin(f), p = Math.cos(f);
  n = Math.abs(n), r = Math.abs(r);
  const g = p * (s - e) * 0.5 + h * (u - t) * 0.5, y = p * (u - t) * 0.5 - h * (s - e) * 0.5;
  let b = g * g / (n * n) + y * y / (r * r);
  b > 1 && (b = Math.sqrt(b), n *= b, r *= b);
  const _ = p / n, S = h / n, C = -h / r, A = p / r, O = _ * s + S * u, R = C * s + A * u, j = _ * e + S * t, $ = C * e + A * t;
  let W = 1 / ((j - O) * (j - O) + ($ - R) * ($ - R)) - 0.25;
  W < 0 && (W = 0);
  let Y = Math.sqrt(W);
  o == i && (Y = -Y);
  const V = 0.5 * (O + j) - Y * ($ - R), ee = 0.5 * (R + $) + Y * (j - O), K = Math.atan2(R - ee, O - V);
  let q = Math.atan2($ - ee, j - V) - K;
  q < 0 && o === 1 ? q += Ny : q > 0 && o === 0 && (q -= Ny);
  const te = Math.ceil(Math.abs(q / (IE + 1e-3))), X = [];
  for (let Z = 0; Z < te; ++Z) {
    const se = K + Z * q / te, H = K + (Z + 1) * q / te;
    X[Z] = [V, ee, se, H, n, r, h, p];
  }
  return XH[l] = X;
}
function Lwt(e) {
  const t = TAe.call(e);
  if (KH[t])
    return KH[t];
  var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], u = e[6], l = e[7];
  const f = l * a, h = -u * s, p = u * a, g = l * s, y = Math.cos(i), b = Math.sin(i), _ = Math.cos(o), S = Math.sin(o), C = 0.5 * (o - i), A = Math.sin(C * 0.5), O = 8 / 3 * A * A / Math.sin(C), R = n + y - O * b, j = r + b + O * y, $ = n + _, z = r + S, W = $ + O * S, Y = z - O * _;
  return KH[t] = [f * R + h * j, p * R + g * j, f * W + h * Y, p * W + g * Y, f * $ + h * z, p * $ + g * z];
}
const Gh = ["l", 0, 0, 0, 0, 0, 0, 0];
function zwt(e, t, n) {
  const r = Gh[0] = e[0];
  if (r === "a" || r === "A")
    Gh[1] = t * e[1], Gh[2] = n * e[2], Gh[3] = e[3], Gh[4] = e[4], Gh[5] = e[5], Gh[6] = t * e[6], Gh[7] = n * e[7];
  else if (r === "h" || r === "H")
    Gh[1] = t * e[1];
  else if (r === "v" || r === "V")
    Gh[1] = n * e[1];
  else
    for (var i = 1, o = e.length; i < o; ++i)
      Gh[i] = (i % 2 == 1 ? t : n) * e[i];
  return Gh;
}
function qk(e, t, n, r, i, o) {
  var a, s = null, u = 0, l = 0, f = 0, h = 0, p, g, y, b, _ = 0, S = 0;
  n == null && (n = 0), r == null && (r = 0), i == null && (i = 1), o == null && (o = i), e.beginPath && e.beginPath();
  for (var C = 0, A = t.length; C < A; ++C) {
    switch (a = t[C], (i !== 1 || o !== 1) && (a = zwt(a, i, o)), a[0]) {
      case "l":
        u += a[1], l += a[2], e.lineTo(u + n, l + r);
        break;
      case "L":
        u = a[1], l = a[2], e.lineTo(u + n, l + r);
        break;
      case "h":
        u += a[1], e.lineTo(u + n, l + r);
        break;
      case "H":
        u = a[1], e.lineTo(u + n, l + r);
        break;
      case "v":
        l += a[1], e.lineTo(u + n, l + r);
        break;
      case "V":
        l = a[1], e.lineTo(u + n, l + r);
        break;
      case "m":
        u += a[1], l += a[2], _ = u, S = l, e.moveTo(u + n, l + r);
        break;
      case "M":
        u = a[1], l = a[2], _ = u, S = l, e.moveTo(u + n, l + r);
        break;
      case "c":
        p = u + a[5], g = l + a[6], f = u + a[3], h = l + a[4], e.bezierCurveTo(
          u + a[1] + n,
          // x1
          l + a[2] + r,
          // y1
          f + n,
          // x2
          h + r,
          // y2
          p + n,
          g + r
        ), u = p, l = g;
        break;
      case "C":
        u = a[5], l = a[6], f = a[3], h = a[4], e.bezierCurveTo(a[1] + n, a[2] + r, f + n, h + r, u + n, l + r);
        break;
      case "s":
        p = u + a[3], g = l + a[4], f = 2 * u - f, h = 2 * l - h, e.bezierCurveTo(f + n, h + r, u + a[1] + n, l + a[2] + r, p + n, g + r), f = u + a[1], h = l + a[2], u = p, l = g;
        break;
      case "S":
        p = a[3], g = a[4], f = 2 * u - f, h = 2 * l - h, e.bezierCurveTo(f + n, h + r, a[1] + n, a[2] + r, p + n, g + r), u = p, l = g, f = a[1], h = a[2];
        break;
      case "q":
        p = u + a[3], g = l + a[4], f = u + a[1], h = l + a[2], e.quadraticCurveTo(f + n, h + r, p + n, g + r), u = p, l = g;
        break;
      case "Q":
        p = a[3], g = a[4], e.quadraticCurveTo(a[1] + n, a[2] + r, p + n, g + r), u = p, l = g, f = a[1], h = a[2];
        break;
      case "t":
        p = u + a[1], g = l + a[2], s[0].match(/[QqTt]/) === null ? (f = u, h = l) : s[0] === "t" ? (f = 2 * u - y, h = 2 * l - b) : s[0] === "q" && (f = 2 * u - f, h = 2 * l - h), y = f, b = h, e.quadraticCurveTo(f + n, h + r, p + n, g + r), u = p, l = g, f = u + a[1], h = l + a[2];
        break;
      case "T":
        p = a[1], g = a[2], f = 2 * u - f, h = 2 * l - h, e.quadraticCurveTo(f + n, h + r, p + n, g + r), u = p, l = g;
        break;
      case "a":
        Gpe(e, u + n, l + r, [a[1], a[2], a[3], a[4], a[5], a[6] + u + n, a[7] + l + r]), u += a[6], l += a[7];
        break;
      case "A":
        Gpe(e, u + n, l + r, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + r]), u = a[6], l = a[7];
        break;
      case "z":
      case "Z":
        u = _, l = S, e.closePath();
        break;
    }
    s = a;
  }
}
function Gpe(e, t, n, r) {
  const i = jwt(
    r[5],
    // end x
    r[6],
    // end y
    r[0],
    // radius x
    r[1],
    // radius y
    r[3],
    // large flag
    r[4],
    // sweep flag
    r[2],
    // rotation
    t,
    n
  );
  for (let o = 0; o < i.length; ++o) {
    const a = Lwt(i[o]);
    e.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
  }
}
const Qpe = 0.5773502691896257, Xpe = {
  circle: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(n, 0), e.arc(0, 0, n, 0, Ny);
    }
  },
  cross: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = n / 2.5;
      e.moveTo(-n, -r), e.lineTo(-n, r), e.lineTo(-r, r), e.lineTo(-r, n), e.lineTo(r, n), e.lineTo(r, r), e.lineTo(n, r), e.lineTo(n, -r), e.lineTo(r, -r), e.lineTo(r, -n), e.lineTo(-r, -n), e.lineTo(-r, -r), e.closePath();
    }
  },
  diamond: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath();
    }
  },
  square: {
    draw: function(e, t) {
      var n = Math.sqrt(t), r = -n / 2;
      e.rect(r, r, n, n);
    }
  },
  arrow: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = n / 7, i = n / 2.5, o = n / 8;
      e.moveTo(-r, n), e.lineTo(r, n), e.lineTo(r, -o), e.lineTo(i, -o), e.lineTo(0, -n), e.lineTo(-i, -o), e.lineTo(-r, -o), e.closePath();
    }
  },
  wedge: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = WM * n, i = r - n * Qpe, o = n / 4;
      e.moveTo(0, -r - i), e.lineTo(-o, r - i), e.lineTo(o, r - i), e.closePath();
    }
  },
  triangle: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = WM * n, i = r - n * Qpe;
      e.moveTo(0, -r - i), e.lineTo(-n, r - i), e.lineTo(n, r - i), e.closePath();
    }
  },
  "triangle-up": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = WM * n;
      e.moveTo(0, -r), e.lineTo(-n, r), e.lineTo(n, r), e.closePath();
    }
  },
  "triangle-down": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = WM * n;
      e.moveTo(0, r), e.lineTo(-n, -r), e.lineTo(n, -r), e.closePath();
    }
  },
  "triangle-right": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = WM * n;
      e.moveTo(r, 0), e.lineTo(-r, -n), e.lineTo(-r, n), e.closePath();
    }
  },
  "triangle-left": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, r = WM * n;
      e.moveTo(-r, 0), e.lineTo(r, -n), e.lineTo(r, n), e.closePath();
    }
  },
  stroke: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(n, 0);
    }
  }
};
function CAe(e) {
  return wn(Xpe, e) ? Xpe[e] : Fwt(e);
}
var ZH = {};
function Fwt(e) {
  if (!wn(ZH, e)) {
    const t = AC(e);
    ZH[e] = {
      draw: function(n, r) {
        qk(n, t, 0, 0, Math.sqrt(r) / 2);
      }
    };
  }
  return ZH[e];
}
const ix = 0.448084975506;
function Bwt(e) {
  return e.x;
}
function Uwt(e) {
  return e.y;
}
function Ywt(e) {
  return e.width;
}
function Hwt(e) {
  return e.height;
}
function O0(e) {
  return typeof e == "function" ? e : () => +e;
}
function b3(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
function NAe() {
  var e = Bwt, t = Uwt, n = Ywt, r = Hwt, i = O0(0), o = i, a = i, s = i, u = null;
  function l(f, h, p) {
    var g, y = h ?? +e.call(this, f), b = p ?? +t.call(this, f), _ = +n.call(this, f), S = +r.call(this, f), C = Math.min(_, S) / 2, A = b3(+i.call(this, f), 0, C), O = b3(+o.call(this, f), 0, C), R = b3(+a.call(this, f), 0, C), j = b3(+s.call(this, f), 0, C);
    if (u || (u = g = wF()), A <= 0 && O <= 0 && R <= 0 && j <= 0)
      u.rect(y, b, _, S);
    else {
      var $ = y + _, z = b + S;
      u.moveTo(y + A, b), u.lineTo($ - O, b), u.bezierCurveTo($ - ix * O, b, $, b + ix * O, $, b + O), u.lineTo($, z - j), u.bezierCurveTo($, z - ix * j, $ - ix * j, z, $ - j, z), u.lineTo(y + R, z), u.bezierCurveTo(y + ix * R, z, y, z - ix * R, y, z - R), u.lineTo(y, b + A), u.bezierCurveTo(y, b + ix * A, y + ix * A, b, y + A, b), u.closePath();
    }
    if (g)
      return u = null, g + "" || null;
  }
  return l.x = function(f) {
    return arguments.length ? (e = O0(f), l) : e;
  }, l.y = function(f) {
    return arguments.length ? (t = O0(f), l) : t;
  }, l.width = function(f) {
    return arguments.length ? (n = O0(f), l) : n;
  }, l.height = function(f) {
    return arguments.length ? (r = O0(f), l) : r;
  }, l.cornerRadius = function(f, h, p, g) {
    return arguments.length ? (i = O0(f), o = h != null ? O0(h) : i, s = p != null ? O0(p) : i, a = g != null ? O0(g) : o, l) : i;
  }, l.context = function(f) {
    return arguments.length ? (u = f ?? null, l) : u;
  }, l;
}
function DAe() {
  var e, t, n, r, i = null, o, a, s, u;
  function l(h, p, g) {
    const y = g / 2;
    if (o) {
      var b = s - p, _ = h - a;
      if (b || _) {
        var S = Math.hypot(b, _), C = (b /= S) * u, A = (_ /= S) * u, O = Math.atan2(_, b);
        i.moveTo(a - C, s - A), i.lineTo(h - b * y, p - _ * y), i.arc(h, p, y, O - Math.PI, O), i.lineTo(a + C, s + A), i.arc(a, s, u, O, O + Math.PI);
      } else
        i.arc(h, p, y, 0, Ny);
      i.closePath();
    } else
      o = 1;
    a = h, s = p, u = y;
  }
  function f(h) {
    var p, g = h.length, y, b = !1, _;
    for (i == null && (i = _ = wF()), p = 0; p <= g; ++p)
      !(p < g && r(y = h[p], p, h)) === b && (b = !b) && (o = 0), b && l(+e(y, p, h), +t(y, p, h), +n(y, p, h));
    if (_)
      return i = null, _ + "" || null;
  }
  return f.x = function(h) {
    return arguments.length ? (e = h, f) : e;
  }, f.y = function(h) {
    return arguments.length ? (t = h, f) : t;
  }, f.size = function(h) {
    return arguments.length ? (n = h, f) : n;
  }, f.defined = function(h) {
    return arguments.length ? (r = h, f) : r;
  }, f.context = function(h) {
    return arguments.length ? (h == null ? i = null : i = h, f) : i;
  }, f;
}
function a4(e, t) {
  return e ?? t;
}
const s4 = (e) => e.x || 0, u4 = (e) => e.y || 0, Vwt = (e) => e.width || 0, Wwt = (e) => e.height || 0, qwt = (e) => (e.x || 0) + (e.width || 0), Gwt = (e) => (e.y || 0) + (e.height || 0), Qwt = (e) => e.startAngle || 0, Xwt = (e) => e.endAngle || 0, Kwt = (e) => e.padAngle || 0, Zwt = (e) => e.innerRadius || 0, Jwt = (e) => e.outerRadius || 0, e_t = (e) => e.cornerRadius || 0, t_t = (e) => a4(e.cornerRadiusTopLeft, e.cornerRadius) || 0, n_t = (e) => a4(e.cornerRadiusTopRight, e.cornerRadius) || 0, r_t = (e) => a4(e.cornerRadiusBottomRight, e.cornerRadius) || 0, i_t = (e) => a4(e.cornerRadiusBottomLeft, e.cornerRadius) || 0, o_t = (e) => a4(e.size, 64), a_t = (e) => e.size || 1, B6 = (e) => e.defined !== !1, s_t = (e) => CAe(e.shape || "circle"), u_t = grt().startAngle(Qwt).endAngle(Xwt).padAngle(Kwt).innerRadius(Zwt).outerRadius(Jwt).cornerRadius(e_t), l_t = M$().x(s4).y1(u4).y0(Gwt).defined(B6), c_t = M$().y(u4).x1(s4).x0(qwt).defined(B6), f_t = IK().x(s4).y(u4).defined(B6), d_t = NAe().x(s4).y(u4).width(Vwt).height(Wwt).cornerRadius(t_t, n_t, r_t, i_t), h_t = Crt().type(s_t).size(o_t), p_t = DAe().x(s4).y(u4).defined(B6).size(a_t);
function _te(e) {
  return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
}
function g_t(e, t) {
  return u_t.context(e)(t);
}
function m_t(e, t) {
  const n = t[0], r = n.interpolate || "linear";
  return (n.orient === "horizontal" ? c_t : l_t).curve(wte(r, n.orient, n.tension)).context(e)(t);
}
function y_t(e, t) {
  const n = t[0], r = n.interpolate || "linear";
  return f_t.curve(wte(r, n.orient, n.tension)).context(e)(t);
}
function RN(e, t, n, r) {
  return d_t.context(e)(t, n, r);
}
function v_t(e, t) {
  return (t.mark.shape || t.shape).context(e)(t);
}
function b_t(e, t) {
  return h_t.context(e)(t);
}
function x_t(e, t) {
  return p_t.context(e)(t);
}
var AAe = 1;
function OAe() {
  AAe = 1;
}
function Ete(e, t, n) {
  var r = t.clip, i = e._defs, o = t.clip_id || (t.clip_id = "clip" + AAe++), a = i.clipping[o] || (i.clipping[o] = {
    id: o
  });
  return pr(r) ? a.path = r(null) : _te(n) ? a.path = RN(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + o + ")";
}
function xs(e) {
  this.clear(), e && this.union(e);
}
xs.prototype = {
  clone() {
    return new xs(this);
  },
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(e) {
    return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2;
  },
  set(e, t, n, r) {
    return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), r < t ? (this.y2 = t, this.y1 = r) : (this.y1 = t, this.y2 = r), this;
  },
  add(e, t) {
    return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this;
  },
  expand(e) {
    return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this;
  },
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  },
  scale(e) {
    return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this;
  },
  translate(e, t) {
    return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this;
  },
  rotate(e, t, n) {
    const r = this.rotatedPoints(e, t, n);
    return this.clear().add(r[0], r[1]).add(r[2], r[3]).add(r[4], r[5]).add(r[6], r[7]);
  },
  rotatedPoints(e, t, n) {
    var {
      x1: r,
      y1: i,
      x2: o,
      y2: a
    } = this, s = Math.cos(e), u = Math.sin(e), l = t - t * s + n * u, f = n - t * u - n * s;
    return [s * r - u * i + l, u * r + s * i + f, s * r - u * a + l, u * r + s * a + f, s * o - u * i + l, u * o + s * i + f, s * o - u * a + l, u * o + s * a + f];
  },
  union(e) {
    return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this;
  },
  intersect(e) {
    return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this;
  },
  encloses(e) {
    return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2;
  },
  alignsWith(e) {
    return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2);
  },
  intersects(e) {
    return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2);
  },
  contains(e, t) {
    return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function U6(e) {
  this.mark = e, this.bounds = this.bounds || new xs();
}
function Y6(e) {
  U6.call(this, e), this.items = this.items || [];
}
Tt(Y6, U6);
class RAe {
  constructor(t) {
    this._pending = 0, this._loader = t || M6();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(t) {
    const n = this;
    return Kpe(n), n._loader.sanitize(t, {
      context: "href"
    }).then((r) => (aO(n), r)).catch(() => (aO(n), null));
  }
  loadImage(t) {
    const n = this, r = Hxt();
    return Kpe(n), n._loader.sanitize(t, {
      context: "image"
    }).then((i) => {
      const o = i.href;
      if (!o || !r)
        throw {
          url: o
        };
      const a = new r(), s = wn(i, "crossOrigin") ? i.crossOrigin : "anonymous";
      return s != null && (a.crossOrigin = s), a.onload = () => aO(n), a.onerror = () => aO(n), a.src = o, a;
    }).catch((i) => (aO(n), {
      complete: !1,
      width: 0,
      height: 0,
      src: i && i.url || ""
    }));
  }
  ready() {
    const t = this;
    return new Promise((n) => {
      function r(i) {
        t.pending() ? setTimeout(() => {
          r(!0);
        }, 10) : n(i);
      }
      r(!1);
    });
  }
}
function Kpe(e) {
  e._pending += 1;
}
function aO(e) {
  e._pending -= 1;
}
function Mb(e, t, n) {
  if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
    const r = t.strokeWidth != null ? +t.strokeWidth : 1;
    e.expand(r + (n ? w_t(t, r) : 0));
  }
  return e;
}
function w_t(e, t) {
  return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
}
const __t = Ny - 1e-8;
let H6, gj, mj, WE, VG, yj, WG, qG;
const Tx = (e, t) => H6.add(e, t), vj = (e, t) => Tx(gj = e, mj = t), Zpe = (e) => Tx(e, H6.y1), Jpe = (e) => Tx(H6.x1, e), jE = (e, t) => VG * e + WG * t, LE = (e, t) => yj * e + qG * t, JH = (e, t) => Tx(jE(e, t), LE(e, t)), eV = (e, t) => vj(jE(e, t), LE(e, t));
function l4(e, t) {
  return H6 = e, t ? (WE = t * lw, VG = qG = Math.cos(WE), yj = Math.sin(WE), WG = -yj) : (VG = qG = 1, WE = yj = WG = 0), E_t;
}
const E_t = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: eV,
  lineTo: eV,
  rect(e, t, n, r) {
    WE ? (JH(e + n, t), JH(e + n, t + r), JH(e, t + r), eV(e, t)) : (Tx(e + n, t + r), vj(e, t));
  },
  quadraticCurveTo(e, t, n, r) {
    const i = jE(e, t), o = LE(e, t), a = jE(n, r), s = LE(n, r);
    ege(gj, i, a, Zpe), ege(mj, o, s, Jpe), vj(a, s);
  },
  bezierCurveTo(e, t, n, r, i, o) {
    const a = jE(e, t), s = LE(e, t), u = jE(n, r), l = LE(n, r), f = jE(i, o), h = LE(i, o);
    tge(gj, a, u, f, Zpe), tge(mj, s, l, h, Jpe), vj(f, h);
  },
  arc(e, t, n, r, i, o) {
    if (r += WE, i += WE, gj = n * Math.cos(i) + e, mj = n * Math.sin(i) + t, Math.abs(i - r) > __t)
      Tx(e - n, t - n), Tx(e + n, t + n);
    else {
      const a = (l) => Tx(n * Math.cos(l) + e, n * Math.sin(l) + t);
      let s, u;
      if (a(r), a(i), i !== r)
        if (r = r % Ny, r < 0 && (r += Ny), i = i % Ny, i < 0 && (i += Ny), i < r && (o = !o, s = r, r = i, i = s), o)
          for (i -= Ny, s = r - r % IE, u = 0; u < 4 && s > i; ++u, s -= IE)
            a(s);
        else
          for (s = r - r % IE + IE, u = 0; u < 4 && s < i; ++u, s = s + IE)
            a(s);
    }
  }
};
function ege(e, t, n, r) {
  const i = (e - t) / (e + n - 2 * t);
  0 < i && i < 1 && r(e + (t - e) * i);
}
function tge(e, t, n, r, i) {
  const o = r - e + 3 * t - 3 * n, a = e + n - 2 * t, s = e - t;
  let u = 0, l = 0, f;
  Math.abs(o) > Iwt ? (f = a * a + s * o, f >= 0 && (f = Math.sqrt(f), u = (-a + f) / o, l = (-a - f) / o)) : u = 0.5 * s / a, 0 < u && u < 1 && i(nge(u, e, t, n, r)), 0 < l && l < 1 && i(nge(l, e, t, n, r));
}
function nge(e, t, n, r, i) {
  const o = 1 - e, a = o * o, s = e * e;
  return a * o * t + 3 * a * e * n + 3 * o * s * r + s * e * i;
}
var Ux = (Ux = Bx(1, 1)) ? Ux.getContext("2d") : null;
const GG = new xs();
function Ste(e) {
  return function(t, n) {
    if (!Ux)
      return !0;
    e(Ux, t), GG.clear().union(t.bounds).intersect(n).round();
    const {
      x1: r,
      y1: i,
      x2: o,
      y2: a
    } = GG;
    for (let s = i; s <= a; ++s)
      for (let u = r; u <= o; ++u)
        if (Ux.isPointInPath(u, s))
          return !0;
    return !1;
  };
}
function Mte(e, t) {
  return t.contains(e.x || 0, e.y || 0);
}
function kAe(e, t) {
  const n = e.x || 0, r = e.y || 0, i = e.width || 0, o = e.height || 0;
  return t.intersects(GG.set(n, r, n + i, r + o));
}
function $Ae(e, t) {
  const n = e.x || 0, r = e.y || 0, i = e.x2 != null ? e.x2 : n, o = e.y2 != null ? e.y2 : r;
  return bT(t, n, r, i, o);
}
function bT(e, t, n, r, i) {
  const {
    x1: o,
    y1: a,
    x2: s,
    y2: u
  } = e, l = r - t, f = i - n;
  let h = 0, p = 1, g, y, b, _;
  for (_ = 0; _ < 4; ++_) {
    if (_ === 0 && (g = -l, y = -(o - t)), _ === 1 && (g = l, y = s - t), _ === 2 && (g = -f, y = -(a - n)), _ === 3 && (g = f, y = u - n), Math.abs(g) < 1e-10 && y < 0)
      return !1;
    if (b = y / g, g < 0) {
      if (b > p)
        return !1;
      b > h && (h = b);
    } else if (g > 0) {
      if (b < h)
        return !1;
      b < p && (p = b);
    }
  }
  return !0;
}
function OC(e, t) {
  e.globalCompositeOperation = t.blend || "source-over";
}
function bg(e, t) {
  return e ?? t;
}
function rge(e, t) {
  const n = t.length;
  for (let r = 0; r < n; ++r)
    e.addColorStop(t[r].offset, t[r].color);
  return e;
}
function S_t(e, t, n) {
  const r = n.width(), i = n.height();
  let o;
  if (t.gradient === "radial")
    o = e.createRadialGradient(n.x1 + bg(t.x1, 0.5) * r, n.y1 + bg(t.y1, 0.5) * i, Math.max(r, i) * bg(t.r1, 0), n.x1 + bg(t.x2, 0.5) * r, n.y1 + bg(t.y2, 0.5) * i, Math.max(r, i) * bg(t.r2, 0.5));
  else {
    const a = bg(t.x1, 0), s = bg(t.y1, 0), u = bg(t.x2, 1), l = bg(t.y2, 0);
    if (a === u || s === l || r === i)
      o = e.createLinearGradient(n.x1 + a * r, n.y1 + s * i, n.x1 + u * r, n.y1 + l * i);
    else {
      const f = Bx(Math.ceil(r), Math.ceil(i)), h = f.getContext("2d");
      return h.scale(r, i), h.fillStyle = rge(h.createLinearGradient(a, s, u, l), t.stops), h.fillRect(0, 0, r, i), e.createPattern(f, "no-repeat");
    }
  }
  return rge(o, t.stops);
}
function PAe(e, t, n) {
  return xte(n) ? S_t(e, n, t.bounds) : n;
}
function m5(e, t, n) {
  return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = PAe(e, t, t.fill), !0) : !1;
}
var M_t = [];
function RC(e, t, n) {
  var r = (r = t.strokeWidth) != null ? r : 1;
  return r <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = PAe(e, t, t.stroke), e.lineWidth = r, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || M_t), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1);
}
function T_t(e, t) {
  return e.zindex - t.zindex || e.index - t.index;
}
function Tte(e) {
  if (!e.zdirty)
    return e.zitems;
  var t = e.items, n = [], r, i, o;
  for (i = 0, o = t.length; i < o; ++i)
    r = t[i], r.index = i, r.zindex && n.push(r);
  return e.zdirty = !1, e.zitems = n.sort(T_t);
}
function Gg(e, t) {
  var n = e.items, r, i;
  if (!n || !n.length)
    return;
  const o = Tte(e);
  if (o && o.length) {
    for (r = 0, i = n.length; r < i; ++r)
      n[r].zindex || t(n[r]);
    n = o;
  }
  for (r = 0, i = n.length; r < i; ++r)
    t(n[r]);
}
function y5(e, t) {
  var n = e.items, r, i;
  if (!n || !n.length)
    return null;
  const o = Tte(e);
  for (o && o.length && (n = o), i = n.length; --i >= 0; )
    if (r = t(n[i]))
      return r;
  if (n === o) {
    for (n = e.items, i = n.length; --i >= 0; )
      if (!n[i].zindex && (r = t(n[i])))
        return r;
  }
  return null;
}
function Cte(e) {
  return function(t, n, r) {
    Gg(n, (i) => {
      (!r || r.intersects(i.bounds)) && IAe(e, t, i, i);
    });
  };
}
function C_t(e) {
  return function(t, n, r) {
    n.items.length && (!r || r.intersects(n.bounds)) && IAe(e, t, n.items[0], n.items);
  };
}
function IAe(e, t, n, r) {
  var i = n.opacity == null ? 1 : n.opacity;
  i !== 0 && (e(t, r) || (OC(t, n), n.fill && m5(t, n, i) && t.fill(), n.stroke && RC(t, n, i) && t.stroke()));
}
function V6(e) {
  return e = e || vp, function(t, n, r, i, o, a) {
    return r *= t.pixelRatio, i *= t.pixelRatio, y5(n, (s) => {
      const u = s.bounds;
      if (!(u && !u.contains(o, a) || !u) && e(t, s, r, i, o, a))
        return s;
    });
  };
}
function c4(e, t) {
  return function(n, r, i, o) {
    var a = Array.isArray(r) ? r[0] : r, s = t ?? a.fill, u = a.stroke && n.isPointInStroke, l, f;
    return u && (l = a.strokeWidth, f = a.strokeCap, n.lineWidth = l ?? 1, n.lineCap = f ?? "butt"), e(n, r) ? !1 : s && n.isPointInPath(i, o) || u && n.isPointInStroke(i, o);
  };
}
function Nte(e) {
  return V6(c4(e));
}
function oS(e, t) {
  return "translate(" + e + "," + t + ")";
}
function Dte(e) {
  return "rotate(" + e + ")";
}
function N_t(e, t) {
  return "scale(" + e + "," + t + ")";
}
function jAe(e) {
  return oS(e.x || 0, e.y || 0);
}
function D_t(e) {
  return oS(e.x || 0, e.y || 0) + (e.angle ? " " + Dte(e.angle) : "");
}
function A_t(e) {
  return oS(e.x || 0, e.y || 0) + (e.angle ? " " + Dte(e.angle) : "") + (e.scaleX || e.scaleY ? " " + N_t(e.scaleX || 1, e.scaleY || 1) : "");
}
function Ate(e, t, n) {
  function r(a, s) {
    a("transform", D_t(s)), a("d", t(null, s));
  }
  function i(a, s) {
    return t(l4(a, s.angle), s), Mb(a, s).translate(s.x || 0, s.y || 0);
  }
  function o(a, s) {
    var u = s.x || 0, l = s.y || 0, f = s.angle || 0;
    a.translate(u, l), f && a.rotate(f *= lw), a.beginPath(), t(a, s), f && a.rotate(-f), a.translate(-u, -l);
  }
  return {
    type: e,
    tag: "path",
    nested: !1,
    attr: r,
    bound: i,
    draw: Cte(o),
    pick: Nte(o),
    isect: n || Ste(o)
  };
}
var O_t = Ate("arc", g_t);
function R_t(e, t) {
  for (var n = e[0].orient === "horizontal" ? t[1] : t[0], r = e[0].orient === "horizontal" ? "y" : "x", i = e.length, o = 1 / 0, a, s; --i >= 0; )
    e[i].defined !== !1 && (s = Math.abs(e[i][r] - n), s < o && (o = s, a = e[i]));
  return a;
}
function k_t(e, t) {
  for (var n = Math.pow(e[0].strokeWidth || 1, 2), r = e.length, i, o, a; --r >= 0; )
    if (e[r].defined !== !1 && (i = e[r].x - t[0], o = e[r].y - t[1], a = i * i + o * o, a < n))
      return e[r];
  return null;
}
function $_t(e, t) {
  for (var n = e.length, r, i, o; --n >= 0; )
    if (e[n].defined !== !1 && (r = e[n].x - t[0], i = e[n].y - t[1], o = r * r + i * i, r = e[n].size || 1, o < r * r))
      return e[n];
  return null;
}
function Ote(e, t, n) {
  function r(u, l) {
    var f = l.mark.items;
    f.length && u("d", t(null, f));
  }
  function i(u, l) {
    var f = l.items;
    return f.length === 0 ? u : (t(l4(u), f), Mb(u, f[0]));
  }
  function o(u, l) {
    u.beginPath(), t(u, l);
  }
  const a = c4(o);
  function s(u, l, f, h, p, g) {
    var y = l.items, b = l.bounds;
    return !y || !y.length || b && !b.contains(p, g) ? null : (f *= u.pixelRatio, h *= u.pixelRatio, a(u, y, f, h) ? y[0] : null);
  }
  return {
    type: e,
    tag: "path",
    nested: !0,
    attr: r,
    bound: i,
    draw: C_t(o),
    pick: s,
    isect: Mte,
    tip: n
  };
}
var P_t = Ote("area", m_t, R_t);
function I_t(e, t) {
  var n = t.clip;
  e.save(), pr(n) ? (e.beginPath(), n(e), e.clip()) : LAe(e, t.group);
}
function LAe(e, t) {
  e.beginPath(), _te(t) ? RN(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip();
}
function zAe(e) {
  const t = bg(e.strokeWidth, 1);
  return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > 0.5 && t < 1.5 ? 0.5 - Math.abs(t - 1) : 0;
}
function j_t(e, t) {
  e("transform", jAe(t));
}
function FAe(e, t) {
  const n = zAe(t);
  e("d", RN(null, t, n, n));
}
function L_t(e, t) {
  e("class", "background"), e("aria-hidden", !0), FAe(e, t);
}
function z_t(e, t) {
  e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? FAe(e, t) : e("d", "");
}
function F_t(e, t, n) {
  const r = t.clip ? Ete(n, t, t) : null;
  e("clip-path", r);
}
function B_t(e, t) {
  if (!t.clip && t.items) {
    const n = t.items, r = n.length;
    for (let i = 0; i < r; ++i)
      e.union(n[i].bounds);
  }
  return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), Mb(e, t), e.translate(t.x || 0, t.y || 0);
}
function Gk(e, t, n, r) {
  const i = zAe(t);
  e.beginPath(), RN(e, t, (n || 0) + i, (r || 0) + i);
}
const U_t = c4(Gk), Y_t = c4(Gk, !1), H_t = c4(Gk, !0);
function V_t(e, t, n, r) {
  Gg(t, (i) => {
    const o = i.x || 0, a = i.y || 0, s = i.strokeForeground, u = i.opacity == null ? 1 : i.opacity;
    (i.stroke || i.fill) && u && (Gk(e, i, o, a), OC(e, i), i.fill && m5(e, i, u) && e.fill(), i.stroke && !s && RC(e, i, u) && e.stroke()), e.save(), e.translate(o, a), i.clip && LAe(e, i), n && n.translate(-o, -a), Gg(i, (l) => {
      (l.marktype === "group" || r == null || r.includes(l.marktype)) && this.draw(e, l, n, r);
    }), n && n.translate(o, a), e.restore(), s && i.stroke && u && (Gk(e, i, o, a), OC(e, i), RC(e, i, u) && e.stroke());
  });
}
function W_t(e, t, n, r, i, o) {
  if (t.bounds && !t.bounds.contains(i, o) || !t.items)
    return null;
  const a = n * e.pixelRatio, s = r * e.pixelRatio;
  return y5(t, (u) => {
    let l, f, h;
    const p = u.bounds;
    if (p && !p.contains(i, o))
      return;
    f = u.x || 0, h = u.y || 0;
    const g = f + (u.width || 0), y = h + (u.height || 0), b = u.clip;
    if (b && (i < f || i > g || o < h || o > y))
      return;
    if (e.save(), e.translate(f, h), f = i - f, h = o - h, b && _te(u) && !H_t(e, u, a, s))
      return e.restore(), null;
    const _ = u.strokeForeground, S = t.interactive !== !1;
    return S && _ && u.stroke && Y_t(e, u, a, s) ? (e.restore(), u) : (l = y5(u, (C) => q_t(C, f, h) ? this.pick(C, n, r, f, h) : null), !l && S && (u.fill || !_ && u.stroke) && U_t(e, u, a, s) && (l = u), e.restore(), l || null);
  });
}
function q_t(e, t, n) {
  return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n);
}
var G_t = {
  type: "group",
  tag: "g",
  nested: !1,
  attr: j_t,
  bound: B_t,
  draw: V_t,
  pick: W_t,
  isect: kAe,
  content: F_t,
  background: L_t,
  foreground: z_t
}, Qk = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  version: "1.1"
};
function Rte(e, t) {
  var n = e.image;
  return (!n || e.url && e.url !== n.url) && (n = {
    complete: !1,
    width: 0,
    height: 0
  }, t.loadImage(e.url).then((r) => {
    e.image = r, e.image.url = e.url;
  })), n;
}
function kte(e, t) {
  return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
}
function $te(e, t) {
  return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
}
function W6(e, t) {
  return e === "center" ? t / 2 : e === "right" ? t : 0;
}
function q6(e, t) {
  return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
}
function Q_t(e, t, n) {
  const r = Rte(t, n), i = kte(t, r), o = $te(t, r), a = (t.x || 0) - W6(t.align, i), s = (t.y || 0) - q6(t.baseline, o), u = !r.src && r.toDataURL ? r.toDataURL() : r.src || "";
  e("href", u, Qk["xmlns:xlink"], "xlink:href"), e("transform", oS(a, s)), e("width", i), e("height", o), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
}
function X_t(e, t) {
  const n = t.image, r = kte(t, n), i = $te(t, n), o = (t.x || 0) - W6(t.align, r), a = (t.y || 0) - q6(t.baseline, i);
  return e.set(o, a, o + r, a + i);
}
function K_t(e, t, n) {
  Gg(t, (r) => {
    if (n && !n.intersects(r.bounds))
      return;
    const i = Rte(r, this);
    let o = kte(r, i), a = $te(r, i);
    if (o === 0 || a === 0)
      return;
    let s = (r.x || 0) - W6(r.align, o), u = (r.y || 0) - q6(r.baseline, a), l, f, h, p;
    r.aspect !== !1 && (f = i.width / i.height, h = r.width / r.height, f === f && h === h && f !== h && (h < f ? (p = o / f, u += (a - p) / 2, a = p) : (p = a * f, s += (o - p) / 2, o = p))), (i.complete || i.toDataURL) && (OC(e, r), e.globalAlpha = (l = r.opacity) != null ? l : 1, e.imageSmoothingEnabled = r.smooth !== !1, e.drawImage(i, s, u, o, a));
  });
}
var Z_t = {
  type: "image",
  tag: "image",
  nested: !1,
  attr: Q_t,
  bound: X_t,
  draw: K_t,
  pick: V6(),
  isect: vp,
  // bounds check is sufficient
  get: Rte,
  xOffset: W6,
  yOffset: q6
}, J_t = Ote("line", y_t, k_t);
function eEt(e, t) {
  var n = t.scaleX || 1, r = t.scaleY || 1;
  (n !== 1 || r !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", A_t(t)), e("d", t.path);
}
function bj(e, t) {
  var n = t.path;
  if (n == null)
    return !0;
  var r = t.x || 0, i = t.y || 0, o = t.scaleX || 1, a = t.scaleY || 1, s = (t.angle || 0) * lw, u = t.pathCache;
  (!u || u.path !== n) && ((t.pathCache = u = AC(n)).path = n), s && e.rotate && e.translate ? (e.translate(r, i), e.rotate(s), qk(e, u, 0, 0, o, a), e.rotate(-s), e.translate(-r, -i)) : qk(e, u, r, i, o, a);
}
function tEt(e, t) {
  return bj(l4(e, t.angle), t) ? e.set(0, 0, 0, 0) : Mb(e, t, !0);
}
var nEt = {
  type: "path",
  tag: "path",
  nested: !1,
  attr: eEt,
  bound: tEt,
  draw: Cte(bj),
  pick: Nte(bj),
  isect: Ste(bj)
};
function rEt(e, t) {
  e("d", RN(null, t));
}
function iEt(e, t) {
  var n, r;
  return Mb(e.set(n = t.x || 0, r = t.y || 0, n + t.width || 0, r + t.height || 0), t);
}
function ige(e, t) {
  e.beginPath(), RN(e, t);
}
var oEt = {
  type: "rect",
  tag: "path",
  nested: !1,
  attr: rEt,
  bound: iEt,
  draw: Cte(ige),
  pick: Nte(ige),
  isect: kAe
};
function aEt(e, t) {
  e("transform", jAe(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
}
function sEt(e, t) {
  var n, r;
  return Mb(e.set(n = t.x || 0, r = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : r), t);
}
function BAe(e, t, n) {
  var r, i, o, a;
  return t.stroke && RC(e, t, n) ? (r = t.x || 0, i = t.y || 0, o = t.x2 != null ? t.x2 : r, a = t.y2 != null ? t.y2 : i, e.beginPath(), e.moveTo(r, i), e.lineTo(o, a), !0) : !1;
}
function uEt(e, t, n) {
  Gg(t, (r) => {
    if (!(n && !n.intersects(r.bounds))) {
      var i = r.opacity == null ? 1 : r.opacity;
      i && BAe(e, r, i) && (OC(e, r), e.stroke());
    }
  });
}
function lEt(e, t, n, r) {
  return e.isPointInStroke ? BAe(e, t, 1) && e.isPointInStroke(n, r) : !1;
}
var cEt = {
  type: "rule",
  tag: "line",
  nested: !1,
  attr: aEt,
  bound: sEt,
  draw: uEt,
  pick: V6(lEt),
  isect: $Ae
}, fEt = Ate("shape", v_t), dEt = Ate("symbol", b_t, Mte);
const oge = MNe();
var $d = {
  height: uv,
  measureWidth: Pte,
  estimateWidth: v5,
  width: v5,
  canvas: UAe
};
UAe(!0);
function UAe(e) {
  $d.width = e && Ux ? Pte : v5;
}
function v5(e, t) {
  return YAe(fw(e, t), uv(e));
}
function YAe(e, t) {
  return ~~(0.8 * e.length * t);
}
function Pte(e, t) {
  return uv(e) <= 0 || !(t = fw(e, t)) ? 0 : HAe(t, G6(e));
}
function HAe(e, t) {
  const n = `(${t}) ${e}`;
  let r = oge.get(n);
  return r === void 0 && (Ux.font = t, r = Ux.measureText(e).width, oge.set(n, r)), r;
}
function uv(e) {
  return e.fontSize != null ? +e.fontSize || 0 : 11;
}
function cw(e) {
  return e.lineHeight != null ? e.lineHeight : uv(e) + 2;
}
function hEt(e) {
  return nt(e) ? e.length > 1 ? e : e[0] : e;
}
function f4(e) {
  return hEt(e.lineBreak && e.text && !nt(e.text) ? e.text.split(e.lineBreak) : e.text);
}
function Ite(e) {
  const t = f4(e);
  return (nt(t) ? t.length - 1 : 0) * cw(e);
}
function fw(e, t) {
  const n = t == null ? "" : (t + "").trim();
  return e.limit > 0 && n.length ? gEt(e, n) : n;
}
function pEt(e) {
  if ($d.width === Pte) {
    const t = G6(e);
    return (n) => HAe(n, t);
  } else if ($d.width === v5) {
    const t = uv(e);
    return (n) => YAe(n, t);
  } else
    return (t) => $d.width(e, t);
}
function gEt(e, t) {
  var n = +e.limit, r = pEt(e);
  if (r(t) < n)
    return t;
  var i = e.ellipsis || "…", o = e.dir === "rtl", a = 0, s = t.length, u;
  if (n -= r(i), o) {
    for (; a < s; )
      u = a + s >>> 1, r(t.slice(u)) > n ? a = u + 1 : s = u;
    return i + t.slice(a);
  } else {
    for (; a < s; )
      u = 1 + (a + s >>> 1), r(t.slice(0, u)) < n ? a = u : s = u - 1;
    return t.slice(0, a) + i;
  }
}
function d4(e, t) {
  var n = e.font;
  return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
}
function G6(e, t) {
  return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + uv(e) + "px " + d4(e, t);
}
function jte(e) {
  var t = e.baseline, n = uv(e);
  return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * cw(e) : t === "line-bottom" ? 0.29 * n - 0.5 * cw(e) : 0);
}
const mEt = {
  left: "start",
  center: "middle",
  right: "end"
}, PR = new xs();
function Q6(e) {
  var t = e.x || 0, n = e.y || 0, r = e.radius || 0, i;
  return r && (i = (e.theta || 0) - IE, t += r * Math.cos(i), n += r * Math.sin(i)), PR.x1 = t, PR.y1 = n, PR;
}
function yEt(e, t) {
  var n = t.dx || 0, r = (t.dy || 0) + jte(t), i = Q6(t), o = i.x1, a = i.y1, s = t.angle || 0, u;
  e("text-anchor", mEt[t.align] || "start"), s ? (u = oS(o, a) + " " + Dte(s), (n || r) && (u += " " + oS(n, r))) : u = oS(o + n, a + r), e("transform", u);
}
function Lte(e, t, n) {
  var r = $d.height(t), i = t.align, o = Q6(t), a = o.x1, s = o.y1, u = t.dx || 0, l = (t.dy || 0) + jte(t) - Math.round(0.8 * r), f = f4(t), h;
  if (nt(f) ? (r += cw(t) * (f.length - 1), h = f.reduce((p, g) => Math.max(p, $d.width(t, g)), 0)) : h = $d.width(t, f), i === "center" ? u -= h / 2 : i === "right" && (u -= h), e.set(u += a, l += s, u + h, l + r), t.angle && !n)
    e.rotate(t.angle * lw, a, s);
  else if (n === 2)
    return e.rotatedPoints(t.angle * lw, a, s);
  return e;
}
function vEt(e, t, n) {
  Gg(t, (r) => {
    var i = r.opacity == null ? 1 : r.opacity, o, a, s, u, l, f, h;
    if (!(n && !n.intersects(r.bounds) || // bounds check
    i === 0 || r.fontSize <= 0 || r.text == null || r.text.length === 0)) {
      if (e.font = G6(r), e.textAlign = r.align || "left", o = Q6(r), a = o.x1, s = o.y1, r.angle && (e.save(), e.translate(a, s), e.rotate(r.angle * lw), a = s = 0), a += r.dx || 0, s += (r.dy || 0) + jte(r), f = f4(r), OC(e, r), nt(f))
        for (l = cw(r), u = 0; u < f.length; ++u)
          h = fw(r, f[u]), r.fill && m5(e, r, i) && e.fillText(h, a, s), r.stroke && RC(e, r, i) && e.strokeText(h, a, s), s += l;
      else
        h = fw(r, f), r.fill && m5(e, r, i) && e.fillText(h, a, s), r.stroke && RC(e, r, i) && e.strokeText(h, a, s);
      r.angle && e.restore();
    }
  });
}
function bEt(e, t, n, r, i, o) {
  if (t.fontSize <= 0)
    return !1;
  if (!t.angle)
    return !0;
  var a = Q6(t), s = a.x1, u = a.y1, l = Lte(PR, t, 1), f = -t.angle * lw, h = Math.cos(f), p = Math.sin(f), g = h * i - p * o + (s - h * s + p * u), y = p * i + h * o + (u - p * s - h * u);
  return l.contains(g, y);
}
function xEt(e, t) {
  const n = Lte(PR, e, 2);
  return bT(t, n[0], n[1], n[2], n[3]) || bT(t, n[0], n[1], n[4], n[5]) || bT(t, n[4], n[5], n[6], n[7]) || bT(t, n[2], n[3], n[6], n[7]);
}
var wEt = {
  type: "text",
  tag: "text",
  nested: !1,
  attr: yEt,
  bound: Lte,
  draw: vEt,
  pick: V6(bEt),
  isect: xEt
}, _Et = Ote("trail", x_t, $_t), Hd = {
  arc: O_t,
  area: P_t,
  group: G_t,
  image: Z_t,
  line: J_t,
  path: nEt,
  rect: oEt,
  rule: cEt,
  shape: fEt,
  symbol: dEt,
  text: wEt,
  trail: _Et
};
function QG(e, t, n) {
  var r = Hd[e.mark.marktype], i = t || r.bound;
  return r.nested && (e = e.mark), i(e.bounds || (e.bounds = new xs()), e, n);
}
var age = {
  mark: null
};
function VAe(e, t, n) {
  var r = Hd[e.marktype], i = r.bound, o = e.items, a = o && o.length, s, u, l, f;
  if (r.nested)
    return a ? l = o[0] : (age.mark = e, l = age), f = QG(l, i, n), t = t && t.union(f) || f, t;
  if (t = t || e.bounds && e.bounds.clear() || new xs(), a)
    for (s = 0, u = o.length; s < u; ++s)
      t.union(QG(o[s], i, n));
  return e.bounds = t;
}
const EEt = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function WAe(e, t) {
  return JSON.stringify(e, EEt, t);
}
function qAe(e) {
  const t = typeof e == "string" ? JSON.parse(e) : e;
  return GAe(t);
}
function GAe(e) {
  var t = e.marktype, n = e.items, r, i, o;
  if (n)
    for (i = 0, o = n.length; i < o; ++i)
      r = t ? "mark" : "group", n[i][r] = e, n[i].zindex && (n[i][r].zdirty = !0), (t || r) === "group" && GAe(n[i]);
  return t && VAe(e), e;
}
class QAe {
  constructor(t) {
    arguments.length ? this.root = qAe(t) : (this.root = sge({
      marktype: "group",
      name: "root",
      role: "frame"
    }), this.root.items = [new Y6(this.root)]);
  }
  toJSON(t) {
    return WAe(this.root, t || 0);
  }
  mark(t, n, r) {
    n = n || this.root.items[0];
    const i = sge(t, n);
    return n.items[r] = i, i.zindex && (i.group.zdirty = !0), i;
  }
}
function sge(e, t) {
  const n = {
    bounds: new xs(),
    clip: !!e.clip,
    group: t,
    interactive: e.interactive !== !1,
    items: [],
    marktype: e.marktype,
    name: e.name || void 0,
    role: e.role || void 0,
    zindex: e.zindex || 0
  };
  return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n;
}
function Cx(e, t, n) {
  return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null;
}
function zte(e, t) {
  t = t.toLowerCase();
  for (var n = e.childNodes, r = 0, i = n.length; r < i; ++r)
    if (n[r].tagName.toLowerCase() === t)
      return n[r];
}
function Us(e, t, n, r) {
  var i = e.childNodes[t], o;
  return (!i || i.tagName.toLowerCase() !== n.toLowerCase()) && (o = i || null, i = Cx(e.ownerDocument, n, r), e.insertBefore(i, o)), i;
}
function Kh(e, t) {
  for (var n = e.childNodes, r = n.length; r > t; )
    e.removeChild(n[--r]);
  return e;
}
function XAe(e) {
  return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "");
}
function X6(e, t) {
  const n = t.getBoundingClientRect();
  return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)];
}
function SEt(e, t, n, r) {
  var i = e && e.mark, o, a;
  if (i && (o = Hd[i.marktype]).tip) {
    for (a = X6(t, n), a[0] -= r[0], a[1] -= r[1]; e = e.mark.group; )
      a[0] -= e.x || 0, a[1] -= e.y || 0;
    e = o.tip(i.items, a);
  }
  return e;
}
let Fte = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(t, n) {
    this._active = null, this._handlers = {}, this._loader = t || M6(), this._tooltip = n || MEt;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(t, n, r) {
    return this._el = t, this._obj = r || null, this.origin(n);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(t) {
    return arguments.length ? (this._origin = t || [0, 0], this) : this._origin.slice();
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(t) {
    return arguments.length ? (this._scene = t, this) : this._scene;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(t, n, r) {
    for (let i = t ? t.length : 0; --i >= 0; )
      if (t[i].type === n && (!r || t[i].handler === r))
        return i;
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(t) {
    const n = this._handlers, r = [];
    if (t)
      r.push(...n[this.eventName(t)]);
    else
      for (const i in n)
        r.push(...n[i]);
    return r;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(t) {
    const n = t.indexOf(".");
    return n < 0 ? t : t.slice(0, n);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(t, n, r) {
    this._loader.sanitize(r, {
      context: "href"
    }).then((i) => {
      const o = new MouseEvent(t.type, t), a = Cx(null, "a");
      for (const s in i)
        a.setAttribute(s, i[s]);
      a.dispatchEvent(o);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(t, n, r) {
    if (n && n.tooltip != null) {
      n = SEt(n, t, this.canvas(), this._origin);
      const i = r && n && n.tooltip || null;
      this._tooltip.call(this._obj, this, t, n, i);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(t) {
    const n = this.canvas();
    if (!n)
      return;
    const r = n.getBoundingClientRect(), i = this._origin, o = t.bounds, a = o.width(), s = o.height();
    let u = o.x1 + i[0] + r.left, l = o.y1 + i[1] + r.top;
    for (; t.mark && (t = t.mark.group); )
      u += t.x || 0, l += t.y || 0;
    return {
      x: u,
      y: l,
      width: a,
      height: s,
      left: u,
      top: l,
      right: u + a,
      bottom: l + s
    };
  }
};
function MEt(e, t, n, r) {
  e.element().setAttribute("title", r || "");
}
class h4 {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(t) {
    this._el = null, this._bgcolor = null, this._loader = new RAe(t);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(t, n, r, i, o) {
    return this._el = t, this.resize(n, r, i, o);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(t) {
    return arguments.length === 0 ? this._bgcolor : (this._bgcolor = t, this);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(t, n, r, i) {
    return this._width = t, this._height = n, this._origin = r || [0, 0], this._scale = i || 1, this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(t, n) {
    const r = this;
    return r._call = function() {
      r._render(t, n);
    }, r._call(), r._call = null, r;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(t, n) {
    const r = this.render(t, n);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(t, n) {
    var r = this, i = r._loader[t](n);
    if (!r._ready) {
      const o = r._call;
      r._ready = r._loader.ready().then((a) => {
        a && o(), r._ready = null;
      });
    }
    return i;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(t) {
    return this._load("sanitizeURL", t);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(t) {
    return this._load("loadImage", t);
  }
}
const TEt = "keydown", CEt = "keypress", NEt = "keyup", KAe = "dragenter", xj = "dragleave", ZAe = "dragover", XG = "pointerdown", DEt = "pointerup", b5 = "pointermove", wj = "pointerout", JAe = "pointerover", KG = "mousedown", AEt = "mouseup", eOe = "mousemove", x5 = "mouseout", tOe = "mouseover", w5 = "click", OEt = "dblclick", REt = "wheel", nOe = "mousewheel", _5 = "touchstart", E5 = "touchmove", S5 = "touchend", kEt = [TEt, CEt, NEt, KAe, xj, ZAe, XG, DEt, b5, wj, JAe, KG, AEt, eOe, x5, tOe, w5, OEt, REt, nOe, _5, E5, S5], ZG = b5, IR = x5, JG = w5;
class p4 extends Fte {
  constructor(t, n) {
    super(t, n), this._down = null, this._touch = null, this._first = !0, this._events = {}, this.events = kEt, this.pointermove = lge([b5, eOe], [JAe, tOe], [wj, x5]), this.dragover = lge([ZAe], [KAe], [xj]), this.pointerout = cge([wj, x5]), this.dragleave = cge([xj]);
  }
  initialize(t, n, r) {
    return this._canvas = t && zte(t, "canvas"), [w5, KG, XG, b5, wj, xj].forEach((i) => uge(this, i)), super.initialize(t, n, r);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(t) {
    this.fire(nOe, t);
  }
  pointerdown(t) {
    this._down = this._active, this.fire(XG, t);
  }
  mousedown(t) {
    this._down = this._active, this.fire(KG, t);
  }
  click(t) {
    this._down === this._active && (this.fire(w5, t), this._down = null);
  }
  touchstart(t) {
    this._touch = this.pickEvent(t.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(_5, t, !0);
  }
  touchmove(t) {
    this.fire(E5, t, !0);
  }
  touchend(t) {
    this.fire(S5, t, !0), this._touch = null;
  }
  // fire an event
  fire(t, n, r) {
    const i = r ? this._touch : this._active, o = this._handlers[t];
    if (n.vegaType = t, t === JG && i && i.href ? this.handleHref(n, i, i.href) : (t === ZG || t === IR) && this.handleTooltip(n, i, t !== IR), o)
      for (let a = 0, s = o.length; a < s; ++a)
        o[a].handler.call(this._obj, n, i);
  }
  // add an event handler
  on(t, n) {
    const r = this.eventName(t), i = this._handlers;
    return this._handlerIndex(i[r], t, n) < 0 && (uge(this, t), (i[r] || (i[r] = [])).push({
      type: t,
      handler: n
    })), this;
  }
  // remove an event handler
  off(t, n) {
    const r = this.eventName(t), i = this._handlers[r], o = this._handlerIndex(i, t, n);
    return o >= 0 && i.splice(o, 1), this;
  }
  pickEvent(t) {
    const n = X6(t, this._canvas), r = this._origin;
    return this.pick(this._scene, n[0], n[1], n[0] - r[0], n[1] - r[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(t, n, r, i, o) {
    const a = this.context();
    return Hd[t.marktype].pick.call(this, a, t, n, r, i, o);
  }
}
const $Et = (e) => e === _5 || e === E5 || e === S5 ? [_5, E5, S5] : [e];
function uge(e, t) {
  $Et(t).forEach((n) => PEt(e, n));
}
function PEt(e, t) {
  const n = e.canvas();
  n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (r) => e[t](r) : (r) => e.fire(t, r)));
}
function GO(e, t, n) {
  t.forEach((r) => e.fire(r, n));
}
function lge(e, t, n) {
  return function(r) {
    const i = this._active, o = this.pickEvent(r);
    o === i ? GO(this, e, r) : ((!i || !i.exit) && GO(this, n, r), this._active = o, GO(this, t, r), GO(this, e, r));
  };
}
function cge(e) {
  return function(t) {
    GO(this, e, t), this._active = null;
  };
}
function IEt() {
  return typeof window < "u" && window.devicePixelRatio || 1;
}
function jEt(e, t, n, r, i, o) {
  const a = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null, s = e.getContext("2d"), u = a ? IEt() : i;
  e.width = t * u, e.height = n * u;
  for (const l in o)
    s[l] = o[l];
  return a && u !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), s.pixelRatio = u, s.setTransform(u, 0, 0, u, u * r[0], u * r[1]), e;
}
class M5 extends h4 {
  constructor(t) {
    super(t), this._options = {}, this._redraw = !1, this._dirty = new xs(), this._tempb = new xs();
  }
  initialize(t, n, r, i, o, a) {
    return this._options = a || {}, this._canvas = this._options.externalContext ? null : Bx(1, 1, this._options.type), t && this._canvas && (Kh(t, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), super.initialize(t, n, r, i, o);
  }
  resize(t, n, r, i) {
    if (super.resize(t, n, r, i), this._canvas)
      jEt(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    else {
      const o = this._options.externalContext;
      o || tt("CanvasRenderer is missing a valid canvas or context"), o.scale(this._scale, this._scale), o.translate(this._origin[0], this._origin[1]);
    }
    return this._redraw = !0, this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(t) {
    const n = this._tempb.clear().union(t.bounds);
    let r = t.mark.group;
    for (; r; )
      n.translate(r.x || 0, r.y || 0), r = r.mark.group;
    this._dirty.union(n);
  }
  _render(t, n) {
    const r = this.context(), i = this._origin, o = this._width, a = this._height, s = this._dirty, u = LEt(i, o, a);
    r.save();
    const l = this._redraw || s.empty() ? (this._redraw = !1, u.expand(1)) : zEt(r, u.intersect(s), i);
    return this.clear(-i[0], -i[1], o, a), this.draw(r, t, l, n), r.restore(), s.clear(), this;
  }
  draw(t, n, r, i) {
    if (n.marktype !== "group" && i != null && !i.includes(n.marktype))
      return;
    const o = Hd[n.marktype];
    n.clip && I_t(t, n), o.draw.call(this, t, n, r, i), n.clip && t.restore();
  }
  clear(t, n, r, i) {
    const o = this._options, a = this.context();
    o.type !== "pdf" && !o.externalContext && a.clearRect(t, n, r, i), this._bgcolor != null && (a.fillStyle = this._bgcolor, a.fillRect(t, n, r, i));
  }
}
const LEt = (e, t, n) => new xs().set(0, 0, t, n).translate(-e[0], -e[1]);
function zEt(e, t, n) {
  return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
}
class rOe extends Fte {
  constructor(t, n) {
    super(t, n);
    const r = this;
    r._hrefHandler = tV(r, (i, o) => {
      o && o.href && r.handleHref(i, o, o.href);
    }), r._tooltipHandler = tV(r, (i, o) => {
      r.handleTooltip(i, o, i.type !== IR);
    });
  }
  initialize(t, n, r) {
    let i = this._svg;
    return i && (i.removeEventListener(JG, this._hrefHandler), i.removeEventListener(ZG, this._tooltipHandler), i.removeEventListener(IR, this._tooltipHandler)), this._svg = i = t && zte(t, "svg"), i && (i.addEventListener(JG, this._hrefHandler), i.addEventListener(ZG, this._tooltipHandler), i.addEventListener(IR, this._tooltipHandler)), super.initialize(t, n, r);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(t, n) {
    const r = this.eventName(t), i = this._handlers;
    if (this._handlerIndex(i[r], t, n) < 0) {
      const a = {
        type: t,
        handler: n,
        listener: tV(this, n)
      };
      (i[r] || (i[r] = [])).push(a), this._svg && this._svg.addEventListener(r, a.listener);
    }
    return this;
  }
  // remove an event handler
  off(t, n) {
    const r = this.eventName(t), i = this._handlers[r], o = this._handlerIndex(i, t, n);
    return o >= 0 && (this._svg && this._svg.removeEventListener(r, i[o].listener), i.splice(o, 1)), this;
  }
}
const tV = (e, t) => (n) => {
  let r = n.target.__data__;
  r = Array.isArray(r) ? r[0] : r, n.vegaType = n.type, t.call(e._obj, n, r);
}, iOe = "aria-hidden", Bte = "aria-label", Ute = "role", Yte = "aria-roledescription", oOe = "graphics-object", Hte = "graphics-symbol", aOe = (e, t, n) => ({
  [Ute]: e,
  [Yte]: t,
  [Bte]: n || void 0
}), FEt = Wg(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]), fge = {
  axis: {
    desc: "axis",
    caption: YEt
  },
  legend: {
    desc: "legend",
    caption: HEt
  },
  "title-text": {
    desc: "title",
    caption: (e) => `Title text '${hge(e)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (e) => `Subtitle text '${hge(e)}'`
  }
}, dge = {
  ariaRole: Ute,
  ariaRoleDescription: Yte,
  description: Bte
};
function sOe(e, t) {
  const n = t.aria === !1;
  if (e(iOe, n || void 0), n || t.description == null)
    for (const r in dge)
      e(dge[r], void 0);
  else {
    const r = t.mark.marktype;
    e(Bte, t.description), e(Ute, t.ariaRole || (r === "group" ? oOe : Hte)), e(Yte, t.ariaRoleDescription || `${r} mark`);
  }
}
function uOe(e) {
  return e.aria === !1 ? {
    [iOe]: !0
  } : FEt[e.role] ? null : fge[e.role] ? UEt(e, fge[e.role]) : BEt(e);
}
function BEt(e) {
  const t = e.marktype, n = t === "group" || t === "text" || e.items.some((r) => r.description != null && r.aria !== !1);
  return aOe(n ? oOe : Hte, `${t} mark container`, e.description);
}
function UEt(e, t) {
  try {
    const n = e.items[0], r = t.caption || (() => "");
    return aOe(t.role || Hte, t.desc, n.description || r(n));
  } catch {
    return null;
  }
}
function hge(e) {
  return Rt(e.text).join(" ");
}
function YEt(e) {
  const t = e.datum, n = e.orient, r = t.title ? lOe(e) : null, i = e.context, o = i.scales[t.scale].value, a = i.dataflow.locale(), s = o.type;
  return `${n === "left" || n === "right" ? "Y" : "X"}-axis` + (r ? ` titled '${r}'` : "") + ` for a ${DC(s) ? "discrete" : s} scale with ${_Ae(a, o, e)}`;
}
function HEt(e) {
  const t = e.datum, n = t.title ? lOe(e) : null, r = `${t.type || ""} legend`.trim(), i = t.scales, o = Object.keys(i), a = e.context, s = a.scales[i[o[0]]].value, u = a.dataflow.locale();
  return WEt(r) + (n ? ` titled '${n}'` : "") + ` for ${VEt(o)} with ${_Ae(u, s, e)}`;
}
function lOe(e) {
  try {
    return Rt(ri(e.items).items[0].text).join(" ");
  } catch {
    return null;
  }
}
function VEt(e) {
  return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + ri(e);
}
function WEt(e) {
  return e.length ? e[0].toUpperCase() + e.slice(1) : e;
}
const cOe = (e) => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), qEt = (e) => cOe(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function Vte() {
  let e = "", t = "", n = "";
  const r = [], i = () => t = n = "", o = (u) => {
    t && (e += `${t}>${n}`, i()), r.push(u);
  }, a = (u, l) => (l != null && (t += ` ${u}="${qEt(l)}"`), s), s = {
    open(u) {
      o(u), t = "<" + u;
      for (var l = arguments.length, f = new Array(l > 1 ? l - 1 : 0), h = 1; h < l; h++)
        f[h - 1] = arguments[h];
      for (const p of f)
        for (const g in p)
          a(g, p[g]);
      return s;
    },
    close() {
      const u = r.pop();
      return t ? e += t + (n ? `>${n}</${u}>` : "/>") : e += `</${u}>`, i(), s;
    },
    attr: a,
    text: (u) => (n += cOe(u), s),
    toString: () => e
  };
  return s;
}
const fOe = (e) => dOe(Vte(), e) + "";
function dOe(e, t) {
  if (e.open(t.tagName), t.hasAttributes()) {
    const n = t.attributes, r = n.length;
    for (let i = 0; i < r; ++i)
      e.attr(n[i].name, n[i].value);
  }
  if (t.hasChildNodes()) {
    const n = t.childNodes;
    for (const r of n)
      r.nodeType === 3 ? e.text(r.nodeValue) : dOe(e, r);
  }
  return e.close();
}
const T5 = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
}, C5 = {
  blend: "mix-blend-mode"
}, hOe = {
  fill: "none",
  "stroke-miterlimit": 10
}, sO = 0, pge = "http://www.w3.org/2000/xmlns/", Fs = Qk.xmlns;
class Wte extends h4 {
  constructor(t) {
    super(t), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(t, n, r, i, o) {
    return this._defs = {}, this._clearDefs(), t && (this._svg = Us(t, 0, "svg", Fs), this._svg.setAttributeNS(pge, "xmlns", Fs), this._svg.setAttributeNS(pge, "xmlns:xlink", Qk["xmlns:xlink"]), this._svg.setAttribute("version", Qk.version), this._svg.setAttribute("class", "marks"), Kh(t, 1), this._root = Us(this._svg, sO, "g", Fs), Nx(this._root, hOe), Kh(this._svg, sO + 1)), this.background(this._bgcolor), super.initialize(t, n, r, i, o);
  }
  /**
   * Get / set the background color.
   */
  background(t) {
    return arguments.length && this._svg && this._svg.style.setProperty("background-color", t), super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(t, n, r, i) {
    return super.resize(t, n, r, i), this._svg && (Nx(this._svg, {
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const t = this._svg, n = this._bgcolor;
    if (!t)
      return null;
    let r;
    n && (t.removeAttribute("style"), r = Us(t, sO, "rect", Fs), Nx(r, {
      width: this._width,
      height: this._height,
      fill: n
    }));
    const i = fOe(t);
    return n && (t.removeChild(r), this._svg.style.setProperty("background-color", n)), i;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(t, n) {
    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t, void 0, n), Kh(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(t) {
    t.dirty !== this._dirtyID && (t.dirty = this._dirtyID, this._dirty.push(t));
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(t) {
    return this._dirtyAll || !t._svg || !t._svg.ownerSVGElement || t.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = !0;
    const t = this._dirty;
    if (!t.length || !this._dirtyID)
      return !0;
    const n = ++this._dirtyID;
    let r, i, o, a, s, u, l;
    for (s = 0, u = t.length; s < u; ++s)
      if (r = t[s], i = r.mark, i.marktype !== o && (o = i.marktype, a = Hd[o]), i.zdirty && i.dirty !== n && (this._dirtyAll = !1, gge(r, n), i.items.forEach((f) => {
        f.dirty = n;
      })), !i.zdirty) {
        if (r.exit) {
          a.nested && i.items.length ? (l = i.items[0], l._svg && this._update(a, l._svg, l)) : r._svg && (l = r._svg.parentNode, l && l.removeChild(r._svg)), r._svg = null;
          continue;
        }
        r = a.nested ? i.items[0] : r, r._update !== n && (!r._svg || !r._svg.ownerSVGElement ? (this._dirtyAll = !1, gge(r, n)) : this._update(a, r._svg, r), r._update = n);
      }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(t, n, r, i) {
    if (!this.isDirty(n))
      return n._svg;
    const o = this._svg, a = n.marktype, s = Hd[a], u = n.interactive === !1 ? "none" : null, l = s.tag === "g", f = mge(n, t, r, "g", o);
    if (a !== "group" && i != null && !i.includes(a))
      return Kh(f, 0), n._svg;
    f.setAttribute("class", XAe(n));
    const h = uOe(n);
    for (const b in h)
      bc(f, b, h[b]);
    l || bc(f, "pointer-events", u), bc(f, "clip-path", n.clip ? Ete(this, n, n.group) : null);
    let p = null, g = 0;
    const y = (b) => {
      const _ = this.isDirty(b), S = mge(b, f, p, s.tag, o);
      _ && (this._update(s, S, b), l && XEt(this, S, b, i)), p = S, ++g;
    };
    return s.nested ? n.items.length && y(n.items[0]) : Gg(n, y), Kh(f, g), f;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(t, n, r) {
    G0 = n, Il = n.__values__, sOe(jR, r), t.attr(jR, r, this);
    const i = ZEt[t.type];
    i && i.call(this, t, n, r), G0 && this.style(G0, r);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(t, n) {
    if (n != null) {
      for (const r in T5) {
        let i = r === "font" ? d4(n) : n[r];
        if (i === Il[r])
          continue;
        const o = T5[r];
        i == null ? t.removeAttribute(o) : (xte(i) && (i = SAe(i, this._defs.gradient, pOe())), t.setAttribute(o, i + "")), Il[r] = i;
      }
      for (const r in C5)
        _j(t, C5[r], n[r]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const t = this._svg, n = this._defs;
    let r = n.el, i = 0;
    for (const o in n.gradient)
      r || (n.el = r = Us(t, sO + 1, "defs", Fs)), i = GEt(r, n.gradient[o], i);
    for (const o in n.clipping)
      r || (n.el = r = Us(t, sO + 1, "defs", Fs)), i = QEt(r, n.clipping[o], i);
    r && (i === 0 ? (t.removeChild(r), n.el = null) : Kh(r, i));
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const t = this._defs;
    t.gradient = {}, t.clipping = {};
  }
}
function gge(e, t) {
  for (; e && e.dirty !== t; e = e.mark.group)
    if (e.dirty = t, e.mark && e.mark.dirty !== t)
      e.mark.dirty = t;
    else
      return;
}
function GEt(e, t, n) {
  let r, i, o;
  if (t.gradient === "radial") {
    let a = Us(e, n++, "pattern", Fs);
    Nx(a, {
      id: g5 + t.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    }), a = Us(a, 0, "rect", Fs), Nx(a, {
      width: 1,
      height: 1,
      fill: `url(${pOe()}#${t.id})`
    }), e = Us(e, n++, "radialGradient", Fs), Nx(e, {
      id: t.id,
      fx: t.x1,
      fy: t.y1,
      fr: t.r1,
      cx: t.x2,
      cy: t.y2,
      r: t.r2
    });
  } else
    e = Us(e, n++, "linearGradient", Fs), Nx(e, {
      id: t.id,
      x1: t.x1,
      x2: t.x2,
      y1: t.y1,
      y2: t.y2
    });
  for (r = 0, i = t.stops.length; r < i; ++r)
    o = Us(e, r, "stop", Fs), o.setAttribute("offset", t.stops[r].offset), o.setAttribute("stop-color", t.stops[r].color);
  return Kh(e, r), n;
}
function QEt(e, t, n) {
  let r;
  return e = Us(e, n, "clipPath", Fs), e.setAttribute("id", t.id), t.path ? (r = Us(e, 0, "path", Fs), r.setAttribute("d", t.path)) : (r = Us(e, 0, "rect", Fs), Nx(r, {
    x: 0,
    y: 0,
    width: t.width,
    height: t.height
  })), Kh(e, 1), n + 1;
}
function XEt(e, t, n, r) {
  t = t.lastChild.previousSibling;
  let i, o = 0;
  Gg(n, (a) => {
    i = e.mark(t, a, i, r), ++o;
  }), Kh(t, 1 + o);
}
function mge(e, t, n, r, i) {
  let o = e._svg, a;
  if (!o && (a = t.ownerDocument, o = Cx(a, r, Fs), e._svg = o, e.mark && (o.__data__ = e, o.__values__ = {
    fill: "default"
  }, r === "g"))) {
    const s = Cx(a, "path", Fs);
    o.appendChild(s), s.__data__ = e;
    const u = Cx(a, "g", Fs);
    o.appendChild(u), u.__data__ = e;
    const l = Cx(a, "path", Fs);
    o.appendChild(l), l.__data__ = e, l.__values__ = {
      fill: "default"
    };
  }
  return (o.ownerSVGElement !== i || KEt(o, n)) && t.insertBefore(o, n ? n.nextSibling : t.firstChild), o;
}
function KEt(e, t) {
  return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
}
let G0 = null, Il = null;
const ZEt = {
  group(e, t, n) {
    const r = G0 = t.childNodes[2];
    Il = r.__values__, e.foreground(jR, n, this), Il = t.__values__, G0 = t.childNodes[1], e.content(jR, n, this);
    const i = G0 = t.childNodes[0];
    e.background(jR, n, this);
    const o = n.mark.interactive === !1 ? "none" : null;
    if (o !== Il.events && (bc(r, "pointer-events", o), bc(i, "pointer-events", o), Il.events = o), n.strokeForeground && n.stroke) {
      const a = n.fill;
      bc(r, "display", null), this.style(i, n), bc(i, "stroke", null), a && (n.fill = null), Il = r.__values__, this.style(r, n), a && (n.fill = a), G0 = null;
    } else
      bc(r, "display", "none");
  },
  image(e, t, n) {
    n.smooth === !1 ? (_j(t, "image-rendering", "optimizeSpeed"), _j(t, "image-rendering", "pixelated")) : _j(t, "image-rendering", null);
  },
  text(e, t, n) {
    const r = f4(n);
    let i, o, a, s;
    nt(r) ? (o = r.map((u) => fw(n, u)), i = o.join(`
`), i !== Il.text && (Kh(t, 0), a = t.ownerDocument, s = cw(n), o.forEach((u, l) => {
      const f = Cx(a, "tspan", Fs);
      f.__data__ = n, f.textContent = u, l && (f.setAttribute("x", 0), f.setAttribute("dy", s)), t.appendChild(f);
    }), Il.text = i)) : (o = fw(n, r), o !== Il.text && (t.textContent = o, Il.text = o)), bc(t, "font-family", d4(n)), bc(t, "font-size", uv(n) + "px"), bc(t, "font-style", n.fontStyle), bc(t, "font-variant", n.fontVariant), bc(t, "font-weight", n.fontWeight);
  }
};
function jR(e, t, n) {
  t !== Il[e] && (n ? JEt(G0, e, t, n) : bc(G0, e, t), Il[e] = t);
}
function _j(e, t, n) {
  n !== Il[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), Il[t] = n);
}
function Nx(e, t) {
  for (const n in t)
    bc(e, n, t[n]);
}
function bc(e, t, n) {
  n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
}
function JEt(e, t, n, r) {
  n != null ? e.setAttributeNS(r, t, n) : e.removeAttributeNS(r, t);
}
function pOe() {
  let e;
  return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href;
}
class gOe extends h4 {
  constructor(t) {
    super(t), this._text = null, this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(t) {
    const n = Vte();
    n.open("svg", hr({}, Qk, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const r = this._bgcolor;
    return r && r !== "transparent" && r !== "none" && n.open("rect", {
      width: this._width,
      height: this._height,
      fill: r
    }).close(), n.open("g", hOe, {
      transform: "translate(" + this._origin + ")"
    }), this.mark(n, t), n.close(), this.defs(n), this._text = n.close() + "", this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(t, n) {
    const r = Hd[n.marktype], i = r.tag, o = [sOe, r.attr];
    t.open("g", {
      class: XAe(n),
      "clip-path": n.clip ? Ete(this, n, n.group) : null
    }, uOe(n), {
      "pointer-events": i !== "g" && n.interactive === !1 ? "none" : null
    });
    const a = (s) => {
      const u = this.href(s);
      if (u && t.open("a", u), t.open(i, this.attr(n, s, o, i !== "g" ? i : null)), i === "text") {
        const l = f4(s);
        if (nt(l)) {
          const f = {
            x: 0,
            dy: cw(s)
          };
          for (let h = 0; h < l.length; ++h)
            t.open("tspan", h ? f : null).text(fw(s, l[h])).close();
        } else
          t.text(fw(s, l));
      } else if (i === "g") {
        const l = s.strokeForeground, f = s.fill, h = s.stroke;
        l && h && (s.stroke = null), t.open("path", this.attr(n, s, r.background, "bgrect")).close(), t.open("g", this.attr(n, s, r.content)), Gg(s, (p) => this.mark(t, p)), t.close(), l && h ? (f && (s.fill = null), s.stroke = h, t.open("path", this.attr(n, s, r.foreground, "bgrect")).close(), f && (s.fill = f)) : t.open("path", this.attr(n, s, r.foreground, "bgfore")).close();
      }
      t.close(), u && t.close();
    };
    return r.nested ? n.items && n.items.length && a(n.items[0]) : Gg(n, a), t.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(t) {
    const n = t.href;
    let r;
    if (n) {
      if (r = this._hrefs && this._hrefs[n])
        return r;
      this.sanitizeURL(n).then((i) => {
        i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[n] = i;
      });
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(t, n, r, i) {
    const o = {}, a = (s, u, l, f) => {
      o[f || s] = u;
    };
    return Array.isArray(r) ? r.forEach((s) => s(a, n, this)) : r(a, n, this), i && eSt(o, n, t, i, this._defs), o;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(t) {
    const n = this._defs.gradient, r = this._defs.clipping;
    if (Object.keys(n).length + Object.keys(r).length !== 0) {
      t.open("defs");
      for (const o in n) {
        const a = n[o], s = a.stops;
        a.gradient === "radial" ? (t.open("pattern", {
          id: g5 + o,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        }), t.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + o + ")"
        }).close(), t.close(), t.open("radialGradient", {
          id: o,
          fx: a.x1,
          fy: a.y1,
          fr: a.r1,
          cx: a.x2,
          cy: a.y2,
          r: a.r2
        })) : t.open("linearGradient", {
          id: o,
          x1: a.x1,
          x2: a.x2,
          y1: a.y1,
          y2: a.y2
        });
        for (let u = 0; u < s.length; ++u)
          t.open("stop", {
            offset: s[u].offset,
            "stop-color": s[u].color
          }).close();
        t.close();
      }
      for (const o in r) {
        const a = r[o];
        t.open("clipPath", {
          id: o
        }), a.path ? t.open("path", {
          d: a.path
        }).close() : t.open("rect", {
          x: 0,
          y: 0,
          width: a.width,
          height: a.height
        }).close(), t.close();
      }
      t.close();
    }
  }
}
function eSt(e, t, n, r, i) {
  let o;
  if (t == null || (r === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), r === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
    return e;
  r === "image" && t.smooth === !1 && (o = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), r === "text" && (e["font-family"] = d4(t), e["font-size"] = uv(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
  for (const a in T5) {
    let s = t[a];
    const u = T5[a];
    s === "transparent" && (u === "fill" || u === "stroke") || s != null && (xte(s) && (s = SAe(s, i.gradient, "")), e[u] = s);
  }
  for (const a in C5) {
    const s = t[a];
    s != null && (o = o || [], o.push(`${C5[a]}: ${s};`));
  }
  return o && (e.style = o.join(" ")), e;
}
const Eg = {
  svgMarkTypes: ["text"],
  svgOnTop: !0,
  debug: !1
};
function tSt(e) {
  Eg.svgMarkTypes = e.svgMarkTypes ?? ["text"], Eg.svgOnTop = e.svgOnTop ?? !0, Eg.debug = e.debug ?? !1;
}
class eQ extends h4 {
  constructor(t) {
    super(t), this._svgRenderer = new Wte(t), this._canvasRenderer = new M5(t);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(t, n, r, i, o) {
    this._root_el = Us(t, 0, "div");
    const a = Us(this._root_el, 0, "div"), s = Us(this._root_el, 1, "div");
    return this._root_el.style.position = "relative", Eg.debug || (a.style.height = "100%", s.style.position = "absolute", s.style.top = "0", s.style.left = "0", s.style.height = "100%", s.style.width = "100%"), this._svgEl = Eg.svgOnTop ? s : a, this._canvasEl = Eg.svgOnTop ? a : s, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, n, r, i, o), this._svgRenderer.initialize(this._svgEl, n, r, i, o), super.initialize(t, n, r, i, o);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(t) {
    return Eg.svgMarkTypes.includes(t.mark.marktype) ? this._svgRenderer.dirty(t) : this._canvasRenderer.dirty(t), this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(t, n) {
    const i = (n ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"]).filter((o) => !Eg.svgMarkTypes.includes(o));
    this._svgRenderer.render(t, Eg.svgMarkTypes), this._canvasRenderer.render(t, i);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(t, n, r, i) {
    return super.resize(t, n, r, i), this._svgRenderer.resize(t, n, r, i), this._canvasRenderer.resize(t, n, r, i), this;
  }
  background(t) {
    return Eg.svgOnTop ? this._canvasRenderer.background(t) : this._svgRenderer.background(t), this;
  }
}
class mOe extends p4 {
  constructor(t, n) {
    super(t, n);
  }
  initialize(t, n, r) {
    const i = Us(Us(t, 0, "div"), Eg.svgOnTop ? 0 : 1, "div");
    return super.initialize(i, n, r);
  }
}
const yOe = "canvas", vOe = "hybrid", bOe = "png", xOe = "svg", wOe = "none", Dx = {
  Canvas: yOe,
  PNG: bOe,
  SVG: xOe,
  Hybrid: vOe,
  None: wOe
}, kS = {};
kS[yOe] = kS[bOe] = {
  renderer: M5,
  headless: M5,
  handler: p4
};
kS[xOe] = {
  renderer: Wte,
  headless: gOe,
  handler: rOe
};
kS[vOe] = {
  renderer: eQ,
  headless: eQ,
  handler: mOe
};
kS[wOe] = {};
function K6(e, t) {
  return e = String(e || "").toLowerCase(), arguments.length > 1 ? (kS[e] = t, this) : kS[e];
}
function _Oe(e, t, n) {
  const r = [], i = new xs().union(t), o = e.marktype;
  return o ? EOe(e, i, n, r) : o === "group" ? SOe(e, i, n, r) : tt("Intersect scene must be mark node or group item.");
}
function EOe(e, t, n, r) {
  if (nSt(e, t, n)) {
    const i = e.items, o = e.marktype, a = i.length;
    let s = 0;
    if (o === "group")
      for (; s < a; ++s)
        SOe(i[s], t, n, r);
    else
      for (const u = Hd[o].isect; s < a; ++s) {
        const l = i[s];
        MOe(l, t, u) && r.push(l);
      }
  }
  return r;
}
function nSt(e, t, n) {
  return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)));
}
function SOe(e, t, n, r) {
  n && n(e.mark) && MOe(e, t, Hd.group.isect) && r.push(e);
  const i = e.items, o = i && i.length;
  if (o) {
    const a = e.x || 0, s = e.y || 0;
    t.translate(-a, -s);
    for (let u = 0; u < o; ++u)
      EOe(i[u], t, n, r);
    t.translate(a, s);
  }
  return r;
}
function MOe(e, t, n) {
  const r = e.bounds;
  return t.encloses(r) || t.intersects(r) && n(e, t);
}
const nV = new xs();
function TOe(e) {
  const t = e.clip;
  if (pr(t))
    t(l4(nV.clear()));
  else if (t)
    nV.set(0, 0, e.group.width, e.group.height);
  else
    return;
  e.bounds.intersect(nV);
}
const rSt = 1e-9;
function qte(e, t, n) {
  return e === t ? !0 : n === "path" ? COe(e, t) : e instanceof Date && t instanceof Date ? +e == +t : pi(e) && pi(t) ? Math.abs(e - t) <= rSt : !e || !t || !Pt(e) && !Pt(t) ? e == t : iSt(e, t);
}
function COe(e, t) {
  return qte(AC(e), AC(t));
}
function iSt(e, t) {
  var n = Object.keys(e), r = Object.keys(t), i, o;
  if (n.length !== r.length)
    return !1;
  for (n.sort(), r.sort(), o = n.length - 1; o >= 0; o--)
    if (n[o] != r[o])
      return !1;
  for (o = n.length - 1; o >= 0; o--)
    if (i = n[o], !qte(e[i], t[i], i))
      return !1;
  return typeof e == typeof t;
}
function oSt() {
  OAe(), Dwt();
}
const kC = "top", Ag = "left", $g = "right", dw = "bottom", aSt = "top-left", sSt = "top-right", uSt = "bottom-left", lSt = "bottom-right", Gte = "start", tQ = "middle", xc = "end", cSt = "x", fSt = "y", Z6 = "group", Qte = "axis", Xte = "title", dSt = "frame", hSt = "scope", Kte = "legend", NOe = "row-header", DOe = "row-footer", AOe = "row-title", OOe = "column-header", ROe = "column-footer", kOe = "column-title", pSt = "padding", gSt = "symbol", $Oe = "fit", POe = "fit-x", IOe = "fit-y", mSt = "pad", Zte = "none", x3 = "all", nQ = "each", Jte = "flush", Ax = "column", Ox = "row";
function jOe(e) {
  Ge.call(this, null, e);
}
Tt(jOe, Ge, {
  transform(e, t) {
    const n = t.dataflow, r = e.mark, i = r.marktype, o = Hd[i], a = o.bound;
    let s = r.bounds, u;
    if (o.nested)
      r.items.length && n.dirty(r.items[0]), s = w3(r, a), r.items.forEach((l) => {
        l.bounds.clear().union(s);
      });
    else if (i === Z6 || e.modified())
      switch (t.visit(t.MOD, (l) => n.dirty(l)), s.clear(), r.items.forEach((l) => s.union(w3(l, a))), r.role) {
        case Qte:
        case Kte:
        case Xte:
          t.reflow();
      }
    else
      u = t.changed(t.REM), t.visit(t.ADD, (l) => {
        s.union(w3(l, a));
      }), t.visit(t.MOD, (l) => {
        u = u || s.alignsWith(l.bounds), n.dirty(l), s.union(w3(l, a));
      }), u && (s.clear(), r.items.forEach((l) => s.union(l.bounds)));
    return TOe(r), t.modifies("bounds");
  }
});
function w3(e, t, n) {
  return t(e.bounds.clear(), e, n);
}
const yge = ":vega_identifier:";
function ene(e) {
  Ge.call(this, 0, e);
}
ene.Definition = {
  type: "Identifier",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "as",
    type: "string",
    required: !0
  }]
};
Tt(ene, Ge, {
  transform(e, t) {
    const n = ySt(t.dataflow), r = e.as;
    let i = n.value;
    return t.visit(t.ADD, (o) => o[r] = o[r] || ++i), n.set(this.value = i), t;
  }
});
function ySt(e) {
  return e._signals[yge] || (e._signals[yge] = e.add(0));
}
function LOe(e) {
  Ge.call(this, null, e);
}
Tt(LOe, Ge, {
  transform(e, t) {
    let n = this.value;
    n || (n = t.dataflow.scenegraph().mark(e.markdef, vSt(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
    const r = n.marktype === Z6 ? Y6 : U6;
    return t.visit(t.ADD, (i) => r.call(i, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t;
  }
});
function vSt(e) {
  const t = e.groups, n = e.parent;
  return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null;
}
function zOe(e) {
  Ge.call(this, null, e);
}
const vge = {
  parity: (e) => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
  greedy: (e, t) => {
    let n;
    return e.filter((r, i) => !i || !FOe(n.bounds, r.bounds, t) ? (n = r, 1) : r.opacity = 0);
  }
}, FOe = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2), bge = (e, t) => {
  for (var n = 1, r = e.length, i = e[0].bounds, o; n < r; i = o, ++n)
    if (FOe(i, o = e[n].bounds, t))
      return !0;
}, bSt = (e) => {
  const t = e.bounds;
  return t.width() > 1 && t.height() > 1;
}, xSt = (e, t, n) => {
  var r = e.range(), i = new xs();
  return t === kC || t === dw ? i.set(r[0], -1 / 0, r[1], 1 / 0) : i.set(-1 / 0, r[0], 1 / 0, r[1]), i.expand(n || 1), (o) => i.encloses(o.bounds);
}, xge = (e) => (e.forEach((t) => t.opacity = 1), e), wge = (e, t) => e.reflow(t.modified()).modifies("opacity");
Tt(zOe, Ge, {
  transform(e, t) {
    const n = vge[e.method] || vge.parity, r = e.separation || 0;
    let i = t.materialize(t.SOURCE).source, o, a;
    if (!i || !i.length)
      return;
    if (!e.method)
      return e.modified("method") && (xge(i), t = wge(t, e)), t;
    if (i = i.filter(bSt), !i.length)
      return;
    if (e.sort && (i = i.slice().sort(e.sort)), o = xge(i), t = wge(t, e), o.length >= 3 && bge(o, r)) {
      do
        o = n(o, r);
      while (o.length >= 3 && bge(o, r));
      o.length < 3 && !ri(i).opacity && (o.length > 1 && (ri(o).opacity = 0), ri(i).opacity = 1);
    }
    e.boundScale && e.boundTolerance >= 0 && (a = xSt(e.boundScale, e.boundOrient, +e.boundTolerance), i.forEach((u) => {
      a(u) || (u.opacity = 0);
    }));
    const s = o[0].mark.bounds.clear();
    return i.forEach((u) => {
      u.opacity && s.union(u.bounds);
    }), t;
  }
});
function BOe(e) {
  Ge.call(this, null, e);
}
Tt(BOe, Ge, {
  transform(e, t) {
    const n = t.dataflow;
    if (t.visit(t.ALL, (r) => n.dirty(r)), t.fields && t.fields.zindex) {
      const r = t.source && t.source[0];
      r && (r.mark.zdirty = !0);
    }
  }
});
const Pl = new xs();
function xT(e, t, n) {
  return e[t] === n ? 0 : (e[t] = n, 1);
}
function wSt(e) {
  var t = e.items[0].orient;
  return t === Ag || t === $g;
}
function _St(e) {
  let t = +e.grid;
  return [
    e.ticks ? t++ : -1,
    // ticks index
    e.labels ? t++ : -1,
    // labels index
    t + +e.domain
    // title index
  ];
}
function ESt(e, t, n, r) {
  var i = t.items[0], o = i.datum, a = i.translate != null ? i.translate : 0.5, s = i.orient, u = _St(o), l = i.range, f = i.offset, h = i.position, p = i.minExtent, g = i.maxExtent, y = o.title && i.items[u[2]].items[0], b = i.titlePadding, _ = i.bounds, S = y && Ite(y), C = 0, A = 0, O, R;
  switch (Pl.clear().union(_), _.clear(), (O = u[0]) > -1 && _.union(i.items[O].bounds), (O = u[1]) > -1 && _.union(i.items[O].bounds), s) {
    case kC:
      C = h || 0, A = -f, R = Math.max(p, Math.min(g, -_.y1)), _.add(0, -R).add(l, 0), y && _3(e, y, R, b, S, 0, -1, _);
      break;
    case Ag:
      C = -f, A = h || 0, R = Math.max(p, Math.min(g, -_.x1)), _.add(-R, 0).add(0, l), y && _3(e, y, R, b, S, 1, -1, _);
      break;
    case $g:
      C = n + f, A = h || 0, R = Math.max(p, Math.min(g, _.x2)), _.add(0, 0).add(R, l), y && _3(e, y, R, b, S, 1, 1, _);
      break;
    case dw:
      C = h || 0, A = r + f, R = Math.max(p, Math.min(g, _.y2)), _.add(0, 0).add(l, R), y && _3(e, y, R, b, 0, 0, 1, _);
      break;
    default:
      C = i.x, A = i.y;
  }
  return Mb(_.translate(C, A), i), xT(i, "x", C + a) | xT(i, "y", A + a) && (i.bounds = Pl, e.dirty(i), i.bounds = _, e.dirty(i)), i.mark.bounds.clear().union(_);
}
function _3(e, t, n, r, i, o, a, s) {
  const u = t.bounds;
  if (t.auto) {
    const l = a * (n + i + r);
    let f = 0, h = 0;
    e.dirty(t), o ? f = (t.x || 0) - (t.x = l) : h = (t.y || 0) - (t.y = l), t.mark.bounds.clear().union(u.translate(-f, -h)), e.dirty(t);
  }
  s.union(u);
}
const _ge = (e, t) => Math.floor(Math.min(e, t)), Ege = (e, t) => Math.ceil(Math.max(e, t));
function SSt(e) {
  var t = e.items, n = t.length, r = 0, i, o;
  const a = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; r < n; ++r)
    if (i = t[r], o = i.items, i.marktype === Z6)
      switch (i.role) {
        case Qte:
        case Kte:
        case Xte:
          break;
        case NOe:
          a.rowheaders.push(...o);
          break;
        case DOe:
          a.rowfooters.push(...o);
          break;
        case OOe:
          a.colheaders.push(...o);
          break;
        case ROe:
          a.colfooters.push(...o);
          break;
        case AOe:
          a.rowtitle = o[0];
          break;
        case kOe:
          a.coltitle = o[0];
          break;
        default:
          a.marks.push(...o);
      }
  return a;
}
function MSt(e) {
  return new xs().set(0, 0, e.width || 0, e.height || 0);
}
function TSt(e) {
  const t = e.bounds.clone();
  return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0));
}
function na(e, t, n) {
  const r = Pt(e) ? e[t] : e;
  return r ?? (n !== void 0 ? n : 0);
}
function Sge(e) {
  return e < 0 ? Math.ceil(-e) : 0;
}
function UOe(e, t, n) {
  var r = !n.nodirty, i = n.bounds === Jte ? MSt : TSt, o = Pl.set(0, 0, 0, 0), a = na(n.align, Ax), s = na(n.align, Ox), u = na(n.padding, Ax), l = na(n.padding, Ox), f = n.columns || t.length, h = f <= 0 ? 1 : Math.ceil(t.length / f), p = t.length, g = Array(p), y = Array(f), b = 0, _ = Array(p), S = Array(h), C = 0, A = Array(p), O = Array(p), R = Array(p), j, $, z, W, Y, V, ee, K, Q, q, te;
  for ($ = 0; $ < f; ++$)
    y[$] = 0;
  for ($ = 0; $ < h; ++$)
    S[$] = 0;
  for ($ = 0; $ < p; ++$)
    V = t[$], Y = R[$] = i(V), V.x = V.x || 0, A[$] = 0, V.y = V.y || 0, O[$] = 0, z = $ % f, W = ~~($ / f), b = Math.max(b, ee = Math.ceil(Y.x2)), C = Math.max(C, K = Math.ceil(Y.y2)), y[z] = Math.max(y[z], ee), S[W] = Math.max(S[W], K), g[$] = u + Sge(Y.x1), _[$] = l + Sge(Y.y1), r && e.dirty(t[$]);
  for ($ = 0; $ < p; ++$)
    $ % f === 0 && (g[$] = 0), $ < f && (_[$] = 0);
  if (a === nQ)
    for (z = 1; z < f; ++z) {
      for (te = 0, $ = z; $ < p; $ += f)
        te < g[$] && (te = g[$]);
      for ($ = z; $ < p; $ += f)
        g[$] = te + y[z - 1];
    }
  else if (a === x3) {
    for (te = 0, $ = 0; $ < p; ++$)
      $ % f && te < g[$] && (te = g[$]);
    for ($ = 0; $ < p; ++$)
      $ % f && (g[$] = te + b);
  } else
    for (a = !1, z = 1; z < f; ++z)
      for ($ = z; $ < p; $ += f)
        g[$] += y[z - 1];
  if (s === nQ)
    for (W = 1; W < h; ++W) {
      for (te = 0, $ = W * f, j = $ + f; $ < j; ++$)
        te < _[$] && (te = _[$]);
      for ($ = W * f; $ < j; ++$)
        _[$] = te + S[W - 1];
    }
  else if (s === x3) {
    for (te = 0, $ = f; $ < p; ++$)
      te < _[$] && (te = _[$]);
    for ($ = f; $ < p; ++$)
      _[$] = te + C;
  } else
    for (s = !1, W = 1; W < h; ++W)
      for ($ = W * f, j = $ + f; $ < j; ++$)
        _[$] += S[W - 1];
  for (Q = 0, $ = 0; $ < p; ++$)
    Q = g[$] + ($ % f ? Q : 0), A[$] += Q - t[$].x;
  for (z = 0; z < f; ++z)
    for (q = 0, $ = z; $ < p; $ += f)
      q += _[$], O[$] += q - t[$].y;
  if (a && na(n.center, Ax) && h > 1)
    for ($ = 0; $ < p; ++$)
      Y = a === x3 ? b : y[$ % f], Q = Y - R[$].x2 - t[$].x - A[$], Q > 0 && (A[$] += Q / 2);
  if (s && na(n.center, Ox) && f !== 1)
    for ($ = 0; $ < p; ++$)
      Y = s === x3 ? C : S[~~($ / f)], q = Y - R[$].y2 - t[$].y - O[$], q > 0 && (O[$] += q / 2);
  for ($ = 0; $ < p; ++$)
    o.union(R[$].translate(A[$], O[$]));
  switch (Q = na(n.anchor, cSt), q = na(n.anchor, fSt), na(n.anchor, Ax)) {
    case xc:
      Q -= o.width();
      break;
    case tQ:
      Q -= o.width() / 2;
  }
  switch (na(n.anchor, Ox)) {
    case xc:
      q -= o.height();
      break;
    case tQ:
      q -= o.height() / 2;
  }
  for (Q = Math.round(Q), q = Math.round(q), o.clear(), $ = 0; $ < p; ++$)
    t[$].mark.bounds.clear();
  for ($ = 0; $ < p; ++$)
    V = t[$], V.x += A[$] += Q, V.y += O[$] += q, o.union(V.mark.bounds.union(V.bounds.translate(A[$], O[$]))), r && e.dirty(V);
  return o;
}
function CSt(e, t, n) {
  var r = SSt(t), i = r.marks, o = n.bounds === Jte ? NSt : DSt, a = n.offset, s = n.columns || i.length, u = s <= 0 ? 1 : Math.ceil(i.length / s), l = u * s, f, h, p, g, y, b, _;
  const S = UOe(e, i, n);
  S.empty() && S.set(0, 0, 0, 0), r.rowheaders && (b = na(n.headerBand, Ox, null), f = E3(e, r.rowheaders, i, s, u, -na(a, "rowHeader"), _ge, 0, o, "x1", 0, s, 1, b)), r.colheaders && (b = na(n.headerBand, Ax, null), h = E3(e, r.colheaders, i, s, s, -na(a, "columnHeader"), _ge, 1, o, "y1", 0, 1, s, b)), r.rowfooters && (b = na(n.footerBand, Ox, null), p = E3(e, r.rowfooters, i, s, u, na(a, "rowFooter"), Ege, 0, o, "x2", s - 1, s, 1, b)), r.colfooters && (b = na(n.footerBand, Ax, null), g = E3(e, r.colfooters, i, s, s, na(a, "columnFooter"), Ege, 1, o, "y2", l - s, 1, s, b)), r.rowtitle && (y = na(n.titleAnchor, Ox), _ = na(a, "rowTitle"), _ = y === xc ? p + _ : f - _, b = na(n.titleBand, Ox, 0.5), Mge(e, r.rowtitle, _, 0, S, b)), r.coltitle && (y = na(n.titleAnchor, Ax), _ = na(a, "columnTitle"), _ = y === xc ? g + _ : h - _, b = na(n.titleBand, Ax, 0.5), Mge(e, r.coltitle, _, 1, S, b));
}
function NSt(e, t) {
  return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0;
}
function DSt(e, t) {
  return e.bounds[t];
}
function E3(e, t, n, r, i, o, a, s, u, l, f, h, p, g) {
  var y = n.length, b = 0, _ = 0, S, C, A, O, R, j, $, z, W;
  if (!y)
    return b;
  for (S = f; S < y; S += h)
    n[S] && (b = a(b, u(n[S], l)));
  if (!t.length)
    return b;
  for (t.length > i && (e.warn("Grid headers exceed limit: " + i), t = t.slice(0, i)), b += o, C = 0, O = t.length; C < O; ++C)
    e.dirty(t[C]), t[C].mark.bounds.clear();
  for (S = f, C = 0, O = t.length; C < O; ++C, S += h) {
    for (j = t[C], R = j.mark.bounds, A = S; A >= 0 && ($ = n[A]) == null; A -= p)
      ;
    s ? (z = g == null ? $.x : Math.round($.bounds.x1 + g * $.bounds.width()), W = b) : (z = b, W = g == null ? $.y : Math.round($.bounds.y1 + g * $.bounds.height())), R.union(j.bounds.translate(z - (j.x || 0), W - (j.y || 0))), j.x = z, j.y = W, e.dirty(j), _ = a(_, R[l]);
  }
  return _;
}
function Mge(e, t, n, r, i, o) {
  if (t) {
    e.dirty(t);
    var a = n, s = n;
    r ? a = Math.round(i.x1 + o * i.width()) : s = Math.round(i.y1 + o * i.height()), t.bounds.translate(a - (t.x || 0), s - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = a, t.y = s, e.dirty(t);
  }
}
function ASt(e, t) {
  const n = e[t] || {};
  return (r, i) => n[r] != null ? n[r] : e[r] != null ? e[r] : i;
}
function OSt(e, t) {
  let n = -1 / 0;
  return e.forEach((r) => {
    r.offset != null && (n = Math.max(n, r.offset));
  }), n > -1 / 0 ? n : t;
}
function RSt(e, t, n, r, i, o, a) {
  const s = ASt(n, t), u = OSt(e, s("offset", 0)), l = s("anchor", Gte), f = l === xc ? 1 : l === tQ ? 0.5 : 0, h = {
    align: nQ,
    bounds: s("bounds", Jte),
    columns: s("direction") === "vertical" ? 1 : e.length,
    padding: s("margin", 8),
    center: s("center"),
    nodirty: !0
  };
  switch (t) {
    case Ag:
      h.anchor = {
        x: Math.floor(r.x1) - u,
        column: xc,
        y: f * (a || r.height() + 2 * r.y1),
        row: l
      };
      break;
    case $g:
      h.anchor = {
        x: Math.ceil(r.x2) + u,
        y: f * (a || r.height() + 2 * r.y1),
        row: l
      };
      break;
    case kC:
      h.anchor = {
        y: Math.floor(i.y1) - u,
        row: xc,
        x: f * (o || i.width() + 2 * i.x1),
        column: l
      };
      break;
    case dw:
      h.anchor = {
        y: Math.ceil(i.y2) + u,
        x: f * (o || i.width() + 2 * i.x1),
        column: l
      };
      break;
    case aSt:
      h.anchor = {
        x: u,
        y: u
      };
      break;
    case sSt:
      h.anchor = {
        x: o - u,
        y: u,
        column: xc
      };
      break;
    case uSt:
      h.anchor = {
        x: u,
        y: a - u,
        row: xc
      };
      break;
    case lSt:
      h.anchor = {
        x: o - u,
        y: a - u,
        column: xc,
        row: xc
      };
      break;
  }
  return h;
}
function kSt(e, t) {
  var n = t.items[0], r = n.datum, i = n.orient, o = n.bounds, a = n.x, s = n.y, u, l;
  return n._bounds ? n._bounds.clear().union(o) : n._bounds = o.clone(), o.clear(), PSt(e, n, n.items[0].items[0]), o = $St(n, o), u = 2 * n.padding, l = 2 * n.padding, o.empty() || (u = Math.ceil(o.width() + u), l = Math.ceil(o.height() + l)), r.type === gSt && ISt(n.items[0].items[0].items[0].items), i !== Zte && (n.x = a = 0, n.y = s = 0), n.width = u, n.height = l, Mb(o.set(a, s, a + u, s + l), n), n.mark.bounds.clear().union(o), n;
}
function $St(e, t) {
  return e.items.forEach((n) => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t;
}
function PSt(e, t, n) {
  var r = t.padding, i = r - n.x, o = r - n.y;
  if (!t.datum.title)
    (i || o) && uO(e, n, i, o);
  else {
    var a = t.items[1].items[0], s = a.anchor, u = t.titlePadding || 0, l = r - a.x, f = r - a.y;
    switch (a.orient) {
      case Ag:
        i += Math.ceil(a.bounds.width()) + u;
        break;
      case $g:
      case dw:
        break;
      default:
        o += a.bounds.height() + u;
    }
    switch ((i || o) && uO(e, n, i, o), a.orient) {
      case Ag:
        f += qM(t, n, a, s, 1, 1);
        break;
      case $g:
        l += qM(t, n, a, xc, 0, 0) + u, f += qM(t, n, a, s, 1, 1);
        break;
      case dw:
        l += qM(t, n, a, s, 0, 0), f += qM(t, n, a, xc, -1, 0, 1) + u;
        break;
      default:
        l += qM(t, n, a, s, 0, 0);
    }
    (l || f) && uO(e, a, l, f), (l = Math.round(a.bounds.x1 - r)) < 0 && (uO(e, n, -l, 0), uO(e, a, -l, 0));
  }
}
function qM(e, t, n, r, i, o, a) {
  const s = e.datum.type !== "symbol", u = n.datum.vgrad, l = s && (o || !u) && !a ? t.items[0] : t, f = l.bounds[i ? "y2" : "x2"] - e.padding, h = u && o ? f : 0, p = u && o ? 0 : f, g = i <= 0 ? 0 : Ite(n);
  return Math.round(r === Gte ? h : r === xc ? p - g : 0.5 * (f - g));
}
function uO(e, t, n, r) {
  t.x += n, t.y += r, t.bounds.translate(n, r), t.mark.bounds.translate(n, r), e.dirty(t);
}
function ISt(e) {
  const t = e.reduce((n, r) => (n[r.column] = Math.max(r.bounds.x2 - r.x, n[r.column] || 0), n), {});
  e.forEach((n) => {
    n.width = t[n.column], n.height = n.bounds.y2 - n.y;
  });
}
function jSt(e, t, n, r, i) {
  var o = t.items[0], a = o.frame, s = o.orient, u = o.anchor, l = o.offset, f = o.padding, h = o.items[0].items[0], p = o.items[1] && o.items[1].items[0], g = s === Ag || s === $g ? r : n, y = 0, b = 0, _ = 0, S = 0, C = 0, A;
  if (a !== Z6 ? s === Ag ? (y = i.y2, g = i.y1) : s === $g ? (y = i.y1, g = i.y2) : (y = i.x1, g = i.x2) : s === Ag && (y = r, g = 0), A = u === Gte ? y : u === xc ? g : (y + g) / 2, p && p.text) {
    switch (s) {
      case kC:
      case dw:
        C = h.bounds.height() + f;
        break;
      case Ag:
        S = h.bounds.width() + f;
        break;
      case $g:
        S = -h.bounds.width() - f;
        break;
    }
    Pl.clear().union(p.bounds), Pl.translate(S - (p.x || 0), C - (p.y || 0)), xT(p, "x", S) | xT(p, "y", C) && (e.dirty(p), p.bounds.clear().union(Pl), p.mark.bounds.clear().union(Pl), e.dirty(p)), Pl.clear().union(p.bounds);
  } else
    Pl.clear();
  switch (Pl.union(h.bounds), s) {
    case kC:
      b = A, _ = i.y1 - Pl.height() - l;
      break;
    case Ag:
      b = i.x1 - Pl.width() - l, _ = A;
      break;
    case $g:
      b = i.x2 + Pl.width() + l, _ = A;
      break;
    case dw:
      b = A, _ = i.y2 + l;
      break;
    default:
      b = o.x, _ = o.y;
  }
  return xT(o, "x", b) | xT(o, "y", _) && (Pl.translate(b, _), e.dirty(o), o.bounds.clear().union(Pl), t.bounds.clear().union(Pl), e.dirty(o)), o.bounds;
}
function YOe(e) {
  Ge.call(this, null, e);
}
Tt(YOe, Ge, {
  transform(e, t) {
    const n = t.dataflow;
    return e.mark.items.forEach((r) => {
      e.layout && CSt(n, r, e.layout), zSt(n, r, e);
    }), LSt(e.mark.group) ? t.reflow() : t;
  }
});
function LSt(e) {
  return e && e.mark.role !== "legend-entry";
}
function zSt(e, t, n) {
  var r = t.items, i = Math.max(0, t.width || 0), o = Math.max(0, t.height || 0), a = new xs().set(0, 0, i, o), s = a.clone(), u = a.clone(), l = [], f, h, p, g, y, b;
  for (y = 0, b = r.length; y < b; ++y)
    switch (h = r[y], h.role) {
      case Qte:
        g = wSt(h) ? s : u, g.union(ESt(e, h, i, o));
        break;
      case Xte:
        f = h;
        break;
      case Kte:
        l.push(kSt(e, h));
        break;
      case dSt:
      case hSt:
      case NOe:
      case DOe:
      case AOe:
      case OOe:
      case ROe:
      case kOe:
        s.union(h.bounds), u.union(h.bounds);
        break;
      default:
        a.union(h.bounds);
    }
  if (l.length) {
    const _ = {};
    l.forEach((S) => {
      p = S.orient || $g, p !== Zte && (_[p] || (_[p] = [])).push(S);
    });
    for (const S in _) {
      const C = _[S];
      UOe(e, C, RSt(C, S, n.legends, s, u, i, o));
    }
    l.forEach((S) => {
      const C = S.bounds;
      if (C.equals(S._bounds) || (S.bounds = S._bounds, e.dirty(S), S.bounds = C, e.dirty(S)), n.autosize && (n.autosize.type === $Oe || n.autosize.type === POe || n.autosize.type === IOe))
        switch (S.orient) {
          case Ag:
          case $g:
            a.add(C.x1, 0).add(C.x2, 0);
            break;
          case kC:
          case dw:
            a.add(0, C.y1).add(0, C.y2);
        }
      else
        a.union(C);
    });
  }
  a.union(s).union(u), f && a.union(jSt(e, f, i, o, a)), t.clip && a.set(0, 0, t.width || 0, t.height || 0), FSt(e, t, a, n);
}
function FSt(e, t, n, r) {
  const i = r.autosize || {}, o = i.type;
  if (e._autosize < 1 || !o)
    return;
  let a = e._width, s = e._height, u = Math.max(0, t.width || 0), l = Math.max(0, Math.ceil(-n.x1)), f = Math.max(0, t.height || 0), h = Math.max(0, Math.ceil(-n.y1));
  const p = Math.max(0, Math.ceil(n.x2 - u)), g = Math.max(0, Math.ceil(n.y2 - f));
  if (i.contains === pSt) {
    const y = e.padding();
    a -= y.left + y.right, s -= y.top + y.bottom;
  }
  o === Zte ? (l = 0, h = 0, u = a, f = s) : o === $Oe ? (u = Math.max(0, a - l - p), f = Math.max(0, s - h - g)) : o === POe ? (u = Math.max(0, a - l - p), s = f + h + g) : o === IOe ? (a = u + l + p, f = Math.max(0, s - h - g)) : o === mSt && (a = u + l + p, s = f + h + g), e._resizeView(a, s, u, f, [l, h], i.resize);
}
const BSt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bound: jOe,
  identifier: ene,
  mark: LOe,
  overlap: zOe,
  render: BOe,
  viewlayout: YOe
}, Symbol.toStringTag, { value: "Module" }));
function HOe(e) {
  Ge.call(this, null, e);
}
Tt(HOe, Ge, {
  transform(e, t) {
    if (this.value && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), r = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = this.value, o = e.scale, a = e.count == null ? e.values ? e.values.length : 10 : e.count, s = vte(o, a, e.minstep), u = e.format || yAe(n, o, s, e.formatSpecifier, e.formatType, !!e.values), l = e.values ? mAe(o, e.values, s) : bte(o, s);
    return i && (r.rem = i), i = l.map((f, h) => Ui({
      index: h / (l.length - 1 || 1),
      value: f,
      label: u(f)
    })), e.extra && i.length && i.push(Ui({
      index: -1,
      extra: {
        value: i[0].value
      },
      label: ""
    })), r.source = i, r.add = i, this.value = i, r;
  }
});
function VOe(e) {
  Ge.call(this, null, e);
}
function USt() {
  return Ui({});
}
function YSt(e) {
  const t = CN().test((n) => n.exit);
  return t.lookup = (n) => t.get(e(n)), t;
}
Tt(VOe, Ge, {
  transform(e, t) {
    var n = t.dataflow, r = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = e.item || USt, o = e.key || bn, a = this.value;
    return nt(r.encode) && (r.encode = null), a && (e.modified("key") || t.modified(o)) && tt("DataJoin does not support modified key function or fields."), a || (t = t.addAll(), this.value = a = YSt(o)), t.visit(t.ADD, (s) => {
      const u = o(s);
      let l = a.get(u);
      l ? l.exit ? (a.empty--, r.add.push(l)) : r.mod.push(l) : (l = i(s), a.set(u, l), r.add.push(l)), l.datum = s, l.exit = !1;
    }), t.visit(t.MOD, (s) => {
      const u = o(s), l = a.get(u);
      l && (l.datum = s, r.mod.push(l));
    }), t.visit(t.REM, (s) => {
      const u = o(s), l = a.get(u);
      s === l.datum && !l.exit && (r.rem.push(l), l.exit = !0, ++a.empty);
    }), t.changed(t.ADD_MOD) && r.modifies("datum"), (t.clean() || e.clean && a.empty > n.cleanThreshold) && n.runAfter(a.clean), r;
  }
});
function WOe(e) {
  Ge.call(this, null, e);
}
Tt(WOe, Ge, {
  transform(e, t) {
    var n = t.fork(t.ADD_REM), r = e.mod || !1, i = e.encoders, o = t.encode;
    if (nt(o))
      if (n.changed() || o.every((h) => i[h]))
        o = o[0], n.encode = null;
      else
        return t.StopPropagation;
    var a = o === "enter", s = i.update || ax, u = i.enter || ax, l = i.exit || ax, f = (o && !a ? i[o] : s) || ax;
    if (t.changed(t.ADD) && (t.visit(t.ADD, (h) => {
      u(h, e), s(h, e);
    }), n.modifies(u.output), n.modifies(s.output), f !== ax && f !== s && (t.visit(t.ADD, (h) => {
      f(h, e);
    }), n.modifies(f.output))), t.changed(t.REM) && l !== ax && (t.visit(t.REM, (h) => {
      l(h, e);
    }), n.modifies(l.output)), a || f !== ax) {
      const h = t.MOD | (e.modified() ? t.REFLOW : 0);
      a ? (t.visit(h, (p) => {
        const g = u(p, e) || r;
        (f(p, e) || g) && n.mod.push(p);
      }), n.mod.length && n.modifies(u.output)) : t.visit(h, (p) => {
        (f(p, e) || r) && n.mod.push(p);
      }), n.mod.length && n.modifies(f.output);
    }
    return n.changed() ? n : t.StopPropagation;
  }
});
function qOe(e) {
  Ge.call(this, [], e);
}
Tt(qOe, Ge, {
  transform(e, t) {
    if (this.value != null && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), r = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = this.value, o = e.type || pj, a = e.scale, s = +e.limit, u = vte(a, e.count == null ? 5 : e.count, e.minstep), l = !!e.values || o === pj, f = e.format || wAe(n, a, u, o, e.formatSpecifier, e.formatType, l), h = e.values || xAe(a, u), p, g, y, b, _;
    return i && (r.rem = i), o === pj ? (s && h.length > s ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), i = h.slice(0, s - 1), _ = !0) : i = h, pr(y = e.size) ? (!e.values && a(i[0]) === 0 && (i = i.slice(1)), b = i.reduce((S, C) => Math.max(S, y(C, e)), 0)) : y = Gl(b = y || 8), i = i.map((S, C) => Ui({
      index: C,
      label: f(S, C, i),
      value: S,
      offset: b,
      size: y(S, e)
    })), _ && (_ = h[i.length], i.push(Ui({
      index: i.length,
      label: `…${h.length - i.length} entries`,
      value: _,
      offset: b,
      size: y(_, e)
    })))) : o === mwt ? (p = a.domain(), g = hAe(a, p[0], ri(p)), h.length < 3 && !e.values && p[0] !== ri(p) && (h = [p[0], ri(p)]), i = h.map((S, C) => Ui({
      index: C,
      label: f(S, C, h),
      value: S,
      perc: g(S)
    }))) : (y = h.length - 1, g = Cwt(a), i = h.map((S, C) => Ui({
      index: C,
      label: f(S, C, h),
      value: S,
      perc: C ? g(S) : 0,
      perc2: C === y ? 1 : g(h[C + 1])
    }))), r.source = i, r.add = i, this.value = i, r;
  }
});
const HSt = (e) => e.source.x, VSt = (e) => e.source.y, WSt = (e) => e.target.x, qSt = (e) => e.target.y;
function tne(e) {
  Ge.call(this, {}, e);
}
tne.Definition = {
  type: "LinkPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sourceX",
    type: "field",
    default: "source.x"
  }, {
    name: "sourceY",
    type: "field",
    default: "source.y"
  }, {
    name: "targetX",
    type: "field",
    default: "target.x"
  }, {
    name: "targetY",
    type: "field",
    default: "target.y"
  }, {
    name: "orient",
    type: "enum",
    default: "vertical",
    values: ["horizontal", "vertical", "radial"]
  }, {
    name: "shape",
    type: "enum",
    default: "line",
    values: ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    name: "require",
    type: "signal"
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
Tt(tne, Ge, {
  transform(e, t) {
    var n = e.sourceX || HSt, r = e.sourceY || VSt, i = e.targetX || WSt, o = e.targetY || qSt, a = e.as || "path", s = e.orient || "vertical", u = e.shape || "line", l = Tge.get(u + "-" + s) || Tge.get(u);
    return l || tt("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (f) => {
      f[a] = l(n(f), r(f), i(f), o(f));
    }), t.reflow(e.modified()).modifies(a);
  }
});
const GOe = (e, t, n, r) => "M" + e + "," + t + "L" + n + "," + r, GSt = (e, t, n, r) => GOe(t * Math.cos(e), t * Math.sin(e), r * Math.cos(n), r * Math.sin(n)), QOe = (e, t, n, r) => {
  var i = n - e, o = r - t, a = Math.hypot(i, o) / 2, s = 180 * Math.atan2(o, i) / Math.PI;
  return "M" + e + "," + t + "A" + a + "," + a + " " + s + " 0 1 " + n + "," + r;
}, QSt = (e, t, n, r) => QOe(t * Math.cos(e), t * Math.sin(e), r * Math.cos(n), r * Math.sin(n)), XOe = (e, t, n, r) => {
  const i = n - e, o = r - t, a = 0.2 * (i + o), s = 0.2 * (o - i);
  return "M" + e + "," + t + "C" + (e + a) + "," + (t + s) + " " + (n + s) + "," + (r - a) + " " + n + "," + r;
}, XSt = (e, t, n, r) => XOe(t * Math.cos(e), t * Math.sin(e), r * Math.cos(n), r * Math.sin(n)), KSt = (e, t, n, r) => "M" + e + "," + t + "V" + r + "H" + n, ZSt = (e, t, n, r) => "M" + e + "," + t + "H" + n + "V" + r, JSt = (e, t, n, r) => {
  const i = Math.cos(e), o = Math.sin(e), a = Math.cos(n), s = Math.sin(n), u = Math.abs(n - e) > Math.PI ? n <= e : n > e;
  return "M" + t * i + "," + t * o + "A" + t + "," + t + " 0 0," + (u ? 1 : 0) + " " + t * a + "," + t * s + "L" + r * a + "," + r * s;
}, e2t = (e, t, n, r) => {
  const i = (e + n) / 2;
  return "M" + e + "," + t + "C" + i + "," + t + " " + i + "," + r + " " + n + "," + r;
}, t2t = (e, t, n, r) => {
  const i = (t + r) / 2;
  return "M" + e + "," + t + "C" + e + "," + i + " " + n + "," + i + " " + n + "," + r;
}, n2t = (e, t, n, r) => {
  const i = Math.cos(e), o = Math.sin(e), a = Math.cos(n), s = Math.sin(n), u = (t + r) / 2;
  return "M" + t * i + "," + t * o + "C" + u * i + "," + u * o + " " + u * a + "," + u * s + " " + r * a + "," + r * s;
}, Tge = CN({
  line: GOe,
  "line-radial": GSt,
  arc: QOe,
  "arc-radial": QSt,
  curve: XOe,
  "curve-radial": XSt,
  "orthogonal-horizontal": KSt,
  "orthogonal-vertical": ZSt,
  "orthogonal-radial": JSt,
  "diagonal-horizontal": e2t,
  "diagonal-vertical": t2t,
  "diagonal-radial": n2t
});
function nne(e) {
  Ge.call(this, null, e);
}
nne.Definition = {
  type: "Pie",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "startAngle",
    type: "number",
    default: 0
  }, {
    name: "endAngle",
    type: "number",
    default: 6.283185307179586
  }, {
    name: "sort",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["startAngle", "endAngle"]
  }]
};
Tt(nne, Ge, {
  transform(e, t) {
    var n = e.as || ["startAngle", "endAngle"], r = n[0], i = n[1], o = e.field || SN, a = e.startAngle || 0, s = e.endAngle != null ? e.endAngle : 2 * Math.PI, u = t.source, l = u.map(o), f = l.length, h = a, p = (s - a) / fp(l), g = qo(f), y, b, _;
    for (e.sort && g.sort((S, C) => l[S] - l[C]), y = 0; y < f; ++y)
      _ = l[g[y]], b = u[g[y]], b[r] = h, b[i] = h += _ * p;
    return this.value = l, t.reflow(e.modified()).modifies(n);
  }
});
const r2t = 5;
function i2t(e) {
  const t = e.type;
  return !e.bins && (t === CC || t === n4 || t === r4);
}
function KOe(e) {
  return gte(e) && e !== By;
}
const o2t = Wg(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function ZOe(e) {
  Ge.call(this, null, e), this.modified(!0);
}
Tt(ZOe, Ge, {
  transform(e, t) {
    var n = t.dataflow, r = this.value, i = a2t(e);
    (!r || i !== r.type) && (this.value = r = Di(i)());
    for (i in e)
      if (!o2t[i]) {
        if (i === "padding" && KOe(r.type))
          continue;
        pr(r[i]) ? r[i](e[i]) : n.warn("Unsupported scale property: " + i);
      }
    return d2t(r, e, f2t(r, e, u2t(r, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function a2t(e) {
  var t = e.type, n = "", r;
  return t === By ? By + "-" + CC : (s2t(e) && (r = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = r === 2 ? By + "-" : r === 3 ? ON + "-" : ""), (n + t || CC).toLowerCase());
}
function s2t(e) {
  const t = e.type;
  return gte(t) && t !== OS && t !== RS && (e.scheme || e.range && e.range.length && e.range.every(kt));
}
function u2t(e, t, n) {
  const r = l2t(e, t.domainRaw, n);
  if (r > -1)
    return r;
  var i = t.domain, o = e.type, a = t.zero || t.zero === void 0 && i2t(e), s, u;
  if (!i)
    return 0;
  if ((a || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (s = (i = i.slice()).length - 1 || 1, a && (i[0] > 0 && (i[0] = 0), i[s] < 0 && (i[s] = 0)), t.domainMin != null && (i[0] = t.domainMin), t.domainMax != null && (i[s] = t.domainMax), t.domainMid != null)) {
    u = t.domainMid;
    const l = u > i[s] ? s + 1 : u < i[0] ? 0 : s;
    l !== s && n.warn("Scale domainMid exceeds domain min or max.", u), i.splice(l, 0, u);
  }
  return KOe(o) && t.padding && i[0] !== ri(i) && (i = c2t(o, i, t.range, t.padding, t.exponent, t.constant)), e.domain(JOe(o, i, n)), o === fte && e.unknown(t.domainImplicit ? UL : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && vte(e, t.nice) || null), i.length;
}
function l2t(e, t, n) {
  return t ? (e.domain(JOe(e.type, t, n)), t.length) : -1;
}
function c2t(e, t, n, r, i, o) {
  var a = Math.abs(ri(n) - n[0]), s = a / (a - 2 * r), u = e === db ? iee(t, null, s) : e === r4 ? f5(t, null, s, 0.5) : e === n4 ? f5(t, null, s, i || 1) : e === j6 ? oee(t, null, s, o || 1) : ree(t, null, s);
  return t = t.slice(), t[0] = u[0], t[t.length - 1] = u[1], t;
}
function JOe(e, t, n) {
  if (uAe(e)) {
    var r = Math.abs(t.reduce((i, o) => i + (o < 0 ? -1 : o > 0 ? 1 : 0), 0));
    r !== t.length && n.warn("Log scale domain includes zero: " + Et(t));
  }
  return t;
}
function f2t(e, t, n) {
  let r = t.bins;
  if (r && !nt(r)) {
    const i = e.domain(), o = i[0], a = ri(i), s = r.step;
    let u = r.start == null ? o : r.start, l = r.stop == null ? a : r.stop;
    s || tt("Scale bins parameter missing step property."), u < o && (u = s * Math.ceil(o / s)), l > a && (l = s * Math.floor(a / s)), r = qo(u, l + s / 2, s);
  }
  return r ? e.bins = r : e.bins && delete e.bins, e.type === dte && (r ? !t.domain && !t.domainRaw && (e.domain(r), n = r.length) : e.bins = e.domain()), n;
}
function d2t(e, t, n) {
  var r = e.type, i = t.round || !1, o = t.range;
  if (t.rangeStep != null)
    o = h2t(r, t, n);
  else if (t.scheme && (o = p2t(r, t, n), pr(o))) {
    if (e.interpolator)
      return e.interpolator(o);
    tt(`Scale type ${r} does not support interpolating color schemes.`);
  }
  if (o && lAe(r))
    return e.interpolator(F6(rQ(o, t.reverse), t.interpolate, t.interpolateGamma));
  o && t.interpolate && e.interpolate ? e.interpolate(mte(t.interpolate, t.interpolateGamma)) : pr(e.round) ? e.round(i) : pr(e.rangeRound) && e.interpolate(i ? fN : Tw), o && e.range(rQ(o, t.reverse));
}
function h2t(e, t, n) {
  e !== nAe && e !== UG && tt("Only band and point scales support rangeStep.");
  var r = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0, i = e === UG ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
  return [0, t.rangeStep * cte(n, i, r)];
}
function p2t(e, t, n) {
  var r = t.schemeExtent, i, o;
  return nt(t.scheme) ? o = F6(t.scheme, t.interpolate, t.interpolateGamma) : (i = t.scheme.toLowerCase(), o = yte(i), o || tt(`Unrecognized scheme name: ${t.scheme}`)), n = e === z6 ? n + 1 : e === dte ? n - 1 : e === NC || e === L6 ? +t.schemeCount || r2t : n, lAe(e) ? Cge(o, r, t.reverse) : pr(o) ? dAe(Cge(o, r), n) : e === fte ? o : o.slice(0, n);
}
function Cge(e, t, n) {
  return pr(e) && (t || n) ? fAe(e, rQ(t || [0, 1], n)) : e;
}
function rQ(e, t) {
  return t ? e.slice().reverse() : e;
}
function eRe(e) {
  Ge.call(this, null, e);
}
Tt(eRe, Ge, {
  transform(e, t) {
    const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
    return n && t.source.sort(i2(e.sort)), this.modified(n), t;
  }
});
const Nge = "zero", tRe = "center", nRe = "normalize", rRe = ["y0", "y1"];
function rne(e) {
  Ge.call(this, null, e);
}
rne.Definition = {
  type: "Stack",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "offset",
    type: "enum",
    default: Nge,
    values: [Nge, tRe, nRe]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: rRe
  }]
};
Tt(rne, Ge, {
  transform(e, t) {
    var n = e.as || rRe, r = n[0], i = n[1], o = i2(e.sort), a = e.field || SN, s = e.offset === tRe ? g2t : e.offset === nRe ? m2t : y2t, u, l, f, h;
    for (u = v2t(t.source, e.groupby, o, a), l = 0, f = u.length, h = u.max; l < f; ++l)
      s(u[l], h, a, r, i);
    return t.reflow(e.modified()).modifies(n);
  }
});
function g2t(e, t, n, r, i) {
  for (var o = (t - e.sum) / 2, a = e.length, s = 0, u; s < a; ++s)
    u = e[s], u[r] = o, u[i] = o += Math.abs(n(u));
}
function m2t(e, t, n, r, i) {
  for (var o = 1 / e.sum, a = 0, s = e.length, u = 0, l = 0, f; u < s; ++u)
    f = e[u], f[r] = a, f[i] = a = o * (l += Math.abs(n(f)));
}
function y2t(e, t, n, r, i) {
  for (var o = 0, a = 0, s = e.length, u = 0, l, f; u < s; ++u)
    f = e[u], l = +n(f), l < 0 ? (f[r] = a, f[i] = a += l) : (f[r] = o, f[i] = o += l);
}
function v2t(e, t, n, r) {
  var i = [], o = (b) => b(f), a, s, u, l, f, h, p, g, y;
  if (t == null)
    i.push(e.slice());
  else
    for (a = {}, s = 0, u = e.length; s < u; ++s)
      f = e[s], h = t.map(o), p = a[h], p || (a[h] = p = [], i.push(p)), p.push(f);
  for (h = 0, y = 0, l = i.length; h < l; ++h) {
    for (p = i[h], s = 0, g = 0, u = p.length; s < u; ++s)
      g += Math.abs(r(p[s]));
    p.sum = g, g > y && (y = g), n && p.sort(n);
  }
  return i.max = y, i;
}
const b2t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  axisticks: HOe,
  datajoin: VOe,
  encode: WOe,
  legendentries: qOe,
  linkpath: tne,
  pie: nne,
  scale: ZOe,
  sortitems: eRe,
  stack: rne
}, Symbol.toStringTag, { value: "Module" }));
var Mn = 1e-6, N5 = 1e-12, Ir = Math.PI, Ua = Ir / 2, D5 = Ir / 4, kc = Ir * 2, Za = 180 / Ir, Dr = Ir / 180, ni = Math.abs, kN = Math.atan, wp = Math.atan2, Nn = Math.cos, S3 = Math.ceil, iRe = Math.exp, iQ = Math.hypot, A5 = Math.log, rV = Math.pow, xn = Math.sin, tp = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, $c = Math.sqrt, ine = Math.tan;
function oRe(e) {
  return e > 1 ? 0 : e < -1 ? Ir : Math.acos(e);
}
function $f(e) {
  return e > 1 ? Ua : e < -1 ? -Ua : Math.asin(e);
}
function el() {
}
function O5(e, t) {
  e && Age.hasOwnProperty(e.type) && Age[e.type](e, t);
}
var Dge = {
  Feature: function(e, t) {
    O5(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, r = -1, i = n.length; ++r < i; )
      O5(n[r].geometry, t);
  }
}, Age = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      e = n[r], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    oQ(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      oQ(n[r], t, 0);
  },
  Polygon: function(e, t) {
    Oge(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      Oge(n[r], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, r = -1, i = n.length; ++r < i; )
      O5(n[r], t);
  }
};
function oQ(e, t, n) {
  var r = -1, i = e.length - n, o;
  for (t.lineStart(); ++r < i; )
    o = e[r], t.point(o[0], o[1], o[2]);
  t.lineEnd();
}
function Oge(e, t) {
  var n = -1, r = e.length;
  for (t.polygonStart(); ++n < r; )
    oQ(e[n], t, 1);
  t.polygonEnd();
}
function Y0(e, t) {
  e && Dge.hasOwnProperty(e.type) ? Dge[e.type](e, t) : O5(e, t);
}
var R5 = new Qo(), k5 = new Qo(), aRe, sRe, aQ, sQ, uQ, Xy = {
  point: el,
  lineStart: el,
  lineEnd: el,
  polygonStart: function() {
    R5 = new Qo(), Xy.lineStart = x2t, Xy.lineEnd = w2t;
  },
  polygonEnd: function() {
    var e = +R5;
    k5.add(e < 0 ? kc + e : e), this.lineStart = this.lineEnd = this.point = el;
  },
  sphere: function() {
    k5.add(kc);
  }
};
function x2t() {
  Xy.point = _2t;
}
function w2t() {
  uRe(aRe, sRe);
}
function _2t(e, t) {
  Xy.point = uRe, aRe = e, sRe = t, e *= Dr, t *= Dr, aQ = e, sQ = Nn(t = t / 2 + D5), uQ = xn(t);
}
function uRe(e, t) {
  e *= Dr, t *= Dr, t = t / 2 + D5;
  var n = e - aQ, r = n >= 0 ? 1 : -1, i = r * n, o = Nn(t), a = xn(t), s = uQ * a, u = sQ * o + s * Nn(i), l = s * r * xn(i);
  R5.add(wp(l, u)), aQ = e, sQ = o, uQ = a;
}
function E2t(e) {
  return k5 = new Qo(), Y0(e, Xy), k5 * 2;
}
function $5(e) {
  return [wp(e[1], e[0]), $f(e[2])];
}
function $S(e) {
  var t = e[0], n = e[1], r = Nn(n);
  return [r * Nn(t), r * xn(t), xn(n)];
}
function M3(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function $C(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function iV(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function T3(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function P5(e) {
  var t = $c(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
var va, mf, Ia, _d, CE, lRe, cRe, PT, LR, hx, hb, F0 = {
  point: lQ,
  lineStart: Rge,
  lineEnd: kge,
  polygonStart: function() {
    F0.point = dRe, F0.lineStart = S2t, F0.lineEnd = M2t, LR = new Qo(), Xy.polygonStart();
  },
  polygonEnd: function() {
    Xy.polygonEnd(), F0.point = lQ, F0.lineStart = Rge, F0.lineEnd = kge, R5 < 0 ? (va = -(Ia = 180), mf = -(_d = 90)) : LR > Mn ? _d = 90 : LR < -Mn && (mf = -90), hb[0] = va, hb[1] = Ia;
  },
  sphere: function() {
    va = -(Ia = 180), mf = -(_d = 90);
  }
};
function lQ(e, t) {
  hx.push(hb = [va = e, Ia = e]), t < mf && (mf = t), t > _d && (_d = t);
}
function fRe(e, t) {
  var n = $S([e * Dr, t * Dr]);
  if (PT) {
    var r = $C(PT, n), i = [r[1], -r[0], 0], o = $C(i, r);
    P5(o), o = $5(o);
    var a = e - CE, s = a > 0 ? 1 : -1, u = o[0] * Za * s, l, f = ni(a) > 180;
    f ^ (s * CE < u && u < s * e) ? (l = o[1] * Za, l > _d && (_d = l)) : (u = (u + 360) % 360 - 180, f ^ (s * CE < u && u < s * e) ? (l = -o[1] * Za, l < mf && (mf = l)) : (t < mf && (mf = t), t > _d && (_d = t))), f ? e < CE ? bd(va, e) > bd(va, Ia) && (Ia = e) : bd(e, Ia) > bd(va, Ia) && (va = e) : Ia >= va ? (e < va && (va = e), e > Ia && (Ia = e)) : e > CE ? bd(va, e) > bd(va, Ia) && (Ia = e) : bd(e, Ia) > bd(va, Ia) && (va = e);
  } else
    hx.push(hb = [va = e, Ia = e]);
  t < mf && (mf = t), t > _d && (_d = t), PT = n, CE = e;
}
function Rge() {
  F0.point = fRe;
}
function kge() {
  hb[0] = va, hb[1] = Ia, F0.point = lQ, PT = null;
}
function dRe(e, t) {
  if (PT) {
    var n = e - CE;
    LR.add(ni(n) > 180 ? n + (n > 0 ? 360 : -360) : n);
  } else
    lRe = e, cRe = t;
  Xy.point(e, t), fRe(e, t);
}
function S2t() {
  Xy.lineStart();
}
function M2t() {
  dRe(lRe, cRe), Xy.lineEnd(), ni(LR) > Mn && (va = -(Ia = 180)), hb[0] = va, hb[1] = Ia, PT = null;
}
function bd(e, t) {
  return (t -= e) < 0 ? t + 360 : t;
}
function T2t(e, t) {
  return e[0] - t[0];
}
function $ge(e, t) {
  return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t;
}
function C2t(e) {
  var t, n, r, i, o, a, s;
  if (_d = Ia = -(va = mf = 1 / 0), hx = [], Y0(e, F0), n = hx.length) {
    for (hx.sort(T2t), t = 1, r = hx[0], o = [r]; t < n; ++t)
      i = hx[t], $ge(r, i[0]) || $ge(r, i[1]) ? (bd(r[0], i[1]) > bd(r[0], r[1]) && (r[1] = i[1]), bd(i[0], r[1]) > bd(r[0], r[1]) && (r[0] = i[0])) : o.push(r = i);
    for (a = -1 / 0, n = o.length - 1, t = 0, r = o[n]; t <= n; r = i, ++t)
      i = o[t], (s = bd(r[1], i[0])) > a && (a = s, va = i[0], Ia = r[1]);
  }
  return hx = hb = null, va === 1 / 0 || mf === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[va, mf], [Ia, _d]];
}
var QO, I5, j5, L5, z5, F5, B5, U5, cQ, fQ, dQ, hRe, pRe, Sc, Mc, Tc, Pg = {
  sphere: el,
  point: one,
  lineStart: Pge,
  lineEnd: Ige,
  polygonStart: function() {
    Pg.lineStart = A2t, Pg.lineEnd = O2t;
  },
  polygonEnd: function() {
    Pg.lineStart = Pge, Pg.lineEnd = Ige;
  }
};
function one(e, t) {
  e *= Dr, t *= Dr;
  var n = Nn(t);
  g4(n * Nn(e), n * xn(e), xn(t));
}
function g4(e, t, n) {
  ++QO, j5 += (e - j5) / QO, L5 += (t - L5) / QO, z5 += (n - z5) / QO;
}
function Pge() {
  Pg.point = N2t;
}
function N2t(e, t) {
  e *= Dr, t *= Dr;
  var n = Nn(t);
  Sc = n * Nn(e), Mc = n * xn(e), Tc = xn(t), Pg.point = D2t, g4(Sc, Mc, Tc);
}
function D2t(e, t) {
  e *= Dr, t *= Dr;
  var n = Nn(t), r = n * Nn(e), i = n * xn(e), o = xn(t), a = wp($c((a = Mc * o - Tc * i) * a + (a = Tc * r - Sc * o) * a + (a = Sc * i - Mc * r) * a), Sc * r + Mc * i + Tc * o);
  I5 += a, F5 += a * (Sc + (Sc = r)), B5 += a * (Mc + (Mc = i)), U5 += a * (Tc + (Tc = o)), g4(Sc, Mc, Tc);
}
function Ige() {
  Pg.point = one;
}
function A2t() {
  Pg.point = R2t;
}
function O2t() {
  gRe(hRe, pRe), Pg.point = one;
}
function R2t(e, t) {
  hRe = e, pRe = t, e *= Dr, t *= Dr, Pg.point = gRe;
  var n = Nn(t);
  Sc = n * Nn(e), Mc = n * xn(e), Tc = xn(t), g4(Sc, Mc, Tc);
}
function gRe(e, t) {
  e *= Dr, t *= Dr;
  var n = Nn(t), r = n * Nn(e), i = n * xn(e), o = xn(t), a = Mc * o - Tc * i, s = Tc * r - Sc * o, u = Sc * i - Mc * r, l = iQ(a, s, u), f = $f(l), h = l && -f / l;
  cQ.add(h * a), fQ.add(h * s), dQ.add(h * u), I5 += f, F5 += f * (Sc + (Sc = r)), B5 += f * (Mc + (Mc = i)), U5 += f * (Tc + (Tc = o)), g4(Sc, Mc, Tc);
}
function k2t(e) {
  QO = I5 = j5 = L5 = z5 = F5 = B5 = U5 = 0, cQ = new Qo(), fQ = new Qo(), dQ = new Qo(), Y0(e, Pg);
  var t = +cQ, n = +fQ, r = +dQ, i = iQ(t, n, r);
  return i < N5 && (t = F5, n = B5, r = U5, I5 < Mn && (t = j5, n = L5, r = z5), i = iQ(t, n, r), i < N5) ? [NaN, NaN] : [wp(n, t) * Za, $f(r / i) * Za];
}
function hQ(e, t) {
  function n(r, i) {
    return r = e(r, i), t(r[0], r[1]);
  }
  return e.invert && t.invert && (n.invert = function(r, i) {
    return r = t.invert(r, i), r && e.invert(r[0], r[1]);
  }), n;
}
function pQ(e, t) {
  return ni(e) > Ir && (e -= Math.round(e / kc) * kc), [e, t];
}
pQ.invert = pQ;
function mRe(e, t, n) {
  return (e %= kc) ? t || n ? hQ(Lge(e), zge(t, n)) : Lge(e) : t || n ? zge(t, n) : pQ;
}
function jge(e) {
  return function(t, n) {
    return t += e, ni(t) > Ir && (t -= Math.round(t / kc) * kc), [t, n];
  };
}
function Lge(e) {
  var t = jge(e);
  return t.invert = jge(-e), t;
}
function zge(e, t) {
  var n = Nn(e), r = xn(e), i = Nn(t), o = xn(t);
  function a(s, u) {
    var l = Nn(u), f = Nn(s) * l, h = xn(s) * l, p = xn(u), g = p * n + f * r;
    return [
      wp(h * i - g * o, f * n - p * r),
      $f(g * i + h * o)
    ];
  }
  return a.invert = function(s, u) {
    var l = Nn(u), f = Nn(s) * l, h = xn(s) * l, p = xn(u), g = p * i - h * o;
    return [
      wp(h * i + p * o, f * n + g * r),
      $f(g * n - f * r)
    ];
  }, a;
}
function $2t(e) {
  e = mRe(e[0] * Dr, e[1] * Dr, e.length > 2 ? e[2] * Dr : 0);
  function t(n) {
    return n = e(n[0] * Dr, n[1] * Dr), n[0] *= Za, n[1] *= Za, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * Dr, n[1] * Dr), n[0] *= Za, n[1] *= Za, n;
  }, t;
}
function P2t(e, t, n, r, i, o) {
  if (n) {
    var a = Nn(t), s = xn(t), u = r * n;
    i == null ? (i = t + r * kc, o = t - u / 2) : (i = Fge(a, i), o = Fge(a, o), (r > 0 ? i < o : i > o) && (i += r * kc));
    for (var l, f = i; r > 0 ? f > o : f < o; f -= u)
      l = $5([a, -s * Nn(f), -s * xn(f)]), e.point(l[0], l[1]);
  }
}
function Fge(e, t) {
  t = $S(t), t[0] -= e, P5(t);
  var n = oRe(-t[1]);
  return ((-t[2] < 0 ? -n : n) + kc - Mn) % kc;
}
function yRe() {
  var e = [], t;
  return {
    point: function(n, r, i) {
      t.push([n, r, i]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: el,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function Ej(e, t) {
  return ni(e[0] - t[0]) < Mn && ni(e[1] - t[1]) < Mn;
}
function C3(e, t, n, r) {
  this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;
}
function vRe(e, t, n, r, i) {
  var o = [], a = [], s, u;
  if (e.forEach(function(y) {
    if (!((b = y.length - 1) <= 0)) {
      var b, _ = y[0], S = y[b], C;
      if (Ej(_, S)) {
        if (!_[2] && !S[2]) {
          for (i.lineStart(), s = 0; s < b; ++s)
            i.point((_ = y[s])[0], _[1]);
          i.lineEnd();
          return;
        }
        S[0] += 2 * Mn;
      }
      o.push(C = new C3(_, y, null, !0)), a.push(C.o = new C3(_, null, C, !1)), o.push(C = new C3(S, y, null, !1)), a.push(C.o = new C3(S, null, C, !0));
    }
  }), !!o.length) {
    for (a.sort(t), Bge(o), Bge(a), s = 0, u = a.length; s < u; ++s)
      a[s].e = n = !n;
    for (var l = o[0], f, h; ; ) {
      for (var p = l, g = !0; p.v; )
        if ((p = p.n) === l)
          return;
      f = p.z, i.lineStart();
      do {
        if (p.v = p.o.v = !0, p.e) {
          if (g)
            for (s = 0, u = f.length; s < u; ++s)
              i.point((h = f[s])[0], h[1]);
          else
            r(p.x, p.n.x, 1, i);
          p = p.n;
        } else {
          if (g)
            for (f = p.p.z, s = f.length - 1; s >= 0; --s)
              i.point((h = f[s])[0], h[1]);
          else
            r(p.x, p.p.x, -1, i);
          p = p.p;
        }
        p = p.o, f = p.z, g = !g;
      } while (!p.v);
      i.lineEnd();
    }
  }
}
function Bge(e) {
  if (t = e.length) {
    for (var t, n = 0, r = e[0], i; ++n < t; )
      r.n = i = e[n], i.p = r, r = i;
    r.n = i = e[0], i.p = r;
  }
}
function oV(e) {
  return ni(e[0]) <= Ir ? e[0] : tp(e[0]) * ((ni(e[0]) + Ir) % kc - Ir);
}
function I2t(e, t) {
  var n = oV(t), r = t[1], i = xn(r), o = [xn(n), -Nn(n), 0], a = 0, s = 0, u = new Qo();
  i === 1 ? r = Ua + Mn : i === -1 && (r = -Ua - Mn);
  for (var l = 0, f = e.length; l < f; ++l)
    if (p = (h = e[l]).length)
      for (var h, p, g = h[p - 1], y = oV(g), b = g[1] / 2 + D5, _ = xn(b), S = Nn(b), C = 0; C < p; ++C, y = O, _ = j, S = $, g = A) {
        var A = h[C], O = oV(A), R = A[1] / 2 + D5, j = xn(R), $ = Nn(R), z = O - y, W = z >= 0 ? 1 : -1, Y = W * z, V = Y > Ir, ee = _ * j;
        if (u.add(wp(ee * W * xn(Y), S * $ + ee * Nn(Y))), a += V ? z + W * kc : z, V ^ y >= n ^ O >= n) {
          var K = $C($S(g), $S(A));
          P5(K);
          var Q = $C(o, K);
          P5(Q);
          var q = (V ^ z >= 0 ? -1 : 1) * $f(Q[2]);
          (r > q || r === q && (K[0] || K[1])) && (s += V ^ z >= 0 ? 1 : -1);
        }
      }
  return (a < -Mn || a < Mn && u < -N5) ^ s & 1;
}
function bRe(e, t, n, r) {
  return function(i) {
    var o = t(i), a = yRe(), s = t(a), u = !1, l, f, h, p = {
      point: g,
      lineStart: b,
      lineEnd: _,
      polygonStart: function() {
        p.point = S, p.lineStart = C, p.lineEnd = A, f = [], l = [];
      },
      polygonEnd: function() {
        p.point = g, p.lineStart = b, p.lineEnd = _, f = TF(f);
        var O = I2t(l, r);
        f.length ? (u || (i.polygonStart(), u = !0), vRe(f, L2t, O, n, i)) : O && (u || (i.polygonStart(), u = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), u && (i.polygonEnd(), u = !1), f = l = null;
      },
      sphere: function() {
        i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();
      }
    };
    function g(O, R) {
      e(O, R) && i.point(O, R);
    }
    function y(O, R) {
      o.point(O, R);
    }
    function b() {
      p.point = y, o.lineStart();
    }
    function _() {
      p.point = g, o.lineEnd();
    }
    function S(O, R) {
      h.push([O, R]), s.point(O, R);
    }
    function C() {
      s.lineStart(), h = [];
    }
    function A() {
      S(h[0][0], h[0][1]), s.lineEnd();
      var O = s.clean(), R = a.result(), j, $ = R.length, z, W, Y;
      if (h.pop(), l.push(h), h = null, !!$) {
        if (O & 1) {
          if (W = R[0], (z = W.length - 1) > 0) {
            for (u || (i.polygonStart(), u = !0), i.lineStart(), j = 0; j < z; ++j)
              i.point((Y = W[j])[0], Y[1]);
            i.lineEnd();
          }
          return;
        }
        $ > 1 && O & 2 && R.push(R.pop().concat(R.shift())), f.push(R.filter(j2t));
      }
    }
    return p;
  };
}
function j2t(e) {
  return e.length > 1;
}
function L2t(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - Ua - Mn : Ua - e[1]) - ((t = t.x)[0] < 0 ? t[1] - Ua - Mn : Ua - t[1]);
}
const Uge = bRe(
  function() {
    return !0;
  },
  z2t,
  B2t,
  [-Ir, -Ua]
);
function z2t(e) {
  var t = NaN, n = NaN, r = NaN, i;
  return {
    lineStart: function() {
      e.lineStart(), i = 1;
    },
    point: function(o, a) {
      var s = o > 0 ? Ir : -Ir, u = ni(o - t);
      ni(u - Ir) < Mn ? (e.point(t, n = (n + a) / 2 > 0 ? Ua : -Ua), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(s, n), e.point(o, n), i = 0) : r !== s && u >= Ir && (ni(t - r) < Mn && (t -= r * Mn), ni(o - s) < Mn && (o -= s * Mn), n = F2t(t, n, o, a), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(s, n), i = 0), e.point(t = o, n = a), r = s;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function F2t(e, t, n, r) {
  var i, o, a = xn(e - n);
  return ni(a) > Mn ? kN((xn(t) * (o = Nn(r)) * xn(n) - xn(r) * (i = Nn(t)) * xn(e)) / (i * o * a)) : (t + r) / 2;
}
function B2t(e, t, n, r) {
  var i;
  if (e == null)
    i = n * Ua, r.point(-Ir, i), r.point(0, i), r.point(Ir, i), r.point(Ir, 0), r.point(Ir, -i), r.point(0, -i), r.point(-Ir, -i), r.point(-Ir, 0), r.point(-Ir, i);
  else if (ni(e[0] - t[0]) > Mn) {
    var o = e[0] < t[0] ? Ir : -Ir;
    i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i);
  } else
    r.point(t[0], t[1]);
}
function U2t(e) {
  var t = Nn(e), n = 2 * Dr, r = t > 0, i = ni(t) > Mn;
  function o(f, h, p, g) {
    P2t(g, e, n, p, f, h);
  }
  function a(f, h) {
    return Nn(f) * Nn(h) > t;
  }
  function s(f) {
    var h, p, g, y, b;
    return {
      lineStart: function() {
        y = g = !1, b = 1;
      },
      point: function(_, S) {
        var C = [_, S], A, O = a(_, S), R = r ? O ? 0 : l(_, S) : O ? l(_ + (_ < 0 ? Ir : -Ir), S) : 0;
        if (!h && (y = g = O) && f.lineStart(), O !== g && (A = u(h, C), (!A || Ej(h, A) || Ej(C, A)) && (C[2] = 1)), O !== g)
          b = 0, O ? (f.lineStart(), A = u(C, h), f.point(A[0], A[1])) : (A = u(h, C), f.point(A[0], A[1], 2), f.lineEnd()), h = A;
        else if (i && h && r ^ O) {
          var j;
          !(R & p) && (j = u(C, h, !0)) && (b = 0, r ? (f.lineStart(), f.point(j[0][0], j[0][1]), f.point(j[1][0], j[1][1]), f.lineEnd()) : (f.point(j[1][0], j[1][1]), f.lineEnd(), f.lineStart(), f.point(j[0][0], j[0][1], 3)));
        }
        O && (!h || !Ej(h, C)) && f.point(C[0], C[1]), h = C, g = O, p = R;
      },
      lineEnd: function() {
        g && f.lineEnd(), h = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return b | (y && g) << 1;
      }
    };
  }
  function u(f, h, p) {
    var g = $S(f), y = $S(h), b = [1, 0, 0], _ = $C(g, y), S = M3(_, _), C = _[0], A = S - C * C;
    if (!A)
      return !p && f;
    var O = t * S / A, R = -t * C / A, j = $C(b, _), $ = T3(b, O), z = T3(_, R);
    iV($, z);
    var W = j, Y = M3($, W), V = M3(W, W), ee = Y * Y - V * (M3($, $) - 1);
    if (!(ee < 0)) {
      var K = $c(ee), Q = T3(W, (-Y - K) / V);
      if (iV(Q, $), Q = $5(Q), !p)
        return Q;
      var q = f[0], te = h[0], X = f[1], Z = h[1], se;
      te < q && (se = q, q = te, te = se);
      var H = te - q, ie = ni(H - Ir) < Mn, he = ie || H < Mn;
      if (!ie && Z < X && (se = X, X = Z, Z = se), he ? ie ? X + Z > 0 ^ Q[1] < (ni(Q[0] - q) < Mn ? X : Z) : X <= Q[1] && Q[1] <= Z : H > Ir ^ (q <= Q[0] && Q[0] <= te)) {
        var ye = T3(W, (-Y + K) / V);
        return iV(ye, $), [Q, $5(ye)];
      }
    }
  }
  function l(f, h) {
    var p = r ? e : Ir - e, g = 0;
    return f < -p ? g |= 1 : f > p && (g |= 2), h < -p ? g |= 4 : h > p && (g |= 8), g;
  }
  return bRe(a, s, o, r ? [0, -e] : [-Ir, e - Ir]);
}
function Y2t(e, t, n, r, i, o) {
  var a = e[0], s = e[1], u = t[0], l = t[1], f = 0, h = 1, p = u - a, g = l - s, y;
  if (y = n - a, !(!p && y > 0)) {
    if (y /= p, p < 0) {
      if (y < f)
        return;
      y < h && (h = y);
    } else if (p > 0) {
      if (y > h)
        return;
      y > f && (f = y);
    }
    if (y = i - a, !(!p && y < 0)) {
      if (y /= p, p < 0) {
        if (y > h)
          return;
        y > f && (f = y);
      } else if (p > 0) {
        if (y < f)
          return;
        y < h && (h = y);
      }
      if (y = r - s, !(!g && y > 0)) {
        if (y /= g, g < 0) {
          if (y < f)
            return;
          y < h && (h = y);
        } else if (g > 0) {
          if (y > h)
            return;
          y > f && (f = y);
        }
        if (y = o - s, !(!g && y < 0)) {
          if (y /= g, g < 0) {
            if (y > h)
              return;
            y > f && (f = y);
          } else if (g > 0) {
            if (y < f)
              return;
            y < h && (h = y);
          }
          return f > 0 && (e[0] = a + f * p, e[1] = s + f * g), h < 1 && (t[0] = a + h * p, t[1] = s + h * g), !0;
        }
      }
    }
  }
}
var XO = 1e9, N3 = -XO;
function xRe(e, t, n, r) {
  function i(l, f) {
    return e <= l && l <= n && t <= f && f <= r;
  }
  function o(l, f, h, p) {
    var g = 0, y = 0;
    if (l == null || (g = a(l, h)) !== (y = a(f, h)) || u(l, f) < 0 ^ h > 0)
      do
        p.point(g === 0 || g === 3 ? e : n, g > 1 ? r : t);
      while ((g = (g + h + 4) % 4) !== y);
    else
      p.point(f[0], f[1]);
  }
  function a(l, f) {
    return ni(l[0] - e) < Mn ? f > 0 ? 0 : 3 : ni(l[0] - n) < Mn ? f > 0 ? 2 : 1 : ni(l[1] - t) < Mn ? f > 0 ? 1 : 0 : f > 0 ? 3 : 2;
  }
  function s(l, f) {
    return u(l.x, f.x);
  }
  function u(l, f) {
    var h = a(l, 1), p = a(f, 1);
    return h !== p ? h - p : h === 0 ? f[1] - l[1] : h === 1 ? l[0] - f[0] : h === 2 ? l[1] - f[1] : f[0] - l[0];
  }
  return function(l) {
    var f = l, h = yRe(), p, g, y, b, _, S, C, A, O, R, j, $ = {
      point: z,
      lineStart: ee,
      lineEnd: K,
      polygonStart: Y,
      polygonEnd: V
    };
    function z(q, te) {
      i(q, te) && f.point(q, te);
    }
    function W() {
      for (var q = 0, te = 0, X = g.length; te < X; ++te)
        for (var Z = g[te], se = 1, H = Z.length, ie = Z[0], he, ye, _e = ie[0], Ne = ie[1]; se < H; ++se)
          he = _e, ye = Ne, ie = Z[se], _e = ie[0], Ne = ie[1], ye <= r ? Ne > r && (_e - he) * (r - ye) > (Ne - ye) * (e - he) && ++q : Ne <= r && (_e - he) * (r - ye) < (Ne - ye) * (e - he) && --q;
      return q;
    }
    function Y() {
      f = h, p = [], g = [], j = !0;
    }
    function V() {
      var q = W(), te = j && q, X = (p = TF(p)).length;
      (te || X) && (l.polygonStart(), te && (l.lineStart(), o(null, null, 1, l), l.lineEnd()), X && vRe(p, s, q, o, l), l.polygonEnd()), f = l, p = g = y = null;
    }
    function ee() {
      $.point = Q, g && g.push(y = []), R = !0, O = !1, C = A = NaN;
    }
    function K() {
      p && (Q(b, _), S && O && h.rejoin(), p.push(h.result())), $.point = z, O && f.lineEnd();
    }
    function Q(q, te) {
      var X = i(q, te);
      if (g && y.push([q, te]), R)
        b = q, _ = te, S = X, R = !1, X && (f.lineStart(), f.point(q, te));
      else if (X && O)
        f.point(q, te);
      else {
        var Z = [C = Math.max(N3, Math.min(XO, C)), A = Math.max(N3, Math.min(XO, A))], se = [q = Math.max(N3, Math.min(XO, q)), te = Math.max(N3, Math.min(XO, te))];
        Y2t(Z, se, e, t, n, r) ? (O || (f.lineStart(), f.point(Z[0], Z[1])), f.point(se[0], se[1]), X || f.lineEnd(), j = !1) : X && (f.lineStart(), f.point(q, te), j = !1);
      }
      C = q, A = te, O = X;
    }
    return $;
  };
}
function Yge(e, t, n) {
  var r = qo(e, t - Mn, n).concat(t);
  return function(i) {
    return r.map(function(o) {
      return [i, o];
    });
  };
}
function Hge(e, t, n) {
  var r = qo(e, t - Mn, n).concat(t);
  return function(i) {
    return r.map(function(o) {
      return [o, i];
    });
  };
}
function H2t() {
  var e, t, n, r, i, o, a, s, u = 10, l = u, f = 90, h = 360, p, g, y, b, _ = 2.5;
  function S() {
    return { type: "MultiLineString", coordinates: C() };
  }
  function C() {
    return qo(S3(r / f) * f, n, f).map(y).concat(qo(S3(s / h) * h, a, h).map(b)).concat(qo(S3(t / u) * u, e, u).filter(function(A) {
      return ni(A % f) > Mn;
    }).map(p)).concat(qo(S3(o / l) * l, i, l).filter(function(A) {
      return ni(A % h) > Mn;
    }).map(g));
  }
  return S.lines = function() {
    return C().map(function(A) {
      return { type: "LineString", coordinates: A };
    });
  }, S.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        y(r).concat(
          b(a).slice(1),
          y(n).reverse().slice(1),
          b(s).reverse().slice(1)
        )
      ]
    };
  }, S.extent = function(A) {
    return arguments.length ? S.extentMajor(A).extentMinor(A) : S.extentMinor();
  }, S.extentMajor = function(A) {
    return arguments.length ? (r = +A[0][0], n = +A[1][0], s = +A[0][1], a = +A[1][1], r > n && (A = r, r = n, n = A), s > a && (A = s, s = a, a = A), S.precision(_)) : [[r, s], [n, a]];
  }, S.extentMinor = function(A) {
    return arguments.length ? (t = +A[0][0], e = +A[1][0], o = +A[0][1], i = +A[1][1], t > e && (A = t, t = e, e = A), o > i && (A = o, o = i, i = A), S.precision(_)) : [[t, o], [e, i]];
  }, S.step = function(A) {
    return arguments.length ? S.stepMajor(A).stepMinor(A) : S.stepMinor();
  }, S.stepMajor = function(A) {
    return arguments.length ? (f = +A[0], h = +A[1], S) : [f, h];
  }, S.stepMinor = function(A) {
    return arguments.length ? (u = +A[0], l = +A[1], S) : [u, l];
  }, S.precision = function(A) {
    return arguments.length ? (_ = +A, p = Yge(o, i, 90), g = Hge(t, e, _), y = Yge(s, a, 90), b = Hge(r, n, _), S) : _;
  }, S.extentMajor([[-180, -90 + Mn], [180, 90 - Mn]]).extentMinor([[-180, -80 - Mn], [180, 80 + Mn]]);
}
const Xk = (e) => e;
var aV = new Qo(), gQ = new Qo(), wRe, _Re, mQ, yQ, _x = {
  point: el,
  lineStart: el,
  lineEnd: el,
  polygonStart: function() {
    _x.lineStart = V2t, _x.lineEnd = q2t;
  },
  polygonEnd: function() {
    _x.lineStart = _x.lineEnd = _x.point = el, aV.add(ni(gQ)), gQ = new Qo();
  },
  result: function() {
    var e = aV / 2;
    return aV = new Qo(), e;
  }
};
function V2t() {
  _x.point = W2t;
}
function W2t(e, t) {
  _x.point = ERe, wRe = mQ = e, _Re = yQ = t;
}
function ERe(e, t) {
  gQ.add(yQ * e - mQ * t), mQ = e, yQ = t;
}
function q2t() {
  ERe(wRe, _Re);
}
const Vge = _x;
var PC = 1 / 0, Y5 = PC, Kk = -PC, H5 = Kk, G2t = {
  point: Q2t,
  lineStart: el,
  lineEnd: el,
  polygonStart: el,
  polygonEnd: el,
  result: function() {
    var e = [[PC, Y5], [Kk, H5]];
    return Kk = H5 = -(Y5 = PC = 1 / 0), e;
  }
};
function Q2t(e, t) {
  e < PC && (PC = e), e > Kk && (Kk = e), t < Y5 && (Y5 = t), t > H5 && (H5 = t);
}
const V5 = G2t;
var vQ = 0, bQ = 0, KO = 0, W5 = 0, q5 = 0, wT = 0, xQ = 0, wQ = 0, ZO = 0, SRe, MRe, Dy, Ay, Og = {
  point: PS,
  lineStart: Wge,
  lineEnd: qge,
  polygonStart: function() {
    Og.lineStart = Z2t, Og.lineEnd = J2t;
  },
  polygonEnd: function() {
    Og.point = PS, Og.lineStart = Wge, Og.lineEnd = qge;
  },
  result: function() {
    var e = ZO ? [xQ / ZO, wQ / ZO] : wT ? [W5 / wT, q5 / wT] : KO ? [vQ / KO, bQ / KO] : [NaN, NaN];
    return vQ = bQ = KO = W5 = q5 = wT = xQ = wQ = ZO = 0, e;
  }
};
function PS(e, t) {
  vQ += e, bQ += t, ++KO;
}
function Wge() {
  Og.point = X2t;
}
function X2t(e, t) {
  Og.point = K2t, PS(Dy = e, Ay = t);
}
function K2t(e, t) {
  var n = e - Dy, r = t - Ay, i = $c(n * n + r * r);
  W5 += i * (Dy + e) / 2, q5 += i * (Ay + t) / 2, wT += i, PS(Dy = e, Ay = t);
}
function qge() {
  Og.point = PS;
}
function Z2t() {
  Og.point = eMt;
}
function J2t() {
  TRe(SRe, MRe);
}
function eMt(e, t) {
  Og.point = TRe, PS(SRe = Dy = e, MRe = Ay = t);
}
function TRe(e, t) {
  var n = e - Dy, r = t - Ay, i = $c(n * n + r * r);
  W5 += i * (Dy + e) / 2, q5 += i * (Ay + t) / 2, wT += i, i = Ay * e - Dy * t, xQ += i * (Dy + e), wQ += i * (Ay + t), ZO += i * 3, PS(Dy = e, Ay = t);
}
const Gge = Og;
function CRe(e) {
  this._context = e;
}
CRe.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, kc);
        break;
      }
    }
  },
  result: el
};
var _Q = new Qo(), sV, NRe, DRe, JO, eR, G5 = {
  point: el,
  lineStart: function() {
    G5.point = tMt;
  },
  lineEnd: function() {
    sV && ARe(NRe, DRe), G5.point = el;
  },
  polygonStart: function() {
    sV = !0;
  },
  polygonEnd: function() {
    sV = null;
  },
  result: function() {
    var e = +_Q;
    return _Q = new Qo(), e;
  }
};
function tMt(e, t) {
  G5.point = ARe, NRe = JO = e, DRe = eR = t;
}
function ARe(e, t) {
  JO -= e, eR -= t, _Q.add($c(JO * JO + eR * eR)), JO = e, eR = t;
}
const Qge = G5;
let Xge, Q5, Kge, Zge;
class Jge {
  constructor(t) {
    this._append = t == null ? ORe : nMt(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== Kge || this._append !== Q5) {
          const r = this._radius, i = this._;
          this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, Kge = r, Q5 = this._append, Zge = this._, this._ = i;
        }
        this._ += Zge;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function ORe(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function nMt(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return ORe;
  if (t !== Xge) {
    const n = 10 ** t;
    Xge = t, Q5 = function(i) {
      let o = 1;
      this._ += i[0];
      for (const a = i.length; o < a; ++o)
        this._ += Math.round(arguments[o] * n) / n + i[o];
    };
  }
  return Q5;
}
function RRe(e, t) {
  let n = 3, r = 4.5, i, o;
  function a(s) {
    return s && (typeof r == "function" && o.pointRadius(+r.apply(this, arguments)), Y0(s, i(o))), o.result();
  }
  return a.area = function(s) {
    return Y0(s, i(Vge)), Vge.result();
  }, a.measure = function(s) {
    return Y0(s, i(Qge)), Qge.result();
  }, a.bounds = function(s) {
    return Y0(s, i(V5)), V5.result();
  }, a.centroid = function(s) {
    return Y0(s, i(Gge)), Gge.result();
  }, a.projection = function(s) {
    return arguments.length ? (i = s == null ? (e = null, Xk) : (e = s).stream, a) : e;
  }, a.context = function(s) {
    return arguments.length ? (o = s == null ? (t = null, new Jge(n)) : new CRe(t = s), typeof r != "function" && o.pointRadius(r), a) : t;
  }, a.pointRadius = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : (o.pointRadius(+s), +s), a) : r;
  }, a.digits = function(s) {
    if (!arguments.length)
      return n;
    if (s == null)
      n = null;
    else {
      const u = Math.floor(s);
      if (!(u >= 0))
        throw new RangeError(`invalid digits: ${s}`);
      n = u;
    }
    return t === null && (o = new Jge(n)), a;
  }, a.projection(e).digits(n).context(t);
}
function J6(e) {
  return function(t) {
    var n = new EQ();
    for (var r in e)
      n[r] = e[r];
    return n.stream = t, n;
  };
}
function EQ() {
}
EQ.prototype = {
  constructor: EQ,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function ane(e, t, n) {
  var r = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), Y0(n, e.stream(V5)), t(V5.result()), r != null && e.clipExtent(r), e;
}
function e8(e, t, n) {
  return ane(e, function(r) {
    var i = t[1][0] - t[0][0], o = t[1][1] - t[0][1], a = Math.min(i / (r[1][0] - r[0][0]), o / (r[1][1] - r[0][1])), s = +t[0][0] + (i - a * (r[1][0] + r[0][0])) / 2, u = +t[0][1] + (o - a * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * a).translate([s, u]);
  }, n);
}
function sne(e, t, n) {
  return e8(e, [[0, 0], t], n);
}
function une(e, t, n) {
  return ane(e, function(r) {
    var i = +t, o = i / (r[1][0] - r[0][0]), a = (i - o * (r[1][0] + r[0][0])) / 2, s = -o * r[0][1];
    e.scale(150 * o).translate([a, s]);
  }, n);
}
function lne(e, t, n) {
  return ane(e, function(r) {
    var i = +t, o = i / (r[1][1] - r[0][1]), a = -o * r[0][0], s = (i - o * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * o).translate([a, s]);
  }, n);
}
var eme = 16, rMt = Nn(30 * Dr);
function tme(e, t) {
  return +t ? oMt(e, t) : iMt(e);
}
function iMt(e) {
  return J6({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function oMt(e, t) {
  function n(r, i, o, a, s, u, l, f, h, p, g, y, b, _) {
    var S = l - r, C = f - i, A = S * S + C * C;
    if (A > 4 * t && b--) {
      var O = a + p, R = s + g, j = u + y, $ = $c(O * O + R * R + j * j), z = $f(j /= $), W = ni(ni(j) - 1) < Mn || ni(o - h) < Mn ? (o + h) / 2 : wp(R, O), Y = e(W, z), V = Y[0], ee = Y[1], K = V - r, Q = ee - i, q = C * K - S * Q;
      (q * q / A > t || ni((S * K + C * Q) / A - 0.5) > 0.3 || a * p + s * g + u * y < rMt) && (n(r, i, o, a, s, u, V, ee, W, O /= $, R /= $, j, b, _), _.point(V, ee), n(V, ee, W, O, R, j, l, f, h, p, g, y, b, _));
    }
  }
  return function(r) {
    var i, o, a, s, u, l, f, h, p, g, y, b, _ = {
      point: S,
      lineStart: C,
      lineEnd: O,
      polygonStart: function() {
        r.polygonStart(), _.lineStart = R;
      },
      polygonEnd: function() {
        r.polygonEnd(), _.lineStart = C;
      }
    };
    function S(z, W) {
      z = e(z, W), r.point(z[0], z[1]);
    }
    function C() {
      h = NaN, _.point = A, r.lineStart();
    }
    function A(z, W) {
      var Y = $S([z, W]), V = e(z, W);
      n(h, p, f, g, y, b, h = V[0], p = V[1], f = z, g = Y[0], y = Y[1], b = Y[2], eme, r), r.point(h, p);
    }
    function O() {
      _.point = S, r.lineEnd();
    }
    function R() {
      C(), _.point = j, _.lineEnd = $;
    }
    function j(z, W) {
      A(i = z, W), o = h, a = p, s = g, u = y, l = b, _.point = A;
    }
    function $() {
      n(h, p, f, g, y, b, o, a, i, s, u, l, eme, r), _.lineEnd = O, O();
    }
    return _;
  };
}
var aMt = J6({
  point: function(e, t) {
    this.stream.point(e * Dr, t * Dr);
  }
});
function sMt(e) {
  return J6({
    point: function(t, n) {
      var r = e(t, n);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function uMt(e, t, n, r, i) {
  function o(a, s) {
    return a *= r, s *= i, [t + e * a, n - e * s];
  }
  return o.invert = function(a, s) {
    return [(a - t) / e * r, (n - s) / e * i];
  }, o;
}
function nme(e, t, n, r, i, o) {
  if (!o)
    return uMt(e, t, n, r, i);
  var a = Nn(o), s = xn(o), u = a * e, l = s * e, f = a / e, h = s / e, p = (s * n - a * t) / e, g = (s * t + a * n) / e;
  function y(b, _) {
    return b *= r, _ *= i, [u * b - l * _ + t, n - l * b - u * _];
  }
  return y.invert = function(b, _) {
    return [r * (f * b - h * _ + p), i * (g - h * b - f * _)];
  }, y;
}
function lv(e) {
  return kRe(function() {
    return e;
  })();
}
function kRe(e) {
  var t, n = 150, r = 480, i = 250, o = 0, a = 0, s = 0, u = 0, l = 0, f, h = 0, p = 1, g = 1, y = null, b = Uge, _ = null, S, C, A, O = Xk, R = 0.5, j, $, z, W, Y;
  function V(q) {
    return z(q[0] * Dr, q[1] * Dr);
  }
  function ee(q) {
    return q = z.invert(q[0], q[1]), q && [q[0] * Za, q[1] * Za];
  }
  V.stream = function(q) {
    return W && Y === q ? W : W = aMt(sMt(f)(b(j(O(Y = q)))));
  }, V.preclip = function(q) {
    return arguments.length ? (b = q, y = void 0, Q()) : b;
  }, V.postclip = function(q) {
    return arguments.length ? (O = q, _ = S = C = A = null, Q()) : O;
  }, V.clipAngle = function(q) {
    return arguments.length ? (b = +q ? U2t(y = q * Dr) : (y = null, Uge), Q()) : y * Za;
  }, V.clipExtent = function(q) {
    return arguments.length ? (O = q == null ? (_ = S = C = A = null, Xk) : xRe(_ = +q[0][0], S = +q[0][1], C = +q[1][0], A = +q[1][1]), Q()) : _ == null ? null : [[_, S], [C, A]];
  }, V.scale = function(q) {
    return arguments.length ? (n = +q, K()) : n;
  }, V.translate = function(q) {
    return arguments.length ? (r = +q[0], i = +q[1], K()) : [r, i];
  }, V.center = function(q) {
    return arguments.length ? (o = q[0] % 360 * Dr, a = q[1] % 360 * Dr, K()) : [o * Za, a * Za];
  }, V.rotate = function(q) {
    return arguments.length ? (s = q[0] % 360 * Dr, u = q[1] % 360 * Dr, l = q.length > 2 ? q[2] % 360 * Dr : 0, K()) : [s * Za, u * Za, l * Za];
  }, V.angle = function(q) {
    return arguments.length ? (h = q % 360 * Dr, K()) : h * Za;
  }, V.reflectX = function(q) {
    return arguments.length ? (p = q ? -1 : 1, K()) : p < 0;
  }, V.reflectY = function(q) {
    return arguments.length ? (g = q ? -1 : 1, K()) : g < 0;
  }, V.precision = function(q) {
    return arguments.length ? (j = tme($, R = q * q), Q()) : $c(R);
  }, V.fitExtent = function(q, te) {
    return e8(V, q, te);
  }, V.fitSize = function(q, te) {
    return sne(V, q, te);
  }, V.fitWidth = function(q, te) {
    return une(V, q, te);
  }, V.fitHeight = function(q, te) {
    return lne(V, q, te);
  };
  function K() {
    var q = nme(n, 0, 0, p, g, h).apply(null, t(o, a)), te = nme(n, r - q[0], i - q[1], p, g, h);
    return f = mRe(s, u, l), $ = hQ(t, te), z = hQ(f, $), j = tme($, R), Q();
  }
  function Q() {
    return W = Y = null, V;
  }
  return function() {
    return t = e.apply(this, arguments), V.invert = t.invert && ee, K();
  };
}
function cne(e) {
  var t = 0, n = Ir / 3, r = kRe(e), i = r(t, n);
  return i.parallels = function(o) {
    return arguments.length ? r(t = o[0] * Dr, n = o[1] * Dr) : [t * Za, n * Za];
  }, i;
}
function lMt(e) {
  var t = Nn(e);
  function n(r, i) {
    return [r * t, xn(i) / t];
  }
  return n.invert = function(r, i) {
    return [r / t, $f(i * t)];
  }, n;
}
function cMt(e, t) {
  var n = xn(e), r = (n + xn(t)) / 2;
  if (ni(r) < Mn)
    return lMt(e);
  var i = 1 + n * (2 * r - n), o = $c(i) / r;
  function a(s, u) {
    var l = $c(i - 2 * r * xn(u)) / r;
    return [l * xn(s *= r), o - l * Nn(s)];
  }
  return a.invert = function(s, u) {
    var l = o - u, f = wp(s, ni(l)) * tp(l);
    return l * r < 0 && (f -= Ir * tp(s) * tp(l)), [f / r, $f((i - (s * s + l * l) * r * r) / (2 * r))];
  }, a;
}
function X5() {
  return cne(cMt).scale(155.424).center([0, 33.6442]);
}
function $Re() {
  return X5().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function fMt(e) {
  var t = e.length;
  return {
    point: function(n, r) {
      for (var i = -1; ++i < t; )
        e[i].point(n, r);
    },
    sphere: function() {
      for (var n = -1; ++n < t; )
        e[n].sphere();
    },
    lineStart: function() {
      for (var n = -1; ++n < t; )
        e[n].lineStart();
    },
    lineEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].lineEnd();
    },
    polygonStart: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonStart();
    },
    polygonEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonEnd();
    }
  };
}
function dMt() {
  var e, t, n = $Re(), r, i = X5().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), o, a = X5().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), s, u, l = { point: function(p, g) {
    u = [p, g];
  } };
  function f(p) {
    var g = p[0], y = p[1];
    return u = null, r.point(g, y), u || (o.point(g, y), u) || (s.point(g, y), u);
  }
  f.invert = function(p) {
    var g = n.scale(), y = n.translate(), b = (p[0] - y[0]) / g, _ = (p[1] - y[1]) / g;
    return (_ >= 0.12 && _ < 0.234 && b >= -0.425 && b < -0.214 ? i : _ >= 0.166 && _ < 0.234 && b >= -0.214 && b < -0.115 ? a : n).invert(p);
  }, f.stream = function(p) {
    return e && t === p ? e : e = fMt([n.stream(t = p), i.stream(p), a.stream(p)]);
  }, f.precision = function(p) {
    return arguments.length ? (n.precision(p), i.precision(p), a.precision(p), h()) : n.precision();
  }, f.scale = function(p) {
    return arguments.length ? (n.scale(p), i.scale(p * 0.35), a.scale(p), f.translate(n.translate())) : n.scale();
  }, f.translate = function(p) {
    if (!arguments.length)
      return n.translate();
    var g = n.scale(), y = +p[0], b = +p[1];
    return r = n.translate(p).clipExtent([[y - 0.455 * g, b - 0.238 * g], [y + 0.455 * g, b + 0.238 * g]]).stream(l), o = i.translate([y - 0.307 * g, b + 0.201 * g]).clipExtent([[y - 0.425 * g + Mn, b + 0.12 * g + Mn], [y - 0.214 * g - Mn, b + 0.234 * g - Mn]]).stream(l), s = a.translate([y - 0.205 * g, b + 0.212 * g]).clipExtent([[y - 0.214 * g + Mn, b + 0.166 * g + Mn], [y - 0.115 * g - Mn, b + 0.234 * g - Mn]]).stream(l), h();
  }, f.fitExtent = function(p, g) {
    return e8(f, p, g);
  }, f.fitSize = function(p, g) {
    return sne(f, p, g);
  }, f.fitWidth = function(p, g) {
    return une(f, p, g);
  }, f.fitHeight = function(p, g) {
    return lne(f, p, g);
  };
  function h() {
    return e = t = null, f;
  }
  return f.scale(1070);
}
function PRe(e) {
  return function(t, n) {
    var r = Nn(t), i = Nn(n), o = e(r * i);
    return o === 1 / 0 ? [2, 0] : [
      o * i * xn(t),
      o * xn(n)
    ];
  };
}
function m4(e) {
  return function(t, n) {
    var r = $c(t * t + n * n), i = e(r), o = xn(i), a = Nn(i);
    return [
      wp(t * o, r * a),
      $f(r && n * o / r)
    ];
  };
}
var IRe = PRe(function(e) {
  return $c(2 / (1 + e));
});
IRe.invert = m4(function(e) {
  return 2 * $f(e / 2);
});
function hMt() {
  return lv(IRe).scale(124.75).clipAngle(180 - 1e-3);
}
var jRe = PRe(function(e) {
  return (e = oRe(e)) && e / xn(e);
});
jRe.invert = m4(function(e) {
  return e;
});
function pMt() {
  return lv(jRe).scale(79.4188).clipAngle(180 - 1e-3);
}
function t8(e, t) {
  return [e, A5(ine((Ua + t) / 2))];
}
t8.invert = function(e, t) {
  return [e, 2 * kN(iRe(t)) - Ua];
};
function gMt() {
  return LRe(t8).scale(961 / kc);
}
function LRe(e) {
  var t = lv(e), n = t.center, r = t.scale, i = t.translate, o = t.clipExtent, a = null, s, u, l;
  t.scale = function(h) {
    return arguments.length ? (r(h), f()) : r();
  }, t.translate = function(h) {
    return arguments.length ? (i(h), f()) : i();
  }, t.center = function(h) {
    return arguments.length ? (n(h), f()) : n();
  }, t.clipExtent = function(h) {
    return arguments.length ? (h == null ? a = s = u = l = null : (a = +h[0][0], s = +h[0][1], u = +h[1][0], l = +h[1][1]), f()) : a == null ? null : [[a, s], [u, l]];
  };
  function f() {
    var h = Ir * r(), p = t($2t(t.rotate()).invert([0, 0]));
    return o(a == null ? [[p[0] - h, p[1] - h], [p[0] + h, p[1] + h]] : e === t8 ? [[Math.max(p[0] - h, a), s], [Math.min(p[0] + h, u), l]] : [[a, Math.max(p[1] - h, s)], [u, Math.min(p[1] + h, l)]]);
  }
  return f();
}
function D3(e) {
  return ine((Ua + e) / 2);
}
function mMt(e, t) {
  var n = Nn(e), r = e === t ? xn(e) : A5(n / Nn(t)) / A5(D3(t) / D3(e)), i = n * rV(D3(e), r) / r;
  if (!r)
    return t8;
  function o(a, s) {
    i > 0 ? s < -Ua + Mn && (s = -Ua + Mn) : s > Ua - Mn && (s = Ua - Mn);
    var u = i / rV(D3(s), r);
    return [u * xn(r * a), i - u * Nn(r * a)];
  }
  return o.invert = function(a, s) {
    var u = i - s, l = tp(r) * $c(a * a + u * u), f = wp(a, ni(u)) * tp(u);
    return u * r < 0 && (f -= Ir * tp(a) * tp(u)), [f / r, 2 * kN(rV(i / l, 1 / r)) - Ua];
  }, o;
}
function yMt() {
  return cne(mMt).scale(109.5).parallels([30, 30]);
}
function K5(e, t) {
  return [e, t];
}
K5.invert = K5;
function vMt() {
  return lv(K5).scale(152.63);
}
function bMt(e, t) {
  var n = Nn(e), r = e === t ? xn(e) : (n - Nn(t)) / (t - e), i = n / r + e;
  if (ni(r) < Mn)
    return K5;
  function o(a, s) {
    var u = i - s, l = r * a;
    return [u * xn(l), i - u * Nn(l)];
  }
  return o.invert = function(a, s) {
    var u = i - s, l = wp(a, ni(u)) * tp(u);
    return u * r < 0 && (l -= Ir * tp(a) * tp(u)), [l / r, i - tp(r) * $c(a * a + u * u)];
  }, o;
}
function xMt() {
  return cne(bMt).scale(131.154).center([0, 13.9389]);
}
var zR = 1.340264, FR = -0.081106, BR = 893e-6, UR = 3796e-6, Z5 = $c(3) / 2, wMt = 12;
function zRe(e, t) {
  var n = $f(Z5 * xn(t)), r = n * n, i = r * r * r;
  return [
    e * Nn(n) / (Z5 * (zR + 3 * FR * r + i * (7 * BR + 9 * UR * r))),
    n * (zR + FR * r + i * (BR + UR * r))
  ];
}
zRe.invert = function(e, t) {
  for (var n = t, r = n * n, i = r * r * r, o = 0, a, s, u; o < wMt && (s = n * (zR + FR * r + i * (BR + UR * r)) - t, u = zR + 3 * FR * r + i * (7 * BR + 9 * UR * r), n -= a = s / u, r = n * n, i = r * r * r, !(ni(a) < N5)); ++o)
    ;
  return [
    Z5 * e * (zR + 3 * FR * r + i * (7 * BR + 9 * UR * r)) / Nn(n),
    $f(xn(n) / Z5)
  ];
};
function _Mt() {
  return lv(zRe).scale(177.158);
}
function FRe(e, t) {
  var n = Nn(t), r = Nn(e) * n;
  return [n * xn(e) / r, xn(t) / r];
}
FRe.invert = m4(kN);
function EMt() {
  return lv(FRe).scale(144.049).clipAngle(60);
}
function SMt() {
  var e = 1, t = 0, n = 0, r = 1, i = 1, o = 0, a, s, u = null, l, f, h, p = 1, g = 1, y = J6({
    point: function(O, R) {
      var j = A([O, R]);
      this.stream.point(j[0], j[1]);
    }
  }), b = Xk, _, S;
  function C() {
    return p = e * r, g = e * i, _ = S = null, A;
  }
  function A(O) {
    var R = O[0] * p, j = O[1] * g;
    if (o) {
      var $ = j * a - R * s;
      R = R * a + j * s, j = $;
    }
    return [R + t, j + n];
  }
  return A.invert = function(O) {
    var R = O[0] - t, j = O[1] - n;
    if (o) {
      var $ = j * a + R * s;
      R = R * a - j * s, j = $;
    }
    return [R / p, j / g];
  }, A.stream = function(O) {
    return _ && S === O ? _ : _ = y(b(S = O));
  }, A.postclip = function(O) {
    return arguments.length ? (b = O, u = l = f = h = null, C()) : b;
  }, A.clipExtent = function(O) {
    return arguments.length ? (b = O == null ? (u = l = f = h = null, Xk) : xRe(u = +O[0][0], l = +O[0][1], f = +O[1][0], h = +O[1][1]), C()) : u == null ? null : [[u, l], [f, h]];
  }, A.scale = function(O) {
    return arguments.length ? (e = +O, C()) : e;
  }, A.translate = function(O) {
    return arguments.length ? (t = +O[0], n = +O[1], C()) : [t, n];
  }, A.angle = function(O) {
    return arguments.length ? (o = O % 360 * Dr, s = xn(o), a = Nn(o), C()) : o * Za;
  }, A.reflectX = function(O) {
    return arguments.length ? (r = O ? -1 : 1, C()) : r < 0;
  }, A.reflectY = function(O) {
    return arguments.length ? (i = O ? -1 : 1, C()) : i < 0;
  }, A.fitExtent = function(O, R) {
    return e8(A, O, R);
  }, A.fitSize = function(O, R) {
    return sne(A, O, R);
  }, A.fitWidth = function(O, R) {
    return une(A, O, R);
  }, A.fitHeight = function(O, R) {
    return lne(A, O, R);
  }, A;
}
function BRe(e, t) {
  var n = t * t, r = n * n;
  return [
    e * (0.8707 - 0.131979 * n + r * (-0.013791 + r * (3971e-6 * n - 1529e-6 * r))),
    t * (1.007226 + n * (0.015085 + r * (-0.044475 + 0.028874 * n - 5916e-6 * r)))
  ];
}
BRe.invert = function(e, t) {
  var n = t, r = 25, i;
  do {
    var o = n * n, a = o * o;
    n -= i = (n * (1.007226 + o * (0.015085 + a * (-0.044475 + 0.028874 * o - 5916e-6 * a))) - t) / (1.007226 + o * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * o - 5916e-6 * 11 * a)));
  } while (ni(i) > Mn && --r > 0);
  return [
    e / (0.8707 + (o = n * n) * (-0.131979 + o * (-0.013791 + o * o * o * (3971e-6 - 1529e-6 * o)))),
    n
  ];
};
function MMt() {
  return lv(BRe).scale(175.295);
}
function URe(e, t) {
  return [Nn(t) * xn(e), xn(t)];
}
URe.invert = m4($f);
function TMt() {
  return lv(URe).scale(249.5).clipAngle(90 + Mn);
}
function YRe(e, t) {
  var n = Nn(t), r = 1 + Nn(e) * n;
  return [n * xn(e) / r, xn(t) / r];
}
YRe.invert = m4(function(e) {
  return 2 * kN(e);
});
function CMt() {
  return lv(YRe).scale(250).clipAngle(142);
}
function HRe(e, t) {
  return [A5(ine((Ua + t) / 2)), -e];
}
HRe.invert = function(e, t) {
  return [-t, 2 * kN(iRe(e)) - Ua];
};
function NMt() {
  var e = LRe(HRe), t = e.center, n = e.rotate;
  return e.center = function(r) {
    return arguments.length ? t([-r[1], r[0]]) : (r = t(), [r[1], -r[0]]);
  }, e.rotate = function(r) {
    return arguments.length ? n([r[0], r[1], r.length > 2 ? r[2] + 90 : 90]) : (r = n(), [r[0], r[1], r[2] - 90]);
  }, n([0, 0, 90]).scale(159.155);
}
var DMt = Math.abs, SQ = Math.cos, J5 = Math.sin, AMt = 1e-6, VRe = Math.PI, MQ = VRe / 2, rme = OMt(2);
function ime(e) {
  return e > 1 ? MQ : e < -1 ? -MQ : Math.asin(e);
}
function OMt(e) {
  return e > 0 ? Math.sqrt(e) : 0;
}
function RMt(e, t) {
  var n = e * J5(t), r = 30, i;
  do
    t -= i = (t + J5(t) - n) / (1 + SQ(t));
  while (DMt(i) > AMt && --r > 0);
  return t / 2;
}
function kMt(e, t, n) {
  function r(i, o) {
    return [e * i * SQ(o = RMt(n, o)), t * J5(o)];
  }
  return r.invert = function(i, o) {
    return o = ime(o / t), [i / (e * SQ(o)), ime((2 * o + J5(2 * o)) / n)];
  }, r;
}
var $Mt = kMt(rme / MQ, rme, VRe);
function PMt() {
  return lv($Mt).scale(169.529);
}
const IMt = RRe(), TQ = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function jMt(e, t) {
  return function n() {
    const r = t();
    return r.type = e, r.path = RRe().projection(r), r.copy = r.copy || function() {
      const i = n();
      return TQ.forEach((o) => {
        r[o] && i[o](r[o]());
      }), i.path.pointRadius(r.path.pointRadius()), i;
    }, aAe(r);
  };
}
function fne(e, t) {
  if (!e || typeof e != "string")
    throw new Error("Projection type must be a name string.");
  return e = e.toLowerCase(), arguments.length > 1 ? (ez[e] = jMt(e, t), this) : ez[e] || null;
}
function WRe(e) {
  return e && e.path || IMt;
}
const ez = {
  // base d3-geo projection types
  albers: $Re,
  albersusa: dMt,
  azimuthalequalarea: hMt,
  azimuthalequidistant: pMt,
  conicconformal: yMt,
  conicequalarea: X5,
  conicequidistant: xMt,
  equalEarth: _Mt,
  equirectangular: vMt,
  gnomonic: EMt,
  identity: SMt,
  mercator: gMt,
  mollweide: PMt,
  naturalEarth1: MMt,
  orthographic: TMt,
  stereographic: CMt,
  transversemercator: NMt
};
for (const e in ez)
  fne(e, ez[e]);
function LMt() {
}
const R0 = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function qRe() {
  var e = 1, t = 1, n = s;
  function r(u, l) {
    return l.map((f) => i(u, f));
  }
  function i(u, l) {
    var f = [], h = [];
    return o(u, l, (p) => {
      n(p, u, l), zMt(p) > 0 ? f.push([p]) : h.push(p);
    }), h.forEach((p) => {
      for (var g = 0, y = f.length, b; g < y; ++g)
        if (FMt((b = f[g])[0], p) !== -1) {
          b.push(p);
          return;
        }
    }), {
      type: "MultiPolygon",
      value: l,
      coordinates: f
    };
  }
  function o(u, l, f) {
    var h = new Array(), p = new Array(), g, y, b, _, S, C;
    for (g = y = -1, _ = u[0] >= l, R0[_ << 1].forEach(A); ++g < e - 1; )
      b = _, _ = u[g + 1] >= l, R0[b | _ << 1].forEach(A);
    for (R0[_ << 0].forEach(A); ++y < t - 1; ) {
      for (g = -1, _ = u[y * e + e] >= l, S = u[y * e] >= l, R0[_ << 1 | S << 2].forEach(A); ++g < e - 1; )
        b = _, _ = u[y * e + e + g + 1] >= l, C = S, S = u[y * e + g + 1] >= l, R0[b | _ << 1 | S << 2 | C << 3].forEach(A);
      R0[_ | S << 3].forEach(A);
    }
    for (g = -1, S = u[y * e] >= l, R0[S << 2].forEach(A); ++g < e - 1; )
      C = S, S = u[y * e + g + 1] >= l, R0[S << 2 | C << 3].forEach(A);
    R0[S << 3].forEach(A);
    function A(O) {
      var R = [O[0][0] + g, O[0][1] + y], j = [O[1][0] + g, O[1][1] + y], $ = a(R), z = a(j), W, Y;
      (W = p[$]) ? (Y = h[z]) ? (delete p[W.end], delete h[Y.start], W === Y ? (W.ring.push(j), f(W.ring)) : h[W.start] = p[Y.end] = {
        start: W.start,
        end: Y.end,
        ring: W.ring.concat(Y.ring)
      }) : (delete p[W.end], W.ring.push(j), p[W.end = z] = W) : (W = h[z]) ? (Y = p[$]) ? (delete h[W.start], delete p[Y.end], W === Y ? (W.ring.push(j), f(W.ring)) : h[Y.start] = p[W.end] = {
        start: Y.start,
        end: W.end,
        ring: Y.ring.concat(W.ring)
      }) : (delete h[W.start], W.ring.unshift(R), h[W.start = $] = W) : h[$] = p[z] = {
        start: $,
        end: z,
        ring: [R, j]
      };
    }
  }
  function a(u) {
    return u[0] * 2 + u[1] * (e + 1) * 4;
  }
  function s(u, l, f) {
    u.forEach((h) => {
      var p = h[0], g = h[1], y = p | 0, b = g | 0, _, S = l[b * e + y];
      p > 0 && p < e && y === p && (_ = l[b * e + y - 1], h[0] = p + (f - _) / (S - _) - 0.5), g > 0 && g < t && b === g && (_ = l[(b - 1) * e + y], h[1] = g + (f - _) / (S - _) - 0.5);
    });
  }
  return r.contour = i, r.size = function(u) {
    if (!arguments.length)
      return [e, t];
    var l = Math.floor(u[0]), f = Math.floor(u[1]);
    return l >= 0 && f >= 0 || tt("invalid size"), e = l, t = f, r;
  }, r.smooth = function(u) {
    return arguments.length ? (n = u ? s : LMt, r) : n === s;
  }, r;
}
function zMt(e) {
  for (var t = 0, n = e.length, r = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; )
    r += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
  return r;
}
function FMt(e, t) {
  for (var n = -1, r = t.length, i; ++n < r; )
    if (i = BMt(e, t[n]))
      return i;
  return 0;
}
function BMt(e, t) {
  for (var n = t[0], r = t[1], i = -1, o = 0, a = e.length, s = a - 1; o < a; s = o++) {
    var u = e[o], l = u[0], f = u[1], h = e[s], p = h[0], g = h[1];
    if (UMt(u, h, t))
      return 0;
    f > r != g > r && n < (p - l) * (r - f) / (g - f) + l && (i = -i);
  }
  return i;
}
function UMt(e, t, n) {
  var r;
  return YMt(e, t, n) && HMt(e[r = +(e[0] === t[0])], n[r], t[r]);
}
function YMt(e, t, n) {
  return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
}
function HMt(e, t, n) {
  return e <= t && t <= n || n <= t && t <= e;
}
function GRe(e, t, n) {
  return function(r) {
    var i = Gy(r), o = n ? Math.min(i[0], 0) : i[0], a = i[1], s = a - o, u = t ? Zx(o, a, e) : s / (e + 1);
    return qo(o + u, a, u);
  };
}
function dne(e) {
  Ge.call(this, null, e);
}
dne.Definition = {
  type: "Isocontour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "levels",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "zero",
    type: "boolean",
    default: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }, {
    name: "scale",
    type: "number",
    expr: !0
  }, {
    name: "translate",
    type: "number",
    array: !0,
    expr: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    default: "contour"
  }]
};
Tt(dne, Ge, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = t.materialize(t.SOURCE).source, i = e.field || ql, o = qRe().smooth(e.smooth !== !1), a = e.thresholds || VMt(r, i, e), s = e.as === null ? null : e.as || "contour", u = [];
    return r.forEach((l) => {
      const f = i(l), h = o.size([f.width, f.height])(f.values, nt(a) ? a : a(f.values));
      WMt(h, f, l, e), h.forEach((p) => {
        u.push(N6(l, Ui(s != null ? {
          [s]: p
        } : p)));
      });
    }), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
  }
});
function VMt(e, t, n) {
  const r = GRe(n.levels || 10, n.nice, n.zero !== !1);
  return n.resolve !== "shared" ? r : r(e.map((i) => Ha(t(i).values)));
}
function WMt(e, t, n, r) {
  let i = r.scale || t.scale, o = r.translate || t.translate;
  if (pr(i) && (i = i(n, r)), pr(o) && (o = o(n, r)), (i === 1 || i == null) && !o)
    return;
  const a = (pi(i) ? i : i[0]) || 1, s = (pi(i) ? i : i[1]) || 1, u = o && o[0] || 0, l = o && o[1] || 0;
  e.forEach(QRe(t, a, s, u, l));
}
function QRe(e, t, n, r, i) {
  const o = e.x1 || 0, a = e.y1 || 0, s = t * n < 0;
  function u(h) {
    h.forEach(l);
  }
  function l(h) {
    s && h.reverse(), h.forEach(f);
  }
  function f(h) {
    h[0] = (h[0] - o) * t + r, h[1] = (h[1] - a) * n + i;
  }
  return function(h) {
    return h.coordinates.forEach(u), h;
  };
}
function ome(e, t, n) {
  const r = e >= 0 ? e : See(t, n);
  return Math.round((Math.sqrt(4 * r * r + 1) - 1) / 2);
}
function uV(e) {
  return pr(e) ? e : Gl(+e);
}
function XRe() {
  var e = (u) => u[0], t = (u) => u[1], n = SN, r = [-1, -1], i = 960, o = 500, a = 2;
  function s(u, l) {
    const f = ome(r[0], u, e) >> a, h = ome(r[1], u, t) >> a, p = f ? f + 2 : 0, g = h ? h + 2 : 0, y = 2 * p + (i >> a), b = 2 * g + (o >> a), _ = new Float32Array(y * b), S = new Float32Array(y * b);
    let C = _;
    u.forEach((O) => {
      const R = p + (+e(O) >> a), j = g + (+t(O) >> a);
      R >= 0 && R < y && j >= 0 && j < b && (_[R + j * y] += +n(O));
    }), f > 0 && h > 0 ? (GM(y, b, _, S, f), QM(y, b, S, _, h), GM(y, b, _, S, f), QM(y, b, S, _, h), GM(y, b, _, S, f), QM(y, b, S, _, h)) : f > 0 ? (GM(y, b, _, S, f), GM(y, b, S, _, f), GM(y, b, _, S, f), C = S) : h > 0 && (QM(y, b, _, S, h), QM(y, b, S, _, h), QM(y, b, _, S, h), C = S);
    const A = l ? Math.pow(2, -2 * a) : 1 / fp(C);
    for (let O = 0, R = y * b; O < R; ++O)
      C[O] *= A;
    return {
      values: C,
      scale: 1 << a,
      width: y,
      height: b,
      x1: p,
      y1: g,
      x2: p + (i >> a),
      y2: g + (o >> a)
    };
  }
  return s.x = function(u) {
    return arguments.length ? (e = uV(u), s) : e;
  }, s.y = function(u) {
    return arguments.length ? (t = uV(u), s) : t;
  }, s.weight = function(u) {
    return arguments.length ? (n = uV(u), s) : n;
  }, s.size = function(u) {
    if (!arguments.length)
      return [i, o];
    var l = +u[0], f = +u[1];
    return l >= 0 && f >= 0 || tt("invalid size"), i = l, o = f, s;
  }, s.cellSize = function(u) {
    return arguments.length ? ((u = +u) >= 1 || tt("invalid cell size"), a = Math.floor(Math.log(u) / Math.LN2), s) : 1 << a;
  }, s.bandwidth = function(u) {
    return arguments.length ? (u = Rt(u), u.length === 1 && (u = [+u[0], +u[0]]), u.length !== 2 && tt("invalid bandwidth"), r = u, s) : r;
  }, s;
}
function GM(e, t, n, r, i) {
  const o = (i << 1) + 1;
  for (let a = 0; a < t; ++a)
    for (let s = 0, u = 0; s < e + i; ++s)
      s < e && (u += n[s + a * e]), s >= i && (s >= o && (u -= n[s - o + a * e]), r[s - i + a * e] = u / Math.min(s + 1, e - 1 + o - s, o));
}
function QM(e, t, n, r, i) {
  const o = (i << 1) + 1;
  for (let a = 0; a < e; ++a)
    for (let s = 0, u = 0; s < t + i; ++s)
      s < t && (u += n[a + s * e]), s >= i && (s >= o && (u -= n[a + (s - o) * e]), r[a + (s - i) * e] = u / Math.min(s + 1, t - 1 + o - s, o));
}
function hne(e) {
  Ge.call(this, null, e);
}
hne.Definition = {
  type: "KDE2D",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: "grid"
  }]
};
const qMt = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function KRe(e, t) {
  return qMt.forEach((n) => t[n] != null ? e[n](t[n]) : 0), e;
}
Tt(hne, Ge, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = t.materialize(t.SOURCE).source, i = GMt(r, e.groupby), o = (e.groupby || []).map(Va), a = KRe(XRe(), e), s = e.as || "grid", u = [];
    function l(f, h) {
      for (let p = 0; p < o.length; ++p)
        f[o[p]] = h[p];
      return f;
    }
    return u = i.map((f) => Ui(l({
      [s]: a(f, e.counts)
    }, f.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
  }
});
function GMt(e, t) {
  var n = [], r = (f) => f(s), i, o, a, s, u, l;
  if (t == null)
    n.push(e);
  else
    for (i = {}, o = 0, a = e.length; o < a; ++o)
      s = e[o], u = t.map(r), l = i[u], l || (i[u] = l = [], l.dims = u, n.push(l)), l.push(s);
  return n;
}
function pne(e) {
  Ge.call(this, null, e);
}
pne.Definition = {
  type: "Contour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "values",
    type: "number",
    array: !0
  }, {
    name: "x",
    type: "field"
  }, {
    name: "y",
    type: "field"
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number"
  }, {
    name: "count",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }]
};
Tt(pne, Ge, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = qRe().smooth(e.smooth !== !1), i = e.values, o = e.thresholds || GRe(e.count || 10, e.nice, !!i), a = e.size, s, u;
    return i || (i = t.materialize(t.SOURCE).source, s = KRe(XRe(), e)(i, !0), u = QRe(s, s.scale || 1, s.scale || 1, 0, 0), a = [s.width, s.height], i = s.values), o = nt(o) ? o : o(i), i = r.size(a)(i, o), u && i.forEach(u), this.value && (n.rem = this.value), this.value = n.source = n.add = (i || []).map(Ui), n;
  }
});
const CQ = "Feature", gne = "FeatureCollection", QMt = "MultiPoint";
function mne(e) {
  Ge.call(this, null, e);
}
mne.Definition = {
  type: "GeoJSON",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    length: 2
  }, {
    name: "geojson",
    type: "field"
  }]
};
Tt(mne, Ge, {
  transform(e, t) {
    var n = this._features, r = this._points, i = e.fields, o = i && i[0], a = i && i[1], s = e.geojson || !i && ql, u = t.ADD, l;
    l = e.modified() || t.changed(t.REM) || t.modified(Yl(s)) || o && t.modified(Yl(o)) || a && t.modified(Yl(a)), (!this.value || l) && (u = t.SOURCE, this._features = n = [], this._points = r = []), s && t.visit(u, (f) => n.push(s(f))), o && a && (t.visit(u, (f) => {
      var h = o(f), p = a(f);
      h != null && p != null && (h = +h) === h && (p = +p) === p && r.push([h, p]);
    }), n = n.concat({
      type: CQ,
      geometry: {
        type: QMt,
        coordinates: r
      }
    })), this.value = {
      type: gne,
      features: n
    };
  }
});
function yne(e) {
  Ge.call(this, null, e);
}
yne.Definition = {
  type: "GeoPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
Tt(yne, Ge, {
  transform(e, t) {
    var n = t.fork(t.ALL), r = this.value, i = e.field || ql, o = e.as || "path", a = n.SOURCE;
    !r || e.modified() ? (this.value = r = WRe(e.projection), n.materialize().reflow()) : a = i === ql || t.modified(i.fields) ? n.ADD_MOD : n.ADD;
    const s = XMt(r, e.pointRadius);
    return n.visit(a, (u) => u[o] = r(i(u))), r.pointRadius(s), n.modifies(o);
  }
});
function XMt(e, t) {
  const n = e.pointRadius();
  return e.context(null), t != null && e.pointRadius(t), n;
}
function vne(e) {
  Ge.call(this, null, e);
}
vne.Definition = {
  type: "GeoPoint",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection",
    required: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["x", "y"]
  }]
};
Tt(vne, Ge, {
  transform(e, t) {
    var n = e.projection, r = e.fields[0], i = e.fields[1], o = e.as || ["x", "y"], a = o[0], s = o[1], u;
    function l(f) {
      const h = n([r(f), i(f)]);
      h ? (f[a] = h[0], f[s] = h[1]) : (f[a] = void 0, f[s] = void 0);
    }
    return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, l) : (u = t.modified(r.fields) || t.modified(i.fields), t.visit(u ? t.ADD_MOD : t.ADD, l)), t.modifies(o);
  }
});
function bne(e) {
  Ge.call(this, null, e);
}
bne.Definition = {
  type: "GeoShape",
  metadata: {
    modifies: !0,
    nomod: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field",
    default: "datum"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "shape"
  }]
};
Tt(bne, Ge, {
  transform(e, t) {
    var n = t.fork(t.ALL), r = this.value, i = e.as || "shape", o = n.ADD;
    return (!r || e.modified()) && (this.value = r = KMt(WRe(e.projection), e.field || yp("datum"), e.pointRadius), n.materialize().reflow(), o = n.SOURCE), n.visit(o, (a) => a[i] = r), n.modifies(i);
  }
});
function KMt(e, t, n) {
  const r = n == null ? (i) => e(t(i)) : (i) => {
    var o = e.pointRadius(), a = e.pointRadius(n)(t(i));
    return e.pointRadius(o), a;
  };
  return r.context = (i) => (e.context(i), r), r;
}
function xne(e) {
  Ge.call(this, [], e), this.generator = H2t();
}
xne.Definition = {
  type: "Graticule",
  metadata: {
    changes: !0,
    generates: !0
  },
  params: [{
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMajor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMinor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "step",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "stepMajor",
    type: "number",
    array: !0,
    length: 2,
    default: [90, 360]
  }, {
    name: "stepMinor",
    type: "number",
    array: !0,
    length: 2,
    default: [10, 10]
  }, {
    name: "precision",
    type: "number",
    default: 2.5
  }]
};
Tt(xne, Ge, {
  transform(e, t) {
    var n = this.value, r = this.generator, i;
    if (!n.length || e.modified())
      for (const o in e)
        pr(r[o]) && r[o](e[o]);
    return i = r(), n.length ? t.mod.push(cDe(n[0], i)) : t.add.push(Ui(i)), n[0] = i, t;
  }
});
function wne(e) {
  Ge.call(this, null, e);
}
wne.Definition = {
  type: "heatmap",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "color",
    type: "string",
    expr: !0
  }, {
    name: "opacity",
    type: "number",
    expr: !0
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "as",
    type: "string",
    default: "image"
  }]
};
Tt(wne, Ge, {
  transform(e, t) {
    if (!t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.materialize(t.SOURCE).source, r = e.resolve === "shared", i = e.field || ql, o = JMt(e.opacity, e), a = ZMt(e.color, e), s = e.as || "image", u = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: r ? Ha(n.map((l) => Ha(i(l).values))) : 0
    };
    return n.forEach((l) => {
      const f = i(l), h = hr({}, l, u);
      r || (h.$max = Ha(f.values || [])), l[s] = eTt(f, h, a.dep ? a : Gl(a(h)), o.dep ? o : Gl(o(h)));
    }), t.reflow(!0).modifies(s);
  }
});
function ZMt(e, t) {
  let n;
  return pr(e) ? (n = (r) => Cf(e(r, t)), n.dep = ZRe(e)) : n = Gl(Cf(e || "#888")), n;
}
function JMt(e, t) {
  let n;
  return pr(e) ? (n = (r) => e(r, t), n.dep = ZRe(e)) : e ? n = Gl(e) : (n = (r) => r.$value / r.$max || 0, n.dep = !0), n;
}
function ZRe(e) {
  if (!pr(e))
    return !1;
  const t = Wg(Yl(e));
  return t.$x || t.$y || t.$value || t.$max;
}
function eTt(e, t, n, r) {
  const i = e.width, o = e.height, a = e.x1 || 0, s = e.y1 || 0, u = e.x2 || i, l = e.y2 || o, f = e.values, h = f ? (_) => f[_] : wx, p = Bx(u - a, l - s), g = p.getContext("2d"), y = g.getImageData(0, 0, u - a, l - s), b = y.data;
  for (let _ = s, S = 0; _ < l; ++_) {
    t.$y = _ - s;
    for (let C = a, A = _ * i; C < u; ++C, S += 4) {
      t.$x = C - a, t.$value = h(C + A);
      const O = n(t);
      b[S + 0] = O.r, b[S + 1] = O.g, b[S + 2] = O.b, b[S + 3] = ~~(255 * r(t));
    }
  }
  return g.putImageData(y, 0, 0), p;
}
function JRe(e) {
  Ge.call(this, null, e), this.modified(!0);
}
Tt(JRe, Ge, {
  transform(e, t) {
    let n = this.value;
    return !n || e.modified("type") ? (this.value = n = nTt(e.type), TQ.forEach((r) => {
      e[r] != null && ame(n, r, e[r]);
    })) : TQ.forEach((r) => {
      e.modified(r) && ame(n, r, e[r]);
    }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && tTt(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function tTt(e, t) {
  const n = rTt(t.fit);
  t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n);
}
function nTt(e) {
  const t = fne((e || "mercator").toLowerCase());
  return t || tt("Unrecognized projection type: " + e), t();
}
function ame(e, t, n) {
  pr(e[t]) && e[t](n);
}
function rTt(e) {
  return e = Rt(e), e.length === 1 ? e[0] : {
    type: gne,
    features: e.reduce((t, n) => t.concat(iTt(n)), [])
  };
}
function iTt(e) {
  return e.type === gne ? e.features : Rt(e).filter((t) => t != null).map((t) => t.type === CQ ? t : {
    type: CQ,
    geometry: t
  });
}
const oTt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contour: pne,
  geojson: mne,
  geopath: yne,
  geopoint: vne,
  geoshape: bne,
  graticule: xne,
  heatmap: wne,
  isocontour: dne,
  kde2d: hne,
  projection: JRe
}, Symbol.toStringTag, { value: "Module" })), sme = {
  center: Mut,
  collide: Hut,
  nbody: tlt,
  link: Wut,
  x: nlt,
  y: rlt
}, tR = "forces", NQ = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], aTt = ["static", "iterations"], eke = ["x", "y", "vx", "vy"];
function _ne(e) {
  Ge.call(this, null, e);
}
_ne.Definition = {
  type: "Force",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "static",
    type: "boolean",
    default: !1
  }, {
    name: "restart",
    type: "boolean",
    default: !1
  }, {
    name: "iterations",
    type: "number",
    default: 300
  }, {
    name: "alpha",
    type: "number",
    default: 1
  }, {
    name: "alphaMin",
    type: "number",
    default: 1e-3
  }, {
    name: "alphaTarget",
    type: "number",
    default: 0
  }, {
    name: "velocityDecay",
    type: "number",
    default: 0.4
  }, {
    name: "forces",
    type: "param",
    array: !0,
    params: [{
      key: {
        force: "center"
      },
      params: [{
        name: "x",
        type: "number",
        default: 0
      }, {
        name: "y",
        type: "number",
        default: 0
      }]
    }, {
      key: {
        force: "collide"
      },
      params: [{
        name: "radius",
        type: "number",
        expr: !0
      }, {
        name: "strength",
        type: "number",
        default: 0.7
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "nbody"
      },
      params: [{
        name: "strength",
        type: "number",
        default: -30,
        expr: !0
      }, {
        name: "theta",
        type: "number",
        default: 0.9
      }, {
        name: "distanceMin",
        type: "number",
        default: 1
      }, {
        name: "distanceMax",
        type: "number"
      }]
    }, {
      key: {
        force: "link"
      },
      params: [{
        name: "links",
        type: "data"
      }, {
        name: "id",
        type: "field"
      }, {
        name: "distance",
        type: "number",
        default: 30,
        expr: !0
      }, {
        name: "strength",
        type: "number",
        expr: !0
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "x"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "x",
        type: "field"
      }]
    }, {
      key: {
        force: "y"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "y",
        type: "field"
      }]
    }]
  }, {
    name: "as",
    type: "string",
    array: !0,
    modify: !1,
    default: eke
  }]
};
Tt(_ne, Ge, {
  transform(e, t) {
    var n = this.value, r = t.changed(t.ADD_REM), i = e.modified(NQ), o = e.iterations || 300;
    if (n ? (r && (t.modifies("index"), n.nodes(t.source)), (i || t.changed(t.MOD)) && tke(n, e, 0, t)) : (this.value = n = uTt(t.source, e), n.on("tick", sTt(t.dataflow, this)), e.static || (r = !0, n.tick()), t.modifies("index")), i || r || e.modified(aTt) || t.changed() && e.restart) {
      if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / o)), e.static)
        for (n.stop(); --o >= 0; )
          n.tick();
      else if (n.stopped() && n.restart(), !r)
        return t.StopPropagation;
    }
    return this.finish(e, t);
  },
  finish(e, t) {
    const n = t.dataflow;
    for (let s = this._argops, u = 0, l = s.length, f; u < l; ++u)
      if (f = s[u], !(f.name !== tR || f.op._argval.force !== "link")) {
        for (var r = f.op._argops, i = 0, o = r.length, a; i < o; ++i)
          if (r[i].name === "links" && (a = r[i].op.source)) {
            n.pulse(a, n.changeset().reflow());
            break;
          }
      }
    return t.reflow(e.modified()).modifies(eke);
  }
});
function sTt(e, t) {
  return () => e.touch(t).run();
}
function uTt(e, t) {
  const n = elt(e), r = n.stop, i = n.restart;
  let o = !1;
  return n.stopped = () => o, n.restart = () => (o = !1, i()), n.stop = () => (o = !0, r()), tke(n, t, !0).on("end", () => o = !0);
}
function tke(e, t, n, r) {
  var i = Rt(t.forces), o, a, s, u;
  for (o = 0, a = NQ.length; o < a; ++o)
    s = NQ[o], s !== tR && t.modified(s) && e[s](t[s]);
  for (o = 0, a = i.length; o < a; ++o)
    u = tR + o, s = n || t.modified(tR, o) ? cTt(i[o]) : r && lTt(i[o], r) ? e.force(u) : null, s && e.force(u, s);
  for (a = e.numForces || 0; o < a; ++o)
    e.force(tR + o, null);
  return e.numForces = i.length, e;
}
function lTt(e, t) {
  var n, r;
  for (n in e)
    if (pr(r = e[n]) && t.modified(Yl(r)))
      return 1;
  return 0;
}
function cTt(e) {
  var t, n;
  wn(sme, e.force) || tt("Unrecognized force: " + e.force), t = sme[e.force]();
  for (n in e)
    pr(t[n]) && fTt(t[n], e[n], e);
  return t;
}
function fTt(e, t, n) {
  e(pr(t) ? (r) => t(r, n) : t);
}
const dTt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  force: _ne
}, Symbol.toStringTag, { value: "Module" }));
function DQ(e, t, n) {
  const r = {};
  return e.each((i) => {
    const o = i.data;
    n(o) && (r[t(o)] = i);
  }), e.lookup = r, e;
}
function Ene(e) {
  Ge.call(this, null, e);
}
Ene.Definition = {
  type: "Nest",
  metadata: {
    treesource: !0,
    changes: !0
  },
  params: [{
    name: "keys",
    type: "field",
    array: !0
  }, {
    name: "generate",
    type: "boolean"
  }]
};
const hTt = (e) => e.values;
Tt(Ene, Ge, {
  transform(e, t) {
    t.source || tt("Nest transform requires an upstream data source.");
    var n = e.generate, r = e.modified(), i = t.clone(), o = this.value;
    return (!o || r || t.changed()) && (o && o.each((a) => {
      a.children && C6(a.data) && i.rem.push(a.data);
    }), this.value = o = pZ({
      values: Rt(e.keys).reduce((a, s) => (a.key(s), a), pTt()).entries(i.source)
    }, hTt), n && o.each((a) => {
      a.children && (a = Ui(a.data), i.add.push(a), i.source.push(a));
    }), DQ(o, bn, bn)), i.source.root = o, i;
  }
});
function pTt() {
  const e = [], t = {
    entries: (i) => r(n(i, 0), 0),
    key: (i) => (e.push(i), t)
  };
  function n(i, o) {
    if (o >= e.length)
      return i;
    const a = i.length, s = e[o++], u = {}, l = {};
    let f = -1, h, p, g;
    for (; ++f < a; )
      h = s(p = i[f]) + "", (g = u[h]) ? g.push(p) : u[h] = [p];
    for (h in u)
      l[h] = n(u[h], o);
    return l;
  }
  function r(i, o) {
    if (++o > e.length)
      return i;
    const a = [];
    for (const s in i)
      a.push({
        key: s,
        values: r(i[s], o)
      });
    return a;
  }
  return t;
}
function Tb(e) {
  Ge.call(this, null, e);
}
const gTt = (e, t) => e.parent === t.parent ? 1 : 2;
Tt(Tb, Ge, {
  transform(e, t) {
    (!t.source || !t.source.root) && tt(this.constructor.name + " transform requires a backing tree data source.");
    const n = this.layout(e.method), r = this.fields, i = t.source.root, o = e.as || r;
    e.field ? i.sum(e.field) : i.count(), e.sort && i.sort(i2(e.sort, (a) => a.data)), mTt(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? gTt : SN);
    try {
      this.value = n(i);
    } catch (a) {
      tt(a);
    }
    return i.each((a) => yTt(a, r, o)), t.reflow(e.modified()).modifies(o).modifies("leaf");
  }
});
function mTt(e, t, n) {
  for (let r, i = 0, o = t.length; i < o; ++i)
    r = t[i], r in n && e[r](n[r]);
}
function yTt(e, t, n) {
  const r = e.data, i = t.length - 1;
  for (let o = 0; o < i; ++o)
    r[n[o]] = e[t[o]];
  r[n[i]] = e.children ? e.children.length : 0;
}
const AQ = ["x", "y", "r", "depth", "children"];
function Sne(e) {
  Tb.call(this, e);
}
Sne.Definition = {
  type: "Pack",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "radius",
    type: "field",
    default: null
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: AQ.length,
    default: AQ
  }]
};
Tt(Sne, Tb, {
  layout: Gct,
  params: ["radius", "size", "padding"],
  fields: AQ
});
const OQ = ["x0", "y0", "x1", "y1", "depth", "children"];
function Mne(e) {
  Tb.call(this, e);
}
Mne.Definition = {
  type: "Partition",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: OQ.length,
    default: OQ
  }]
};
Tt(Mne, Tb, {
  layout: Qct,
  params: ["size", "round", "padding"],
  fields: OQ
});
function Tne(e) {
  Ge.call(this, null, e);
}
Tne.Definition = {
  type: "Stratify",
  metadata: {
    treesource: !0
  },
  params: [{
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "parentKey",
    type: "field",
    required: !0
  }]
};
Tt(Tne, Ge, {
  transform(e, t) {
    t.source || tt("Stratify transform requires an upstream data source.");
    let n = this.value;
    const r = e.modified(), i = t.fork(t.ALL).materialize(t.SOURCE), o = !n || r || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
    return i.source = i.source.slice(), o && (n = i.source.length ? DQ(BL().id(e.key).parentId(e.parentKey)(i.source), e.key, vp) : DQ(BL()([{}]), e.key, e.key)), i.source.root = this.value = n, i;
  }
});
const ume = {
  tidy: Ok,
  cluster: hZ
}, RQ = ["x", "y", "depth", "children"];
function Cne(e) {
  Tb.call(this, e);
}
Cne.Definition = {
  type: "Tree",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "tidy",
    values: ["tidy", "cluster"]
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "nodeSize",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "separation",
    type: "boolean",
    default: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: RQ.length,
    default: RQ
  }]
};
Tt(Cne, Tb, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(e) {
    const t = e || "tidy";
    if (wn(ume, t))
      return ume[t]();
    tt("Unrecognized Tree layout method: " + t);
  },
  params: ["size", "nodeSize"],
  fields: RQ
});
function Nne(e) {
  Ge.call(this, [], e);
}
Nne.Definition = {
  type: "TreeLinks",
  metadata: {
    tree: !0,
    generates: !0,
    changes: !0
  },
  params: []
};
Tt(Nne, Ge, {
  transform(e, t) {
    const n = this.value, r = t.source && t.source.root, i = t.fork(t.NO_SOURCE), o = {};
    return r || tt("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (i.rem = n, t.visit(t.SOURCE, (a) => o[bn(a)] = 1), r.each((a) => {
      const s = a.data, u = a.parent && a.parent.data;
      u && o[bn(s)] && o[bn(u)] && i.add.push(Ui({
        source: u,
        target: s
      }));
    }), this.value = i.add) : t.changed(t.MOD) && (t.visit(t.MOD, (a) => o[bn(a)] = 1), n.forEach((a) => {
      (o[bn(a.source)] || o[bn(a.target)]) && i.mod.push(a);
    })), i;
  }
});
const lme = {
  binary: aft,
  dice: R$,
  slice: LF,
  slicedice: sft,
  squarify: uSe,
  resquarify: uft
}, kQ = ["x0", "y0", "x1", "y1", "depth", "children"];
function Dne(e) {
  Tb.call(this, e);
}
Dne.Definition = {
  type: "Treemap",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "squarify",
    values: ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "paddingInner",
    type: "number",
    default: 0
  }, {
    name: "paddingOuter",
    type: "number",
    default: 0
  }, {
    name: "paddingTop",
    type: "number",
    default: 0
  }, {
    name: "paddingRight",
    type: "number",
    default: 0
  }, {
    name: "paddingBottom",
    type: "number",
    default: 0
  }, {
    name: "paddingLeft",
    type: "number",
    default: 0
  }, {
    name: "ratio",
    type: "number",
    default: 1.618033988749895
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: kQ.length,
    default: kQ
  }]
};
Tt(Dne, Tb, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const e = oft();
    return e.ratio = (t) => {
      const n = e.tile();
      n.ratio && e.tile(n.ratio(t));
    }, e.method = (t) => {
      wn(lme, t) ? e.tile(lme[t]) : tt("Unrecognized Treemap layout method: " + t);
    }, e;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: kQ
});
const vTt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nest: Ene,
  pack: Sne,
  partition: Mne,
  stratify: Tne,
  tree: Cne,
  treelinks: Nne,
  treemap: Dne
}, Symbol.toStringTag, { value: "Module" })), lV = 4278190080;
function bTt(e, t) {
  const n = e.bitmap();
  return (t || []).forEach((r) => n.set(e(r.boundary[0]), e(r.boundary[3]))), [n, void 0];
}
function xTt(e, t, n, r, i) {
  const o = e.width, a = e.height, s = r || i, u = Bx(o, a).getContext("2d"), l = Bx(o, a).getContext("2d"), f = s && Bx(o, a).getContext("2d");
  n.forEach((z) => Sj(u, z, !1)), Sj(l, t, !1), s && Sj(f, t, !0);
  const h = cV(u, o, a), p = cV(l, o, a), g = s && cV(f, o, a), y = e.bitmap(), b = s && e.bitmap();
  let _, S, C, A, O, R, j, $;
  for (S = 0; S < a; ++S)
    for (_ = 0; _ < o; ++_)
      O = S * o + _, R = h[O] & lV, $ = p[O] & lV, j = s && g[O] & lV, (R || j || $) && (C = e(_), A = e(S), !i && (R || $) && y.set(C, A), s && (R || j) && b.set(C, A));
  return [y, b];
}
function cV(e, t, n) {
  return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer);
}
function Sj(e, t, n) {
  if (!t.length)
    return;
  const r = t[0].mark.marktype;
  r === "group" ? t.forEach((i) => {
    i.items.forEach((o) => Sj(e, o.items, n));
  }) : Hd[r].draw(e, {
    items: n ? t.map(wTt) : t
  });
}
function wTt(e) {
  const t = N6(e, {});
  return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
    ...t,
    strokeOpacity: 1,
    stroke: "#000",
    fillOpacity: 0
  } : t;
}
const k0 = 5, yc = 31, Zk = 32, px = new Uint32Array(Zk + 1), Tg = new Uint32Array(Zk + 1);
Tg[0] = 0;
px[0] = ~Tg[0];
for (let e = 1; e <= Zk; ++e)
  Tg[e] = Tg[e - 1] << 1 | 1, px[e] = ~Tg[e];
function _Tt(e, t) {
  const n = new Uint32Array(~~((e * t + Zk) / Zk));
  function r(o, a) {
    n[o] |= a;
  }
  function i(o, a) {
    n[o] &= a;
  }
  return {
    array: n,
    get: (o, a) => {
      const s = a * e + o;
      return n[s >>> k0] & 1 << (s & yc);
    },
    set: (o, a) => {
      const s = a * e + o;
      r(s >>> k0, 1 << (s & yc));
    },
    clear: (o, a) => {
      const s = a * e + o;
      i(s >>> k0, ~(1 << (s & yc)));
    },
    getRange: (o, a, s, u) => {
      let l = u, f, h, p, g;
      for (; l >= a; --l)
        if (f = l * e + o, h = l * e + s, p = f >>> k0, g = h >>> k0, p === g) {
          if (n[p] & px[f & yc] & Tg[(h & yc) + 1])
            return !0;
        } else {
          if (n[p] & px[f & yc] || n[g] & Tg[(h & yc) + 1])
            return !0;
          for (let y = p + 1; y < g; ++y)
            if (n[y])
              return !0;
        }
      return !1;
    },
    setRange: (o, a, s, u) => {
      let l, f, h, p, g;
      for (; a <= u; ++a)
        if (l = a * e + o, f = a * e + s, h = l >>> k0, p = f >>> k0, h === p)
          r(h, px[l & yc] & Tg[(f & yc) + 1]);
        else
          for (r(h, px[l & yc]), r(p, Tg[(f & yc) + 1]), g = h + 1; g < p; ++g)
            r(g, 4294967295);
    },
    clearRange: (o, a, s, u) => {
      let l, f, h, p, g;
      for (; a <= u; ++a)
        if (l = a * e + o, f = a * e + s, h = l >>> k0, p = f >>> k0, h === p)
          i(h, Tg[l & yc] | px[(f & yc) + 1]);
        else
          for (i(h, Tg[l & yc]), i(p, px[(f & yc) + 1]), g = h + 1; g < p; ++g)
            i(g, 0);
    },
    outOfBounds: (o, a, s, u) => o < 0 || a < 0 || u >= t || s >= e
  };
}
function ETt(e, t, n) {
  const r = Math.max(1, Math.sqrt(e * t / 1e6)), i = ~~((e + 2 * n + r) / r), o = ~~((t + 2 * n + r) / r), a = (s) => ~~((s + n) / r);
  return a.invert = (s) => s * r - n, a.bitmap = () => _Tt(i, o), a.ratio = r, a.padding = n, a.width = e, a.height = t, a;
}
function STt(e, t, n, r) {
  const i = e.width, o = e.height;
  return function(a) {
    const s = a.datum.datum.items[r].items, u = s.length, l = a.datum.fontSize, f = $d.width(a.datum, a.datum.text);
    let h = 0, p, g, y, b, _, S, C;
    for (let A = 0; A < u; ++A)
      p = s[A].x, y = s[A].y, g = s[A].x2 === void 0 ? p : s[A].x2, b = s[A].y2 === void 0 ? y : s[A].y2, _ = (p + g) / 2, S = (y + b) / 2, C = Math.abs(g - p + b - y), C >= h && (h = C, a.x = _, a.y = S);
    return _ = f / 2, S = l / 2, p = a.x - _, g = a.x + _, y = a.y - S, b = a.y + S, a.align = "center", p < 0 && g <= i ? a.align = "left" : 0 <= p && i < g && (a.align = "right"), a.baseline = "middle", y < 0 && b <= o ? a.baseline = "top" : 0 <= y && o < b && (a.baseline = "bottom"), !0;
  };
}
function tz(e, t, n, r, i, o) {
  let a = n / 2;
  return e - a < 0 || e + a > i || t - (a = r / 2) < 0 || t + a > o;
}
function Rx(e, t, n, r, i, o, a, s) {
  const u = i * o / (r * 2), l = e(t - u), f = e(t + u), h = e(n - (o = o / 2)), p = e(n + o);
  return a.outOfBounds(l, h, f, p) || a.getRange(l, h, f, p) || s && s.getRange(l, h, f, p);
}
function MTt(e, t, n, r) {
  const i = e.width, o = e.height, a = t[0], s = t[1];
  function u(l, f, h, p, g) {
    const y = e.invert(l), b = e.invert(f);
    let _ = h, S = o, C;
    if (!tz(y, b, p, g, i, o) && !Rx(e, y, b, g, p, _, a, s) && !Rx(e, y, b, g, p, g, a, null)) {
      for (; S - _ >= 1; )
        C = (_ + S) / 2, Rx(e, y, b, g, p, C, a, s) ? S = C : _ = C;
      if (_ > h)
        return [y, b, _, !0];
    }
  }
  return function(l) {
    const f = l.datum.datum.items[r].items, h = f.length, p = l.datum.fontSize, g = $d.width(l.datum, l.datum.text);
    let y = n ? p : 0, b = !1, _ = !1, S = 0, C, A, O, R, j, $, z, W, Y, V, ee, K, Q, q, te, X, Z;
    for (let se = 0; se < h; ++se) {
      for (C = f[se].x, O = f[se].y, A = f[se].x2 === void 0 ? C : f[se].x2, R = f[se].y2 === void 0 ? O : f[se].y2, C > A && (Z = C, C = A, A = Z), O > R && (Z = O, O = R, R = Z), Y = e(C), ee = e(A), V = ~~((Y + ee) / 2), K = e(O), q = e(R), Q = ~~((K + q) / 2), z = V; z >= Y; --z)
        for (W = Q; W >= K; --W)
          X = u(z, W, y, g, p), X && ([l.x, l.y, y, b] = X);
      for (z = V; z <= ee; ++z)
        for (W = Q; W <= q; ++W)
          X = u(z, W, y, g, p), X && ([l.x, l.y, y, b] = X);
      !b && !n && (te = Math.abs(A - C + R - O), j = (C + A) / 2, $ = (O + R) / 2, te >= S && !tz(j, $, g, p, i, o) && !Rx(e, j, $, p, g, p, a, null) && (S = te, l.x = j, l.y = $, _ = !0));
    }
    return b || _ ? (j = g / 2, $ = p / 2, a.setRange(e(l.x - j), e(l.y - $), e(l.x + j), e(l.y + $)), l.align = "center", l.baseline = "middle", !0) : !1;
  };
}
const TTt = [-1, -1, 1, 1], CTt = [-1, 1, -1, 1];
function NTt(e, t, n, r) {
  const i = e.width, o = e.height, a = t[0], s = t[1], u = e.bitmap();
  return function(l) {
    const f = l.datum.datum.items[r].items, h = f.length, p = l.datum.fontSize, g = $d.width(l.datum, l.datum.text), y = [];
    let b = n ? p : 0, _ = !1, S = !1, C = 0, A, O, R, j, $, z, W, Y, V, ee, K, Q;
    for (let q = 0; q < h; ++q) {
      for (A = f[q].x, R = f[q].y, O = f[q].x2 === void 0 ? A : f[q].x2, j = f[q].y2 === void 0 ? R : f[q].y2, y.push([e((A + O) / 2), e((R + j) / 2)]); y.length; )
        if ([W, Y] = y.pop(), !(a.get(W, Y) || s.get(W, Y) || u.get(W, Y))) {
          u.set(W, Y);
          for (let te = 0; te < 4; ++te)
            $ = W + TTt[te], z = Y + CTt[te], u.outOfBounds($, z, $, z) || y.push([$, z]);
          if ($ = e.invert(W), z = e.invert(Y), V = b, ee = o, !tz($, z, g, p, i, o) && !Rx(e, $, z, p, g, V, a, s) && !Rx(e, $, z, p, g, p, a, null)) {
            for (; ee - V >= 1; )
              K = (V + ee) / 2, Rx(e, $, z, p, g, K, a, s) ? ee = K : V = K;
            V > b && (l.x = $, l.y = z, b = V, _ = !0);
          }
        }
      !_ && !n && (Q = Math.abs(O - A + j - R), $ = (A + O) / 2, z = (R + j) / 2, Q >= C && !tz($, z, g, p, i, o) && !Rx(e, $, z, p, g, p, a, null) && (C = Q, l.x = $, l.y = z, S = !0));
    }
    return _ || S ? ($ = g / 2, z = p / 2, a.setRange(e(l.x - $), e(l.y - z), e(l.x + $), e(l.y + z)), l.align = "center", l.baseline = "middle", !0) : !1;
  };
}
const DTt = ["right", "center", "left"], ATt = ["bottom", "middle", "top"];
function OTt(e, t, n, r) {
  const i = e.width, o = e.height, a = t[0], s = t[1], u = r.length;
  return function(l) {
    const f = l.boundary, h = l.datum.fontSize;
    if (f[2] < 0 || f[5] < 0 || f[0] > i || f[3] > o)
      return !1;
    let p = l.textWidth ?? 0, g, y, b, _, S, C, A, O, R, j, $, z, W, Y, V;
    for (let ee = 0; ee < u; ++ee) {
      if (g = (n[ee] & 3) - 1, y = (n[ee] >>> 2 & 3) - 1, b = g === 0 && y === 0 || r[ee] < 0, _ = g && y ? Math.SQRT1_2 : 1, S = r[ee] < 0 ? -1 : 1, C = f[1 + g] + r[ee] * g * _, $ = f[4 + y] + S * h * y / 2 + r[ee] * y * _, O = $ - h / 2, R = $ + h / 2, z = e(C), Y = e(O), V = e(R), !p)
        if (cme(z, z, Y, V, a, s, C, C, O, R, f, b))
          p = $d.width(l.datum, l.datum.text);
        else
          continue;
      if (j = C + S * p * g / 2, C = j - p / 2, A = j + p / 2, z = e(C), W = e(A), cme(z, W, Y, V, a, s, C, A, O, R, f, b))
        return l.x = g ? g * S < 0 ? A : C : j, l.y = y ? y * S < 0 ? R : O : $, l.align = DTt[g * S + 1], l.baseline = ATt[y * S + 1], a.setRange(z, Y, W, V), !0;
    }
    return !1;
  };
}
function cme(e, t, n, r, i, o, a, s, u, l, f, h) {
  return !(i.outOfBounds(e, n, t, r) || (h && o || i).getRange(e, n, t, r));
}
const fV = 0, dV = 4, hV = 8, pV = 0, gV = 1, mV = 2, RTt = {
  "top-left": fV + pV,
  top: fV + gV,
  "top-right": fV + mV,
  left: dV + pV,
  middle: dV + gV,
  right: dV + mV,
  "bottom-left": hV + pV,
  bottom: hV + gV,
  "bottom-right": hV + mV
}, kTt = {
  naive: STt,
  "reduced-search": MTt,
  floodfill: NTt
};
function $Tt(e, t, n, r, i, o, a, s, u, l, f) {
  if (!e.length)
    return e;
  const h = Math.max(r.length, i.length), p = PTt(r, h), g = ITt(i, h), y = jTt(e[0].datum), b = y === "group" && e[0].datum.items[u].marktype, _ = b === "area", S = LTt(y, b, s, u), C = l === null || l === 1 / 0, A = _ && f === "naive";
  let O = -1, R = -1;
  const j = e.map((Y) => {
    const V = C ? $d.width(Y, Y.text) : void 0;
    return O = Math.max(O, V), R = Math.max(R, Y.fontSize), {
      datum: Y,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: S(Y),
      textWidth: V
    };
  });
  l = l === null || l === 1 / 0 ? Math.max(O, R) + Math.max(...r) : l;
  const $ = ETt(t[0], t[1], l);
  let z;
  if (!A) {
    n && j.sort((ee, K) => n(ee.datum, K.datum));
    let Y = !1;
    for (let ee = 0; ee < g.length && !Y; ++ee)
      Y = g[ee] === 5 || p[ee] < 0;
    const V = (y && a || _) && e.map((ee) => ee.datum);
    z = o.length || V ? xTt($, V || [], o, Y, _) : bTt($, a && j);
  }
  const W = _ ? kTt[f]($, z, a, u) : OTt($, z, g, p);
  return j.forEach((Y) => Y.opacity = +W(Y)), j;
}
function PTt(e, t) {
  const n = new Float64Array(t), r = e.length;
  for (let i = 0; i < r; ++i)
    n[i] = e[i] || 0;
  for (let i = r; i < t; ++i)
    n[i] = n[r - 1];
  return n;
}
function ITt(e, t) {
  const n = new Int8Array(t), r = e.length;
  for (let i = 0; i < r; ++i)
    n[i] |= RTt[e[i]];
  for (let i = r; i < t; ++i)
    n[i] = n[r - 1];
  return n;
}
function jTt(e) {
  return e && e.mark && e.mark.marktype;
}
function LTt(e, t, n, r) {
  const i = (o) => [o.x, o.x, o.x, o.y, o.y, o.y];
  return e ? e === "line" || e === "area" ? (o) => i(o.datum) : t === "line" ? (o) => {
    const a = o.datum.items[r].items;
    return i(a.length ? a[n === "start" ? 0 : a.length - 1] : {
      x: NaN,
      y: NaN
    });
  } : (o) => {
    const a = o.datum.bounds;
    return [a.x1, (a.x1 + a.x2) / 2, a.x2, a.y1, (a.y1 + a.y2) / 2, a.y2];
  } : i;
}
const $Q = ["x", "y", "opacity", "align", "baseline"], nke = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Ane(e) {
  Ge.call(this, null, e);
}
Ane.Definition = {
  type: "Label",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: !0,
    default: nke
  }, {
    name: "offset",
    type: "number",
    array: !0,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: !0
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: !0
  }, {
    name: "avoidMarks",
    type: "data",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: $Q.length,
    default: $Q
  }]
};
Tt(Ane, Ge, {
  transform(e, t) {
    function n(o) {
      const a = e[o];
      return pr(a) && t.modified(a.fields);
    }
    const r = e.modified();
    if (!(r || t.changed(t.ADD_REM) || n("sort")))
      return;
    (!e.size || e.size.length !== 2) && tt("Size parameter should be specified as a [width, height] array.");
    const i = e.as || $Q;
    return $Tt(t.materialize(t.SOURCE).source || [], e.size, e.sort, Rt(e.offset == null ? 1 : e.offset), Rt(e.anchor || nke), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((o) => {
      const a = o.datum;
      a[i[0]] = o.x, a[i[1]] = o.y, a[i[2]] = o.opacity, a[i[3]] = o.align, a[i[4]] = o.baseline;
    }), t.reflow(r).modifies(i);
  }
});
const zTt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label: Ane
}, Symbol.toStringTag, { value: "Module" }));
function rke(e, t) {
  var n = [], r = function(f) {
    return f(s);
  }, i, o, a, s, u, l;
  if (t == null)
    n.push(e);
  else
    for (i = {}, o = 0, a = e.length; o < a; ++o)
      s = e[o], u = t.map(r), l = i[u], l || (i[u] = l = [], l.dims = u, n.push(l)), l.push(s);
  return n;
}
function One(e) {
  Ge.call(this, null, e);
}
One.Definition = {
  type: "Loess",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "bandwidth",
    type: "number",
    default: 0.3
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
Tt(One, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const r = t.materialize(t.SOURCE).source, i = rke(r, e.groupby), o = (e.groupby || []).map(Va), a = o.length, s = e.as || [Va(e.x), Va(e.y)], u = [];
      i.forEach((l) => {
        NDe(l, e.x, e.y, e.bandwidth || 0.3).forEach((f) => {
          const h = {};
          for (let p = 0; p < a; ++p)
            h[o[p]] = l.dims[p];
          h[s[0]] = f[0], h[s[1]] = f[1], u.push(Ui(h));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = u;
    }
    return n;
  }
});
const PQ = {
  constant: Iee,
  linear: jee,
  log: SDe,
  exp: MDe,
  pow: TDe,
  quad: Lee,
  poly: CDe
}, FTt = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
function Rne(e) {
  Ge.call(this, null, e);
}
Rne.Definition = {
  type: "Regression",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "linear",
    values: Object.keys(PQ)
  }, {
    name: "order",
    type: "number",
    default: 3
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "params",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
Tt(Rne, Ge, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const r = t.materialize(t.SOURCE).source, i = rke(r, e.groupby), o = (e.groupby || []).map(Va), a = e.method || "linear", s = e.order == null ? 3 : e.order, u = FTt(a, s), l = e.as || [Va(e.x), Va(e.y)], f = PQ[a], h = [];
      let p = e.extent;
      wn(PQ, a) || tt("Invalid regression method: " + a), p != null && a === "log" && p[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), p = null), i.forEach((g) => {
        if (g.length <= u) {
          t.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const b = f(g, e.x, e.y, s);
        if (e.params) {
          h.push(Ui({
            keys: g.dims,
            coef: b.coef,
            rSquared: b.rSquared
          }));
          return;
        }
        const _ = p || Gy(g, e.x), S = (C) => {
          const A = {};
          for (let O = 0; O < o.length; ++O)
            A[o[O]] = g.dims[O];
          A[l[0]] = C[0], A[l[1]] = C[1], h.push(Ui(A));
        };
        a === "linear" || a === "constant" ? _.forEach((C) => S([C, b.predict(C)])) : P6(b.predict, _, 25, 200).forEach(S);
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = h;
    }
    return n;
  }
});
const BTt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loess: One,
  regression: Rne
}, Symbol.toStringTag, { value: "Module" }));
function kne(e) {
  Ge.call(this, null, e);
}
kne.Definition = {
  type: "Voronoi",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    default: [[-1e5, -1e5], [1e5, 1e5]],
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
const UTt = [-1e5, -1e5, 1e5, 1e5];
Tt(kne, Ge, {
  transform(e, t) {
    const n = e.as || "path", r = t.source;
    if (!r || !r.length)
      return t;
    let i = e.size;
    i = i ? [0, 0, i[0], i[1]] : (i = e.extent) ? [i[0][0], i[0][1], i[1][0], i[1][1]] : UTt;
    const o = this.value = wb.from(r, e.x, e.y).voronoi(i);
    for (let a = 0, s = r.length; a < s; ++a) {
      const u = o.cellPolygon(a);
      r[a][n] = u && !HTt(u) ? YTt(u) : null;
    }
    return t.reflow(e.modified()).modifies(n);
  }
});
function YTt(e) {
  const t = e[0][0], n = e[0][1];
  let r = e.length - 1;
  for (; e[r][0] === t && e[r][1] === n; --r)
    ;
  return "M" + e.slice(0, r + 1).join("L") + "Z";
}
function HTt(e) {
  return e.length === 2 && e[0][0] === e[1][0] && e[0][1] === e[1][1];
}
const VTt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  voronoi: kne
}, Symbol.toStringTag, { value: "Module" }));
var yV = Math.PI / 180, nR = 64, Mj = 2048;
function WTt() {
  var e = [256, 256], t, n, r, i, o, a, s, u = ike, l = [], f = Math.random, h = {};
  h.layout = function() {
    for (var y = p(Bx()), b = ZTt((e[0] >> 5) * e[1]), _ = null, S = l.length, C = -1, A = [], O = l.map((j) => ({
      text: t(j),
      font: n(j),
      style: i(j),
      weight: o(j),
      rotate: a(j),
      size: ~~(r(j) + 1e-14),
      padding: s(j),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: !1,
      sprite: null,
      datum: j
    })).sort((j, $) => $.size - j.size); ++C < S; ) {
      var R = O[C];
      R.x = e[0] * (f() + 0.5) >> 1, R.y = e[1] * (f() + 0.5) >> 1, qTt(y, R, O, C), R.hasText && g(b, R, _) && (A.push(R), _ ? QTt(_, R) : _ = [{
        x: R.x + R.x0,
        y: R.y + R.y0
      }, {
        x: R.x + R.x1,
        y: R.y + R.y1
      }], R.x -= e[0] >> 1, R.y -= e[1] >> 1);
    }
    return A;
  };
  function p(y) {
    y.width = y.height = 1;
    var b = Math.sqrt(y.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    y.width = (nR << 5) / b, y.height = Mj / b;
    var _ = y.getContext("2d");
    return _.fillStyle = _.strokeStyle = "red", _.textAlign = "center", {
      context: _,
      ratio: b
    };
  }
  function g(y, b, _) {
    for (var S = b.x, C = b.y, A = Math.sqrt(e[0] * e[0] + e[1] * e[1]), O = u(e), R = f() < 0.5 ? 1 : -1, j = -R, $, z, W; ($ = O(j += R)) && (z = ~~$[0], W = ~~$[1], !(Math.min(Math.abs(z), Math.abs(W)) >= A)); )
      if (b.x = S + z, b.y = C + W, !(b.x + b.x0 < 0 || b.y + b.y0 < 0 || b.x + b.x1 > e[0] || b.y + b.y1 > e[1]) && (!_ || !GTt(b, y, e[0])) && (!_ || XTt(b, _))) {
        for (var Y = b.sprite, V = b.width >> 5, ee = e[0] >> 5, K = b.x - (V << 4), Q = K & 127, q = 32 - Q, te = b.y1 - b.y0, X = (b.y + b.y0) * ee + (K >> 5), Z, se = 0; se < te; se++) {
          Z = 0;
          for (var H = 0; H <= V; H++)
            y[X + H] |= Z << q | (H < V ? (Z = Y[se * V + H]) >>> Q : 0);
          X += ee;
        }
        return b.sprite = null, !0;
      }
    return !1;
  }
  return h.words = function(y) {
    return arguments.length ? (l = y, h) : l;
  }, h.size = function(y) {
    return arguments.length ? (e = [+y[0], +y[1]], h) : e;
  }, h.font = function(y) {
    return arguments.length ? (n = fE(y), h) : n;
  }, h.fontStyle = function(y) {
    return arguments.length ? (i = fE(y), h) : i;
  }, h.fontWeight = function(y) {
    return arguments.length ? (o = fE(y), h) : o;
  }, h.rotate = function(y) {
    return arguments.length ? (a = fE(y), h) : a;
  }, h.text = function(y) {
    return arguments.length ? (t = fE(y), h) : t;
  }, h.spiral = function(y) {
    return arguments.length ? (u = JTt[y] || y, h) : u;
  }, h.fontSize = function(y) {
    return arguments.length ? (r = fE(y), h) : r;
  }, h.padding = function(y) {
    return arguments.length ? (s = fE(y), h) : s;
  }, h.random = function(y) {
    return arguments.length ? (f = y, h) : f;
  }, h;
}
function qTt(e, t, n, r) {
  if (!t.sprite) {
    var i = e.context, o = e.ratio;
    i.clearRect(0, 0, (nR << 5) / o, Mj / o);
    var a = 0, s = 0, u = 0, l = n.length, f, h, p, g, y;
    for (--r; ++r < l; ) {
      if (t = n[r], i.save(), i.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / o) + "px " + t.font, f = i.measureText(t.text + "m").width * o, p = t.size << 1, t.rotate) {
        var b = Math.sin(t.rotate * yV), _ = Math.cos(t.rotate * yV), S = f * _, C = f * b, A = p * _, O = p * b;
        f = Math.max(Math.abs(S + O), Math.abs(S - O)) + 31 >> 5 << 5, p = ~~Math.max(Math.abs(C + A), Math.abs(C - A));
      } else
        f = f + 31 >> 5 << 5;
      if (p > u && (u = p), a + f >= nR << 5 && (a = 0, s += u, u = 0), s + p >= Mj)
        break;
      i.translate((a + (f >> 1)) / o, (s + (p >> 1)) / o), t.rotate && i.rotate(t.rotate * yV), i.fillText(t.text, 0, 0), t.padding && (i.lineWidth = 2 * t.padding, i.strokeText(t.text, 0, 0)), i.restore(), t.width = f, t.height = p, t.xoff = a, t.yoff = s, t.x1 = f >> 1, t.y1 = p >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += f;
    }
    for (var R = i.getImageData(0, 0, (nR << 5) / o, Mj / o).data, j = []; --r >= 0; )
      if (t = n[r], !!t.hasText) {
        for (f = t.width, h = f >> 5, p = t.y1 - t.y0, g = 0; g < p * h; g++)
          j[g] = 0;
        if (a = t.xoff, a == null)
          return;
        s = t.yoff;
        var $ = 0, z = -1;
        for (y = 0; y < p; y++) {
          for (g = 0; g < f; g++) {
            var W = h * y + (g >> 5), Y = R[(s + y) * (nR << 5) + (a + g) << 2] ? 1 << 31 - g % 32 : 0;
            j[W] |= Y, $ |= Y;
          }
          $ ? z = y : (t.y0++, p--, y--, s++);
        }
        t.y1 = t.y0 + z, t.sprite = j.slice(0, (t.y1 - t.y0) * h);
      }
  }
}
function GTt(e, t, n) {
  n >>= 5;
  for (var r = e.sprite, i = e.width >> 5, o = e.x - (i << 4), a = o & 127, s = 32 - a, u = e.y1 - e.y0, l = (e.y + e.y0) * n + (o >> 5), f, h = 0; h < u; h++) {
    f = 0;
    for (var p = 0; p <= i; p++)
      if ((f << s | (p < i ? (f = r[h * i + p]) >>> a : 0)) & t[l + p])
        return !0;
    l += n;
  }
  return !1;
}
function QTt(e, t) {
  var n = e[0], r = e[1];
  t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > r.x && (r.x = t.x + t.x1), t.y + t.y1 > r.y && (r.y = t.y + t.y1);
}
function XTt(e, t) {
  return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
}
function ike(e) {
  var t = e[0] / e[1];
  return function(n) {
    return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
  };
}
function KTt(e) {
  var t = 4, n = t * e[0] / e[1], r = 0, i = 0;
  return function(o) {
    var a = o < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * a * o) - a & 3) {
      case 0:
        r += n;
        break;
      case 1:
        i += t;
        break;
      case 2:
        r -= n;
        break;
      default:
        i -= t;
        break;
    }
    return [r, i];
  };
}
function ZTt(e) {
  for (var t = [], n = -1; ++n < e; )
    t[n] = 0;
  return t;
}
function fE(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
var JTt = {
  archimedean: ike,
  rectangular: KTt
};
const oke = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"], eCt = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function $ne(e) {
  Ge.call(this, WTt(), e);
}
$ne.Definition = {
  type: "Wordcloud",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "font",
    type: "string",
    expr: !0,
    default: "sans-serif"
  }, {
    name: "fontStyle",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontWeight",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontSize",
    type: "number",
    expr: !0,
    default: 14
  }, {
    name: "fontSizeRange",
    type: "number",
    array: "nullable",
    default: [10, 50]
  }, {
    name: "rotate",
    type: "number",
    expr: !0,
    default: 0
  }, {
    name: "text",
    type: "field"
  }, {
    name: "spiral",
    type: "string",
    values: ["archimedean", "rectangular"]
  }, {
    name: "padding",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 7,
    default: oke
  }]
};
Tt($ne, Ge, {
  transform(e, t) {
    e.size && !(e.size[0] && e.size[1]) && tt("Wordcloud size dimensions must be non-zero.");
    function n(y) {
      const b = e[y];
      return pr(b) && t.modified(b.fields);
    }
    const r = e.modified();
    if (!(r || t.changed(t.ADD_REM) || eCt.some(n)))
      return;
    const i = t.materialize(t.SOURCE).source, o = this.value, a = e.as || oke;
    let s = e.fontSize || 14, u;
    if (pr(s) ? u = e.fontSizeRange : s = Gl(s), u) {
      const y = s, b = Di("sqrt")().domain(Gy(i, y)).range(u);
      s = (_) => b(y(_));
    }
    i.forEach((y) => {
      y[a[0]] = NaN, y[a[1]] = NaN, y[a[3]] = 0;
    });
    const l = o.words(i).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(s).random(xp).layout(), f = o.size(), h = f[0] >> 1, p = f[1] >> 1, g = l.length;
    for (let y = 0, b, _; y < g; ++y)
      b = l[y], _ = b.datum, _[a[0]] = b.x + h, _[a[1]] = b.y + p, _[a[2]] = b.font, _[a[3]] = b.size, _[a[4]] = b.style, _[a[5]] = b.weight, _[a[6]] = b.rotate;
    return t.reflow(r).modifies(a);
  }
});
const tCt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  wordcloud: $ne
}, Symbol.toStringTag, { value: "Module" })), nCt = (e) => new Uint8Array(e), rCt = (e) => new Uint16Array(e), YR = (e) => new Uint32Array(e);
function iCt() {
  let e = 8, t = [], n = YR(0), r = A3(0, e), i = A3(0, e);
  return {
    data: () => t,
    seen: () => n = oCt(n, t.length),
    add(o) {
      for (let a = 0, s = t.length, u = o.length, l; a < u; ++a)
        l = o[a], l._index = s++, t.push(l);
    },
    remove(o, a) {
      const s = t.length, u = Array(s - o), l = t;
      let f, h, p;
      for (h = 0; !a[h] && h < s; ++h)
        u[h] = t[h], l[h] = h;
      for (p = h; h < s; ++h)
        f = t[h], a[h] ? l[h] = -1 : (l[h] = p, r[p] = r[h], i[p] = i[h], u[p] = f, f._index = p++), r[h] = 0;
      return t = u, l;
    },
    size: () => t.length,
    curr: () => r,
    prev: () => i,
    reset: (o) => i[o] = r[o],
    all: () => e < 257 ? 255 : e < 65537 ? 65535 : 4294967295,
    set(o, a) {
      r[o] |= a;
    },
    clear(o, a) {
      r[o] &= ~a;
    },
    resize(o, a) {
      const s = r.length;
      (o > s || a > e) && (e = Math.max(a, e), r = A3(o, e, r), i = A3(o, e));
    }
  };
}
function oCt(e, t, n) {
  return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n);
}
function A3(e, t, n) {
  const r = (t < 257 ? nCt : t < 65537 ? rCt : YR)(e);
  return n && r.set(n), r;
}
function fme(e, t, n) {
  const r = 1 << t;
  return {
    one: r,
    zero: ~r,
    range: n.slice(),
    bisect: e.bisect,
    index: e.index,
    size: e.size,
    onAdd(i, o) {
      const a = this, s = a.bisect(a.range, i.value), u = i.index, l = s[0], f = s[1], h = u.length;
      let p;
      for (p = 0; p < l; ++p)
        o[u[p]] |= r;
      for (p = f; p < h; ++p)
        o[u[p]] |= r;
      return a;
    }
  };
}
function dme() {
  let e = YR(0), t = [], n = 0;
  function r(s, u, l) {
    if (!u.length)
      return [];
    const f = n, h = u.length, p = YR(h);
    let g = Array(h), y, b, _;
    for (_ = 0; _ < h; ++_)
      g[_] = s(u[_]), p[_] = _;
    if (g = aCt(g, p), f)
      y = t, b = e, t = Array(f + h), e = YR(f + h), sCt(l, y, b, f, g, p, h, t, e);
    else {
      if (l > 0)
        for (_ = 0; _ < h; ++_)
          p[_] += l;
      t = g, e = p;
    }
    return n = f + h, {
      index: p,
      value: g
    };
  }
  function i(s, u) {
    const l = n;
    let f, h, p;
    for (h = 0; !u[e[h]] && h < l; ++h)
      ;
    for (p = h; h < l; ++h)
      u[f = e[h]] || (e[p] = f, t[p] = t[h], ++p);
    n = l - s;
  }
  function o(s) {
    for (let u = 0, l = n; u < l; ++u)
      e[u] = s[e[u]];
  }
  function a(s, u) {
    let l;
    return u ? l = u.length : (u = t, l = n), [Irt(u, s[0], 0, l), aL(u, s[1], 0, l)];
  }
  return {
    insert: r,
    remove: i,
    bisect: a,
    reindex: o,
    index: () => e,
    size: () => n
  };
}
function aCt(e, t) {
  return e.sort.call(t, (n, r) => {
    const i = e[n], o = e[r];
    return i < o ? -1 : i > o ? 1 : 0;
  }), f_e(e, t);
}
function sCt(e, t, n, r, i, o, a, s, u) {
  let l = 0, f = 0, h;
  for (h = 0; l < r && f < a; ++h)
    t[l] < i[f] ? (s[h] = t[l], u[h] = n[l++]) : (s[h] = i[f], u[h] = o[f++] + e);
  for (; l < r; ++l, ++h)
    s[h] = t[l], u[h] = n[l];
  for (; f < a; ++f, ++h)
    s[h] = i[f], u[h] = o[f] + e;
}
function Pne(e) {
  Ge.call(this, iCt(), e), this._indices = null, this._dims = null;
}
Pne.Definition = {
  type: "CrossFilter",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "query",
    type: "array",
    array: !0,
    required: !0,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }]
};
Tt(Pne, Ge, {
  transform(e, t) {
    if (this._dims) {
      var n = e.modified("fields") || e.fields.some((r) => t.modified(r.fields));
      return n ? this.reinit(e, t) : this.eval(e, t);
    } else
      return this.init(e, t);
  },
  init(e, t) {
    const n = e.fields, r = e.query, i = this._indices = {}, o = this._dims = [], a = r.length;
    let s = 0, u, l;
    for (; s < a; ++s)
      u = n[s].fname, l = i[u] || (i[u] = dme()), o.push(fme(l, s, r[s]));
    return this.eval(e, t);
  },
  reinit(e, t) {
    const n = t.materialize().fork(), r = e.fields, i = e.query, o = this._indices, a = this._dims, s = this.value, u = s.curr(), l = s.prev(), f = s.all(), h = n.rem = n.add, p = n.mod, g = i.length, y = {};
    let b, _, S, C, A, O, R, j, $;
    if (l.set(u), t.rem.length && (A = this.remove(e, t, n)), t.add.length && s.add(t.add), t.mod.length)
      for (O = {}, C = t.mod, R = 0, j = C.length; R < j; ++R)
        O[C[R]._index] = 1;
    for (R = 0; R < g; ++R)
      $ = r[R], (!a[R] || e.modified("fields", R) || t.modified($.fields)) && (S = $.fname, (b = y[S]) || (o[S] = _ = dme(), y[S] = b = _.insert($, t.source, 0)), a[R] = fme(_, R, i[R]).onAdd(b, u));
    for (R = 0, j = s.data().length; R < j; ++R)
      A[R] || (l[R] !== u[R] ? h.push(R) : O[R] && u[R] !== f && p.push(R));
    return s.mask = (1 << g) - 1, n;
  },
  eval(e, t) {
    const n = t.materialize().fork(), r = this._dims.length;
    let i = 0;
    return t.rem.length && (this.remove(e, t, n), i |= (1 << r) - 1), e.modified("query") && !e.modified("fields") && (i |= this.update(e, t, n)), t.add.length && (this.insert(e, t, n), i |= (1 << r) - 1), t.mod.length && (this.modify(t, n), i |= (1 << r) - 1), this.value.mask = i, n;
  },
  insert(e, t, n) {
    const r = t.add, i = this.value, o = this._dims, a = this._indices, s = e.fields, u = {}, l = n.add, f = i.size() + r.length, h = o.length;
    let p = i.size(), g, y, b;
    i.resize(f, h), i.add(r);
    const _ = i.curr(), S = i.prev(), C = i.all();
    for (g = 0; g < h; ++g)
      y = s[g].fname, b = u[y] || (u[y] = a[y].insert(s[g], r, p)), o[g].onAdd(b, _);
    for (; p < f; ++p)
      S[p] = C, _[p] !== C && l.push(p);
  },
  modify(e, t) {
    const n = t.mod, r = this.value, i = r.curr(), o = r.all(), a = e.mod;
    let s, u, l;
    for (s = 0, u = a.length; s < u; ++s)
      l = a[s]._index, i[l] !== o && n.push(l);
  },
  remove(e, t, n) {
    const r = this._indices, i = this.value, o = i.curr(), a = i.prev(), s = i.all(), u = {}, l = n.rem, f = t.rem;
    let h, p, g, y;
    for (h = 0, p = f.length; h < p; ++h)
      g = f[h]._index, u[g] = 1, a[g] = y = o[g], o[g] = s, y !== s && l.push(g);
    for (g in r)
      r[g].remove(p, u);
    return this.reindex(t, p, u), u;
  },
  // reindex filters and indices after propagation completes
  reindex(e, t, n) {
    const r = this._indices, i = this.value;
    e.runAfter(() => {
      const o = i.remove(t, n);
      for (const a in r)
        r[a].reindex(o);
    });
  },
  update(e, t, n) {
    const r = this._dims, i = e.query, o = t.stamp, a = r.length;
    let s = 0, u, l;
    for (n.filters = 0, l = 0; l < a; ++l)
      e.modified("query", l) && (u = l, ++s);
    if (s === 1)
      s = r[u].one, this.incrementOne(r[u], i[u], n.add, n.rem);
    else
      for (l = 0, s = 0; l < a; ++l)
        e.modified("query", l) && (s |= r[l].one, this.incrementAll(r[l], i[l], o, n.add), n.rem = n.add);
    return s;
  },
  incrementAll(e, t, n, r) {
    const i = this.value, o = i.seen(), a = i.curr(), s = i.prev(), u = e.index(), l = e.bisect(e.range), f = e.bisect(t), h = f[0], p = f[1], g = l[0], y = l[1], b = e.one;
    let _, S, C;
    if (h < g)
      for (_ = h, S = Math.min(g, p); _ < S; ++_)
        C = u[_], o[C] !== n && (s[C] = a[C], o[C] = n, r.push(C)), a[C] ^= b;
    else if (h > g)
      for (_ = g, S = Math.min(h, y); _ < S; ++_)
        C = u[_], o[C] !== n && (s[C] = a[C], o[C] = n, r.push(C)), a[C] ^= b;
    if (p > y)
      for (_ = Math.max(h, y), S = p; _ < S; ++_)
        C = u[_], o[C] !== n && (s[C] = a[C], o[C] = n, r.push(C)), a[C] ^= b;
    else if (p < y)
      for (_ = Math.max(g, p), S = y; _ < S; ++_)
        C = u[_], o[C] !== n && (s[C] = a[C], o[C] = n, r.push(C)), a[C] ^= b;
    e.range = t.slice();
  },
  incrementOne(e, t, n, r) {
    const i = this.value, o = i.curr(), a = e.index(), s = e.bisect(e.range), u = e.bisect(t), l = u[0], f = u[1], h = s[0], p = s[1], g = e.one;
    let y, b, _;
    if (l < h)
      for (y = l, b = Math.min(h, f); y < b; ++y)
        _ = a[y], o[_] ^= g, n.push(_);
    else if (l > h)
      for (y = h, b = Math.min(l, p); y < b; ++y)
        _ = a[y], o[_] ^= g, r.push(_);
    if (f > p)
      for (y = Math.max(l, p), b = f; y < b; ++y)
        _ = a[y], o[_] ^= g, n.push(_);
    else if (f < p)
      for (y = Math.max(h, f), b = p; y < b; ++y)
        _ = a[y], o[_] ^= g, r.push(_);
    e.range = t.slice();
  }
});
function Ine(e) {
  Ge.call(this, null, e);
}
Ine.Definition = {
  type: "ResolveFilter",
  metadata: {},
  params: [{
    name: "ignore",
    type: "number",
    required: !0,
    description: "A bit mask indicating which filters to ignore."
  }, {
    name: "filter",
    type: "object",
    required: !0,
    description: "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
Tt(Ine, Ge, {
  transform(e, t) {
    const n = ~(e.ignore || 0), r = e.filter, i = r.mask;
    if (!(i & n))
      return t.StopPropagation;
    const o = t.fork(t.ALL), a = r.data(), s = r.curr(), u = r.prev(), l = (f) => s[f] & n ? null : a[f];
    return o.filter(o.MOD, l), i & i - 1 ? (o.filter(o.ADD, (f) => {
      const h = s[f] & n;
      return !h && h ^ u[f] & n ? a[f] : null;
    }), o.filter(o.REM, (f) => {
      const h = s[f] & n;
      return h && !(h ^ (h ^ u[f] & n)) ? a[f] : null;
    })) : (o.filter(o.ADD, l), o.filter(o.REM, (f) => (s[f] & n) === i ? a[f] : null)), o.filter(o.SOURCE, (f) => l(f._index));
  }
});
const uCt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crossfilter: Pne,
  resolvefilter: Ine
}, Symbol.toStringTag, { value: "Module" })), lCt = "RawCode", IS = "Literal", cCt = "Property", fCt = "Identifier", dCt = "ArrayExpression", hCt = "BinaryExpression", ake = "CallExpression", pCt = "ConditionalExpression", gCt = "LogicalExpression", mCt = "MemberExpression", yCt = "ObjectExpression", vCt = "UnaryExpression";
function tm(e) {
  this.type = e;
}
tm.prototype.visit = function(e) {
  let t, n, r;
  if (e(this))
    return 1;
  for (t = bCt(this), n = 0, r = t.length; n < r; ++n)
    if (t[n].visit(e))
      return 1;
};
function bCt(e) {
  switch (e.type) {
    case dCt:
      return e.elements;
    case hCt:
    case gCt:
      return [e.left, e.right];
    case ake:
      return [e.callee].concat(e.arguments);
    case pCt:
      return [e.test, e.consequent, e.alternate];
    case mCt:
      return [e.object, e.property];
    case yCt:
      return e.properties;
    case cCt:
      return [e.key, e.value];
    case vCt:
      return [e.argument];
    case fCt:
    case IS:
    case lCt:
    default:
      return [];
  }
}
var cv, en, et, Vl, io, n8 = 1, y4 = 2, jS = 3, Iw = 4, r8 = 5, s2 = 6, gf = 7, v4 = 8, xCt = 9;
cv = {};
cv[n8] = "Boolean";
cv[y4] = "<end>";
cv[jS] = "Identifier";
cv[Iw] = "Keyword";
cv[r8] = "Null";
cv[s2] = "Numeric";
cv[gf] = "Punctuator";
cv[v4] = "String";
cv[xCt] = "RegularExpression";
var wCt = "ArrayExpression", _Ct = "BinaryExpression", ECt = "CallExpression", SCt = "ConditionalExpression", ske = "Identifier", MCt = "Literal", TCt = "LogicalExpression", CCt = "MemberExpression", NCt = "ObjectExpression", DCt = "Property", ACt = "UnaryExpression", mu = "Unexpected token %0", OCt = "Unexpected number", RCt = "Unexpected string", kCt = "Unexpected identifier", $Ct = "Unexpected reserved word", PCt = "Unexpected end of input", IQ = "Invalid regular expression", vV = "Invalid regular expression: missing /", uke = "Octal literals are not allowed in strict mode.", ICt = "Duplicate data property in object literal not allowed in strict mode", tl = "ILLEGAL", Jk = "Disabled.", jCt = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), LCt = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function i8(e, t) {
  if (!e)
    throw new Error("ASSERT: " + t);
}
function B0(e) {
  return e >= 48 && e <= 57;
}
function jne(e) {
  return "0123456789abcdefABCDEF".indexOf(e) >= 0;
}
function HR(e) {
  return "01234567".indexOf(e) >= 0;
}
function zCt(e) {
  return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0;
}
function e$(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function b4(e) {
  return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
  e >= 65 && e <= 90 || // A..Z
  e >= 97 && e <= 122 || // a..z
  e === 92 || // \ (backslash)
  e >= 128 && jCt.test(String.fromCharCode(e));
}
function nz(e) {
  return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
  e >= 65 && e <= 90 || // A..Z
  e >= 97 && e <= 122 || // a..z
  e >= 48 && e <= 57 || // 0..9
  e === 92 || // \ (backslash)
  e >= 128 && LCt.test(String.fromCharCode(e));
}
const FCt = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1
};
function lke() {
  for (; et < Vl; ) {
    const e = en.charCodeAt(et);
    if (zCt(e) || e$(e))
      ++et;
    else
      break;
  }
}
function jQ(e) {
  var t, n, r, i = 0;
  for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t)
    et < Vl && jne(en[et]) ? (r = en[et++], i = i * 16 + "0123456789abcdef".indexOf(r.toLowerCase())) : Ci({}, mu, tl);
  return String.fromCharCode(i);
}
function BCt() {
  var e, t, n, r;
  for (e = en[et], t = 0, e === "}" && Ci({}, mu, tl); et < Vl && (e = en[et++], !!jne(e)); )
    t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
  return (t > 1114111 || e !== "}") && Ci({}, mu, tl), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, r = (t - 65536 & 1023) + 56320, String.fromCharCode(n, r));
}
function cke() {
  var e, t;
  for (e = en.charCodeAt(et++), t = String.fromCharCode(e), e === 92 && (en.charCodeAt(et) !== 117 && Ci({}, mu, tl), ++et, e = jQ("u"), (!e || e === "\\" || !b4(e.charCodeAt(0))) && Ci({}, mu, tl), t = e); et < Vl && (e = en.charCodeAt(et), !!nz(e)); )
    ++et, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), en.charCodeAt(et) !== 117 && Ci({}, mu, tl), ++et, e = jQ("u"), (!e || e === "\\" || !nz(e.charCodeAt(0))) && Ci({}, mu, tl), t += e);
  return t;
}
function UCt() {
  var e, t;
  for (e = et++; et < Vl; ) {
    if (t = en.charCodeAt(et), t === 92)
      return et = e, cke();
    if (nz(t))
      ++et;
    else
      break;
  }
  return en.slice(e, et);
}
function YCt() {
  var e, t, n;
  return e = et, t = en.charCodeAt(et) === 92 ? cke() : UCt(), t.length === 1 ? n = jS : FCt.hasOwnProperty(t) ? n = Iw : t === "null" ? n = r8 : t === "true" || t === "false" ? n = n8 : n = jS, {
    type: n,
    value: t,
    start: e,
    end: et
  };
}
function bV() {
  var e = et, t = en.charCodeAt(et), n, r = en[et], i, o, a;
  switch (t) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      return ++et, {
        type: gf,
        value: String.fromCharCode(t),
        start: e,
        end: et
      };
    default:
      if (n = en.charCodeAt(et + 1), n === 61)
        switch (t) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            return et += 2, {
              type: gf,
              value: String.fromCharCode(t) + String.fromCharCode(n),
              start: e,
              end: et
            };
          case 33:
          case 61:
            return et += 2, en.charCodeAt(et) === 61 && ++et, {
              type: gf,
              value: en.slice(e, et),
              start: e,
              end: et
            };
        }
  }
  if (a = en.substr(et, 4), a === ">>>=")
    return et += 4, {
      type: gf,
      value: a,
      start: e,
      end: et
    };
  if (o = a.substr(0, 3), o === ">>>" || o === "<<=" || o === ">>=")
    return et += 3, {
      type: gf,
      value: o,
      start: e,
      end: et
    };
  if (i = o.substr(0, 2), r === i[1] && "+-<>&|".indexOf(r) >= 0 || i === "=>")
    return et += 2, {
      type: gf,
      value: i,
      start: e,
      end: et
    };
  if (i === "//" && Ci({}, mu, tl), "<>=!+-*%&|^/".indexOf(r) >= 0)
    return ++et, {
      type: gf,
      value: r,
      start: e,
      end: et
    };
  Ci({}, mu, tl);
}
function HCt(e) {
  let t = "";
  for (; et < Vl && jne(en[et]); )
    t += en[et++];
  return t.length === 0 && Ci({}, mu, tl), b4(en.charCodeAt(et)) && Ci({}, mu, tl), {
    type: s2,
    value: parseInt("0x" + t, 16),
    start: e,
    end: et
  };
}
function VCt(e) {
  let t = "0" + en[et++];
  for (; et < Vl && HR(en[et]); )
    t += en[et++];
  return (b4(en.charCodeAt(et)) || B0(en.charCodeAt(et))) && Ci({}, mu, tl), {
    type: s2,
    value: parseInt(t, 8),
    octal: !0,
    start: e,
    end: et
  };
}
function hme() {
  var e, t, n;
  if (n = en[et], i8(B0(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = et, e = "", n !== ".") {
    if (e = en[et++], n = en[et], e === "0") {
      if (n === "x" || n === "X")
        return ++et, HCt(t);
      if (HR(n))
        return VCt(t);
      n && B0(n.charCodeAt(0)) && Ci({}, mu, tl);
    }
    for (; B0(en.charCodeAt(et)); )
      e += en[et++];
    n = en[et];
  }
  if (n === ".") {
    for (e += en[et++]; B0(en.charCodeAt(et)); )
      e += en[et++];
    n = en[et];
  }
  if (n === "e" || n === "E")
    if (e += en[et++], n = en[et], (n === "+" || n === "-") && (e += en[et++]), B0(en.charCodeAt(et)))
      for (; B0(en.charCodeAt(et)); )
        e += en[et++];
    else
      Ci({}, mu, tl);
  return b4(en.charCodeAt(et)) && Ci({}, mu, tl), {
    type: s2,
    value: parseFloat(e),
    start: t,
    end: et
  };
}
function WCt() {
  var e = "", t, n, r, i, o = !1;
  for (t = en[et], i8(t === "'" || t === '"', "String literal must starts with a quote"), n = et, ++et; et < Vl; )
    if (r = en[et++], r === t) {
      t = "";
      break;
    } else if (r === "\\")
      if (r = en[et++], !r || !e$(r.charCodeAt(0)))
        switch (r) {
          case "u":
          case "x":
            en[et] === "{" ? (++et, e += BCt()) : e += jQ(r);
            break;
          case "n":
            e += `
`;
            break;
          case "r":
            e += "\r";
            break;
          case "t":
            e += "	";
            break;
          case "b":
            e += "\b";
            break;
          case "f":
            e += "\f";
            break;
          case "v":
            e += "\v";
            break;
          default:
            HR(r) ? (i = "01234567".indexOf(r), i !== 0 && (o = !0), et < Vl && HR(en[et]) && (o = !0, i = i * 8 + "01234567".indexOf(en[et++]), "0123".indexOf(r) >= 0 && et < Vl && HR(en[et]) && (i = i * 8 + "01234567".indexOf(en[et++]))), e += String.fromCharCode(i)) : e += r;
            break;
        }
      else
        r === "\r" && en[et] === `
` && ++et;
    else {
      if (e$(r.charCodeAt(0)))
        break;
      e += r;
    }
  return t !== "" && Ci({}, mu, tl), {
    type: v4,
    value: e,
    octal: o,
    start: n,
    end: et
  };
}
function qCt(e, t) {
  let n = e;
  t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (r, i) => {
    if (parseInt(i, 16) <= 1114111)
      return "x";
    Ci({}, IQ);
  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
  try {
    new RegExp(n);
  } catch {
    Ci({}, IQ);
  }
  try {
    return new RegExp(e, t);
  } catch {
    return null;
  }
}
function GCt() {
  var e, t, n, r, i;
  for (e = en[et], i8(e === "/", "Regular expression literal must start with a slash"), t = en[et++], n = !1, r = !1; et < Vl; )
    if (e = en[et++], t += e, e === "\\")
      e = en[et++], e$(e.charCodeAt(0)) && Ci({}, vV), t += e;
    else if (e$(e.charCodeAt(0)))
      Ci({}, vV);
    else if (n)
      e === "]" && (n = !1);
    else if (e === "/") {
      r = !0;
      break;
    } else
      e === "[" && (n = !0);
  return r || Ci({}, vV), i = t.substr(1, t.length - 2), {
    value: i,
    literal: t
  };
}
function QCt() {
  var e, t, n;
  for (t = "", n = ""; et < Vl && (e = en[et], !!nz(e.charCodeAt(0))); )
    ++et, e === "\\" && et < Vl ? Ci({}, mu, tl) : (n += e, t += e);
  return n.search(/[^gimuy]/g) >= 0 && Ci({}, IQ, n), {
    value: n,
    literal: t
  };
}
function XCt() {
  var e, t, n, r;
  return io = null, lke(), e = et, t = GCt(), n = QCt(), r = qCt(t.value, n.value), {
    literal: t.literal + n.literal,
    value: r,
    regex: {
      pattern: t.value,
      flags: n.value
    },
    start: e,
    end: et
  };
}
function KCt(e) {
  return e.type === jS || e.type === Iw || e.type === n8 || e.type === r8;
}
function fke() {
  if (lke(), et >= Vl)
    return {
      type: y4,
      start: et,
      end: et
    };
  const e = en.charCodeAt(et);
  return b4(e) ? YCt() : e === 40 || e === 41 || e === 59 ? bV() : e === 39 || e === 34 ? WCt() : e === 46 ? B0(en.charCodeAt(et + 1)) ? hme() : bV() : B0(e) ? hme() : bV();
}
function vf() {
  const e = io;
  return et = e.end, io = fke(), et = e.end, e;
}
function dke() {
  const e = et;
  io = fke(), et = e;
}
function ZCt(e) {
  const t = new tm(wCt);
  return t.elements = e, t;
}
function pme(e, t, n) {
  const r = new tm(e === "||" || e === "&&" ? TCt : _Ct);
  return r.operator = e, r.left = t, r.right = n, r;
}
function JCt(e, t) {
  const n = new tm(ECt);
  return n.callee = e, n.arguments = t, n;
}
function eNt(e, t, n) {
  const r = new tm(SCt);
  return r.test = e, r.consequent = t, r.alternate = n, r;
}
function Lne(e) {
  const t = new tm(ske);
  return t.name = e, t;
}
function rR(e) {
  const t = new tm(MCt);
  return t.value = e.value, t.raw = en.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
}
function gme(e, t, n) {
  const r = new tm(CCt);
  return r.computed = e === "[", r.object = t, r.property = n, r.computed || (n.member = !0), r;
}
function tNt(e) {
  const t = new tm(NCt);
  return t.properties = e, t;
}
function mme(e, t, n) {
  const r = new tm(DCt);
  return r.key = t, r.value = n, r.kind = e, r;
}
function nNt(e, t) {
  const n = new tm(ACt);
  return n.operator = e, n.argument = t, n.prefix = !0, n;
}
function Ci(e, t) {
  var n, r = Array.prototype.slice.call(arguments, 2), i = t.replace(/%(\d)/g, (o, a) => (i8(a < r.length, "Message reference must be in range"), r[a]));
  throw n = new Error(i), n.index = et, n.description = i, n;
}
function o8(e) {
  e.type === y4 && Ci(e, PCt), e.type === s2 && Ci(e, OCt), e.type === v4 && Ci(e, RCt), e.type === jS && Ci(e, kCt), e.type === Iw && Ci(e, $Ct), Ci(e, mu, e.value);
}
function Wl(e) {
  const t = vf();
  (t.type !== gf || t.value !== e) && o8(t);
}
function Ho(e) {
  return io.type === gf && io.value === e;
}
function xV(e) {
  return io.type === Iw && io.value === e;
}
function rNt() {
  const e = [];
  for (et = io.start, Wl("["); !Ho("]"); )
    Ho(",") ? (vf(), e.push(null)) : (e.push(LS()), Ho("]") || Wl(","));
  return vf(), ZCt(e);
}
function yme() {
  et = io.start;
  const e = vf();
  return e.type === v4 || e.type === s2 ? (e.octal && Ci(e, uke), rR(e)) : Lne(e.value);
}
function iNt() {
  var e, t, n, r;
  if (et = io.start, e = io, e.type === jS)
    return n = yme(), Wl(":"), r = LS(), mme("init", n, r);
  if (e.type === y4 || e.type === gf)
    o8(e);
  else
    return t = yme(), Wl(":"), r = LS(), mme("init", t, r);
}
function oNt() {
  var e = [], t, n, r, i = {}, o = String;
  for (et = io.start, Wl("{"); !Ho("}"); )
    t = iNt(), t.key.type === ske ? n = t.key.name : n = o(t.key.value), r = "$" + n, Object.prototype.hasOwnProperty.call(i, r) ? Ci({}, ICt) : i[r] = !0, e.push(t), Ho("}") || Wl(",");
  return Wl("}"), tNt(e);
}
function aNt() {
  Wl("(");
  const e = zne();
  return Wl(")"), e;
}
const sNt = {
  if: 1
};
function uNt() {
  var e, t, n;
  if (Ho("("))
    return aNt();
  if (Ho("["))
    return rNt();
  if (Ho("{"))
    return oNt();
  if (e = io.type, et = io.start, e === jS || sNt[io.value])
    n = Lne(vf().value);
  else if (e === v4 || e === s2)
    io.octal && Ci(io, uke), n = rR(vf());
  else {
    if (e === Iw)
      throw new Error(Jk);
    e === n8 ? (t = vf(), t.value = t.value === "true", n = rR(t)) : e === r8 ? (t = vf(), t.value = null, n = rR(t)) : Ho("/") || Ho("/=") ? (n = rR(XCt()), dke()) : o8(vf());
  }
  return n;
}
function lNt() {
  const e = [];
  if (Wl("("), !Ho(")"))
    for (; et < Vl && (e.push(LS()), !Ho(")")); )
      Wl(",");
  return Wl(")"), e;
}
function cNt() {
  et = io.start;
  const e = vf();
  return KCt(e) || o8(e), Lne(e.value);
}
function fNt() {
  return Wl("."), cNt();
}
function dNt() {
  Wl("[");
  const e = zne();
  return Wl("]"), e;
}
function hNt() {
  var e, t, n;
  for (e = uNt(); ; )
    if (Ho("."))
      n = fNt(), e = gme(".", e, n);
    else if (Ho("("))
      t = lNt(), e = JCt(e, t);
    else if (Ho("["))
      n = dNt(), e = gme("[", e, n);
    else
      break;
  return e;
}
function vme() {
  const e = hNt();
  if (io.type === gf && (Ho("++") || Ho("--")))
    throw new Error(Jk);
  return e;
}
function Tj() {
  var e, t;
  if (io.type !== gf && io.type !== Iw)
    t = vme();
  else {
    if (Ho("++") || Ho("--"))
      throw new Error(Jk);
    if (Ho("+") || Ho("-") || Ho("~") || Ho("!"))
      e = vf(), t = Tj(), t = nNt(e.value, t);
    else {
      if (xV("delete") || xV("void") || xV("typeof"))
        throw new Error(Jk);
      t = vme();
    }
  }
  return t;
}
function bme(e) {
  let t = 0;
  if (e.type !== gf && e.type !== Iw)
    return 0;
  switch (e.value) {
    case "||":
      t = 1;
      break;
    case "&&":
      t = 2;
      break;
    case "|":
      t = 3;
      break;
    case "^":
      t = 4;
      break;
    case "&":
      t = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      t = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      t = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      t = 8;
      break;
    case "+":
    case "-":
      t = 9;
      break;
    case "*":
    case "/":
    case "%":
      t = 11;
      break;
  }
  return t;
}
function pNt() {
  var e, t, n, r, i, o, a, s, u, l;
  if (e = io, u = Tj(), r = io, i = bme(r), i === 0)
    return u;
  for (r.prec = i, vf(), t = [e, io], a = Tj(), o = [u, r, a]; (i = bme(io)) > 0; ) {
    for (; o.length > 2 && i <= o[o.length - 2].prec; )
      a = o.pop(), s = o.pop().value, u = o.pop(), t.pop(), n = pme(s, u, a), o.push(n);
    r = vf(), r.prec = i, o.push(r), t.push(io), n = Tj(), o.push(n);
  }
  for (l = o.length - 1, n = o[l], t.pop(); l > 1; )
    t.pop(), n = pme(o[l - 1].value, o[l - 2], n), l -= 2;
  return n;
}
function LS() {
  var e, t, n;
  return e = pNt(), Ho("?") && (vf(), t = LS(), Wl(":"), n = LS(), e = eNt(e, t, n)), e;
}
function zne() {
  const e = LS();
  if (Ho(","))
    throw new Error(Jk);
  return e;
}
function Fne(e) {
  en = e, et = 0, Vl = en.length, io = null, dke();
  const t = zne();
  if (io.type !== y4)
    throw new Error("Unexpect token after expression.");
  return t;
}
var hke = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function pke(e) {
  function t(a, s, u, l) {
    let f = e(s[0]);
    return u && (f = u + "(" + f + ")", u.lastIndexOf("new ", 0) === 0 && (f = "(" + f + ")")), f + "." + a + (l < 0 ? "" : l === 0 ? "()" : "(" + s.slice(1).map(e).join(",") + ")");
  }
  function n(a, s, u) {
    return (l) => t(a, l, s, u);
  }
  const r = "new Date", i = "String", o = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(a) {
      a.length < 3 && tt("Missing arguments to clamp function."), a.length > 3 && tt("Too many arguments to clamp function.");
      const s = a.map(e);
      return "Math.max(" + s[1] + ", Math.min(" + s[2] + "," + s[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: r,
    date: n("getDate", r, 0),
    day: n("getDay", r, 0),
    year: n("getFullYear", r, 0),
    month: n("getMonth", r, 0),
    hours: n("getHours", r, 0),
    minutes: n("getMinutes", r, 0),
    seconds: n("getSeconds", r, 0),
    milliseconds: n("getMilliseconds", r, 0),
    time: n("getTime", r, 0),
    timezoneoffset: n("getTimezoneOffset", r, 0),
    utcdate: n("getUTCDate", r, 0),
    utcday: n("getUTCDay", r, 0),
    utcyear: n("getUTCFullYear", r, 0),
    utcmonth: n("getUTCMonth", r, 0),
    utchours: n("getUTCHours", r, 0),
    utcminutes: n("getUTCMinutes", r, 0),
    utcseconds: n("getUTCSeconds", r, 0),
    utcmilliseconds: n("getUTCMilliseconds", r, 0),
    // sequence functions
    length: n("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: n("toUpperCase", i, 0),
    lower: n("toLowerCase", i, 0),
    substring: n("substring", i),
    split: n("split", i),
    trim: n("trim", i, 0),
    // REGEXP functions
    regexp: o,
    test: n("test", o),
    // Control Flow functions
    if: function(a) {
      a.length < 3 && tt("Missing arguments to if function."), a.length > 3 && tt("Too many arguments to if function.");
      const s = a.map(e);
      return "(" + s[0] + "?" + s[1] + ":" + s[2] + ")";
    }
  };
}
function gNt(e) {
  const t = e && e.length - 1;
  return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e;
}
function gke(e) {
  e = e || {};
  const t = e.allowed ? Wg(e.allowed) : {}, n = e.forbidden ? Wg(e.forbidden) : {}, r = e.constants || hke, i = (e.functions || pke)(h), o = e.globalvar, a = e.fieldvar, s = pr(o) ? o : (y) => `${o}["${y}"]`;
  let u = {}, l = {}, f = 0;
  function h(y) {
    if (kt(y))
      return y;
    const b = p[y.type];
    return b == null && tt("Unsupported type: " + y.type), b(y);
  }
  const p = {
    Literal: (y) => y.raw,
    Identifier: (y) => {
      const b = y.name;
      return f > 0 ? b : wn(n, b) ? tt("Illegal identifier: " + b) : wn(r, b) ? r[b] : wn(t, b) ? b : (u[b] = 1, s(b));
    },
    MemberExpression: (y) => {
      const b = !y.computed, _ = h(y.object);
      b && (f += 1);
      const S = h(y.property);
      return _ === a && (l[gNt(S)] = 1), b && (f -= 1), _ + (b ? "." + S : "[" + S + "]");
    },
    CallExpression: (y) => {
      y.callee.type !== "Identifier" && tt("Illegal callee type: " + y.callee.type);
      const b = y.callee.name, _ = y.arguments, S = wn(i, b) && i[b];
      return S || tt("Unrecognized function: " + b), pr(S) ? S(_) : S + "(" + _.map(h).join(",") + ")";
    },
    ArrayExpression: (y) => "[" + y.elements.map(h).join(",") + "]",
    BinaryExpression: (y) => "(" + h(y.left) + " " + y.operator + " " + h(y.right) + ")",
    UnaryExpression: (y) => "(" + y.operator + h(y.argument) + ")",
    ConditionalExpression: (y) => "(" + h(y.test) + "?" + h(y.consequent) + ":" + h(y.alternate) + ")",
    LogicalExpression: (y) => "(" + h(y.left) + y.operator + h(y.right) + ")",
    ObjectExpression: (y) => "{" + y.properties.map(h).join(",") + "}",
    Property: (y) => {
      f += 1;
      const b = h(y.key);
      return f -= 1, b + ":" + h(y.value);
    }
  };
  function g(y) {
    const b = {
      code: h(y),
      globals: Object.keys(u),
      fields: Object.keys(l)
    };
    return u = {}, l = {}, b;
  }
  return g.functions = i, g.constants = r, g;
}
const xme = Symbol("vega_selection_getter");
function mke(e) {
  return (!e.getter || !e.getter[xme]) && (e.getter = yp(e.field), e.getter[xme] = !0), e.getter;
}
const Bne = "intersect", wme = "union", mNt = "vlMulti", yNt = "vlPoint", _me = "or", vNt = "and", Sy = "_vgsid_", t$ = yp(Sy), bNt = "E", xNt = "R", wNt = "R-E", _Nt = "R-LE", ENt = "R-RE", rz = "index:unit";
function Eme(e, t) {
  for (var n = t.fields, r = t.values, i = n.length, o = 0, a, s; o < i; ++o)
    if (s = n[o], a = mke(s)(e), zx(a) && (a = Fl(a)), zx(r[o]) && (r[o] = Fl(r[o])), nt(r[o]) && zx(r[o][0]) && (r[o] = r[o].map(Fl)), s.type === bNt) {
      if (nt(r[o]) ? r[o].indexOf(a) < 0 : a !== r[o])
        return !1;
    } else if (s.type === xNt) {
      if (!vT(a, r[o]))
        return !1;
    } else if (s.type === ENt) {
      if (!vT(a, r[o], !0, !1))
        return !1;
    } else if (s.type === wNt) {
      if (!vT(a, r[o], !1, !1))
        return !1;
    } else if (s.type === _Nt && !vT(a, r[o], !1, !0))
      return !1;
  return !0;
}
function SNt(e, t, n) {
  for (var r = this.context.data[e], i = r ? r.values.value : [], o = r ? r[rz] && r[rz].value : void 0, a = n === Bne, s = i.length, u = 0, l, f, h, p, g; u < s; ++u)
    if (l = i[u], o && a) {
      if (f = f || {}, h = f[p = l.unit] || 0, h === -1)
        continue;
      if (g = Eme(t, l), f[p] = g ? -1 : ++h, g && o.size === 1)
        return !0;
      if (!g && h === o.get(p).count)
        return !1;
    } else if (g = Eme(t, l), a ^ g)
      return g;
  return s && a;
}
const yke = Qx(t$), MNt = yke.left, TNt = yke.right;
function CNt(e, t, n) {
  const r = this.context.data[e], i = r ? r.values.value : [], o = r ? r[rz] && r[rz].value : void 0, a = n === Bne, s = t$(t), u = MNt(i, s);
  if (u === i.length || t$(i[u]) !== s)
    return !1;
  if (o && a) {
    if (o.size === 1)
      return !0;
    if (TNt(i, s) - u < o.size)
      return !1;
  }
  return !0;
}
function NNt(e, t) {
  return e.map((n) => hr(t.fields ? {
    values: t.fields.map((r) => mke(r)(n.datum))
  } : {
    [Sy]: t$(n.datum)
  }, t));
}
function DNt(e, t, n, r) {
  for (var i = this.context.data[e], o = i ? i.values.value : [], a = {}, s = {}, u = {}, l, f, h, p, g, y, b, _, S, C, A = o.length, O = 0, R, j; O < A; ++O)
    if (l = o[O], p = l.unit, f = l.fields, h = l.values, f && h) {
      for (R = 0, j = f.length; R < j; ++R)
        g = f[R], b = a[g.field] || (a[g.field] = {}), _ = b[p] || (b[p] = []), u[g.field] = S = g.type.charAt(0), C = wV[`${S}_union`], b[p] = C(_, Rt(h[R]));
      n && (_ = s[p] || (s[p] = []), _.push(Rt(h).reduce(($, z, W) => ($[f[W].field] = z, $), {})));
    } else
      g = Sy, y = t$(l), b = a[g] || (a[g] = {}), _ = b[p] || (b[p] = []), _.push(y), n && (_ = s[p] || (s[p] = []), _.push({
        [Sy]: y
      }));
  if (t = t || wme, a[Sy] ? a[Sy] = wV[`${Sy}_${t}`](...Object.values(a[Sy])) : Object.keys(a).forEach(($) => {
    a[$] = Object.keys(a[$]).map((z) => a[$][z]).reduce((z, W) => z === void 0 ? W : wV[`${u[$]}_${t}`](z, W));
  }), o = Object.keys(s), n && o.length) {
    const $ = r ? yNt : mNt;
    a[$] = t === wme ? {
      [_me]: o.reduce((z, W) => (z.push(...s[W]), z), [])
    } : {
      [vNt]: o.map((z) => ({
        [_me]: s[z]
      }))
    };
  }
  return a;
}
var wV = {
  [`${Sy}_union`]: oit,
  [`${Sy}_intersect`]: rit,
  E_union: function(e, t) {
    if (!e.length)
      return t;
    for (var n = 0, r = t.length; n < r; ++n)
      e.indexOf(t[n]) < 0 && e.push(t[n]);
    return e;
  },
  E_intersect: function(e, t) {
    return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
  },
  R_union: function(e, t) {
    var n = Fl(t[0]), r = Fl(t[1]);
    return n > r && (n = t[1], r = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < r && (e[1] = r), e) : [n, r];
  },
  R_intersect: function(e, t) {
    var n = Fl(t[0]), r = Fl(t[1]);
    return n > r && (n = t[1], r = t[0]), e.length ? r < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > r && (e[1] = r), e) : [n, r];
  }
};
const ANt = ":", ONt = "@";
function Une(e, t, n, r) {
  t[0].type !== IS && tt("First argument to selection functions must be a string literal.");
  const i = t[0].value, o = t.length >= 2 && ri(t).value, a = "unit", s = ONt + a, u = ANt + i;
  o === Bne && !wn(r, s) && (r[s] = n.getData(i).indataRef(n, a)), wn(r, u) || (r[u] = n.getData(i).tuplesRef());
}
function vke(e) {
  const t = this.context.data[e];
  return t ? t.values.value : [];
}
function RNt(e, t, n) {
  const r = this.context.data[e]["index:" + t], i = r ? r.value.get(n) : void 0;
  return i && i.count;
}
function kNt(e, t) {
  const n = this.context.dataflow, r = this.context.data[e], i = r.input;
  return n.pulse(i, n.changeset().remove(vp).insert(t)), 1;
}
function $Nt(e, t, n) {
  if (e) {
    const r = this.context.dataflow, i = e.mark.source;
    r.pulse(i, r.changeset().encode(e, t));
  }
  return n !== void 0 ? n : e;
}
const x4 = (e) => function(t, n) {
  return this.context.dataflow.locale()[e](n)(t);
}, PNt = x4("format"), bke = x4("timeFormat"), INt = x4("utcFormat"), jNt = x4("timeParse"), LNt = x4("utcParse"), O3 = new Date(2e3, 0, 1);
function a8(e, t, n) {
  return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (O3.setYear(2e3), O3.setMonth(e), O3.setDate(t), bke.call(this, O3, n));
}
function zNt(e) {
  return a8.call(this, e, 1, "%B");
}
function FNt(e) {
  return a8.call(this, e, 1, "%b");
}
function BNt(e) {
  return a8.call(this, 0, 2 + e, "%A");
}
function UNt(e) {
  return a8.call(this, 0, 2 + e, "%a");
}
const YNt = ":", HNt = "@", LQ = "%", xke = "$";
function Yne(e, t, n, r) {
  t[0].type !== IS && tt("First argument to data functions must be a string literal.");
  const i = t[0].value, o = YNt + i;
  if (!wn(o, r))
    try {
      r[o] = n.getData(i).tuplesRef();
    } catch {
    }
}
function VNt(e, t, n, r) {
  t[0].type !== IS && tt("First argument to indata must be a string literal."), t[1].type !== IS && tt("Second argument to indata must be a string literal.");
  const i = t[0].value, o = t[1].value, a = HNt + o;
  wn(a, r) || (r[a] = n.getData(i).indataRef(n, o));
}
function Ac(e, t, n, r) {
  if (t[0].type === IS)
    Sme(n, r, t[0].value);
  else
    for (e in n.scales)
      Sme(n, r, e);
}
function Sme(e, t, n) {
  const r = LQ + n;
  if (!wn(t, r))
    try {
      t[r] = e.scaleRef(n);
    } catch {
    }
}
function fv(e, t) {
  if (pr(e))
    return e;
  if (kt(e)) {
    const n = t.scales[e];
    return n && uwt(n.value) ? n.value : void 0;
  }
}
function WNt(e, t, n) {
  t.__bandwidth = (i) => i && i.bandwidth ? i.bandwidth() : 0, n._bandwidth = Ac, n._range = Ac, n._scale = Ac;
  const r = (i) => "_[" + (i.type === IS ? Et(LQ + i.value) : Et(LQ) + "+" + e(i)) + "]";
  return {
    _bandwidth: (i) => `this.__bandwidth(${r(i[0])})`,
    _range: (i) => `${r(i[0])}.range()`,
    _scale: (i) => `${r(i[0])}(${e(i[1])})`
  };
}
function Hne(e, t) {
  return function(n, r, i) {
    if (n) {
      const o = fv(n, (i || this).context);
      return o && o.path[e](r);
    } else
      return t(r);
  };
}
const qNt = Hne("area", E2t), GNt = Hne("bounds", C2t), QNt = Hne("centroid", k2t);
function XNt(e, t) {
  const n = fv(e, (t || this).context);
  return n && n.scale();
}
function KNt(e) {
  const t = this.context.group;
  let n = !1;
  if (t)
    for (; e; ) {
      if (e === t) {
        n = !0;
        break;
      }
      e = e.mark.group;
    }
  return n;
}
function Vne(e, t, n) {
  try {
    e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)));
  } catch (r) {
    e.warn(r);
  }
  return n[n.length - 1];
}
function ZNt() {
  return Vne(this.context.dataflow, "warn", arguments);
}
function JNt() {
  return Vne(this.context.dataflow, "info", arguments);
}
function eDt() {
  return Vne(this.context.dataflow, "debug", arguments);
}
function _V(e) {
  const t = e / 255;
  return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function zQ(e) {
  const t = Cf(e), n = _V(t.r), r = _V(t.g), i = _V(t.b);
  return 0.2126 * n + 0.7152 * r + 0.0722 * i;
}
function tDt(e, t) {
  const n = zQ(e), r = zQ(t), i = Math.max(n, r), o = Math.min(n, r);
  return (i + 0.05) / (o + 0.05);
}
function nDt() {
  const e = [].slice.call(arguments);
  return e.unshift({}), hr(...e);
}
function wke(e, t) {
  return e === t || e !== e && t !== t ? !0 : nt(e) ? nt(t) && e.length === t.length ? rDt(e, t) : !1 : Pt(e) && Pt(t) ? _ke(e, t) : !1;
}
function rDt(e, t) {
  for (let n = 0, r = e.length; n < r; ++n)
    if (!wke(e[n], t[n]))
      return !1;
  return !0;
}
function _ke(e, t) {
  for (const n in e)
    if (!wke(e[n], t[n]))
      return !1;
  return !0;
}
function Mme(e) {
  return (t) => _ke(e, t);
}
function iDt(e, t, n, r, i, o) {
  const a = this.context.dataflow, s = this.context.data[e], u = s.input, l = a.stamp();
  let f = s.changes, h, p;
  if (a._trigger === !1 || !(u.value.length || t || r))
    return 0;
  if ((!f || f.stamp < l) && (s.changes = f = a.changeset(), f.stamp = l, a.runAfter(() => {
    s.modified = !0, a.pulse(u, f).run();
  }, !0, 1)), n && (h = n === !0 ? vp : nt(n) || C6(n) ? n : Mme(n), f.remove(h)), t && f.insert(t), r && (h = Mme(r), u.value.some(h) ? f.remove(h) : f.insert(r)), i)
    for (p in o)
      f.modify(i, p, o[p]);
  return 1;
}
function oDt(e) {
  const t = e.touches, n = t[0].clientX - t[1].clientX, r = t[0].clientY - t[1].clientY;
  return Math.hypot(n, r);
}
function aDt(e) {
  const t = e.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
const Tme = {};
function sDt(e, t) {
  const n = Tme[t] || (Tme[t] = yp(t));
  return nt(e) ? e.map(n) : n(e);
}
function Wne(e) {
  return nt(e) || ArrayBuffer.isView(e) ? e : null;
}
function qne(e) {
  return Wne(e) || (kt(e) ? e : null);
}
function uDt(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return Wne(e).join(...n);
}
function lDt(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return qne(e).indexOf(...n);
}
function cDt(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return qne(e).lastIndexOf(...n);
}
function fDt(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return qne(e).slice(...n);
}
function dDt(e, t, n) {
  return pr(n) && tt("Function argument passed to replace."), String(e).replace(t, n);
}
function hDt(e) {
  return Wne(e).slice().reverse();
}
function pDt(e, t, n) {
  return cte(e || 0, t || 0, n || 0);
}
function gDt(e, t) {
  const n = fv(e, (t || this).context);
  return n && n.bandwidth ? n.bandwidth() : 0;
}
function mDt(e, t) {
  const n = fv(e, (t || this).context);
  return n ? n.copy() : void 0;
}
function yDt(e, t) {
  const n = fv(e, (t || this).context);
  return n ? n.domain() : [];
}
function vDt(e, t, n) {
  const r = fv(e, (n || this).context);
  return r ? nt(t) ? (r.invertRange || r.invert)(t) : (r.invert || r.invertExtent)(t) : void 0;
}
function bDt(e, t) {
  const n = fv(e, (t || this).context);
  return n && n.range ? n.range() : [];
}
function xDt(e, t, n) {
  const r = fv(e, (n || this).context);
  return r ? r(t) : void 0;
}
function wDt(e, t, n, r, i) {
  e = fv(e, (i || this).context);
  const o = MAe(t, n);
  let a = e.domain(), s = a[0], u = ri(a), l = ql;
  return u - s ? l = hAe(e, s, u) : e = (e.interpolator ? Di("sequential")().interpolator(e.interpolator()) : Di("linear")().interpolate(e.interpolate()).range(e.range())).domain([s = 0, u = 1]), e.ticks && (a = e.ticks(+r || 15), s !== a[0] && a.unshift(s), u !== ri(a) && a.push(u)), a.forEach((f) => o.stop(l(f), e(f))), o;
}
function _Dt(e, t, n) {
  const r = fv(e, (n || this).context);
  return function(i) {
    return r ? r.path.context(i)(t) : "";
  };
}
function EDt(e) {
  let t = null;
  return function(n) {
    return n ? qk(n, t = t || AC(e)) : e;
  };
}
const Eke = (e) => e.data;
function Ske(e, t) {
  const n = vke.call(t, e);
  return n.root && n.root.lookup || {};
}
function SDt(e, t, n) {
  const r = Ske(e, this), i = r[t], o = r[n];
  return i && o ? i.path(o).map(Eke) : void 0;
}
function MDt(e, t) {
  const n = Ske(e, this)[t];
  return n ? n.ancestors().map(Eke) : void 0;
}
const Mke = () => typeof window < "u" && window || null;
function TDt() {
  const e = Mke();
  return e ? e.screen : {};
}
function CDt() {
  const e = Mke();
  return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0];
}
function NDt() {
  const e = this.context.dataflow, t = e.container && e.container();
  return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0];
}
function Tke(e, t, n) {
  if (!e)
    return [];
  const [r, i] = e, o = new xs().set(r[0], r[1], i[0], i[1]), a = n || this.context.dataflow.scenegraph().root;
  return _Oe(a, o, DDt(t));
}
function DDt(e) {
  let t = null;
  if (e) {
    const n = Rt(e.marktype), r = Rt(e.markname);
    t = (i) => (!n.length || n.some((o) => i.marktype === o)) && (!r.length || r.some((o) => i.name === o));
  }
  return t;
}
function ADt(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  e = Rt(e);
  const i = e[e.length - 1];
  return i === void 0 || Math.hypot(i[0] - t, i[1] - n) > r ? [...e, [t, n]] : e;
}
function ODt(e) {
  return Rt(e).reduce((t, n, r) => {
    let [i, o] = n;
    return t += r == 0 ? `M ${i},${o} ` : r === e.length - 1 ? " Z" : `L ${i},${o} `;
  }, "");
}
function RDt(e, t, n) {
  const {
    x: r,
    y: i,
    mark: o
  } = n, a = new xs().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [u, l] of t)
    u < a.x1 && (a.x1 = u), u > a.x2 && (a.x2 = u), l < a.y1 && (a.y1 = l), l > a.y2 && (a.y2 = l);
  return a.translate(r, i), Tke([[a.x1, a.y1], [a.x2, a.y2]], e, o).filter((u) => kDt(u.x, u.y, t));
}
function kDt(e, t, n) {
  let r = 0;
  for (let i = 0, o = n.length - 1; i < n.length; o = i++) {
    const [a, s] = n[o], [u, l] = n[i];
    l > t != s > t && e < (a - u) * (t - l) / (s - l) + u && r++;
  }
  return r & 1;
}
const n$ = {
  random() {
    return xp();
  },
  // override default
  cumulativeNormal: R6,
  cumulativeLogNormal: Aee,
  cumulativeUniform: $ee,
  densityNormal: Mee,
  densityLogNormal: Dee,
  densityUniform: kee,
  quantileNormal: k6,
  quantileLogNormal: Oee,
  quantileUniform: Pee,
  sampleNormal: O6,
  sampleLogNormal: Nee,
  sampleUniform: Ree,
  isArray: nt,
  isBoolean: Pw,
  isDate: zx,
  isDefined(e) {
    return e !== void 0;
  },
  isNumber: pi,
  isObject: Pt,
  isRegExp: ENe,
  isString: kt,
  isTuple: C6,
  isValid(e) {
    return e != null && e === e;
  },
  toBoolean: lee,
  toDate(e) {
    return cee(e);
  },
  // suppress extra arguments
  toNumber: Fl,
  toString: fee,
  indexof: lDt,
  join: uDt,
  lastindexof: cDt,
  replace: dDt,
  reverse: hDt,
  slice: fDt,
  flush: wNe,
  lerp: SNe,
  merge: nDt,
  pad: CNe,
  peek: ri,
  pluck: sDt,
  span: Z$,
  inrange: vT,
  truncate: NNe,
  rgb: Cf,
  lab: hL,
  hcl: pL,
  hsl: fL,
  luminance: zQ,
  contrast: tDt,
  sequence: qo,
  format: PNt,
  utcFormat: INt,
  utcParse: LNt,
  utcOffset: UNe,
  utcSequence: VNe,
  timeFormat: bke,
  timeParse: jNt,
  timeOffset: BNe,
  timeSequence: HNe,
  timeUnitSpecifier: ANe,
  monthFormat: zNt,
  monthAbbrevFormat: FNt,
  dayFormat: BNt,
  dayAbbrevFormat: UNt,
  quarter: yNe,
  utcquarter: vNe,
  week: RNe,
  utcweek: PNe,
  dayofyear: ONe,
  utcdayofyear: $Ne,
  warn: ZNt,
  info: JNt,
  debug: eDt,
  extent(e) {
    return Gy(e);
  },
  // suppress extra arguments
  inScope: KNt,
  intersect: Tke,
  clampRange: bNe,
  pinchDistance: oDt,
  pinchAngle: aDt,
  screen: TDt,
  containerSize: NDt,
  windowSize: CDt,
  bandspace: pDt,
  setdata: kNt,
  pathShape: EDt,
  panLinear: hNe,
  panLog: pNe,
  panPow: gNe,
  panSymlog: mNe,
  zoomLinear: ree,
  zoomLog: iee,
  zoomPow: f5,
  zoomSymlog: oee,
  encode: $Nt,
  modify: iDt,
  lassoAppend: ADt,
  lassoPath: ODt,
  intersectLasso: RDt
}, $Dt = ["view", "item", "group", "xy", "x", "y"], PDt = "event.vega.", Cke = "this.", Gne = {}, Nke = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (e) => `_[${Et(xke + e)}]`,
  functions: IDt,
  constants: hke,
  visitors: Gne
}, FQ = gke(Nke);
function IDt(e) {
  const t = pke(e);
  $Dt.forEach((n) => t[n] = PDt + n);
  for (const n in n$)
    t[n] = Cke + n;
  return hr(t, WNt(e, n$, Gne)), t;
}
function os(e, t, n) {
  return arguments.length === 1 ? n$[e] : (n$[e] = t, n && (Gne[e] = n), FQ && (FQ.functions[e] = Cke + e), this);
}
os("bandwidth", gDt, Ac);
os("copy", mDt, Ac);
os("domain", yDt, Ac);
os("range", bDt, Ac);
os("invert", vDt, Ac);
os("scale", xDt, Ac);
os("gradient", wDt, Ac);
os("geoArea", qNt, Ac);
os("geoBounds", GNt, Ac);
os("geoCentroid", QNt, Ac);
os("geoShape", _Dt, Ac);
os("geoScale", XNt, Ac);
os("indata", RNt, VNt);
os("data", vke, Yne);
os("treePath", SDt, Yne);
os("treeAncestors", MDt, Yne);
os("vlSelectionTest", SNt, Une);
os("vlSelectionIdTest", CNt, Une);
os("vlSelectionResolve", DNt, Une);
os("vlSelectionTuples", NNt);
function Ky(e, t) {
  const n = {};
  let r;
  try {
    e = kt(e) ? e : Et(e) + "", r = Fne(e);
  } catch {
    tt("Expression parse error: " + e);
  }
  r.visit((o) => {
    if (o.type !== ake)
      return;
    const a = o.callee.name, s = Nke.visitors[a];
    s && s(a, o.arguments, t, n);
  });
  const i = FQ(r);
  return i.globals.forEach((o) => {
    const a = xke + o;
    !wn(n, a) && t.getSignal(o) && (n[a] = t.signalRef(o));
  }), {
    $expr: hr({
      code: i.code
    }, t.options.ast ? {
      ast: r
    } : null),
    $fields: i.fields,
    $params: n
  };
}
function jDt(e) {
  const t = this, n = e.operators || [];
  return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach((r) => t.parseOperator(r)), n.forEach((r) => t.parseOperatorParameters(r)), (e.streams || []).forEach((r) => t.parseStream(r)), (e.updates || []).forEach((r) => t.parseUpdate(r)), t.resolve();
}
const LDt = Wg(["rule"]), Cme = Wg(["group", "image", "rect"]);
function zDt(e, t) {
  let n = "";
  return LDt[t] || (e.x2 && (e.x ? (Cme[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (Cme[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n;
}
function Qne(e) {
  return (e + "").toLowerCase();
}
function FDt(e) {
  return Qne(e) === "operator";
}
function BDt(e) {
  return Qne(e) === "collect";
}
function lO(e, t, n) {
  n.endsWith(";") || (n = "return(" + n + ");");
  const r = Function(...t.concat(n));
  return e && e.functions ? r.bind(e.functions) : r;
}
function UDt(e, t, n, r) {
  return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
  : (u > v || v == null) && u != null ? ${r}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
  : v !== v && u === u ? ${r} : `;
}
var YDt = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (e, t) => lO(e, ["_"], t.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (e, t) => lO(e, ["datum", "_"], t.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (e, t) => lO(e, ["event"], t.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (e, t) => {
    const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
    return lO(e, ["_", "event"], n);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (e, t) => {
    const {
      marktype: n,
      channels: r
    } = t;
    let i = "var o=item,datum=o.datum,m=0,$;";
    for (const o in r) {
      const a = "o[" + Et(o) + "]";
      i += `$=${r[o].code};if(${a}!==$)${a}=$,m=1;`;
    }
    return i += zDt(r, n), i += "return m;", lO(e, ["item", "_"], i);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(e) {
      const t = `[${e.map(Et).join("][")}]`, n = Function("_", `return _${t};`);
      return n.path = t, n;
    },
    comparator(e, t) {
      let n;
      const r = (o, a) => {
        const s = t[a];
        let u, l;
        return o.path ? (u = `a${o.path}`, l = `b${o.path}`) : ((n = n || {})["f" + a] = o, u = `this.f${a}(a)`, l = `this.f${a}(b)`), UDt(u, l, -s, s);
      }, i = Function("a", "b", "var u, v; return " + e.map(r).join("") + "0;");
      return n ? i.bind(n) : i;
    }
  }
};
function HDt(e) {
  const t = this;
  FDt(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type);
}
function VDt(e) {
  const t = this;
  if (e.params) {
    const n = t.get(e.id);
    n || tt("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
  }
}
function WDt(e, t) {
  t = t || {};
  const n = this;
  for (const r in e) {
    const i = e[r];
    t[r] = nt(i) ? i.map((o) => Nme(o, n, t)) : Nme(i, n, t);
  }
  return t;
}
function Nme(e, t, n) {
  if (!e || !Pt(e))
    return e;
  for (let r = 0, i = Dme.length, o; r < i; ++r)
    if (o = Dme[r], wn(e, o.key))
      return o.parse(e, t, n);
  return e;
}
var Dme = [{
  key: "$ref",
  parse: qDt
}, {
  key: "$key",
  parse: QDt
}, {
  key: "$expr",
  parse: GDt
}, {
  key: "$field",
  parse: XDt
}, {
  key: "$encode",
  parse: ZDt
}, {
  key: "$compare",
  parse: KDt
}, {
  key: "$context",
  parse: JDt
}, {
  key: "$subflow",
  parse: eAt
}, {
  key: "$tupleid",
  parse: tAt
}];
function qDt(e, t) {
  return t.get(e.$ref) || tt("Operator not defined: " + e.$ref);
}
function GDt(e, t, n) {
  e.$params && t.parseParameters(e.$params, n);
  const r = "e:" + e.$expr.code;
  return t.fn[r] || (t.fn[r] = Ff(t.parameterExpression(e.$expr), e.$fields));
}
function QDt(e, t) {
  const n = "k:" + e.$key + "_" + !!e.$flat;
  return t.fn[n] || (t.fn[n] = uee(e.$key, e.$flat, t.expr.codegen));
}
function XDt(e, t) {
  if (!e.$field)
    return null;
  const n = "f:" + e.$field + "_" + e.$name;
  return t.fn[n] || (t.fn[n] = yp(e.$field, e.$name, t.expr.codegen));
}
function KDt(e, t) {
  const n = "c:" + e.$compare + "_" + e.$order, r = Rt(e.$compare).map((i) => i && i.$tupleid ? bn : i);
  return t.fn[n] || (t.fn[n] = aee(r, e.$order, t.expr.codegen));
}
function ZDt(e, t) {
  const n = e.$encode, r = {};
  for (const i in n) {
    const o = n[i];
    r[i] = Ff(t.encodeExpression(o.$expr), o.$fields), r[i].output = o.$output;
  }
  return r;
}
function JDt(e, t) {
  return t;
}
function eAt(e, t) {
  const n = e.$subflow;
  return function(r, i, o) {
    const a = t.fork().parse(n), s = a.get(n.operators[0].id), u = a.signals.parent;
    return u && u.set(o), s.detachSubflow = () => t.detach(a), s;
  };
}
function tAt() {
  return bn;
}
function nAt(e) {
  var t = this, n = e.filter != null ? t.eventExpression(e.filter) : void 0, r = e.stream != null ? t.get(e.stream) : void 0, i;
  e.source ? r = t.events(e.source, e.type, n) : e.merge && (i = e.merge.map((o) => t.get(o)), r = i[0].merge.apply(i[0], i.slice(1))), e.between && (i = e.between.map((o) => t.get(o)), r = r.between(i[0], i[1])), e.filter && (r = r.filter(n)), e.throttle != null && (r = r.throttle(+e.throttle)), e.debounce != null && (r = r.debounce(+e.debounce)), r == null && tt("Invalid stream definition: " + JSON.stringify(e)), e.consume && r.consume(!0), t.stream(e, r);
}
function rAt(e) {
  var t = this, n = Pt(n = e.source) ? n.$ref : n, r = t.get(n), i = null, o = e.update, a = void 0;
  r || tt("Source not defined: " + e.source), i = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), o && o.$expr && (o.$params && (a = t.parseParameters(o.$params)), o = t.handlerExpression(o.$expr)), t.update(e, r, i, o, a);
}
const iAt = {
  skip: !0
};
function oAt(e) {
  var t = this, n = {};
  if (e.signals) {
    var r = n.signals = {};
    Object.keys(t.signals).forEach((o) => {
      const a = t.signals[o];
      e.signals(o, a) && (r[o] = a.value);
    });
  }
  if (e.data) {
    var i = n.data = {};
    Object.keys(t.data).forEach((o) => {
      const a = t.data[o];
      e.data(o, a) && (i[o] = a.input.value);
    });
  }
  return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map((o) => o.getState(e))), n;
}
function aAt(e) {
  var t = this, n = t.dataflow, r = e.data, i = e.signals;
  Object.keys(i || {}).forEach((o) => {
    n.update(t.signals[o], i[o], iAt);
  }), Object.keys(r || {}).forEach((o) => {
    n.pulse(t.data[o].input, n.changeset().remove(vp).insert(r[o]));
  }), (e.subcontext || []).forEach((o, a) => {
    const s = t.subcontext[a];
    s && s.setState(o);
  });
}
function Dke(e, t, n, r) {
  return new Ake(e, t, n, r);
}
function Ake(e, t, n, r) {
  this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = r || YDt, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this);
}
function Ame(e) {
  this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this);
}
Ake.prototype = Ame.prototype = {
  fork() {
    const e = new Ame(this);
    return (this.subcontext || (this.subcontext = [])).push(e), e;
  },
  detach(e) {
    this.subcontext = this.subcontext.filter((n) => n !== e);
    const t = Object.keys(e.nodes);
    for (const n of t)
      e.nodes[n]._targets = null;
    for (const n of t)
      e.nodes[n].detach();
    e.nodes = null;
  },
  get(e) {
    return this.nodes[e];
  },
  set(e, t) {
    return this.nodes[e] = t;
  },
  add(e, t) {
    const n = this, r = n.dataflow, i = e.value;
    if (n.set(e.id, t), BDt(e.type) && i && (i.$ingest ? r.ingest(t, i.$ingest, i.$format) : i.$request ? r.preload(t, i.$request, i.$format) : r.pulse(t, r.changeset().insert(i))), e.root && (n.root = t), e.parent) {
      let o = n.get(e.parent.$ref);
      o ? (r.connect(o, [t]), t.targets().add(o)) : (n.unresolved = n.unresolved || []).push(() => {
        o = n.get(e.parent.$ref), r.connect(o, [t]), t.targets().add(o);
      });
    }
    if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
      for (const o in e.data) {
        const a = n.data[o] || (n.data[o] = {});
        e.data[o].forEach((s) => a[s] = t);
      }
  },
  resolve() {
    return (this.unresolved || []).forEach((e) => e()), delete this.unresolved, this;
  },
  operator(e, t) {
    this.add(e, this.dataflow.add(e.value, t));
  },
  transform(e, t) {
    this.add(e, this.dataflow.add(this.transforms[Qne(t)]));
  },
  stream(e, t) {
    this.set(e.id, t);
  },
  update(e, t, n, r, i) {
    this.dataflow.on(t, n, r, i, e.options);
  },
  // expression parsing
  operatorExpression(e) {
    return this.expr.operator(this, e);
  },
  parameterExpression(e) {
    return this.expr.parameter(this, e);
  },
  eventExpression(e) {
    return this.expr.event(this, e);
  },
  handlerExpression(e) {
    return this.expr.handler(this, e);
  },
  encodeExpression(e) {
    return this.expr.encode(this, e);
  },
  // parse methods
  parse: jDt,
  parseOperator: HDt,
  parseOperatorParameters: VDt,
  parseParameters: WDt,
  parseStream: nAt,
  parseUpdate: rAt,
  // state methods
  getState: oAt,
  setState: aAt
};
function sAt(e) {
  const t = e.container();
  t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), Oke(t, e.description()));
}
function Oke(e, t) {
  e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t));
}
function uAt(e) {
  e.add(null, (t) => (e._background = t.bg, e._resize = 1, t.bg), {
    bg: e._signals.background
  });
}
const EV = "default";
function lAt(e) {
  const t = e._signals.cursor || (e._signals.cursor = e.add({
    user: EV,
    item: null
  }));
  e.on(e.events("view", "pointermove"), t, (n, r) => {
    const i = t.value, o = i ? kt(i) ? i : i.user : EV, a = r.item && r.item.cursor || null;
    return i && o === i.user && a == i.item ? i : {
      user: o,
      item: a
    };
  }), e.add(null, function(n) {
    let r = n.cursor, i = this.value;
    return kt(r) || (i = r.item, r = r.user), BQ(e, r && r !== EV ? r : i || r), i;
  }, {
    cursor: t
  });
}
function BQ(e, t) {
  const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
  if (n)
    return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t;
}
function iz(e, t) {
  var n = e._runtime.data;
  return wn(n, t) || tt("Unrecognized data set: " + t), n[t];
}
function cAt(e, t) {
  return arguments.length < 2 ? iz(this, e).values.value : s8.call(this, e, o2().remove(vp).insert(t));
}
function s8(e, t) {
  fDe(t) || tt("Second argument to changes must be a changeset.");
  const n = iz(this, e);
  return n.modified = !0, this.pulse(n.input, t);
}
function fAt(e, t) {
  return s8.call(this, e, o2().insert(t));
}
function dAt(e, t) {
  return s8.call(this, e, o2().remove(t));
}
function Rke(e) {
  var t = e.padding();
  return Math.max(0, e._viewWidth + t.left + t.right);
}
function kke(e) {
  var t = e.padding();
  return Math.max(0, e._viewHeight + t.top + t.bottom);
}
function u8(e) {
  var t = e.padding(), n = e._origin;
  return [t.left + n[0], t.top + n[1]];
}
function hAt(e) {
  var t = u8(e), n = Rke(e), r = kke(e);
  e._renderer.background(e.background()), e._renderer.resize(n, r, t), e._handler.origin(t), e._resizeListeners.forEach((i) => {
    try {
      i(n, r);
    } catch (o) {
      e.error(o);
    }
  });
}
function pAt(e, t, n) {
  var r = e._renderer, i = r && r.canvas(), o, a, s;
  return i && (s = u8(e), a = t.changedTouches ? t.changedTouches[0] : t, o = X6(a, i), o[0] -= s[0], o[1] -= s[1]), t.dataflow = e, t.item = n, t.vega = gAt(e, n, o), t;
}
function gAt(e, t, n) {
  const r = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
  function i(a) {
    var s = r, u;
    if (a) {
      for (u = t; u; u = u.mark.group)
        if (u.mark.name === a) {
          s = u;
          break;
        }
    }
    return s && s.mark && s.mark.interactive ? s : {};
  }
  function o(a) {
    if (!a)
      return n;
    kt(a) && (a = i(a));
    const s = n.slice();
    for (; a; )
      s[0] -= a.x || 0, s[1] -= a.y || 0, a = a.mark && a.mark.group;
    return s;
  }
  return {
    view: Gl(e),
    item: Gl(t || {}),
    group: i,
    xy: o,
    x: (a) => o(a)[0],
    y: (a) => o(a)[1]
  };
}
const Ome = "view", mAt = "timer", yAt = "window", vAt = {
  trap: !1
};
function bAt(e) {
  const t = hr({
    defaults: {}
  }, e), n = (r, i) => {
    i.forEach((o) => {
      nt(r[o]) && (r[o] = Wg(r[o]));
    });
  };
  return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t;
}
function $ke(e, t, n, r) {
  e._eventListeners.push({
    type: n,
    sources: Rt(t),
    handler: r
  });
}
function xAt(e, t) {
  var n = e._eventConfig.defaults, r = n.prevent, i = n.allow;
  return r === !1 || i === !0 ? !1 : r === !0 || i === !1 ? !0 : r ? r[t] : i ? !i[t] : e.preventDefault();
}
function R3(e, t, n) {
  const r = e._eventConfig && e._eventConfig[t];
  return r === !1 || Pt(r) && !r[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
}
function wAt(e, t, n) {
  var r = this, i = new A6(n), o = function(l, f) {
    r.runAsync(null, () => {
      e === Ome && xAt(r, t) && l.preventDefault(), i.receive(pAt(r, l, f));
    });
  }, a;
  if (e === mAt)
    R3(r, "timer", t) && r.timer(o, t);
  else if (e === Ome)
    R3(r, "view", t) && r.addEventListener(t, o, vAt);
  else if (e === yAt ? R3(r, "window", t) && typeof window < "u" && (a = [window]) : typeof document < "u" && R3(r, "selector", t) && (a = Array.from(document.querySelectorAll(e))), !a)
    r.warn("Can not resolve event source: " + e);
  else {
    for (var s = 0, u = a.length; s < u; ++s)
      a[s].addEventListener(t, o);
    $ke(r, a, t, o);
  }
  return i;
}
function Rme(e) {
  return e.item;
}
function kme(e) {
  return e.item.mark.source;
}
function $me(e) {
  return function(t, n) {
    return n.vega.view().changeset().encode(n.item, e);
  };
}
function _At(e, t) {
  return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "pointerover", Rme), kme, $me(e)), this.on(this.events("view", "pointerout", Rme), kme, $me(t)), this;
}
function EAt() {
  var e = this._tooltip, t = this._timers, n = this._handler.handlers(), r = this._eventListeners, i, o, a, s, u;
  for (i = t.length; --i >= 0; )
    t[i].stop();
  for (i = r.length; --i >= 0; )
    for (a = r[i], o = a.sources.length; --o >= 0; )
      a.sources[o].removeEventListener(a.type, a.handler);
  for (e && e.call(this, this._handler, null, null, null), i = n.length; --i >= 0; )
    u = n[i].type, s = n[i].handler, this._handler.off(u, s);
  return this;
}
function Pd(e, t, n) {
  const r = document.createElement(e);
  for (const i in t)
    r.setAttribute(i, t[i]);
  return n != null && (r.textContent = n), r;
}
const SAt = "vega-bind", MAt = "vega-bind-name", TAt = "vega-bind-radio";
function CAt(e, t, n) {
  if (!t)
    return;
  const r = n.param;
  let i = n.state;
  return i || (i = n.state = {
    elements: null,
    active: !1,
    set: null,
    update: (a) => {
      a != e.signal(r.signal) && e.runAsync(null, () => {
        i.source = !0, e.signal(r.signal, a);
      });
    }
  }, r.debounce && (i.update = see(r.debounce, i.update))), (r.input == null && r.element ? NAt : AAt)(i, t, r, e), i.active || (e.on(e._signals[r.signal], null, () => {
    i.source ? i.source = !1 : i.set(e.signal(r.signal));
  }), i.active = !0), i;
}
function NAt(e, t, n, r) {
  const i = n.event || "input", o = () => e.update(t.value);
  r.signal(n.signal, t.value), t.addEventListener(i, o), $ke(r, t, i, o), e.set = (a) => {
    t.value = a, t.dispatchEvent(DAt(i));
  };
}
function DAt(e) {
  return typeof Event < "u" ? new Event(e) : {
    type: e
  };
}
function AAt(e, t, n, r) {
  const i = r.signal(n.signal), o = Pd("div", {
    class: SAt
  }), a = n.input === "radio" ? o : o.appendChild(Pd("label"));
  a.appendChild(Pd("span", {
    class: MAt
  }, n.name || n.signal)), t.appendChild(o);
  let s = OAt;
  switch (n.input) {
    case "checkbox":
      s = RAt;
      break;
    case "select":
      s = kAt;
      break;
    case "radio":
      s = $At;
      break;
    case "range":
      s = PAt;
      break;
  }
  s(e, a, n, i);
}
function OAt(e, t, n, r) {
  const i = Pd("input");
  for (const o in n)
    o !== "signal" && o !== "element" && i.setAttribute(o === "input" ? "type" : o, n[o]);
  i.setAttribute("name", n.signal), i.value = r, t.appendChild(i), i.addEventListener("input", () => e.update(i.value)), e.elements = [i], e.set = (o) => i.value = o;
}
function RAt(e, t, n, r) {
  const i = {
    type: "checkbox",
    name: n.signal
  };
  r && (i.checked = !0);
  const o = Pd("input", i);
  t.appendChild(o), o.addEventListener("change", () => e.update(o.checked)), e.elements = [o], e.set = (a) => o.checked = !!a || null;
}
function kAt(e, t, n, r) {
  const i = Pd("select", {
    name: n.signal
  }), o = n.labels || [];
  n.options.forEach((a, s) => {
    const u = {
      value: a
    };
    oz(a, r) && (u.selected = !0), i.appendChild(Pd("option", u, (o[s] || a) + ""));
  }), t.appendChild(i), i.addEventListener("change", () => {
    e.update(n.options[i.selectedIndex]);
  }), e.elements = [i], e.set = (a) => {
    for (let s = 0, u = n.options.length; s < u; ++s)
      if (oz(n.options[s], a)) {
        i.selectedIndex = s;
        return;
      }
  };
}
function $At(e, t, n, r) {
  const i = Pd("span", {
    class: TAt
  }), o = n.labels || [];
  t.appendChild(i), e.elements = n.options.map((a, s) => {
    const u = {
      type: "radio",
      name: n.signal,
      value: a
    };
    oz(a, r) && (u.checked = !0);
    const l = Pd("input", u);
    l.addEventListener("change", () => e.update(a));
    const f = Pd("label", {}, (o[s] || a) + "");
    return f.prepend(l), i.appendChild(f), l;
  }), e.set = (a) => {
    const s = e.elements, u = s.length;
    for (let l = 0; l < u; ++l)
      oz(s[l].value, a) && (s[l].checked = !0);
  };
}
function PAt(e, t, n, r) {
  r = r !== void 0 ? r : (+n.max + +n.min) / 2;
  const i = n.max != null ? n.max : Math.max(100, +r) || 100, o = n.min || Math.min(0, i, +r) || 0, a = n.step || Zx(o, i, 100), s = Pd("input", {
    type: "range",
    name: n.signal,
    min: o,
    max: i,
    step: a
  });
  s.value = r;
  const u = Pd("span", {}, +r);
  t.appendChild(s), t.appendChild(u);
  const l = () => {
    u.textContent = s.value, e.update(+s.value);
  };
  s.addEventListener("input", l), s.addEventListener("change", l), e.elements = [s], e.set = (f) => {
    s.value = f, u.textContent = f;
  };
}
function oz(e, t) {
  return e === t || e + "" == t + "";
}
function Pke(e, t, n, r, i, o) {
  return t = t || new r(e.loader()), t.initialize(n, Rke(e), kke(e), u8(e), i, o).background(e.background());
}
function Xne(e, t) {
  return t ? function() {
    try {
      t.apply(this, arguments);
    } catch (n) {
      e.error(n);
    }
  } : null;
}
function IAt(e, t, n, r) {
  const i = new r(e.loader(), Xne(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, u8(e), e);
  return t && t.handlers().forEach((o) => {
    i.on(o.type, o.handler);
  }), i;
}
function jAt(e, t) {
  const n = this, r = n._renderType, i = n._eventConfig.bind, o = K6(r);
  e = n._el = e ? SV(n, e, !0) : null, sAt(n), o || n.error("Unrecognized renderer type: " + r);
  const a = o.handler || p4, s = e ? o.renderer : o.headless;
  return n._renderer = s ? Pke(n, n._renderer, e, s) : null, n._handler = IAt(n, n._handler, e, a), n._redraw = !0, e && i !== "none" && (t = t ? n._elBind = SV(n, t, !0) : e.appendChild(Pd("form", {
    class: "vega-bindings"
  })), n._bind.forEach((u) => {
    u.param.element && i !== "container" && (u.element = SV(n, u.param.element, !!u.param.input));
  }), n._bind.forEach((u) => {
    CAt(n, u.element || t, u);
  })), n;
}
function SV(e, t, n) {
  if (typeof t == "string")
    if (typeof document < "u") {
      if (t = document.querySelector(t), !t)
        return e.error("Signal bind element not found: " + t), null;
    } else
      return e.error("DOM document instance not found."), null;
  if (t && n)
    try {
      t.textContent = "";
    } catch (r) {
      t = null, e.error(r);
    }
  return t;
}
const cO = (e) => +e || 0, LAt = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function Pme(e) {
  return Pt(e) ? {
    top: cO(e.top),
    bottom: cO(e.bottom),
    left: cO(e.left),
    right: cO(e.right)
  } : LAt(cO(e));
}
async function Kne(e, t, n, r) {
  const i = K6(t), o = i && i.headless;
  return o || tt("Unrecognized renderer type: " + t), await e.runAsync(), Pke(e, null, null, o, n, r).renderAsync(e._scenegraph.root);
}
async function zAt(e, t) {
  e !== Dx.Canvas && e !== Dx.SVG && e !== Dx.PNG && tt("Unrecognized image type: " + e);
  const n = await Kne(this, e, t);
  return e === Dx.SVG ? FAt(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png");
}
function FAt(e, t) {
  const n = new Blob([e], {
    type: t
  });
  return window.URL.createObjectURL(n);
}
async function BAt(e, t) {
  return (await Kne(this, Dx.Canvas, e, t)).canvas();
}
async function UAt(e) {
  return (await Kne(this, Dx.SVG, e)).svg();
}
function YAt(e, t, n) {
  return Dke(e, TC, n$, n).parse(t);
}
function HAt(e) {
  var t = this._runtime.scales;
  return wn(t, e) || tt("Unrecognized scale or projection: " + e), t[e].value;
}
var Ike = "width", jke = "height", Zne = "padding", Ime = {
  skip: !0
};
function Lke(e, t) {
  var n = e.autosize(), r = e.padding();
  return t - (n && n.contains === Zne ? r.left + r.right : 0);
}
function zke(e, t) {
  var n = e.autosize(), r = e.padding();
  return t - (n && n.contains === Zne ? r.top + r.bottom : 0);
}
function VAt(e) {
  var t = e._signals, n = t[Ike], r = t[jke], i = t[Zne];
  function o() {
    e._autosize = e._resize = 1;
  }
  e._resizeWidth = e.add(null, (s) => {
    e._width = s.size, e._viewWidth = Lke(e, s.size), o();
  }, {
    size: n
  }), e._resizeHeight = e.add(null, (s) => {
    e._height = s.size, e._viewHeight = zke(e, s.size), o();
  }, {
    size: r
  });
  const a = e.add(null, o, {
    pad: i
  });
  e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = r.rank + 1, a.rank = i.rank + 1;
}
function WAt(e, t, n, r, i, o) {
  this.runAfter((a) => {
    let s = 0;
    a._autosize = 0, a.width() !== n && (s = 1, a.signal(Ike, n, Ime), a._resizeWidth.skip(!0)), a.height() !== r && (s = 1, a.signal(jke, r, Ime), a._resizeHeight.skip(!0)), a._viewWidth !== e && (a._resize = 1, a._viewWidth = e), a._viewHeight !== t && (a._resize = 1, a._viewHeight = t), (a._origin[0] !== i[0] || a._origin[1] !== i[1]) && (a._resize = 1, a._origin = i), s && a.run("enter"), o && a.runAfter((u) => u.resize());
  }, !1, 1);
}
function qAt(e) {
  return this._runtime.getState(e || {
    data: GAt,
    signals: QAt,
    recurse: !0
  });
}
function GAt(e, t) {
  return t.modified && nt(t.input.value) && !e.startsWith("_:vega:_");
}
function QAt(e, t) {
  return !(e === "parent" || t instanceof TC.proxy);
}
function XAt(e) {
  return this.runAsync(null, (t) => {
    t._trigger = !1, t._runtime.setState(e);
  }, (t) => {
    t._trigger = !0;
  }), this;
}
function KAt(e, t) {
  function n(r) {
    e({
      timestamp: Date.now(),
      elapsed: r
    });
  }
  this._timers.push(Rat(n, t));
}
function ZAt(e, t, n, r) {
  const i = e.element();
  i && i.setAttribute("title", JAt(r));
}
function JAt(e) {
  return e == null ? "" : nt(e) ? Fke(e) : Pt(e) && !zx(e) ? eOt(e) : e + "";
}
function eOt(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return t + ": " + (nt(n) ? Fke(n) : Bke(n));
  }).join(`
`);
}
function Fke(e) {
  return "[" + e.map(Bke).join(", ") + "]";
}
function Bke(e) {
  return nt(e) ? "[…]" : Pt(e) && !zx(e) ? "{…}" : e;
}
function tOt() {
  if (this.renderer() === "canvas" && this._renderer._canvas) {
    let e = null;
    const t = () => {
      e != null && e();
      const n = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      n.addEventListener("change", t), e = () => {
        n.removeEventListener("change", t);
      }, this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1, this._redraw = !0, this._resize = 1, this.resize().runAsync();
    };
    t();
  }
}
function Uke(e, t) {
  const n = this;
  if (t = t || {}, $T.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
    const o = hr({}, e.locale, t.locale);
    n.locale(tDe(o.number, o.time));
  }
  n._el = null, n._elBind = null, n._renderType = t.renderer || Dx.Canvas, n._scenegraph = new QAe();
  const r = n._scenegraph.root;
  n._renderer = null, n._tooltip = t.tooltip || ZAt, n._redraw = !0, n._handler = new p4().scene(r), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = bAt(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
  const i = YAt(n, e, t.expr);
  n._runtime = i, n._signals = i.signals, n._bind = (e.bindings || []).map((o) => ({
    state: null,
    param: hr({}, o)
  })), i.root && i.root.set(r), r.source = i.data.root.input, n.pulse(i.data.root.input, n.changeset().insert(r.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = Lke(n, n._width), n._viewHeight = zke(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, VAt(n), uAt(n), lAt(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind), t.watchPixelRatio && n._watchPixelRatio();
}
function k3(e, t) {
  return wn(e._signals, t) ? e._signals[t] : tt("Unrecognized signal name: " + Et(t));
}
function Yke(e, t) {
  const n = (e._targets || []).filter((r) => r._update && r._update.handler === t);
  return n.length ? n[0] : null;
}
function jme(e, t, n, r) {
  let i = Yke(n, r);
  return i || (i = Xne(e, () => r(t, n.value)), i.handler = r, e.on(n, null, i)), e;
}
function Lme(e, t, n) {
  const r = Yke(t, n);
  return r && t._targets.remove(r), e;
}
Tt(Uke, $T, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(e, t, n) {
    if (await $T.prototype.evaluate.call(this, e, t), this._redraw || this._resize)
      try {
        this._renderer && (this._resize && (this._resize = 0, hAt(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
      } catch (r) {
        this.error(r);
      }
    return n && dj(this, n), this;
  },
  dirty(e) {
    this._redraw = !0, this._renderer && this._renderer.dirty(e);
  },
  // -- GET / SET ----
  description(e) {
    if (arguments.length) {
      const t = e != null ? e + "" : null;
      return t !== this._desc && Oke(this._el, this._desc = t), this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(e, t, n) {
    const r = k3(this, e);
    return arguments.length === 1 ? r.value : this.update(r, t, n);
  },
  width(e) {
    return arguments.length ? this.signal("width", e) : this.signal("width");
  },
  height(e) {
    return arguments.length ? this.signal("height", e) : this.signal("height");
  },
  padding(e) {
    return arguments.length ? this.signal("padding", Pme(e)) : Pme(this.signal("padding"));
  },
  autosize(e) {
    return arguments.length ? this.signal("autosize", e) : this.signal("autosize");
  },
  background(e) {
    return arguments.length ? this.signal("background", e) : this.signal("background");
  },
  renderer(e) {
    return arguments.length ? (K6(e) || tt("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
  },
  tooltip(e) {
    return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip;
  },
  loader(e) {
    return arguments.length ? (e !== this._loader && ($T.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader;
  },
  resize() {
    return this._autosize = 1, this.touch(k3(this, "autosize"));
  },
  _resetRenderer() {
    this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind));
  },
  // -- SIZING ----
  _resizeView: WAt,
  // -- EVENT HANDLING ----
  addEventListener(e, t, n) {
    let r = t;
    return n && n.trap === !1 || (r = Xne(this, t), r.raw = t), this._handler.on(e, r), this;
  },
  removeEventListener(e, t) {
    for (var n = this._handler.handlers(e), r = n.length, i, o; --r >= 0; )
      if (o = n[r].type, i = n[r].handler, e === o && (t === i || t === i.raw)) {
        this._handler.off(o, i);
        break;
      }
    return this;
  },
  addResizeListener(e) {
    const t = this._resizeListeners;
    return t.includes(e) || t.push(e), this;
  },
  removeResizeListener(e) {
    var t = this._resizeListeners, n = t.indexOf(e);
    return n >= 0 && t.splice(n, 1), this;
  },
  addSignalListener(e, t) {
    return jme(this, e, k3(this, e), t);
  },
  removeSignalListener(e, t) {
    return Lme(this, k3(this, e), t);
  },
  addDataListener(e, t) {
    return jme(this, e, iz(this, e).values, t);
  },
  removeDataListener(e, t) {
    return Lme(this, iz(this, e).values, t);
  },
  globalCursor(e) {
    if (arguments.length) {
      if (this._globalCursor !== !!e) {
        const t = BQ(this, null);
        this._globalCursor = !!e, t && BQ(this, t);
      }
      return this;
    } else
      return this._globalCursor;
  },
  preventDefault(e) {
    return arguments.length ? (this._preventDefault = e, this) : this._preventDefault;
  },
  timer: KAt,
  events: wAt,
  finalize: EAt,
  hover: _At,
  // -- DATA ----
  data: cAt,
  change: s8,
  insert: fAt,
  remove: dAt,
  // -- SCALES --
  scale: HAt,
  // -- INITIALIZATION ----
  initialize: jAt,
  // -- HEADLESS RENDERING ----
  toImageURL: zAt,
  toCanvas: BAt,
  toSVG: UAt,
  // -- SAVE / RESTORE STATE ----
  getState: qAt,
  setState: XAt,
  // RE-RENDER ON ZOOM
  _watchPixelRatio: tOt
});
const nOt = "view", az = "[", sz = "]", Hke = "{", Vke = "}", rOt = ":", Wke = ",", iOt = "@", oOt = ">", aOt = /[[\]{}]/, sOt = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let qke, Gke;
function jw(e, t, n) {
  return qke = t || nOt, Gke = n || sOt, Qke(e.trim()).map(UQ);
}
function uOt(e) {
  return Gke[e];
}
function VR(e, t, n, r, i) {
  const o = e.length;
  let a = 0, s;
  for (; t < o; ++t) {
    if (s = e[t], !a && s === n)
      return t;
    i && i.indexOf(s) >= 0 ? --a : r && r.indexOf(s) >= 0 && ++a;
  }
  return t;
}
function Qke(e) {
  const t = [], n = e.length;
  let r = 0, i = 0;
  for (; i < n; )
    i = VR(e, i, Wke, az + Hke, sz + Vke), t.push(e.substring(r, i).trim()), r = ++i;
  if (t.length === 0)
    throw "Empty event selector: " + e;
  return t;
}
function UQ(e) {
  return e[0] === "[" ? lOt(e) : cOt(e);
}
function lOt(e) {
  const t = e.length;
  let n = 1, r;
  if (n = VR(e, n, sz, az, sz), n === t)
    throw "Empty between selector: " + e;
  if (r = Qke(e.substring(1, n)), r.length !== 2)
    throw "Between selector must have two elements: " + e;
  if (e = e.slice(n + 1).trim(), e[0] !== oOt)
    throw "Expected '>' after between selector: " + e;
  r = r.map(UQ);
  const i = UQ(e.slice(1).trim());
  return i.between ? {
    between: r,
    stream: i
  } : (i.between = r, i);
}
function cOt(e) {
  const t = {
    source: qke
  }, n = [];
  let r = [0, 0], i = 0, o = 0, a = e.length, s = 0, u, l;
  if (e[a - 1] === Vke) {
    if (s = e.lastIndexOf(Hke), s >= 0) {
      try {
        r = fOt(e.substring(s + 1, a - 1));
      } catch {
        throw "Invalid throttle specification: " + e;
      }
      e = e.slice(0, s).trim(), a = e.length;
    } else
      throw "Unmatched right brace: " + e;
    s = 0;
  }
  if (!a)
    throw e;
  if (e[0] === iOt && (i = ++s), u = VR(e, s, rOt), u < a && (n.push(e.substring(o, u).trim()), o = s = ++u), s = VR(e, s, az), s === a)
    n.push(e.substring(o, a).trim());
  else if (n.push(e.substring(o, s).trim()), l = [], o = ++s, o === a)
    throw "Unmatched left bracket: " + e;
  for (; s < a; ) {
    if (s = VR(e, s, sz), s === a)
      throw "Unmatched left bracket: " + e;
    if (l.push(e.substring(o, s).trim()), s < a - 1 && e[++s] !== az)
      throw "Expected left bracket: " + e;
    o = ++s;
  }
  if (!(a = n.length) || aOt.test(n[a - 1]))
    throw "Invalid event selector: " + e;
  return a > 1 ? (t.type = n[1], i ? t.markname = n[0].slice(1) : uOt(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), l != null && (t.filter = l), r[0] && (t.throttle = r[0]), r[1] && (t.debounce = r[1]), t;
}
function fOt(e) {
  const t = e.split(Wke);
  if (!e.length || t.length > 2)
    throw e;
  return t.map((n) => {
    const r = +n;
    if (r !== r)
      throw e;
    return r;
  });
}
function dOt(e) {
  return Pt(e) ? e : {
    type: e || "pad"
  };
}
const fO = (e) => +e || 0, hOt = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function pOt(e) {
  return Pt(e) ? e.signal ? e : {
    top: fO(e.top),
    bottom: fO(e.bottom),
    left: fO(e.left),
    right: fO(e.right)
  } : hOt(fO(e));
}
const yu = (e) => Pt(e) && !nt(e) ? hr({}, e) : {
  value: e
};
function zme(e, t, n, r) {
  return n != null ? (Pt(n) && !nt(n) || nt(n) && n.length && Pt(n[0]) ? e.update[t] = n : e[r || "enter"][t] = {
    value: n
  }, 1) : 0;
}
function ol(e, t, n) {
  for (const r in t)
    zme(e, r, t[r]);
  for (const r in n)
    zme(e, r, n[r], "update");
}
function $N(e, t, n) {
  for (const r in t)
    n && wn(n, r) || (e[r] = hr(e[r] || {}, t[r]));
  return e;
}
function sT(e, t) {
  return t && (t.enter && t.enter[e] || t.update && t.update[e]);
}
const Jne = "mark", ere = "frame", tre = "scope", gOt = "axis", mOt = "axis-domain", yOt = "axis-grid", vOt = "axis-label", bOt = "axis-tick", xOt = "axis-title", wOt = "legend", _Ot = "legend-band", EOt = "legend-entry", SOt = "legend-gradient", Xke = "legend-label", MOt = "legend-symbol", TOt = "legend-title", COt = "title", NOt = "title-text", DOt = "title-subtitle";
function AOt(e, t, n, r, i) {
  const o = {}, a = {};
  let s, u, l, f;
  u = "lineBreak", t === "text" && i[u] != null && !sT(u, e) && MV(o, u, i[u]), (n == "legend" || String(n).startsWith("axis")) && (n = null), f = n === ere ? i.group : n === Jne ? hr({}, i.mark, i[t]) : null;
  for (u in f)
    l = sT(u, e) || (u === "fill" || u === "stroke") && (sT("fill", e) || sT("stroke", e)), l || MV(o, u, f[u]);
  Rt(r).forEach((h) => {
    const p = i.style && i.style[h];
    for (const g in p)
      sT(g, e) || MV(o, g, p[g]);
  }), e = hr({}, e);
  for (u in o)
    f = o[u], f.signal ? (s = s || {})[u] = f : a[u] = f;
  return e.enter = hr(a, e.enter), s && (e.update = hr(s, e.update)), e;
}
function MV(e, t, n) {
  e[t] = n && n.signal ? {
    signal: n.signal
  } : {
    value: n
  };
}
const Kke = (e) => kt(e) ? Et(e) : e.signal ? `(${e.signal})` : Zke(e);
function l8(e) {
  if (e.gradient != null)
    return ROt(e);
  let t = e.signal ? `(${e.signal})` : e.color ? OOt(e.color) : e.field != null ? Zke(e.field) : e.value !== void 0 ? Et(e.value) : void 0;
  return e.scale != null && (t = kOt(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${Cj(e.exponent)})`), e.mult != null && (t += `*${Cj(e.mult)}`), e.offset != null && (t += `+${Cj(e.offset)}`), e.round && (t = `round(${t})`), t;
}
const $3 = (e, t, n, r) => `(${e}(${[t, n, r].map(l8).join(",")})+'')`;
function OOt(e) {
  return e.c ? $3("hcl", e.h, e.c, e.l) : e.h || e.s ? $3("hsl", e.h, e.s, e.l) : e.l || e.a ? $3("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? $3("rgb", e.r, e.g, e.b) : null;
}
function ROt(e) {
  const t = [e.start, e.stop, e.count].map((n) => n == null ? null : Et(n));
  for (; t.length && ri(t) == null; )
    t.pop();
  return t.unshift(Kke(e.gradient)), `gradient(${t.join(",")})`;
}
function Cj(e) {
  return Pt(e) ? "(" + l8(e) + ")" : e;
}
function Zke(e) {
  return Jke(Pt(e) ? e : {
    datum: e
  });
}
function Jke(e) {
  let t, n, r;
  if (e.signal)
    t = "datum", r = e.signal;
  else if (e.group || e.parent) {
    for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0; )
      t += ".mark.group";
    e.parent ? (r = e.parent, t += ".datum") : r = e.group;
  } else
    e.datum ? (t = "datum", r = e.datum) : tt("Invalid field reference: " + Et(e));
  return e.signal || (r = kt(r) ? av(r).map(Et).join("][") : Jke(r)), t + "[" + r + "]";
}
function kOt(e, t) {
  const n = Kke(e.scale);
  return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + Cj(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t;
}
function $Ot(e) {
  let t = "";
  return e.forEach((n) => {
    const r = l8(n);
    t += n.test ? `(${n.test})?${r}:` : r;
  }), ri(t) === ":" && (t += "null"), t;
}
function e$e(e, t, n, r, i, o) {
  const a = {};
  o = o || {}, o.encoders = {
    $encode: a
  }, e = AOt(e, t, n, r, i.config);
  for (const s in e)
    a[s] = POt(e[s], t, o, i);
  return o;
}
function POt(e, t, n, r) {
  const i = {}, o = {};
  for (const a in e)
    e[a] != null && (i[a] = jOt(IOt(e[a]), r, n, o));
  return {
    $expr: {
      marktype: t,
      channels: i
    },
    $fields: Object.keys(o),
    $output: Object.keys(e)
  };
}
function IOt(e) {
  return nt(e) ? $Ot(e) : l8(e);
}
function jOt(e, t, n, r) {
  const i = Ky(e, t);
  return i.$fields.forEach((o) => r[o] = 1), hr(n, i.$params), i.$expr;
}
const LOt = "outer", zOt = ["value", "update", "init", "react", "bind"];
function Fme(e, t) {
  tt(e + ' for "outer" push: ' + Et(t));
}
function t$e(e, t) {
  const n = e.name;
  if (e.push === LOt)
    t.signals[n] || Fme("No prior signal definition", n), zOt.forEach((r) => {
      e[r] !== void 0 && Fme("Invalid property ", r);
    });
  else {
    const r = t.addSignal(n, e.value);
    e.react === !1 && (r.react = !1), e.bind && t.addBinding(n, e.bind);
  }
}
function YQ(e, t, n, r) {
  this.id = -1, this.type = e, this.value = t, this.params = n, r && (this.parent = r);
}
function c8(e, t, n, r) {
  return new YQ(e, t, n, r);
}
function uz(e, t) {
  return c8("operator", e, t);
}
function vn(e) {
  const t = {
    $ref: e.id
  };
  return e.id < 0 && (e.refs = e.refs || []).push(t), t;
}
function r$(e, t) {
  return t ? {
    $field: e,
    $name: t
  } : {
    $field: e
  };
}
const HQ = r$("key");
function Bme(e, t) {
  return {
    $compare: e,
    $order: t
  };
}
function FOt(e, t) {
  const n = {
    $key: e
  };
  return t && (n.$flat = !0), n;
}
const BOt = "ascending", UOt = "descending";
function YOt(e) {
  return Pt(e) ? (e.order === UOt ? "-" : "+") + f8(e.op, e.field) : "";
}
function f8(e, t) {
  return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "");
}
const nre = "scope", VQ = "view";
function Ws(e) {
  return e && e.signal;
}
function HOt(e) {
  return e && e.expr;
}
function Nj(e) {
  if (Ws(e))
    return !0;
  if (Pt(e)) {
    for (const t in e)
      if (Nj(e[t]))
        return !0;
  }
  return !1;
}
function Sg(e, t) {
  return e ?? t;
}
function aS(e) {
  return e && e.signal || e;
}
const Ume = "timer";
function i$(e, t) {
  return (e.merge ? WOt : e.stream ? qOt : e.type ? GOt : tt("Invalid stream specification: " + Et(e)))(e, t);
}
function VOt(e) {
  return e === nre ? VQ : e || VQ;
}
function WOt(e, t) {
  const n = e.merge.map((i) => i$(i, t)), r = rre({
    merge: n
  }, e, t);
  return t.addStream(r).id;
}
function qOt(e, t) {
  const n = i$(e.stream, t), r = rre({
    stream: n
  }, e, t);
  return t.addStream(r).id;
}
function GOt(e, t) {
  let n;
  e.type === Ume ? (n = t.event(Ume, e.throttle), e = {
    between: e.between,
    filter: e.filter
  }) : n = t.event(VOt(e.source), e.type);
  const r = rre({
    stream: n
  }, e, t);
  return Object.keys(r).length === 1 ? n : t.addStream(r).id;
}
function rre(e, t, n) {
  let r = t.between;
  return r && (r.length !== 2 && tt('Stream "between" parameter must have 2 entries: ' + Et(t)), e.between = [i$(r[0], n), i$(r[1], n)]), r = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && r.push(QOt(t.marktype, t.markname, t.markrole)), t.source === nre && r.push("inScope(event.item)"), r.length && (e.filter = Ky("(" + r.join(")&&(") + ")", n).$expr), (r = t.throttle) != null && (e.throttle = +r), (r = t.debounce) != null && (e.debounce = +r), t.consume && (e.consume = !0), e;
}
function QOt(e, t, n) {
  const r = "event.item";
  return r + (e && e !== "*" ? "&&" + r + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + r + ".mark.role==='" + n + "'" : "") + (t ? "&&" + r + ".mark.name==='" + t + "'" : "");
}
const XOt = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function KOt(e, t, n) {
  const r = e.encode, i = {
    target: n
  };
  let o = e.events, a = e.update, s = [];
  o || tt("Signal update missing events specification."), kt(o) && (o = jw(o, t.isSubscope() ? nre : VQ)), o = Rt(o).filter((u) => u.signal || u.scale ? (s.push(u), 0) : 1), s.length > 1 && (s = [JOt(s)]), o.length && s.push(o.length > 1 ? {
    merge: o
  } : o[0]), r != null && (a && tt("Signal encode and update are mutually exclusive."), a = "encode(item()," + Et(r) + ")"), i.update = kt(a) ? Ky(a, t) : a.expr != null ? Ky(a.expr, t) : a.value != null ? a.value : a.signal != null ? {
    $expr: XOt,
    $params: {
      $value: t.signalRef(a.signal)
    }
  } : tt("Invalid signal update specification."), e.force && (i.options = {
    force: !0
  }), s.forEach((u) => t.addUpdate(hr(ZOt(u, t), i)));
}
function ZOt(e, t) {
  return {
    source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : i$(e, t)
  };
}
function JOt(e) {
  return {
    signal: "[" + e.map((t) => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
  };
}
function eRt(e, t) {
  const n = t.getSignal(e.name);
  let r = e.update;
  e.init && (r ? tt("Signals can not include both init and update expressions.") : (r = e.init, n.initonly = !0)), r && (r = Ky(r, t), n.update = r.$expr, n.params = r.$params), e.on && e.on.forEach((i) => KOt(i, t, n.id));
}
const yo = (e) => (t, n, r) => c8(e, n, t || void 0, r), n$e = yo("aggregate"), tRt = yo("axisticks"), r$e = yo("bound"), nm = yo("collect"), Yme = yo("compare"), nRt = yo("datajoin"), i$e = yo("encode"), rRt = yo("expression"), iRt = yo("facet"), oRt = yo("field"), aRt = yo("key"), sRt = yo("legendentries"), uRt = yo("load"), lRt = yo("mark"), cRt = yo("multiextent"), fRt = yo("multivalues"), dRt = yo("overlap"), hRt = yo("params"), o$e = yo("prefacet"), pRt = yo("projection"), gRt = yo("proxy"), mRt = yo("relay"), a$e = yo("render"), yRt = yo("scale"), u2 = yo("sieve"), vRt = yo("sortitems"), s$e = yo("viewlayout"), bRt = yo("values");
let xRt = 0;
const u$e = {
  min: "min",
  max: "max",
  count: "sum"
};
function wRt(e, t) {
  const n = e.type || "linear";
  sAe(n) || tt("Unrecognized scale type: " + Et(n)), t.addScale(e.name, {
    type: n,
    domain: void 0
  });
}
function _Rt(e, t) {
  const n = t.getScale(e.name).params;
  let r;
  n.domain = l$e(e.domain, e, t), e.range != null && (n.range = f$e(e, t, n)), e.interpolate != null && RRt(e.interpolate, n), e.nice != null && (n.nice = ORt(e.nice, t)), e.bins != null && (n.bins = ARt(e.bins, t));
  for (r in e)
    wn(n, r) || r === "name" || (n[r] = np(e[r], t));
}
function np(e, t) {
  return Pt(e) ? e.signal ? t.signalRef(e.signal) : tt("Unsupported object: " + Et(e)) : e;
}
function Dj(e, t) {
  return e.signal ? t.signalRef(e.signal) : e.map((n) => np(n, t));
}
function d8(e) {
  tt("Can not find data set: " + Et(e));
}
function l$e(e, t, n) {
  if (!e) {
    (t.domainMin != null || t.domainMax != null) && tt("No scale domain defined for domainMin/domainMax to override.");
    return;
  }
  return e.signal ? n.signalRef(e.signal) : (nt(e) ? ERt : e.fields ? MRt : SRt)(e, t, n);
}
function ERt(e, t, n) {
  return e.map((r) => np(r, n));
}
function SRt(e, t, n) {
  const r = n.getData(e.data);
  return r || d8(e.data), DC(t.type) ? r.valuesRef(n, e.field, c$e(e.sort, !1)) : cAe(t.type) ? r.domainRef(n, e.field) : r.extentRef(n, e.field);
}
function MRt(e, t, n) {
  const r = e.data, i = e.fields.reduce((o, a) => (a = kt(a) ? {
    data: r,
    field: a
  } : nt(a) || a.signal ? TRt(a, n) : a, o.push(a), o), []);
  return (DC(t.type) ? CRt : cAe(t.type) ? NRt : DRt)(e, n, i);
}
function TRt(e, t) {
  const n = "_:vega:_" + xRt++, r = nm({});
  if (nt(e))
    r.value = {
      $ingest: e
    };
  else if (e.signal) {
    const i = "setdata(" + Et(n) + "," + e.signal + ")";
    r.params.input = t.signalRef(i);
  }
  return t.addDataPipeline(n, [r, u2({})]), {
    data: n,
    field: "data"
  };
}
function CRt(e, t, n) {
  const r = c$e(e.sort, !0);
  let i, o;
  const a = n.map((l) => {
    const f = t.getData(l.data);
    return f || d8(l.data), f.countsRef(t, l.field, r);
  }), s = {
    groupby: HQ,
    pulse: a
  };
  r && (i = r.op || "count", o = r.field ? f8(i, r.field) : "count", s.ops = [u$e[i]], s.fields = [t.fieldRef(o)], s.as = [o]), i = t.add(n$e(s));
  const u = t.add(nm({
    pulse: vn(i)
  }));
  return o = t.add(bRt({
    field: HQ,
    sort: t.sortRef(r),
    pulse: vn(u)
  })), vn(o);
}
function c$e(e, t) {
  return e && (!e.field && !e.op ? Pt(e) ? e.field = "key" : e = {
    field: "key"
  } : !e.field && e.op !== "count" ? tt("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !u$e[e.op] && tt("Multiple domain scales can not be sorted using " + e.op)), e;
}
function NRt(e, t, n) {
  const r = n.map((i) => {
    const o = t.getData(i.data);
    return o || d8(i.data), o.domainRef(t, i.field);
  });
  return vn(t.add(fRt({
    values: r
  })));
}
function DRt(e, t, n) {
  const r = n.map((i) => {
    const o = t.getData(i.data);
    return o || d8(i.data), o.extentRef(t, i.field);
  });
  return vn(t.add(cRt({
    extents: r
  })));
}
function ARt(e, t) {
  return e.signal || nt(e) ? Dj(e, t) : t.objectProperty(e);
}
function ORt(e, t) {
  return e.signal ? t.signalRef(e.signal) : Pt(e) ? {
    interval: np(e.interval),
    step: np(e.step)
  } : np(e);
}
function RRt(e, t) {
  t.interpolate = np(e.type || e), e.gamma != null && (t.interpolateGamma = np(e.gamma));
}
function f$e(e, t, n) {
  const r = t.config.range;
  let i = e.range;
  if (i.signal)
    return t.signalRef(i.signal);
  if (kt(i)) {
    if (r && wn(r, i))
      return e = hr({}, e, {
        range: r[i]
      }), f$e(e, t, n);
    i === "width" ? i = [0, {
      signal: "width"
    }] : i === "height" ? i = DC(e.type) ? [0, {
      signal: "height"
    }] : [{
      signal: "height"
    }, 0] : tt("Unrecognized scale range value: " + Et(i));
  } else if (i.scheme) {
    n.scheme = nt(i.scheme) ? Dj(i.scheme, t) : np(i.scheme, t), i.extent && (n.schemeExtent = Dj(i.extent, t)), i.count && (n.schemeCount = np(i.count, t));
    return;
  } else if (i.step) {
    n.rangeStep = np(i.step, t);
    return;
  } else {
    if (DC(e.type) && !nt(i))
      return l$e(i, e, t);
    nt(i) || tt("Unsupported range type: " + Et(i));
  }
  return i.map((o) => (nt(o) ? Dj : np)(o, t));
}
function kRt(e, t) {
  const n = t.config.projection || {}, r = {};
  for (const i in e)
    i !== "name" && (r[i] = WQ(e[i], i, t));
  for (const i in n)
    r[i] == null && (r[i] = WQ(n[i], i, t));
  t.addProjection(e.name, r);
}
function WQ(e, t, n) {
  return nt(e) ? e.map((r) => WQ(r, t, n)) : Pt(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : tt("Unsupported parameter object: " + Et(e)) : e;
}
const rm = "top", PN = "left", IN = "right", hw = "bottom", d$e = "center", $Rt = "vertical", PRt = "start", IRt = "middle", jRt = "end", qQ = "index", ire = "label", LRt = "offset", IC = "perc", zRt = "perc2", ap = "value", w4 = "guide-label", ore = "guide-title", FRt = "group-title", BRt = "group-subtitle", Hme = "symbol", Aj = "gradient", GQ = "discrete", QQ = "size", URt = "shape", YRt = "fill", HRt = "stroke", VRt = "strokeWidth", WRt = "strokeDash", qRt = "opacity", are = [QQ, URt, YRt, HRt, VRt, WRt, qRt], _4 = {
  name: 1,
  style: 1,
  interactive: 1
}, ci = {
  value: 0
}, sp = {
  value: 1
}, h8 = "group", h$e = "rect", sre = "rule", GRt = "symbol", l2 = "text";
function o$(e) {
  return e.type = h8, e.interactive = e.interactive || !1, e;
}
function Bf(e, t) {
  const n = (r, i) => Sg(e[r], Sg(t[r], i));
  return n.isVertical = (r) => $Rt === Sg(e.direction, t.direction || (r ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => Sg(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => Sg(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => Sg(e.columns, Sg(t.columns, +n.isVertical(!0))), n;
}
function p$e(e, t) {
  const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
  return n && n.signal ? n : n ? n.value : null;
}
function QRt(e, t, n) {
  const r = t.config.style[n];
  return r && r[e];
}
function p8(e, t, n) {
  return `item.anchor === '${PRt}' ? ${e} : item.anchor === '${jRt}' ? ${t} : ${n}`;
}
const ure = p8(Et(PN), Et(IN), Et(d$e));
function XRt(e) {
  const t = e("tickBand");
  let n = e("tickOffset"), r, i;
  return t ? t.signal ? (r = {
    signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
  }, i = {
    signal: `(${t.signal}) === 'extent'`
  }, Pt(n) || (n = {
    signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
  })) : t === "extent" ? (r = 1, i = !0, n = 0) : (r = 0.5, i = !1) : (r = e("bandPosition"), i = e("tickExtra")), {
    extra: i,
    band: r,
    offset: n
  };
}
function g$e(e, t) {
  return t ? e ? Pt(e) ? Object.assign({}, e, {
    offset: g$e(e.offset, t)
  }) : {
    value: e,
    offset: t
  } : t : e;
}
function Vd(e, t) {
  return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = $N(e.encode, t, _4)) : e.interactive = !1, e;
}
function KRt(e, t, n, r) {
  const i = Bf(e, n), o = i.isVertical(), a = i.gradientThickness(), s = i.gradientLength();
  let u, l, f, h, p;
  o ? (l = [0, 1], f = [0, 0], h = a, p = s) : (l = [0, 0], f = [1, 0], h = s, p = a);
  const g = {
    enter: u = {
      opacity: ci,
      x: ci,
      y: ci,
      width: yu(h),
      height: yu(p)
    },
    update: hr({}, u, {
      opacity: sp,
      fill: {
        gradient: t,
        start: l,
        stop: f
      }
    }),
    exit: {
      opacity: ci
    }
  };
  return ol(g, {
    stroke: i("gradientStrokeColor"),
    strokeWidth: i("gradientStrokeWidth")
  }, {
    // update
    opacity: i("gradientOpacity")
  }), Vd({
    type: h$e,
    role: SOt,
    encode: g
  }, r);
}
function ZRt(e, t, n, r, i) {
  const o = Bf(e, n), a = o.isVertical(), s = o.gradientThickness(), u = o.gradientLength();
  let l, f, h, p, g = "";
  a ? (l = "y", h = "y2", f = "x", p = "width", g = "1-") : (l = "x", h = "x2", f = "y", p = "height");
  const y = {
    opacity: ci,
    fill: {
      scale: t,
      field: ap
    }
  };
  y[l] = {
    signal: g + "datum." + IC,
    mult: u
  }, y[f] = ci, y[h] = {
    signal: g + "datum." + zRt,
    mult: u
  }, y[p] = yu(s);
  const b = {
    enter: y,
    update: hr({}, y, {
      opacity: sp
    }),
    exit: {
      opacity: ci
    }
  };
  return ol(b, {
    stroke: o("gradientStrokeColor"),
    strokeWidth: o("gradientStrokeWidth")
  }, {
    // update
    opacity: o("gradientOpacity")
  }), Vd({
    type: h$e,
    role: _Ot,
    key: ap,
    from: i,
    encode: b
  }, r);
}
const JRt = `datum.${IC}<=0?"${PN}":datum.${IC}>=1?"${IN}":"${d$e}"`, ekt = `datum.${IC}<=0?"${hw}":datum.${IC}>=1?"${rm}":"${IRt}"`;
function Vme(e, t, n, r) {
  const i = Bf(e, t), o = i.isVertical(), a = yu(i.gradientThickness()), s = i.gradientLength();
  let u = i("labelOverlap"), l, f, h, p, g = "";
  const y = {
    enter: l = {
      opacity: ci
    },
    update: f = {
      opacity: sp,
      text: {
        field: ire
      }
    },
    exit: {
      opacity: ci
    }
  };
  return ol(y, {
    fill: i("labelColor"),
    fillOpacity: i("labelOpacity"),
    font: i("labelFont"),
    fontSize: i("labelFontSize"),
    fontStyle: i("labelFontStyle"),
    fontWeight: i("labelFontWeight"),
    limit: Sg(e.labelLimit, t.gradientLabelLimit)
  }), o ? (l.align = {
    value: "left"
  }, l.baseline = f.baseline = {
    signal: ekt
  }, h = "y", p = "x", g = "1-") : (l.align = f.align = {
    signal: JRt
  }, l.baseline = {
    value: "top"
  }, h = "x", p = "y"), l[h] = f[h] = {
    signal: g + "datum." + IC,
    mult: s
  }, l[p] = f[p] = a, a.offset = Sg(e.labelOffset, t.gradientLabelOffset) || 0, u = u ? {
    separation: i("labelSeparation"),
    method: u,
    order: "datum." + qQ
  } : void 0, Vd({
    type: l2,
    role: Xke,
    style: w4,
    key: ap,
    from: r,
    encode: y,
    overlap: u
  }, n);
}
function tkt(e, t, n, r, i) {
  const o = Bf(e, t), a = n.entries, s = !!(a && a.interactive), u = a ? a.name : void 0, l = o("clipHeight"), f = o("symbolOffset"), h = {
    data: "value"
  }, p = `(${i}) ? datum.${LRt} : datum.${QQ}`, g = l ? yu(l) : {
    field: QQ
  }, y = `datum.${qQ}`, b = `max(1, ${i})`;
  let _, S, C, A, O;
  g.mult = 0.5, _ = {
    enter: S = {
      opacity: ci,
      x: {
        signal: p,
        mult: 0.5,
        offset: f
      },
      y: g
    },
    update: C = {
      opacity: sp,
      x: S.x,
      y: S.y
    },
    exit: {
      opacity: ci
    }
  };
  let R = null, j = null;
  e.fill || (R = t.symbolBaseFillColor, j = t.symbolBaseStrokeColor), ol(_, {
    fill: o("symbolFillColor", R),
    shape: o("symbolType"),
    size: o("symbolSize"),
    stroke: o("symbolStrokeColor", j),
    strokeDash: o("symbolDash"),
    strokeDashOffset: o("symbolDashOffset"),
    strokeWidth: o("symbolStrokeWidth")
  }, {
    // update
    opacity: o("symbolOpacity")
  }), are.forEach((Y) => {
    e[Y] && (C[Y] = S[Y] = {
      scale: e[Y],
      field: ap
    });
  });
  const $ = Vd({
    type: GRt,
    role: MOt,
    key: ap,
    from: h,
    clip: l ? !0 : void 0,
    encode: _
  }, n.symbols), z = yu(f);
  z.offset = o("labelOffset"), _ = {
    enter: S = {
      opacity: ci,
      x: {
        signal: p,
        offset: z
      },
      y: g
    },
    update: C = {
      opacity: sp,
      text: {
        field: ire
      },
      x: S.x,
      y: S.y
    },
    exit: {
      opacity: ci
    }
  }, ol(_, {
    align: o("labelAlign"),
    baseline: o("labelBaseline"),
    fill: o("labelColor"),
    fillOpacity: o("labelOpacity"),
    font: o("labelFont"),
    fontSize: o("labelFontSize"),
    fontStyle: o("labelFontStyle"),
    fontWeight: o("labelFontWeight"),
    limit: o("labelLimit")
  });
  const W = Vd({
    type: l2,
    role: Xke,
    style: w4,
    key: ap,
    from: h,
    encode: _
  }, n.labels);
  return _ = {
    enter: {
      noBound: {
        value: !l
      },
      // ignore width/height in bounds calc
      width: ci,
      height: l ? yu(l) : ci,
      opacity: ci
    },
    exit: {
      opacity: ci
    },
    update: C = {
      opacity: sp,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }, o.isVertical(!0) ? (A = `ceil(item.mark.items.length / ${b})`, C.row.signal = `${y}%${A}`, C.column.signal = `floor(${y} / ${A})`, O = {
    field: ["row", y]
  }) : (C.row.signal = `floor(${y} / ${b})`, C.column.signal = `${y} % ${b}`, O = {
    field: y
  }), C.column.signal = `(${i})?${C.column.signal}:${y}`, r = {
    facet: {
      data: r,
      name: "value",
      groupby: qQ
    }
  }, o$({
    role: tre,
    from: r,
    encode: $N(_, a, _4),
    marks: [$, W],
    name: u,
    interactive: s,
    sort: O
  });
}
function nkt(e, t) {
  const n = Bf(e, t);
  return {
    align: n("gridAlign"),
    columns: n.entryColumns(),
    center: {
      row: !0,
      column: !1
    },
    padding: {
      row: n("rowPadding"),
      column: n("columnPadding")
    }
  };
}
const lre = 'item.orient === "left"', cre = 'item.orient === "right"', g8 = `(${lre} || ${cre})`, rkt = `datum.vgrad && ${g8}`, ikt = p8('"top"', '"bottom"', '"middle"'), okt = p8('"right"', '"left"', '"center"'), akt = `datum.vgrad && ${cre} ? (${okt}) : (${g8} && !(datum.vgrad && ${lre})) ? "left" : ${ure}`, skt = `item._anchor || (${g8} ? "middle" : "start")`, ukt = `${rkt} ? (${lre} ? -90 : 90) : 0`, lkt = `${g8} ? (datum.vgrad ? (${cre} ? "bottom" : "top") : ${ikt}) : "top"`;
function ckt(e, t, n, r) {
  const i = Bf(e, t), o = {
    enter: {
      opacity: ci
    },
    update: {
      opacity: sp,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: ci
    }
  };
  return ol(o, {
    orient: i("titleOrient"),
    _anchor: i("titleAnchor"),
    anchor: {
      signal: skt
    },
    angle: {
      signal: ukt
    },
    align: {
      signal: akt
    },
    baseline: {
      signal: lkt
    },
    text: e.title,
    fill: i("titleColor"),
    fillOpacity: i("titleOpacity"),
    font: i("titleFont"),
    fontSize: i("titleFontSize"),
    fontStyle: i("titleFontStyle"),
    fontWeight: i("titleFontWeight"),
    limit: i("titleLimit"),
    lineHeight: i("titleLineHeight")
  }, {
    // require update
    align: i("titleAlign"),
    baseline: i("titleBaseline")
  }), Vd({
    type: l2,
    role: TOt,
    style: ore,
    from: r,
    encode: o
  }, n);
}
function fkt(e, t) {
  let n;
  return Pt(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + Wme(e.path) + ")" : e.sphere && (n = "geoShape(" + Wme(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
}
function Wme(e) {
  return Pt(e) && e.signal ? e.signal : Et(e);
}
function m$e(e) {
  const t = e.role || "";
  return t.startsWith("axis") || t.startsWith("legend") || t.startsWith("title") ? t : e.type === h8 ? tre : t || Jne;
}
function dkt(e) {
  return {
    marktype: e.type,
    name: e.name || void 0,
    role: e.role || m$e(e),
    zindex: +e.zindex || void 0,
    aria: e.aria,
    description: e.description
  };
}
function hkt(e, t) {
  return e && e.signal ? t.signalRef(e.signal) : e !== !1;
}
function fre(e, t) {
  const n = pDe(e.type);
  n || tt("Unrecognized transform type: " + Et(e.type));
  const r = c8(n.type.toLowerCase(), null, y$e(n, e, t));
  return e.signal && t.addSignal(e.signal, t.proxy(r)), r.metadata = n.metadata || {}, r;
}
function y$e(e, t, n) {
  const r = {}, i = e.params.length;
  for (let o = 0; o < i; ++o) {
    const a = e.params[o];
    r[a.name] = pkt(a, t, n);
  }
  return r;
}
function pkt(e, t, n) {
  const r = e.type, i = t[e.name];
  if (r === "index")
    return gkt(e, t, n);
  if (i === void 0) {
    e.required && tt("Missing required " + Et(t.type) + " parameter: " + Et(e.name));
    return;
  } else {
    if (r === "param")
      return mkt(e, t, n);
    if (r === "projection")
      return n.projectionRef(t[e.name]);
  }
  return e.array && !Ws(i) ? i.map((o) => qme(e, o, n)) : qme(e, i, n);
}
function qme(e, t, n) {
  const r = e.type;
  if (Ws(t))
    return Qme(r) ? tt("Expression references can not be signals.") : TV(r) ? n.fieldRef(t) : Xme(r) ? n.compareRef(t) : n.signalRef(t.signal);
  {
    const i = e.expr || TV(r);
    return i && ykt(t) ? n.exprRef(t.expr, t.as) : i && vkt(t) ? r$(t.field, t.as) : Qme(r) ? Ky(t, n) : bkt(r) ? vn(n.getData(t).values) : TV(r) ? r$(t) : Xme(r) ? n.compareRef(t) : t;
  }
}
function gkt(e, t, n) {
  return kt(t.from) || tt('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
}
function mkt(e, t, n) {
  const r = t[e.name];
  return e.array ? (nt(r) || tt("Expected an array of sub-parameters. Instead: " + Et(r)), r.map((i) => Gme(e, i, n))) : Gme(e, r, n);
}
function Gme(e, t, n) {
  const r = e.params.length;
  let i;
  for (let a = 0; a < r; ++a) {
    i = e.params[a];
    for (const s in i.key)
      if (i.key[s] !== t[s]) {
        i = null;
        break;
      }
    if (i)
      break;
  }
  i || tt("Unsupported parameter: " + Et(t));
  const o = hr(y$e(i, t, n), i.key);
  return vn(n.add(hRt(o)));
}
const ykt = (e) => e && e.expr, vkt = (e) => e && e.field, bkt = (e) => e === "data", Qme = (e) => e === "expr", TV = (e) => e === "field", Xme = (e) => e === "compare";
function xkt(e, t, n) {
  let r, i, o, a, s;
  return e ? (r = e.facet) && (t || tt("Only group marks can be faceted."), r.field != null ? a = s = Oj(r, n) : (e.data ? s = vn(n.getData(e.data).aggregate) : (o = fre(hr({
    type: "aggregate",
    groupby: Rt(r.groupby)
  }, r.aggregate), n), o.params.key = n.keyRef(r.groupby), o.params.pulse = Oj(r, n), a = s = vn(n.add(o))), i = n.keyRef(r.groupby, !0))) : a = vn(n.add(nm(null, [{}]))), a || (a = Oj(e, n)), {
    key: i,
    pulse: a,
    parent: s
  };
}
function Oj(e, t) {
  return e.$ref ? e : e.data && e.data.$ref ? e.data : vn(t.getData(e.data).output);
}
function zS(e, t, n, r, i) {
  this.scope = e, this.input = t, this.output = n, this.values = r, this.aggregate = i, this.index = {};
}
zS.fromEntries = function(e, t) {
  const n = t.length, r = t[n - 1], i = t[n - 2];
  let o = t[0], a = null, s = 1;
  for (o && o.type === "load" && (o = t[1]), e.add(t[0]); s < n; ++s)
    t[s].params.pulse = vn(t[s - 1]), e.add(t[s]), t[s].type === "aggregate" && (a = t[s]);
  return new zS(e, o, i, r, a);
};
function v$e(e) {
  return kt(e) ? e : null;
}
function Kme(e, t, n) {
  const r = f8(n.op, n.field);
  let i;
  if (t.ops) {
    for (let o = 0, a = t.as.length; o < a; ++o)
      if (t.as[o] === r)
        return;
  } else
    t.ops = ["count"], t.fields = [null], t.as = ["count"];
  n.op && (t.ops.push((i = n.op.signal) ? e.signalRef(i) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(r));
}
function dO(e, t, n, r, i, o, a) {
  const s = t[n] || (t[n] = {}), u = YOt(o);
  let l = v$e(i), f, h;
  if (l != null && (e = t.scope, l = l + (u ? "|" + u : ""), f = s[l]), !f) {
    const p = o ? {
      field: HQ,
      pulse: t.countsRef(e, i, o)
    } : {
      field: e.fieldRef(i),
      pulse: vn(t.output)
    };
    u && (p.sort = e.sortRef(o)), h = e.add(c8(r, void 0, p)), a && (t.index[i] = h), f = vn(h), l != null && (s[l] = f);
  }
  return f;
}
zS.prototype = {
  countsRef(e, t, n) {
    const r = this, i = r.counts || (r.counts = {}), o = v$e(t);
    let a, s, u;
    return o != null && (e = r.scope, a = i[o]), a ? n && n.field && Kme(e, a.agg.params, n) : (u = {
      groupby: e.fieldRef(t, "key"),
      pulse: vn(r.output)
    }, n && n.field && Kme(e, u, n), s = e.add(n$e(u)), a = e.add(nm({
      pulse: vn(s)
    })), a = {
      agg: s,
      ref: vn(a)
    }, o != null && (i[o] = a)), a.ref;
  },
  tuplesRef() {
    return vn(this.values);
  },
  extentRef(e, t) {
    return dO(e, this, "extent", "extent", t, !1);
  },
  domainRef(e, t) {
    return dO(e, this, "domain", "values", t, !1);
  },
  valuesRef(e, t, n) {
    return dO(e, this, "vals", "values", t, n || !0);
  },
  lookupRef(e, t) {
    return dO(e, this, "lookup", "tupleindex", t, !1);
  },
  indataRef(e, t) {
    return dO(e, this, "indata", "tupleindex", t, !0, !0);
  }
};
function wkt(e, t, n) {
  const r = e.from.facet, i = r.name, o = Oj(r, t);
  let a;
  r.name || tt("Facet must have a name: " + Et(r)), r.data || tt("Facet must reference a data set: " + Et(r)), r.field ? a = t.add(o$e({
    field: t.fieldRef(r.field),
    pulse: o
  })) : r.groupby ? a = t.add(iRt({
    key: t.keyRef(r.groupby),
    group: vn(t.proxy(n.parent)),
    pulse: o
  })) : tt("Facet must specify groupby or field: " + Et(r));
  const s = t.fork(), u = s.add(nm()), l = s.add(u2({
    pulse: vn(u)
  }));
  s.addData(i, new zS(s, u, u, l)), s.addSignal("parent", null), a.params.subflow = {
    $subflow: s.parse(e).toRuntime()
  };
}
function _kt(e, t, n) {
  const r = t.add(o$e({
    pulse: n.pulse
  })), i = t.fork();
  i.add(u2()), i.addSignal("parent", null), r.params.subflow = {
    $subflow: i.parse(e).toRuntime()
  };
}
function b$e(e, t, n) {
  const r = e.remove, i = e.insert, o = e.toggle, a = e.modify, s = e.values, u = t.add(uz()), l = "if(" + e.trigger + ',modify("' + n + '",' + [i, r, o, a, s].map((h) => h ?? "null").join(",") + "),0)", f = Ky(l, t);
  u.update = f.$expr, u.params = f.$params;
}
function m8(e, t) {
  const n = m$e(e), r = e.type === h8, i = e.from && e.from.facet, o = e.overlap;
  let a = e.layout || n === tre || n === ere, s, u, l, f, h, p, g;
  const y = n === Jne || a || i, b = xkt(e.from, r, t);
  u = t.add(nRt({
    key: b.key || (e.key ? r$(e.key) : void 0),
    pulse: b.pulse,
    clean: !r
  }));
  const _ = vn(u);
  u = l = t.add(nm({
    pulse: _
  })), u = t.add(lRt({
    markdef: dkt(e),
    interactive: hkt(e.interactive, t),
    clip: fkt(e.clip, t),
    context: {
      $context: !0
    },
    groups: t.lookup(),
    parent: t.signals.parent ? t.signalRef("parent") : null,
    index: t.markpath(),
    pulse: vn(u)
  }));
  const S = vn(u);
  u = f = t.add(i$e(e$e(e.encode, e.type, n, e.style, t, {
    mod: !1,
    pulse: S
  }))), u.params.parent = t.encode(), e.transform && e.transform.forEach((j) => {
    const $ = fre(j, t), z = $.metadata;
    (z.generates || z.changes) && tt("Mark transforms should not generate new data."), z.nomod || (f.params.mod = !0), $.params.pulse = vn(u), t.add(u = $);
  }), e.sort && (u = t.add(vRt({
    sort: t.compareRef(e.sort),
    pulse: vn(u)
  })));
  const C = vn(u);
  (i || a) && (a = t.add(s$e({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    mark: S,
    pulse: C
  })), p = vn(a));
  const A = t.add(r$e({
    mark: S,
    pulse: p || C
  }));
  g = vn(A), r && (y && (s = t.operators, s.pop(), a && s.pop()), t.pushState(C, p || g, _), i ? wkt(e, t, b) : y ? _kt(e, t, b) : t.parse(e), t.popState(), y && (a && s.push(a), s.push(A))), o && (g = Ekt(o, g, t));
  const O = t.add(a$e({
    pulse: g
  })), R = t.add(u2({
    pulse: vn(O)
  }, void 0, t.parent()));
  e.name != null && (h = e.name, t.addData(h, new zS(t, l, O, R)), e.on && e.on.forEach((j) => {
    (j.insert || j.remove || j.toggle) && tt("Marks only support modify triggers."), b$e(j, t, h);
  }));
}
function Ekt(e, t, n) {
  const r = e.method, i = e.bound, o = e.separation, a = {
    separation: Ws(o) ? n.signalRef(o.signal) : o,
    method: Ws(r) ? n.signalRef(r.signal) : r,
    pulse: t
  };
  if (e.order && (a.sort = n.compareRef({
    field: e.order
  })), i) {
    const s = i.tolerance;
    a.boundTolerance = Ws(s) ? n.signalRef(s.signal) : +s, a.boundScale = n.scaleRef(i.scale), a.boundOrient = i.orient;
  }
  return vn(n.add(dRt(a)));
}
function Skt(e, t) {
  const n = t.config.legend, r = e.encode || {}, i = Bf(e, n), o = r.legend || {}, a = o.name || void 0, s = o.interactive, u = o.style, l = {};
  let f = 0, h, p, g;
  are.forEach((A) => e[A] ? (l[A] = e[A], f = f || e[A]) : 0), f || tt("Missing valid scale for legend.");
  const y = Mkt(e, t.scaleType(f)), b = {
    title: e.title != null,
    scales: l,
    type: y,
    vgrad: y !== "symbol" && i.isVertical()
  }, _ = vn(t.add(nm(null, [b]))), S = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }, C = vn(t.add(sRt(p = {
    type: y,
    scale: t.scaleRef(f),
    count: t.objectProperty(i("tickCount")),
    limit: t.property(i("symbolLimit")),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  })));
  return y === Aj ? (g = [KRt(e, f, n, r.gradient), Vme(e, n, r.labels, C)], p.count = p.count || t.signalRef(`max(2,2*floor((${aS(i.gradientLength())})/100))`)) : y === GQ ? g = [ZRt(e, f, n, r.gradient, C), Vme(e, n, r.labels, C)] : (h = nkt(e, n), g = [tkt(e, n, r, C, aS(h.columns))], p.size = Nkt(e, t, g[0].marks)), g = [o$({
    role: EOt,
    from: _,
    encode: S,
    marks: g,
    layout: h,
    interactive: s
  })], b.title && g.push(ckt(e, n, r.title, _)), m8(o$({
    role: wOt,
    from: _,
    encode: $N(Ckt(i, e, n), o, _4),
    marks: g,
    aria: i("aria"),
    description: i("description"),
    zindex: i("zindex"),
    name: a,
    interactive: s,
    style: u
  }), t);
}
function Mkt(e, t) {
  let n = e.type || Hme;
  return !e.type && Tkt(e) === 1 && (e.fill || e.stroke) && (n = gte(t) ? Aj : YG(t) ? GQ : Hme), n !== Aj ? n : YG(t) ? GQ : Aj;
}
function Tkt(e) {
  return are.reduce((t, n) => t + (e[n] ? 1 : 0), 0);
}
function Ckt(e, t, n) {
  const r = {
    enter: {},
    update: {}
  };
  return ol(r, {
    orient: e("orient"),
    offset: e("offset"),
    padding: e("padding"),
    titlePadding: e("titlePadding"),
    cornerRadius: e("cornerRadius"),
    fill: e("fillColor"),
    stroke: e("strokeColor"),
    strokeWidth: n.strokeWidth,
    strokeDash: n.strokeDash,
    x: e("legendX"),
    y: e("legendY"),
    // accessibility support
    format: t.format,
    formatType: t.formatType
  }), r;
}
function Nkt(e, t, n) {
  const r = aS(Zme("size", e, n)), i = aS(Zme("strokeWidth", e, n)), o = aS(Dkt(n[1].encode, t, w4));
  return Ky(`max(ceil(sqrt(${r})+${i}),${o})`, t);
}
function Zme(e, t, n) {
  return t[e] ? `scale("${t[e]}",datum)` : p$e(e, n[0].encode);
}
function Dkt(e, t, n) {
  return p$e("fontSize", e) || QRt("fontSize", t, n);
}
const Akt = `item.orient==="${PN}"?-90:item.orient==="${IN}"?90:0`;
function Okt(e, t) {
  e = kt(e) ? {
    text: e
  } : e;
  const n = Bf(e, t.config.title), r = e.encode || {}, i = r.group || {}, o = i.name || void 0, a = i.interactive, s = i.style, u = [], l = {}, f = vn(t.add(nm(null, [l])));
  return u.push($kt(e, n, Rkt(e), f)), e.subtitle && u.push(Pkt(e, n, r.subtitle, f)), m8(o$({
    role: COt,
    from: f,
    encode: kkt(n, i),
    marks: u,
    aria: n("aria"),
    description: n("description"),
    zindex: n("zindex"),
    name: o,
    interactive: a,
    style: s
  }), t);
}
function Rkt(e) {
  const t = e.encode;
  return t && t.title || hr({
    name: e.name,
    interactive: e.interactive,
    style: e.style
  }, t);
}
function kkt(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return ol(n, {
    orient: e("orient"),
    anchor: e("anchor"),
    align: {
      signal: ure
    },
    angle: {
      signal: Akt
    },
    limit: e("limit"),
    frame: e("frame"),
    offset: e("offset") || 0,
    padding: e("subtitlePadding")
  }), $N(n, t, _4);
}
function $kt(e, t, n, r) {
  const i = {
    value: 0
  }, o = e.text, a = {
    enter: {
      opacity: i
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: i
    }
  };
  return ol(a, {
    text: o,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("color"),
    font: t("font"),
    fontSize: t("fontSize"),
    fontStyle: t("fontStyle"),
    fontWeight: t("fontWeight"),
    lineHeight: t("lineHeight")
  }, {
    // update
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), Vd({
    type: l2,
    role: NOt,
    style: FRt,
    from: r,
    encode: a
  }, n);
}
function Pkt(e, t, n, r) {
  const i = {
    value: 0
  }, o = e.subtitle, a = {
    enter: {
      opacity: i
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: i
    }
  };
  return ol(a, {
    text: o,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("subtitleColor"),
    font: t("subtitleFont"),
    fontSize: t("subtitleFontSize"),
    fontStyle: t("subtitleFontStyle"),
    fontWeight: t("subtitleFontWeight"),
    lineHeight: t("subtitleLineHeight")
  }, {
    // update
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), Vd({
    type: l2,
    role: DOt,
    style: BRt,
    from: r,
    encode: a
  }, n);
}
function Ikt(e, t) {
  const n = [];
  e.transform && e.transform.forEach((r) => {
    n.push(fre(r, t));
  }), e.on && e.on.forEach((r) => {
    b$e(r, t, e.name);
  }), t.addDataPipeline(e.name, jkt(e, t, n));
}
function jkt(e, t, n) {
  const r = [];
  let i = null, o = !1, a = !1, s, u, l, f, h;
  for (e.values ? Ws(e.values) || Nj(e.format) ? (r.push(Jme(t, e)), r.push(i = dE())) : r.push(i = dE({
    $ingest: e.values,
    $format: e.format
  })) : e.url ? Nj(e.url) || Nj(e.format) ? (r.push(Jme(t, e)), r.push(i = dE())) : r.push(i = dE({
    $request: e.url,
    $format: e.format
  })) : e.source && (i = s = Rt(e.source).map((p) => vn(t.getData(p).output)), r.push(null)), u = 0, l = n.length; u < l; ++u)
    f = n[u], h = f.metadata, !i && !h.source && r.push(i = dE()), r.push(f), h.generates && (a = !0), h.modifies && !a && (o = !0), h.source ? i = f : h.changes && (i = null);
  return s && (l = s.length - 1, r[0] = mRt({
    derive: o,
    pulse: l ? s : s[0]
  }), (o || l) && r.splice(1, 0, dE())), i || r.push(dE()), r.push(u2({})), r;
}
function dE(e) {
  const t = nm({}, e);
  return t.metadata = {
    source: !0
  }, t;
}
function Jme(e, t) {
  return uRt({
    url: t.url ? e.property(t.url) : void 0,
    async: t.async ? e.property(t.async) : void 0,
    values: t.values ? e.property(t.values) : void 0,
    format: e.objectProperty(t.format)
  });
}
const x$e = (e) => e === hw || e === rm, y8 = (e, t, n) => Ws(e) ? Bkt(e.signal, t, n) : e === PN || e === rm ? t : n, vu = (e, t, n) => Ws(e) ? zkt(e.signal, t, n) : x$e(e) ? t : n, Bg = (e, t, n) => Ws(e) ? Fkt(e.signal, t, n) : x$e(e) ? n : t, w$e = (e, t, n) => Ws(e) ? Ukt(e.signal, t, n) : e === rm ? {
  value: t
} : {
  value: n
}, Lkt = (e, t, n) => Ws(e) ? Ykt(e.signal, t, n) : e === IN ? {
  value: t
} : {
  value: n
}, zkt = (e, t, n) => _$e(`${e} === '${rm}' || ${e} === '${hw}'`, t, n), Fkt = (e, t, n) => _$e(`${e} !== '${rm}' && ${e} !== '${hw}'`, t, n), Bkt = (e, t, n) => dre(`${e} === '${PN}' || ${e} === '${rm}'`, t, n), Ukt = (e, t, n) => dre(`${e} === '${rm}'`, t, n), Ykt = (e, t, n) => dre(`${e} === '${IN}'`, t, n), _$e = (e, t, n) => (t = t != null ? yu(t) : t, n = n != null ? yu(n) : n, eye(t) && eye(n) ? (t = t ? t.signal || Et(t.value) : null, n = n ? n.signal || Et(n.value) : null, {
  signal: `${e} ? (${t}) : (${n})`
}) : [hr({
  test: e
}, t)].concat(n || [])), eye = (e) => e == null || Object.keys(e).length === 1, dre = (e, t, n) => ({
  signal: `${e} ? (${_T(t)}) : (${_T(n)})`
}), Hkt = (e, t, n, r, i) => ({
  signal: (r != null ? `${e} === '${PN}' ? (${_T(r)}) : ` : "") + (n != null ? `${e} === '${hw}' ? (${_T(n)}) : ` : "") + (i != null ? `${e} === '${IN}' ? (${_T(i)}) : ` : "") + (t != null ? `${e} === '${rm}' ? (${_T(t)}) : ` : "") + "(null)"
}), _T = (e) => Ws(e) ? e.signal : e == null ? null : Et(e), Vkt = (e, t) => t === 0 ? 0 : Ws(e) ? {
  signal: `(${e.signal}) * ${t}`
} : {
  value: e * t
}, IT = (e, t) => {
  const n = e.signal;
  return n && n.endsWith("(null)") ? {
    signal: n.slice(0, -6) + t.signal
  } : e;
};
function XM(e, t, n, r) {
  let i;
  if (t && wn(t, e))
    return t[e];
  if (wn(n, e))
    return n[e];
  if (e.startsWith("title")) {
    switch (e) {
      case "titleColor":
        i = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        i = e[5].toLowerCase() + e.slice(6);
    }
    return r[ore][i];
  } else if (e.startsWith("label")) {
    switch (e) {
      case "labelColor":
        i = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        i = e[5].toLowerCase() + e.slice(6);
    }
    return r[w4][i];
  }
  return null;
}
function tye(e) {
  const t = {};
  for (const n of e)
    if (n)
      for (const r in n)
        t[r] = 1;
  return Object.keys(t);
}
function Wkt(e, t) {
  var n = t.config, r = n.style, i = n.axis, o = t.scaleType(e.scale) === "band" && n.axisBand, a = e.orient, s, u, l;
  if (Ws(a)) {
    const h = tye([n.axisX, n.axisY]), p = tye([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
    s = {};
    for (l of h)
      s[l] = vu(a, XM(l, n.axisX, i, r), XM(l, n.axisY, i, r));
    u = {};
    for (l of p)
      u[l] = Hkt(a.signal, XM(l, n.axisTop, i, r), XM(l, n.axisBottom, i, r), XM(l, n.axisLeft, i, r), XM(l, n.axisRight, i, r));
  } else
    s = a === rm || a === hw ? n.axisX : n.axisY, u = n["axis" + a[0].toUpperCase() + a.slice(1)];
  return s || u || o ? hr({}, i, s, u, o) : i;
}
function qkt(e, t, n, r) {
  const i = Bf(e, t), o = e.orient;
  let a, s;
  const u = {
    enter: a = {
      opacity: ci
    },
    update: s = {
      opacity: sp
    },
    exit: {
      opacity: ci
    }
  };
  ol(u, {
    stroke: i("domainColor"),
    strokeCap: i("domainCap"),
    strokeDash: i("domainDash"),
    strokeDashOffset: i("domainDashOffset"),
    strokeWidth: i("domainWidth"),
    strokeOpacity: i("domainOpacity")
  });
  const l = nye(e, 0), f = nye(e, 1);
  return a.x = s.x = vu(o, l, ci), a.x2 = s.x2 = vu(o, f), a.y = s.y = Bg(o, l, ci), a.y2 = s.y2 = Bg(o, f), Vd({
    type: sre,
    role: mOt,
    from: r,
    encode: u
  }, n);
}
function nye(e, t) {
  return {
    scale: e.scale,
    range: t
  };
}
function Gkt(e, t, n, r, i) {
  const o = Bf(e, t), a = e.orient, s = e.gridScale, u = y8(a, 1, -1), l = Qkt(e.offset, u);
  let f, h, p;
  const g = {
    enter: f = {
      opacity: ci
    },
    update: p = {
      opacity: sp
    },
    exit: h = {
      opacity: ci
    }
  };
  ol(g, {
    stroke: o("gridColor"),
    strokeCap: o("gridCap"),
    strokeDash: o("gridDash"),
    strokeDashOffset: o("gridDashOffset"),
    strokeOpacity: o("gridOpacity"),
    strokeWidth: o("gridWidth")
  });
  const y = {
    scale: e.scale,
    field: ap,
    band: i.band,
    extra: i.extra,
    offset: i.offset,
    round: o("tickRound")
  }, b = vu(a, {
    signal: "height"
  }, {
    signal: "width"
  }), _ = s ? {
    scale: s,
    range: 0,
    mult: u,
    offset: l
  } : {
    value: 0,
    offset: l
  }, S = s ? {
    scale: s,
    range: 1,
    mult: u,
    offset: l
  } : hr(b, {
    mult: u,
    offset: l
  });
  return f.x = p.x = vu(a, y, _), f.y = p.y = Bg(a, y, _), f.x2 = p.x2 = Bg(a, S), f.y2 = p.y2 = vu(a, S), h.x = vu(a, y), h.y = Bg(a, y), Vd({
    type: sre,
    role: yOt,
    key: ap,
    from: r,
    encode: g
  }, n);
}
function Qkt(e, t) {
  if (t !== 1)
    if (!Pt(e))
      e = Ws(t) ? {
        signal: `(${t.signal}) * (${e || 0})`
      } : t * (e || 0);
    else {
      let n = e = hr({}, e);
      for (; n.mult != null; )
        if (Pt(n.mult))
          n = n.mult = hr({}, n.mult);
        else
          return n.mult = Ws(t) ? {
            signal: `(${n.mult}) * (${t.signal})`
          } : n.mult * t, e;
      n.mult = t;
    }
  return e;
}
function Xkt(e, t, n, r, i, o) {
  const a = Bf(e, t), s = e.orient, u = y8(s, -1, 1);
  let l, f, h;
  const p = {
    enter: l = {
      opacity: ci
    },
    update: h = {
      opacity: sp
    },
    exit: f = {
      opacity: ci
    }
  };
  ol(p, {
    stroke: a("tickColor"),
    strokeCap: a("tickCap"),
    strokeDash: a("tickDash"),
    strokeDashOffset: a("tickDashOffset"),
    strokeOpacity: a("tickOpacity"),
    strokeWidth: a("tickWidth")
  });
  const g = yu(i);
  g.mult = u;
  const y = {
    scale: e.scale,
    field: ap,
    band: o.band,
    extra: o.extra,
    offset: o.offset,
    round: a("tickRound")
  };
  return h.y = l.y = vu(s, ci, y), h.y2 = l.y2 = vu(s, g), f.x = vu(s, y), h.x = l.x = Bg(s, ci, y), h.x2 = l.x2 = Bg(s, g), f.y = Bg(s, y), Vd({
    type: sre,
    role: bOt,
    key: ap,
    from: r,
    encode: p
  }, n);
}
function CV(e, t, n, r, i) {
  return {
    signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + r + "," + i + ")"
  };
}
function Kkt(e, t, n, r, i, o) {
  const a = Bf(e, t), s = e.orient, u = e.scale, l = y8(s, -1, 1), f = aS(a("labelFlush")), h = aS(a("labelFlushOffset")), p = a("labelAlign"), g = a("labelBaseline");
  let y = f === 0 || !!f, b;
  const _ = yu(i);
  _.mult = l, _.offset = yu(a("labelPadding") || 0), _.offset.mult = l;
  const S = {
    scale: u,
    field: ap,
    band: 0.5,
    offset: g$e(o.offset, a("labelOffset"))
  }, C = vu(s, y ? CV(u, f, '"left"', '"right"', '"center"') : {
    value: "center"
  }, Lkt(s, "left", "right")), A = vu(s, w$e(s, "bottom", "top"), y ? CV(u, f, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  }), O = CV(u, f, `-(${h})`, h, 0);
  y = y && h;
  const R = {
    opacity: ci,
    x: vu(s, S, _),
    y: Bg(s, S, _)
  }, j = {
    enter: R,
    update: b = {
      opacity: sp,
      text: {
        field: ire
      },
      x: R.x,
      y: R.y,
      align: C,
      baseline: A
    },
    exit: {
      opacity: ci,
      x: R.x,
      y: R.y
    }
  };
  ol(j, {
    dx: !p && y ? vu(s, O) : null,
    dy: !g && y ? Bg(s, O) : null
  }), ol(j, {
    angle: a("labelAngle"),
    fill: a("labelColor"),
    fillOpacity: a("labelOpacity"),
    font: a("labelFont"),
    fontSize: a("labelFontSize"),
    fontWeight: a("labelFontWeight"),
    fontStyle: a("labelFontStyle"),
    limit: a("labelLimit"),
    lineHeight: a("labelLineHeight")
  }, {
    align: p,
    baseline: g
  });
  const $ = a("labelBound");
  let z = a("labelOverlap");
  return z = z || $ ? {
    separation: a("labelSeparation"),
    method: z,
    order: "datum.index",
    bound: $ ? {
      scale: u,
      orient: s,
      tolerance: $
    } : null
  } : void 0, b.align !== C && (b.align = IT(b.align, C)), b.baseline !== A && (b.baseline = IT(b.baseline, A)), Vd({
    type: l2,
    role: vOt,
    style: w4,
    key: ap,
    from: r,
    encode: j,
    overlap: z
  }, n);
}
function Zkt(e, t, n, r) {
  const i = Bf(e, t), o = e.orient, a = y8(o, -1, 1);
  let s, u;
  const l = {
    enter: s = {
      opacity: ci,
      anchor: yu(i("titleAnchor", null)),
      align: {
        signal: ure
      }
    },
    update: u = hr({}, s, {
      opacity: sp,
      text: yu(e.title)
    }),
    exit: {
      opacity: ci
    }
  }, f = {
    signal: `lerp(range("${e.scale}"), ${p8(0, 1, 0.5)})`
  };
  return u.x = vu(o, f), u.y = Bg(o, f), s.angle = vu(o, ci, Vkt(a, 90)), s.baseline = vu(o, w$e(o, hw, rm), {
    value: hw
  }), u.angle = s.angle, u.baseline = s.baseline, ol(l, {
    fill: i("titleColor"),
    fillOpacity: i("titleOpacity"),
    font: i("titleFont"),
    fontSize: i("titleFontSize"),
    fontStyle: i("titleFontStyle"),
    fontWeight: i("titleFontWeight"),
    limit: i("titleLimit"),
    lineHeight: i("titleLineHeight")
  }, {
    // require update
    align: i("titleAlign"),
    angle: i("titleAngle"),
    baseline: i("titleBaseline")
  }), Jkt(i, o, l, n), l.update.align = IT(l.update.align, s.align), l.update.angle = IT(l.update.angle, s.angle), l.update.baseline = IT(l.update.baseline, s.baseline), Vd({
    type: l2,
    role: xOt,
    style: ore,
    from: r,
    encode: l
  }, n);
}
function Jkt(e, t, n, r) {
  const i = (s, u) => s != null ? (n.update[u] = IT(yu(s), n.update[u]), !1) : !sT(u, r), o = i(e("titleX"), "x"), a = i(e("titleY"), "y");
  n.enter.auto = a === o ? yu(a) : vu(t, yu(a), yu(o));
}
function e$t(e, t) {
  const n = Wkt(e, t), r = e.encode || {}, i = r.axis || {}, o = i.name || void 0, a = i.interactive, s = i.style, u = Bf(e, n), l = XRt(u), f = {
    scale: e.scale,
    ticks: !!u("ticks"),
    labels: !!u("labels"),
    grid: !!u("grid"),
    domain: !!u("domain"),
    title: e.title != null
  }, h = vn(t.add(nm({}, [f]))), p = vn(t.add(tRt({
    scale: t.scaleRef(e.scale),
    extra: t.property(l.extra),
    count: t.objectProperty(e.tickCount),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  }))), g = [];
  let y;
  return f.grid && g.push(Gkt(e, n, r.grid, p, l)), f.ticks && (y = u("tickSize"), g.push(Xkt(e, n, r.ticks, p, y, l))), f.labels && (y = f.ticks ? y : 0, g.push(Kkt(e, n, r.labels, p, y, l))), f.domain && g.push(qkt(e, n, r.domain, h)), f.title && g.push(Zkt(e, n, r.title, h)), m8(o$({
    role: gOt,
    from: h,
    encode: $N(t$t(u, e), i, _4),
    marks: g,
    aria: u("aria"),
    description: u("description"),
    zindex: u("zindex"),
    name: o,
    interactive: a,
    style: s
  }), t);
}
function t$t(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return ol(n, {
    orient: e("orient"),
    offset: e("offset") || 0,
    position: Sg(t.position, 0),
    titlePadding: e("titlePadding"),
    minExtent: e("minExtent"),
    maxExtent: e("maxExtent"),
    range: {
      signal: `abs(span(range("${t.scale}")))`
    },
    translate: e("translate"),
    // accessibility support
    format: t.format,
    formatType: t.formatType
  }), n;
}
function E$e(e, t, n) {
  const r = Rt(e.signals), i = Rt(e.scales);
  return n || r.forEach((o) => t$e(o, t)), Rt(e.projections).forEach((o) => kRt(o, t)), i.forEach((o) => wRt(o, t)), Rt(e.data).forEach((o) => Ikt(o, t)), i.forEach((o) => _Rt(o, t)), (n || r).forEach((o) => eRt(o, t)), Rt(e.axes).forEach((o) => e$t(o, t)), Rt(e.marks).forEach((o) => m8(o, t)), Rt(e.legends).forEach((o) => Skt(o, t)), e.title && Okt(e.title, t), t.parseLambdas(), t;
}
const n$t = (e) => $N({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, e);
function r$t(e, t) {
  const n = t.config, r = vn(t.root = t.add(uz())), i = i$t(e, n);
  i.forEach((l) => t$e(l, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
  const o = t.add(nm()), a = t.add(i$e(e$e(n$t(e.encode), h8, ere, e.style, t, {
    pulse: vn(o)
  }))), s = t.add(s$e({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    autosize: t.signalRef("autosize"),
    mark: r,
    pulse: vn(a)
  }));
  t.operators.pop(), t.pushState(vn(a), vn(s), null), E$e(e, t, i), t.operators.push(s);
  let u = t.add(r$e({
    mark: r,
    pulse: vn(s)
  }));
  return u = t.add(a$e({
    pulse: vn(u)
  })), u = t.add(u2({
    pulse: vn(u)
  })), t.addData("root", new zS(t, o, o, u)), t;
}
function hO(e, t) {
  return t && t.signal ? {
    name: e,
    update: t.signal
  } : {
    name: e,
    value: t
  };
}
function i$t(e, t) {
  const n = (a) => Sg(e[a], t[a]), r = [hO("background", n("background")), hO("autosize", dOt(n("autosize"))), hO("padding", pOt(n("padding"))), hO("width", n("width") || 0), hO("height", n("height") || 0)], i = r.reduce((a, s) => (a[s.name] = s, a), {}), o = {};
  return Rt(e.signals).forEach((a) => {
    wn(i, a.name) ? a = hr(i[a.name], a) : r.push(a), o[a.name] = a;
  }), Rt(t.signals).forEach((a) => {
    !wn(o, a.name) && !wn(i, a.name) && r.push(a);
  }), r;
}
function S$e(e, t) {
  this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
}
function rye(e) {
  this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath;
}
S$e.prototype = rye.prototype = {
  parse(e) {
    return E$e(e, this);
  },
  fork() {
    return new rye(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    return this.finish(), {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(e) {
    return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach((t) => {
      t.$ref = e.id;
    }), e.refs = null), e;
  },
  proxy(e) {
    const t = e instanceof YQ ? vn(e) : e;
    return this.add(gRt({
      value: t
    }));
  },
  addStream(e) {
    return this.streams.push(e), e.id = this.id(), e;
  },
  addUpdate(e) {
    return this.updates.push(e), e;
  },
  // Apply metadata
  finish() {
    let e, t;
    this.root && (this.root.root = !0);
    for (e in this.signals)
      this.signals[e].signal = e;
    for (e in this.scales)
      this.scales[e].scale = e;
    function n(r, i, o) {
      let a, s;
      r && (a = r.data || (r.data = {}), s = a[i] || (a[i] = []), s.push(o));
    }
    for (e in this.data) {
      t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
      for (const r in t.index)
        n(t.index[r], e, "index:" + r);
    }
    return this;
  },
  // ----
  pushState(e, t, n) {
    this._encode.push(vn(this.add(u2({
      pulse: e
    })))), this._parent.push(t), this._lookup.push(n ? vn(this.proxy(n)) : null), this._markpath.push(-1);
  },
  popState() {
    this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
  },
  parent() {
    return ri(this._parent);
  },
  encode() {
    return ri(this._encode);
  },
  lookup() {
    return ri(this._lookup);
  },
  markpath() {
    const e = this._markpath;
    return ++e[e.length - 1];
  },
  // ----
  fieldRef(e, t) {
    if (kt(e))
      return r$(e, t);
    e.signal || tt("Unsupported field reference: " + Et(e));
    const n = e.signal;
    let r = this.field[n];
    if (!r) {
      const i = {
        name: this.signalRef(n)
      };
      t && (i.as = t), this.field[n] = r = vn(this.add(oRt(i)));
    }
    return r;
  },
  compareRef(e) {
    let t = !1;
    const n = (o) => Ws(o) ? (t = !0, this.signalRef(o.signal)) : HOt(o) ? (t = !0, this.exprRef(o.expr)) : o, r = Rt(e.field).map(n), i = Rt(e.order).map(n);
    return t ? vn(this.add(Yme({
      fields: r,
      orders: i
    }))) : Bme(r, i);
  },
  keyRef(e, t) {
    let n = !1;
    const r = (o) => Ws(o) ? (n = !0, vn(i[o.signal])) : o, i = this.signals;
    return e = Rt(e).map(r), n ? vn(this.add(aRt({
      fields: e,
      flat: t
    }))) : FOt(e, t);
  },
  sortRef(e) {
    if (!e)
      return e;
    const t = f8(e.op, e.field), n = e.order || BOt;
    return n.signal ? vn(this.add(Yme({
      fields: t,
      orders: this.signalRef(n.signal)
    }))) : Bme(t, n);
  },
  // ----
  event(e, t) {
    const n = e + ":" + t;
    if (!this.events[n]) {
      const r = this.id();
      this.streams.push({
        id: r,
        source: e,
        type: t
      }), this.events[n] = r;
    }
    return this.events[n];
  },
  // ----
  hasOwnSignal(e) {
    return wn(this.signals, e);
  },
  addSignal(e, t) {
    this.hasOwnSignal(e) && tt("Duplicate signal name: " + Et(e));
    const n = t instanceof YQ ? t : this.add(uz(t));
    return this.signals[e] = n;
  },
  getSignal(e) {
    return this.signals[e] || tt("Unrecognized signal name: " + Et(e)), this.signals[e];
  },
  signalRef(e) {
    return this.signals[e] ? vn(this.signals[e]) : (wn(this.lambdas, e) || (this.lambdas[e] = this.add(uz(null))), vn(this.lambdas[e]));
  },
  parseLambdas() {
    const e = Object.keys(this.lambdas);
    for (let t = 0, n = e.length; t < n; ++t) {
      const r = e[t], i = Ky(r, this), o = this.lambdas[r];
      o.params = i.$params, o.update = i.$expr;
    }
  },
  property(e) {
    return e && e.signal ? this.signalRef(e.signal) : e;
  },
  objectProperty(e) {
    return !e || !Pt(e) ? e : this.signalRef(e.signal || hre(e));
  },
  exprRef(e, t) {
    const n = {
      expr: Ky(e, this)
    };
    return t && (n.expr.$name = t), vn(this.add(rRt(n)));
  },
  addBinding(e, t) {
    this.bindings || tt("Nested signals do not support binding: " + Et(e)), this.bindings.push(hr({
      signal: e
    }, t));
  },
  // ----
  addScaleProj(e, t) {
    wn(this.scales, e) && tt("Duplicate scale or projection name: " + Et(e)), this.scales[e] = this.add(t);
  },
  addScale(e, t) {
    this.addScaleProj(e, yRt(t));
  },
  addProjection(e, t) {
    this.addScaleProj(e, pRt(t));
  },
  getScale(e) {
    return this.scales[e] || tt("Unrecognized scale name: " + Et(e)), this.scales[e];
  },
  scaleRef(e) {
    return vn(this.getScale(e));
  },
  scaleType(e) {
    return this.getScale(e).params.type;
  },
  projectionRef(e) {
    return this.scaleRef(e);
  },
  projectionType(e) {
    return this.scaleType(e);
  },
  // ----
  addData(e, t) {
    return wn(this.data, e) && tt("Duplicate data set name: " + Et(e)), this.data[e] = t;
  },
  getData(e) {
    return this.data[e] || tt("Undefined data set name: " + Et(e)), this.data[e];
  },
  addDataPipeline(e, t) {
    return wn(this.data, e) && tt("Duplicate data set name: " + Et(e)), this.addData(e, zS.fromEntries(this, t));
  }
};
function hre(e) {
  return (nt(e) ? o$t : a$t)(e);
}
function o$t(e) {
  const t = e.length;
  let n = "[";
  for (let r = 0; r < t; ++r) {
    const i = e[r];
    n += (r > 0 ? "," : "") + (Pt(i) ? i.signal || hre(i) : Et(i));
  }
  return n + "]";
}
function a$t(e) {
  let t = "{", n = 0, r, i;
  for (r in e)
    i = e[r], t += (++n > 1 ? "," : "") + Et(r) + ":" + (Pt(i) ? i.signal || hre(i) : Et(i));
  return t + "}";
}
function s$t() {
  const e = "sans-serif", r = "#4c78a8", i = "#000", o = "#888", a = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: r
    },
    area: {
      fill: r
    },
    image: null,
    line: {
      stroke: r,
      strokeWidth: 2
    },
    path: {
      stroke: r
    },
    rect: {
      fill: r
    },
    rule: {
      stroke: i
    },
    shape: {
      stroke: r
    },
    symbol: {
      fill: r,
      size: 64
    },
    text: {
      fill: i,
      font: e,
      fontSize: 11
    },
    trail: {
      fill: r,
      size: 2
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: i,
        font: e,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: i,
        font: e,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: i,
        font: e,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: i,
        font: e,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: 30,
        strokeWidth: 2,
        shape: "circle"
      },
      circle: {
        size: 30,
        strokeWidth: 2
      },
      square: {
        size: 30,
        strokeWidth: 2,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: a
      },
      view: {
        fill: "transparent"
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: !0,
      domainWidth: 1,
      domainColor: o,
      grid: !1,
      gridWidth: 1,
      gridColor: a,
      labels: !0,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: !0,
      tickColor: o,
      tickOffset: 0,
      tickRound: !0,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: a,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: !0,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: o,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function u$t(e, t, n) {
  return Pt(e) || tt("Input Vega specification must be an object."), t = MN(s$t(), t, e.config), r$t(e, new S$e(t, n)).toRuntime();
}
var l$t = "5.29.0";
hr(TC, Yxt, BSt, b2t, oTt, dTt, zTt, vTt, BTt, VTt, tCt, uCt);
const c$t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bounds: xs,
  CanvasHandler: p4,
  CanvasRenderer: M5,
  DATE: kf,
  DAY: zl,
  DAYOFYEAR: Qy,
  Dataflow: $T,
  Debug: uNe,
  Error: eee,
  EventStream: A6,
  Gradient: MAe,
  GroupItem: Y6,
  HOURS: Ud,
  Handler: Fte,
  HybridHandler: mOe,
  HybridRenderer: eQ,
  Info: sNe,
  Item: U6,
  MILLISECONDS: qg,
  MINUTES: Yd,
  MONTH: Hl,
  Marks: Hd,
  MultiPulse: xee,
  None: aNe,
  Operator: So,
  Parameters: D6,
  Pulse: Fx,
  QUARTER: Rf,
  RenderType: Dx,
  Renderer: h4,
  ResourceLoader: RAe,
  SECONDS: bp,
  SVGHandler: rOe,
  SVGRenderer: Wte,
  SVGStringRenderer: gOe,
  Scenegraph: QAe,
  TIME_UNITS: dee,
  Transform: Ge,
  View: Uke,
  WEEK: Ys,
  Warn: tee,
  YEAR: rl,
  accessor: Ff,
  accessorFields: Yl,
  accessorName: Va,
  array: Rt,
  ascending: E6,
  bandwidthNRD: See,
  bin: yDe,
  bootstrapCI: vDe,
  boundClip: TOe,
  boundContext: l4,
  boundItem: QG,
  boundMark: VAe,
  boundStroke: Mb,
  changeset: o2,
  clampRange: bNe,
  codegenExpression: gke,
  compare: aee,
  constant: Gl,
  cumulativeLogNormal: Aee,
  cumulativeNormal: R6,
  cumulativeUniform: $ee,
  dayofyear: ONe,
  debounce: see,
  defaultLocale: gee,
  definition: pDe,
  densityLogNormal: Dee,
  densityNormal: Mee,
  densityUniform: kee,
  domChild: Us,
  domClear: Kh,
  domCreate: Cx,
  domFind: zte,
  dotbin: bDe,
  error: tt,
  expressionFunction: os,
  extend: hr,
  extent: Gy,
  extentIndex: xNe,
  falsy: ax,
  fastmap: CN,
  field: yp,
  flush: wNe,
  font: G6,
  fontFamily: d4,
  fontSize: uv,
  format: fj,
  formatLocale: d5,
  formats: vee,
  hasOwnProperty: wn,
  id: K$,
  identity: ql,
  inferType: rDe,
  inferTypes: iDe,
  ingest: Ui,
  inherits: Tt,
  inrange: vT,
  interpolate: mte,
  interpolateColors: F6,
  interpolateRange: fAe,
  intersect: _Oe,
  intersectBoxLine: bT,
  intersectPath: Ste,
  intersectPoint: Mte,
  intersectRule: $Ae,
  isArray: nt,
  isBoolean: Pw,
  isDate: zx,
  isFunction: pr,
  isIterable: _Ne,
  isNumber: pi,
  isObject: Pt,
  isRegExp: ENe,
  isString: kt,
  isTuple: C6,
  key: uee,
  lerp: SNe,
  lineHeight: cw,
  loader: M6,
  locale: tDe,
  logger: nee,
  lruCache: MNe,
  markup: Vte,
  merge: TNe,
  mergeConfig: MN,
  multiLineOffset: Ite,
  one: SN,
  pad: CNe,
  panLinear: hNe,
  panLog: pNe,
  panPow: gNe,
  panSymlog: mNe,
  parse: u$t,
  parseExpression: Fne,
  parseSelector: jw,
  path: wF,
  pathCurves: wte,
  pathEqual: COe,
  pathParse: AC,
  pathRectangle: NAe,
  pathRender: qk,
  pathSymbols: CAe,
  pathTrail: DAe,
  peek: ri,
  point: X6,
  projection: fne,
  quantileLogNormal: Oee,
  quantileNormal: k6,
  quantileUniform: Pee,
  quantiles: _ee,
  quantizeInterpolator: dAe,
  quarter: yNe,
  quartiles: Eee,
  get random() {
    return xp;
  },
  randomInteger: q1t,
  randomKDE: Cee,
  randomLCG: W1t,
  randomLogNormal: wDe,
  randomMixture: _De,
  randomNormal: Tee,
  randomUniform: EDe,
  read: sDe,
  regressionConstant: Iee,
  regressionExp: MDe,
  regressionLinear: jee,
  regressionLoess: NDe,
  regressionLog: SDe,
  regressionPoly: CDe,
  regressionPow: TDe,
  regressionQuad: Lee,
  renderModule: K6,
  repeat: FO,
  resetDefaultLocale: Ybt,
  resetSVGClipId: OAe,
  resetSVGDefIds: oSt,
  responseType: aDe,
  runtimeContext: Dke,
  sampleCurve: P6,
  sampleLogNormal: Nee,
  sampleNormal: O6,
  sampleUniform: Ree,
  scale: Di,
  sceneEqual: qte,
  sceneFromJSON: qAe,
  scenePickVisit: y5,
  sceneToJSON: WAe,
  sceneVisit: Gg,
  sceneZOrder: Tte,
  scheme: yte,
  serializeXML: fOe,
  setHybridRendererOptions: tSt,
  setRandom: H1t,
  span: Z$,
  splitAccessPath: av,
  stringValue: Et,
  textMetrics: $d,
  timeBin: GNe,
  timeFloor: LNe,
  timeFormatLocale: Hk,
  timeInterval: NN,
  timeOffset: BNe,
  timeSequence: HNe,
  timeUnitSpecifier: ANe,
  timeUnits: hee,
  toBoolean: lee,
  toDate: cee,
  toNumber: Fl,
  toSet: Wg,
  toString: fee,
  transform: gDe,
  transforms: TC,
  truncate: NNe,
  truthy: vp,
  tupleid: bn,
  typeParsers: FG,
  utcFloor: zNe,
  utcInterval: DN,
  utcOffset: UNe,
  utcSequence: VNe,
  utcdayofyear: $Ne,
  utcquarter: vNe,
  utcweek: PNe,
  version: l$t,
  visitArray: fx,
  week: RNe,
  writeConfig: TN,
  zero: wx,
  zoomLinear: ree,
  zoomLog: iee,
  zoomPow: f5,
  zoomSymlog: oee
}, Symbol.toStringTag, { value: "Module" }));
function f$t(e, t, n) {
  let r;
  t.x2 && (t.x ? (n && e.x > e.x2 && (r = e.x, e.x = e.x2, e.x2 = r), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (r = e.y, e.y = e.y2, e.y2 = r), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2);
}
var d$t = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
}, h$t = {
  "*": (e, t) => e * t,
  "+": (e, t) => e + t,
  "-": (e, t) => e - t,
  "/": (e, t) => e / t,
  "%": (e, t) => e % t,
  ">": (e, t) => e > t,
  "<": (e, t) => e < t,
  "<=": (e, t) => e <= t,
  ">=": (e, t) => e >= t,
  "==": (e, t) => e == t,
  "!=": (e, t) => e != t,
  "===": (e, t) => e === t,
  "!==": (e, t) => e !== t,
  "&": (e, t) => e & t,
  "|": (e, t) => e | t,
  "^": (e, t) => e ^ t,
  "<<": (e, t) => e << t,
  ">>": (e, t) => e >> t,
  ">>>": (e, t) => e >>> t
}, p$t = {
  "+": (e) => +e,
  "-": (e) => -e,
  "~": (e) => ~e,
  "!": (e) => !e
};
const g$t = Array.prototype.slice, hE = (e, t, n) => {
  const r = n ? n(t[0]) : t[0];
  return r[e].apply(r, g$t.call(t, 1));
}, m$t = (e, t, n, r, i, o, a) => new Date(e, t || 0, n ?? 1, r || 0, i || 0, o || 0, a || 0);
var y$t = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime: m$t,
  date: (e) => new Date(e).getDate(),
  day: (e) => new Date(e).getDay(),
  year: (e) => new Date(e).getFullYear(),
  month: (e) => new Date(e).getMonth(),
  hours: (e) => new Date(e).getHours(),
  minutes: (e) => new Date(e).getMinutes(),
  seconds: (e) => new Date(e).getSeconds(),
  milliseconds: (e) => new Date(e).getMilliseconds(),
  time: (e) => new Date(e).getTime(),
  timezoneoffset: (e) => new Date(e).getTimezoneOffset(),
  utcdate: (e) => new Date(e).getUTCDate(),
  utcday: (e) => new Date(e).getUTCDay(),
  utcyear: (e) => new Date(e).getUTCFullYear(),
  utcmonth: (e) => new Date(e).getUTCMonth(),
  utchours: (e) => new Date(e).getUTCHours(),
  utcminutes: (e) => new Date(e).getUTCMinutes(),
  utcseconds: (e) => new Date(e).getUTCSeconds(),
  utcmilliseconds: (e) => new Date(e).getUTCMilliseconds(),
  // sequence functions
  length: (e) => e.length,
  join: function() {
    return hE("join", arguments);
  },
  indexof: function() {
    return hE("indexOf", arguments);
  },
  lastindexof: function() {
    return hE("lastIndexOf", arguments);
  },
  slice: function() {
    return hE("slice", arguments);
  },
  reverse: (e) => e.slice().reverse(),
  // string functions
  parseFloat,
  parseInt,
  upper: (e) => String(e).toUpperCase(),
  lower: (e) => String(e).toLowerCase(),
  substring: function() {
    return hE("substring", arguments, String);
  },
  split: function() {
    return hE("split", arguments, String);
  },
  replace: function() {
    return hE("replace", arguments, String);
  },
  trim: (e) => String(e).trim(),
  // regexp functions
  regexp: RegExp,
  test: (e, t) => RegExp(e).test(t)
};
const v$t = ["view", "item", "group", "xy", "x", "y"], XQ = /* @__PURE__ */ new Set([Function, eval, setTimeout, setInterval]);
typeof setImmediate == "function" && XQ.add(setImmediate);
const b$t = {
  Literal: (e, t) => t.value,
  Identifier: (e, t) => {
    const n = t.name;
    return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : d$t[n] || e.params["$" + n];
  },
  MemberExpression: (e, t) => {
    const n = !t.computed, r = e(t.object);
    n && (e.memberDepth += 1);
    const i = e(t.property);
    if (n && (e.memberDepth -= 1), XQ.has(r[i])) {
      console.error(`Prevented interpretation of member "${i}" which could lead to insecure code execution`);
      return;
    }
    return r[i];
  },
  CallExpression: (e, t) => {
    const n = t.arguments;
    let r = t.callee.name;
    return r.startsWith("_") && (r = r.slice(1)), r === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[r] || y$t[r]).apply(e.fn, n.map(e));
  },
  ArrayExpression: (e, t) => t.elements.map(e),
  BinaryExpression: (e, t) => h$t[t.operator](e(t.left), e(t.right)),
  UnaryExpression: (e, t) => p$t[t.operator](e(t.argument)),
  ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
  LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
  ObjectExpression: (e, t) => t.properties.reduce((n, r) => {
    e.memberDepth += 1;
    const i = e(r.key);
    return e.memberDepth -= 1, XQ.has(e(r.value)) ? console.error(`Prevented interpretation of property "${i}" which could lead to insecure code execution`) : n[i] = e(r.value), n;
  }, {})
};
function pO(e, t, n, r, i, o) {
  const a = (s) => b$t[s.type](a, s);
  return a.memberDepth = 0, a.fn = Object.create(t), a.params = n, a.datum = r, a.event = i, a.item = o, v$t.forEach((s) => a.fn[s] = function() {
    return i.vega[s](...arguments);
  }), a(e);
}
var x$t = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(e, t) {
    const n = t.ast, r = e.functions;
    return (i) => pO(n, r, i);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(e, t) {
    const n = t.ast, r = e.functions;
    return (i, o) => pO(n, r, o, i);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(e, t) {
    const n = t.ast, r = e.functions;
    return (i) => pO(n, r, void 0, void 0, i);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(e, t) {
    const n = t.ast, r = e.functions;
    return (i, o) => {
      const a = o.item && o.item.datum;
      return pO(n, r, i, a, o);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(e, t) {
    const {
      marktype: n,
      channels: r
    } = t, i = e.functions, o = n === "group" || n === "image" || n === "rect";
    return (a, s) => {
      const u = a.datum;
      let l = 0, f;
      for (const h in r)
        f = pO(r[h].ast, i, s, u, void 0, a), a[h] !== f && (a[h] = f, l = 1);
      return n !== "rule" && f$t(a, r, o), l;
    };
  }
};
const w$t = "vega-lite", _$t = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer', E$t = "5.18.1", S$t = [
  "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
  "Dominik Moritz (https://www.domoritz.de)",
  "Arvind Satyanarayan (https://arvindsatya.com)",
  "Jeffrey Heer (https://jheer.org)"
], M$t = "https://vega.github.io/vega-lite/", T$t = "Vega-Lite is a concise high-level language for interactive visualization.", C$t = [
  "vega",
  "chart",
  "visualization"
], N$t = "build/vega-lite.js", D$t = "build/vega-lite.min.js", A$t = "build/vega-lite.min.js", O$t = "build/src/index", R$t = "build/src/index.d.ts", k$t = {
  vl2pdf: "./bin/vl2pdf",
  vl2png: "./bin/vl2png",
  vl2svg: "./bin/vl2svg",
  vl2vg: "./bin/vl2vg"
}, $$t = [
  "bin",
  "build",
  "src",
  "vega-lite*",
  "tsconfig.json"
], P$t = {
  changelog: "conventional-changelog -p angular -r 2",
  prebuild: "yarn clean:build",
  build: "yarn build:only",
  "build:only": "tsc -p tsconfig.build.json && rollup -c",
  "prebuild:examples": "yarn build:only",
  "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
  "prebuild:examples-full": "yarn build:only",
  "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
  "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
  "build:toc": "yarn build:jekyll && scripts/generate-toc",
  "build:site": "rollup -c site/rollup.config.mjs",
  "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
  "build:versions": "scripts/update-version.sh",
  clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
  "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
  data: "rsync -r node_modules/vega-datasets/data/* site/data",
  "build-editor-preview": "scripts/build-editor-preview.sh",
  schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
  renameschema: "scripts/rename-schema.sh",
  presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
  site: "yarn site:only",
  "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
  prettierbase: "prettier '**/*.{md,css,yml}'",
  format: "eslint . --fix && yarn prettierbase --write",
  lint: "eslint . && yarn prettierbase --check",
  test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
  "test:cover": "yarn jest --collectCoverage test/",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand test",
  "test:runtime": "TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
  "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
  watch: "tsc -p tsconfig.build.json -w",
  "watch:site": "yarn build:site -w",
  "watch:test": "yarn jest --watch test/",
  "watch:test:runtime": "TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
  release: "release-it"
}, I$t = {
  type: "git",
  url: "https://github.com/vega/vega-lite.git"
}, j$t = "BSD-3-Clause", L$t = {
  url: "https://github.com/vega/vega-lite/issues"
}, z$t = {
  "@babel/core": "^7.24.5",
  "@babel/preset-env": "^7.24.5",
  "@babel/preset-typescript": "^7.24.1",
  "@release-it/conventional-changelog": "^8.0.1",
  "@rollup/plugin-alias": "^5.1.0",
  "@rollup/plugin-babel": "^6.0.4",
  "@rollup/plugin-commonjs": "^25.0.7",
  "@rollup/plugin-json": "^6.1.0",
  "@rollup/plugin-node-resolve": "^15.2.3",
  "@rollup/plugin-terser": "^0.4.4",
  "@types/d3": "^7.4.3",
  "@types/jest": "^29.5.12",
  "@types/pako": "^2.0.3",
  "@typescript-eslint/eslint-plugin": "^7.8.0",
  "@typescript-eslint/parser": "^7.8.0",
  ajv: "^8.13.0",
  "ajv-formats": "^2.1.1",
  cheerio: "^1.0.0-rc.12",
  "conventional-changelog-cli": "^4.1.0",
  d3: "^7.9.0",
  "del-cli": "^5.1.0",
  eslint: "^8.57.0",
  "eslint-config-prettier": "^9.1.0",
  "eslint-plugin-jest": "^27.9.0",
  "eslint-plugin-prettier": "^5.1.3",
  "fast-json-stable-stringify": "~2.1.0",
  "highlight.js": "^11.9.0",
  jest: "^29.7.0",
  "jest-dev-server": "^10.0.0",
  mkdirp: "^3.0.1",
  pako: "^2.1.0",
  prettier: "^3.2.5",
  puppeteer: "^15.0.0",
  "release-it": "^17.2.1",
  rollup: "^4.17.2",
  "rollup-plugin-bundle-size": "^1.0.3",
  serve: "^14.2.3",
  terser: "^5.31.0",
  "ts-jest": "^29.1.2",
  "ts-json-schema-generator": "^1.5.0",
  typescript: "~5.4.5",
  "vega-cli": "^5.28.0",
  "vega-datasets": "^2.8.1",
  "vega-embed": "^6.25.0",
  "vega-tooltip": "^0.34.0",
  "yaml-front-matter": "^4.1.1"
}, F$t = {
  "json-stringify-pretty-compact": "~3.0.0",
  tslib: "~2.6.2",
  "vega-event-selector": "~3.0.1",
  "vega-expression": "~5.1.0",
  "vega-util": "~1.17.2",
  yargs: "~17.7.2"
}, B$t = {
  vega: "^5.24.0"
}, U$t = {
  node: ">=18"
}, Y$t = "yarn@1.22.19", H$t = {
  name: w$t,
  author: _$t,
  version: E$t,
  collaborators: S$t,
  homepage: M$t,
  description: T$t,
  keywords: C$t,
  main: N$t,
  unpkg: D$t,
  jsdelivr: A$t,
  module: O$t,
  types: R$t,
  bin: k$t,
  files: $$t,
  scripts: P$t,
  repository: I$t,
  license: j$t,
  bugs: L$t,
  devDependencies: z$t,
  dependencies: F$t,
  peerDependencies: B$t,
  engines: U$t,
  packageManager: Y$t
};
function pre(e) {
  return !!e.or;
}
function gre(e) {
  return !!e.and;
}
function mre(e) {
  return !!e.not;
}
function Rj(e, t) {
  if (mre(e))
    Rj(e.not, t);
  else if (gre(e))
    for (const n of e.and)
      Rj(n, t);
  else if (pre(e))
    for (const n of e.or)
      Rj(n, t);
  else
    t(e);
}
function jT(e, t) {
  return mre(e) ? { not: jT(e.not, t) } : gre(e) ? { and: e.and.map((n) => jT(n, t)) } : pre(e) ? { or: e.or.map((n) => jT(n, t)) } : t(e);
}
const Kn = structuredClone;
function M$e(e) {
  throw new Error(e);
}
function jC(e, t) {
  const n = {};
  for (const r of t)
    wn(e, r) && (n[r] = e[r]);
  return n;
}
function Ef(e, t) {
  const n = { ...e };
  for (const r of t)
    delete n[r];
  return n;
}
Set.prototype.toJSON = function() {
  return `Set(${[...this].map((e) => mo(e)).join(",")})`;
};
function Xr(e) {
  if (pi(e))
    return e;
  const t = kt(e) ? e : mo(e);
  if (t.length < 250)
    return t;
  let n = 0;
  for (let r = 0; r < t.length; r++) {
    const i = t.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return n;
}
function KQ(e) {
  return e === !1 || e === null;
}
function Kr(e, t) {
  return e.includes(t);
}
function FS(e, t) {
  let n = 0;
  for (const [r, i] of e.entries())
    if (t(i, r, n++))
      return !0;
  return !1;
}
function yre(e, t) {
  let n = 0;
  for (const [r, i] of e.entries())
    if (!t(i, r, n++))
      return !1;
  return !0;
}
function T$e(e, ...t) {
  for (const n of t)
    V$t(e, n ?? {});
  return e;
}
function V$t(e, t) {
  for (const n of yt(t))
    TN(e, n, t[n], !0);
}
function $y(e, t) {
  const n = [], r = {};
  let i;
  for (const o of e)
    i = t(o), !(i in r) && (r[i] = 1, n.push(o));
  return n;
}
function W$t(e, t) {
  const n = yt(e), r = yt(t);
  if (n.length !== r.length)
    return !1;
  for (const i of n)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
function C$e(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function vre(e, t) {
  for (const n of e)
    if (t.has(n))
      return !0;
  return !1;
}
function ZQ(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e) {
    const i = av(n).map((a, s) => s === 0 ? a : `[${a}]`), o = i.map((a, s) => i.slice(0, s + 1).join(""));
    for (const a of o)
      t.add(a);
  }
  return t;
}
function bre(e, t) {
  return e === void 0 || t === void 0 ? !0 : vre(ZQ(e), ZQ(t));
}
function go(e) {
  return yt(e).length === 0;
}
const yt = Object.keys, il = Object.values, pw = Object.entries;
function a$(e) {
  return e === !0 || e === !1;
}
function oa(e) {
  const t = e.replace(/\W/g, "_");
  return (e.match(/^\d+/) ? "_" : "") + t;
}
function WR(e, t) {
  return mre(e) ? `!(${WR(e.not, t)})` : gre(e) ? `(${e.and.map((n) => WR(n, t)).join(") && (")})` : pre(e) ? `(${e.or.map((n) => WR(n, t)).join(") || (")})` : t(e);
}
function lz(e, t) {
  if (t.length === 0)
    return !0;
  const n = t.shift();
  return n in e && lz(e[n], t) && delete e[n], go(e);
}
function E4(e) {
  return e.charAt(0).toUpperCase() + e.substr(1);
}
function xre(e, t = "datum") {
  const n = av(e), r = [];
  for (let i = 1; i <= n.length; i++) {
    const o = `[${n.slice(0, i).map(Et).join("][")}]`;
    r.push(`${t}${o}`);
  }
  return r.join(" && ");
}
function N$e(e, t = "datum") {
  return `${t}[${Et(av(e).join("."))}]`;
}
function q$t(e) {
  return e.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function _p(e) {
  return `${av(e).map(q$t).join("\\.")}`;
}
function BS(e, t, n) {
  return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n);
}
function jN(e) {
  return `${av(e).join(".")}`;
}
function LC(e) {
  return e ? av(e).length : 0;
}
function rs(...e) {
  for (const t of e)
    if (t !== void 0)
      return t;
}
let D$e = 42;
function A$e(e) {
  const t = ++D$e;
  return e ? String(e) + t : t;
}
function G$t() {
  D$e = 42;
}
function O$e(e) {
  return R$e(e) ? e : `__${e}`;
}
function R$e(e) {
  return e.startsWith("__");
}
function s$(e) {
  if (e !== void 0)
    return (e % 360 + 360) % 360;
}
function v8(e) {
  return pi(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e));
}
const iye = Object.getPrototypeOf(structuredClone({}));
function Dd(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor.name !== t.constructor.name)
      return !1;
    let n, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!Dd(e[r], t[r]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (r of e.entries())
        if (!t.has(r[0]))
          return !1;
      for (r of e.entries())
        if (!Dd(r[1], t.get(r[0])))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (r of e.entries())
        if (!t.has(r[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (e[r] !== t[r])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf && e.valueOf !== iye.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString && e.toString !== iye.toString)
      return e.toString() === t.toString();
    const i = Object.keys(e);
    if (n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!Dd(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function mo(e) {
  const t = [];
  return function n(r) {
    if (r && r.toJSON && typeof r.toJSON == "function" && (r = r.toJSON()), r === void 0)
      return;
    if (typeof r == "number")
      return isFinite(r) ? "" + r : "null";
    if (typeof r != "object")
      return JSON.stringify(r);
    let i, o;
    if (Array.isArray(r)) {
      for (o = "[", i = 0; i < r.length; i++)
        i && (o += ","), o += n(r[i]) || "null";
      return o + "]";
    }
    if (r === null)
      return "null";
    if (t.includes(r))
      throw new TypeError("Converting circular structure to JSON");
    const a = t.push(r) - 1, s = Object.keys(r).sort();
    for (o = "", i = 0; i < s.length; i++) {
      const u = s[i], l = n(r[u]);
      l && (o && (o += ","), o += JSON.stringify(u) + ":" + l);
    }
    return t.splice(a, 1), `{${o}}`;
  }(e);
}
const tb = "row", nb = "column", b8 = "facet", aa = "x", _u = "y", im = "x2", dv = "y2", Lw = "xOffset", LN = "yOffset", om = "radius", Cb = "radius2", Tp = "theta", Nb = "theta2", am = "latitude", sm = "longitude", um = "latitude2", Ep = "longitude2", Pf = "color", hv = "fill", pv = "stroke", If = "shape", Db = "size", c2 = "angle", Ab = "opacity", zw = "fillOpacity", Fw = "strokeOpacity", Bw = "strokeWidth", Uw = "strokeDash", S4 = "text", zC = "order", M4 = "detail", x8 = "key", US = "tooltip", w8 = "href", _8 = "url", E8 = "description", Q$t = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
}, k$e = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function $$e(e) {
  return e in k$e;
}
const wre = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function P$e(e) {
  switch (e) {
    case am:
      return "y";
    case um:
      return "y2";
    case sm:
      return "x";
    case Ep:
      return "x2";
  }
}
function I$e(e) {
  return e in wre;
}
const X$t = yt(wre), _re = {
  ...Q$t,
  ...k$e,
  ...wre,
  xOffset: 1,
  yOffset: 1,
  // color
  color: 1,
  fill: 1,
  stroke: 1,
  // other non-position with scale
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  // channels without scales
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
};
function LT(e) {
  return e === Pf || e === hv || e === pv;
}
const j$e = {
  row: 1,
  column: 1,
  facet: 1
}, rp = yt(j$e), Ere = {
  ..._re,
  ...j$e
}, K$t = yt(Ere), { order: b9t, detail: x9t, tooltip: w9t, ...Z$t } = Ere, { row: _9t, column: E9t, facet: S9t, ...J$t } = Z$t;
function e4t(e) {
  return !!J$t[e];
}
function L$e(e) {
  return !!Ere[e];
}
const t4t = [im, dv, um, Ep, Nb, Cb];
function z$e(e) {
  return f2(e) !== e;
}
function f2(e) {
  switch (e) {
    case im:
      return aa;
    case dv:
      return _u;
    case um:
      return am;
    case Ep:
      return sm;
    case Nb:
      return Tp;
    case Cb:
      return om;
  }
  return e;
}
function gw(e) {
  if ($$e(e))
    switch (e) {
      case Tp:
        return "startAngle";
      case Nb:
        return "endAngle";
      case om:
        return "outerRadius";
      case Cb:
        return "innerRadius";
    }
  return e;
}
function gv(e) {
  switch (e) {
    case aa:
      return im;
    case _u:
      return dv;
    case am:
      return um;
    case sm:
      return Ep;
    case Tp:
      return Nb;
    case om:
      return Cb;
  }
}
function jf(e) {
  switch (e) {
    case aa:
    case im:
      return "width";
    case _u:
    case dv:
      return "height";
  }
}
function F$e(e) {
  switch (e) {
    case aa:
      return "xOffset";
    case _u:
      return "yOffset";
    case im:
      return "x2Offset";
    case dv:
      return "y2Offset";
    case Tp:
      return "thetaOffset";
    case om:
      return "radiusOffset";
    case Nb:
      return "theta2Offset";
    case Cb:
      return "radius2Offset";
  }
}
function Sre(e) {
  switch (e) {
    case aa:
      return "xOffset";
    case _u:
      return "yOffset";
  }
}
function n4t(e) {
  switch (e) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
const r4t = yt(_re), {
  x: M9t,
  y: T9t,
  // x2 and y2 share the same scale as x and y
  x2: C9t,
  y2: N9t,
  //
  xOffset: D9t,
  yOffset: A9t,
  latitude: O9t,
  longitude: R9t,
  latitude2: k9t,
  longitude2: $9t,
  theta: P9t,
  theta2: I9t,
  radius: j9t,
  radius2: L9t,
  // The rest of unit channels then have scale
  ...Mre
} = _re, i4t = yt(Mre), Tre = {
  x: 1,
  y: 1
}, mv = yt(Tre);
function is(e) {
  return e in Tre;
}
const Cre = {
  theta: 1,
  radius: 1
}, o4t = yt(Cre);
function S8(e) {
  return e === "width" ? aa : _u;
}
const B$e = { xOffset: 1, yOffset: 1 };
function T4(e) {
  return e in B$e;
}
const {
  // x2 and y2 share the same scale as x and y
  // text and tooltip have format instead of scale,
  // href has neither format, nor scale
  text: z9t,
  tooltip: F9t,
  href: B9t,
  url: U9t,
  description: Y9t,
  // detail and order have no scale
  detail: H9t,
  key: V9t,
  order: W9t,
  ...U$e
} = Mre, a4t = yt(U$e);
function s4t(e) {
  return !!Mre[e];
}
function u4t(e) {
  switch (e) {
    case Pf:
    case hv:
    case pv:
    case Db:
    case If:
    case Ab:
    case Bw:
    case Uw:
      return !0;
    case zw:
    case Fw:
    case c2:
      return !1;
  }
}
const Y$e = {
  ...Tre,
  ...Cre,
  ...B$e,
  ...U$e
}, M8 = yt(Y$e);
function Ob(e) {
  return !!Y$e[e];
}
function l4t(e, t) {
  return f4t(e)[t];
}
const H$e = {
  // all marks
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
}, { geoshape: q9t, ...c4t } = H$e;
function f4t(e) {
  switch (e) {
    case Pf:
    case hv:
    case pv:
    case E8:
    case M4:
    case x8:
    case US:
    case w8:
    case zC:
    case Ab:
    case zw:
    case Fw:
    case Bw:
    case b8:
    case tb:
    case nb:
      return H$e;
    case aa:
    case _u:
    case Lw:
    case LN:
    case am:
    case sm:
      return c4t;
    case im:
    case dv:
    case um:
    case Ep:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case Db:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case Uw:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case If:
      return { point: "always", geoshape: "always" };
    case S4:
      return { text: "always" };
    case c2:
      return { point: "always", square: "always", text: "always" };
    case _8:
      return { image: "always" };
    case Tp:
      return { text: "always", arc: "always" };
    case om:
      return { text: "always", arc: "always" };
    case Nb:
    case Cb:
      return { arc: "always" };
  }
}
function NV(e) {
  switch (e) {
    case aa:
    case _u:
    case Tp:
    case om:
    case Lw:
    case LN:
    case Db:
    case c2:
    case Bw:
    case Ab:
    case zw:
    case Fw:
    case im:
    case dv:
    case Nb:
    case Cb:
      return;
    case b8:
    case tb:
    case nb:
    case If:
    case Uw:
    case S4:
    case US:
    case w8:
    case _8:
    case E8:
      return "discrete";
    case Pf:
    case hv:
    case pv:
      return "flexible";
    case am:
    case sm:
    case um:
    case Ep:
    case M4:
    case x8:
    case zC:
      return;
  }
}
const d4t = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  exponential: 1,
  exponentialb: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
}, h4t = {
  count: 1,
  min: 1,
  max: 1
};
function pb(e) {
  return !!e && !!e.argmin;
}
function Yw(e) {
  return !!e && !!e.argmax;
}
function Nre(e) {
  return kt(e) && !!d4t[e];
}
const p4t = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function V$e(e) {
  return kt(e) && p4t.has(e);
}
function g4t(e) {
  return kt(e) && Kr(["min", "max"], e);
}
const m4t = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]), y4t = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);
function W$e(e) {
  return Pw(e) && (e = j8(e, void 0)), "bin" + yt(e).map((t) => T8(e[t]) ? oa(`_${t}_${pw(e[t])}`) : oa(`_${t}_${e[t]}`)).join("");
}
function Lo(e) {
  return e === !0 || d2(e) && !e.binned;
}
function Qu(e) {
  return e === "binned" || d2(e) && e.binned === !0;
}
function d2(e) {
  return Pt(e);
}
function T8(e) {
  return e == null ? void 0 : e.param;
}
function oye(e) {
  switch (e) {
    case tb:
    case nb:
    case Db:
    case Pf:
    case hv:
    case pv:
    case Bw:
    case Ab:
    case zw:
    case Fw:
    case If:
      return 6;
    case Uw:
      return 4;
    default:
      return 10;
  }
}
function C4(e) {
  return !!(e != null && e.expr);
}
function yf(e) {
  const t = yt(e || {}), n = {};
  for (const r of t)
    n[r] = Sd(e[r]);
  return n;
}
function q$e(e) {
  const {
    // These are non-mark title config that need to be hardcoded
    anchor: t,
    frame: n,
    offset: r,
    orient: i,
    angle: o,
    limit: a,
    // color needs to be redirect to fill
    color: s,
    // subtitle properties
    subtitleColor: u,
    subtitleFont: l,
    subtitleFontSize: f,
    subtitleFontStyle: h,
    subtitleFontWeight: p,
    subtitleLineHeight: g,
    subtitlePadding: y,
    // The rest are mark config.
    ...b
  } = e, _ = {
    ...b,
    ...s ? { fill: s } : {}
  }, S = {
    ...t ? { anchor: t } : {},
    ...n ? { frame: n } : {},
    ...r ? { offset: r } : {},
    ...i ? { orient: i } : {},
    ...o !== void 0 ? { angle: o } : {},
    ...a !== void 0 ? { limit: a } : {}
  }, C = {
    ...u ? { subtitleColor: u } : {},
    ...l ? { subtitleFont: l } : {},
    ...f ? { subtitleFontSize: f } : {},
    ...h ? { subtitleFontStyle: h } : {},
    ...p ? { subtitleFontWeight: p } : {},
    ...g ? { subtitleLineHeight: g } : {},
    ...y ? { subtitlePadding: y } : {}
  }, A = jC(e, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig: _, subtitleMarkConfig: A, nonMarkTitleProperties: S, subtitle: C };
}
function gx(e) {
  return kt(e) || nt(e) && kt(e[0]);
}
function an(e) {
  return !!(e != null && e.signal);
}
function Hw(e) {
  return !!e.step;
}
function v4t(e) {
  return nt(e) ? !1 : "fields" in e && !("data" in e);
}
function b4t(e) {
  return nt(e) ? !1 : "fields" in e && "data" in e;
}
function Q0(e) {
  return nt(e) ? !1 : "field" in e && "data" in e;
}
const x4t = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
  // commented below are vg channel that do not have mark config.
  // x: 1,
  // y: 1,
  // x2: 1,
  // y2: 1,
  // xc'|'yc'
  // clip: 1,
  // path: 1,
  // url: 1,
}, w4t = yt(x4t), _4t = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
}, JQ = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];
function G$e(e) {
  const t = nt(e.condition) ? e.condition.map(aye) : aye(e.condition);
  return {
    ...Sd(e),
    condition: t
  };
}
function Sd(e) {
  if (C4(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function aye(e) {
  if (C4(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function Vo(e) {
  if (C4(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return an(e) ? e : e !== void 0 ? { value: e } : void 0;
}
function E4t(e) {
  return an(e) ? e.signal : Et(e);
}
function sye(e) {
  return an(e) ? e.signal : Et(e.value);
}
function Ig(e) {
  return an(e) ? e.signal : e == null ? null : Et(e);
}
function S4t(e, t, n) {
  for (const r of n) {
    const i = gb(r, t.markDef, t.config);
    i !== void 0 && (e[r] = Vo(i));
  }
  return e;
}
function Q$e(e) {
  return [].concat(e.type, e.style ?? []);
}
function Fi(e, t, n, r = {}) {
  const { vgChannel: i, ignoreVgConfig: o } = r;
  return i && t[i] !== void 0 ? t[i] : t[e] !== void 0 ? t[e] : o && (!i || i === e) ? void 0 : gb(e, t, n, r);
}
function gb(e, t, n, { vgChannel: r } = {}) {
  return rs(
    // style config has highest precedence
    r ? cz(e, t, n.style) : void 0,
    cz(e, t, n.style),
    // then mark-specific config
    r ? n[t.type][r] : void 0,
    n[t.type][e],
    // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
    // If there is vgChannel, skip vl channel.
    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
    r ? n.mark[r] : n.mark[e]
    // Need to cast for the same reason as above
  );
}
function cz(e, t, n) {
  return X$e(e, Q$e(t), n);
}
function X$e(e, t, n) {
  t = Rt(t);
  let r;
  for (const i of t) {
    const o = n[i];
    o && o[e] !== void 0 && (r = o[e]);
  }
  return r;
}
function K$e(e, t) {
  return Rt(e).reduce((n, r) => (n.field.push(Mt(r, t)), n.order.push(r.sort ?? "ascending"), n), { field: [], order: [] });
}
function Z$e(e, t) {
  const n = [...e];
  return t.forEach((r) => {
    for (const i of n)
      if (Dd(i, r))
        return;
    n.push(r);
  }), n;
}
function J$e(e, t) {
  return Dd(e, t) || !t ? e : e ? [...Rt(e), ...Rt(t)].join(", ") : t;
}
function e4e(e, t) {
  const n = e.value, r = t.value;
  if (n == null || r === null)
    return {
      explicit: e.explicit,
      value: null
    };
  if ((gx(n) || an(n)) && (gx(r) || an(r)))
    return {
      explicit: e.explicit,
      value: J$e(n, r)
    };
  if (gx(n) || an(n))
    return {
      explicit: e.explicit,
      value: n
    };
  if (gx(r) || an(r))
    return {
      explicit: e.explicit,
      value: r
    };
  if (!gx(n) && !an(n) && !gx(r) && !an(r))
    return {
      explicit: e.explicit,
      value: Z$e(n, r)
    };
  throw new Error("It should never reach here");
}
function Dre(e) {
  return `Invalid specification ${mo(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
const M4t = 'Autosize "fit" only works for single views and layered views.';
function uye(e) {
  return `${e == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
}
function lye(e) {
  const t = e == "width" ? "Width" : "Height", n = e == "width" ? "x" : "y";
  return `${t} "container" only works well with autosize "fit" or "fit-${n}".`;
}
function cye(e) {
  return e ? `Dropping "fit-${e}" because spec has discrete ${jf(e)}.` : 'Dropping "fit" because spec has discrete size.';
}
function Are(e) {
  return `Unknown field for ${e}. Cannot calculate view size.`;
}
function fye(e) {
  return `Cannot project a selection on encoding channel "${e}", which has no field.`;
}
function T4t(e, t) {
  return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`;
}
function C4t(e) {
  return `The "nearest" transform is not supported for ${e} marks.`;
}
function t4e(e) {
  return `Selection not supported for ${e} yet.`;
}
function N4t(e) {
  return `Cannot find a selection named "${e}".`;
}
const D4t = "Scale bindings are currently only supported for scales with unbinned, continuous domains.", A4t = "Sequntial scales are deprecated. The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc", O4t = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function R4t(e) {
  return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`;
}
function k4t(e) {
  return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
const $4t = "The same selection must be used to override scale domains in a layered view.", P4t = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
function I4t(e) {
  return `Unknown repeated value "${e}".`;
}
function dye(e) {
  return `The "columns" property cannot be used when "${e}" has nested row/column.`;
}
const j4t = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function L4t(e) {
  return `Unrecognized parse "${e}".`;
}
function hye(e, t, n) {
  return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`;
}
const z4t = "Attempt to add the same child twice.";
function F4t(e) {
  return `Ignoring an invalid transform: ${mo(e)}.`;
}
const B4t = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function pye(e) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`;
}
function U4t(e) {
  const { parentProjection: t, projection: n } = e;
  return `Layer's shared projection ${mo(t)} is overridden by a child projection ${mo(n)}.`;
}
const Y4t = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function H4t(e) {
  return `${e}Offset dropped because ${e} is continuous`;
}
function V4t(e, t, n) {
  return `Channel ${e} is a ${t}. Converted to {value: ${mo(n)}}.`;
}
function n4e(e) {
  return `Invalid field type "${e}".`;
}
function W4t(e, t) {
  return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`;
}
function q4t(e) {
  return `Invalid aggregation operator "${e}".`;
}
function r4e(e, t) {
  const { fill: n, stroke: r } = t;
  return `Dropping color ${e} as the plot also has ${n && r ? "fill and stroke" : n ? "fill" : "stroke"}.`;
}
function G4t(e) {
  return `Position range does not support relative band size for ${e}.`;
}
function eX(e, t) {
  return `Dropping ${mo(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`;
}
const Q4t = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function C8(e, t, n) {
  return `${e} dropped as it is incompatible with "${t}"${n ? ` when ${n}` : ""}.`;
}
function X4t(e) {
  return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`;
}
function K4t(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned).`;
}
function Z4t(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function J4t(e) {
  return `Facet encoding dropped as ${e.join(" and ")} ${e.length > 1 ? "are" : "is"} also specified.`;
}
function DV(e, t) {
  return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t === "ordinal" ? "order" : "magnitude"}.`;
}
function ePt(e) {
  return `The ${e} for range marks cannot be an expression`;
}
function tPt(e, t) {
  return `Line mark is for continuous lines and thus cannot be used with ${e && t ? "x2 and y2" : e ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`;
}
function nPt(e, t) {
  return `Specified orient "${e}" overridden with "${t}".`;
}
function rPt(e) {
  return `Cannot use the scale property "${e}" with non-color channel.`;
}
function iPt(e) {
  return `Cannot use the relative band size with ${e} scale.`;
}
function oPt(e) {
  return `Using unaggregated domain with raw field has no effect (${mo(e)}).`;
}
function aPt(e) {
  return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`;
}
function sPt(e) {
  return `Unaggregated domain is currently unsupported for log scale (${mo(e)}).`;
}
function uPt(e) {
  return `Cannot apply size to non-oriented mark "${e}".`;
}
function lPt(e, t, n) {
  return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`;
}
function cPt(e, t) {
  return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`;
}
function i4e(e, t, n) {
  return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`;
}
function o4e(e) {
  return `The step for "${e}" is dropped because the ${e === "width" ? "x" : "y"} is continuous.`;
}
function fPt(e, t, n, r) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${mo(n)} and ${mo(r)}). Using ${mo(n)}.`;
}
function dPt(e, t, n, r) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${mo(n)} and ${mo(r)}). Using the union of the two domains.`;
}
function hPt(e) {
  return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`;
}
function pPt(e) {
  return `Dropping sort property ${mo(e)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
const gye = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.", gPt = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.", mPt = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.", yPt = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function vPt(e) {
  return `Cannot stack "${e}" if there is already "${e}2".`;
}
function bPt(e) {
  return `Stack is applied to a non-linear scale (${e}).`;
}
function xPt(e) {
  return `Stacking is applied even though the aggregate function is non-summative ("${e}").`;
}
function fz(e, t) {
  return `Invalid ${e}: ${mo(t)}.`;
}
function wPt(e) {
  return `Dropping day from datetime ${mo(e)} as day cannot be combined with other units.`;
}
function _Pt(e, t) {
  return `${t ? "extent " : ""}${t && e ? "and " : ""}${e ? "center " : ""}${t && e ? "are " : "is "}not needed when data are aggregated.`;
}
function EPt(e, t, n) {
  return `${e} is not usually used with ${t} for ${n}.`;
}
function SPt(e, t) {
  return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`;
}
function mye(e) {
  return `1D error band does not support ${e}.`;
}
function a4e(e) {
  return `Channel ${e} is required for "binned" bin.`;
}
function MPt(e) {
  return `Channel ${e} should not be used with "binned" bin.`;
}
function TPt(e) {
  return `Domain for ${e} is required for threshold scale.`;
}
globalThis && globalThis.__classPrivateFieldSet;
globalThis && globalThis.__classPrivateFieldGet;
const s4e = nee(tee);
let FC = s4e;
function CPt(e) {
  return FC = e, FC;
}
function NPt() {
  return FC = s4e, FC;
}
function bt(...e) {
  FC.warn(...e);
}
function DPt(...e) {
  FC.debug(...e);
}
function h2(e) {
  if (e && Pt(e)) {
    for (const t of Rre)
      if (t in e)
        return !0;
  }
  return !1;
}
const u4e = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], APt = u4e.map((e) => e.substr(0, 3)), l4e = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"], OPt = l4e.map((e) => e.substr(0, 3));
function RPt(e) {
  if (v8(e) && (e = +e), pi(e))
    return e > 4 && bt(fz("quarter", e)), e - 1;
  throw new Error(fz("quarter", e));
}
function kPt(e) {
  if (v8(e) && (e = +e), pi(e))
    return e - 1;
  {
    const t = e.toLowerCase(), n = u4e.indexOf(t);
    if (n !== -1)
      return n;
    const r = t.substr(0, 3), i = APt.indexOf(r);
    if (i !== -1)
      return i;
    throw new Error(fz("month", e));
  }
}
function $Pt(e) {
  if (v8(e) && (e = +e), pi(e))
    return e % 7;
  {
    const t = e.toLowerCase(), n = l4e.indexOf(t);
    if (n !== -1)
      return n;
    const r = t.substr(0, 3), i = OPt.indexOf(r);
    if (i !== -1)
      return i;
    throw new Error(fz("day", e));
  }
}
function Ore(e, t) {
  const n = [];
  if (t && e.day !== void 0 && yt(e).length > 1 && (bt(wPt(e)), e = Kn(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
    const r = t ? kPt(e.month) : e.month;
    n.push(r);
  } else if (e.quarter !== void 0) {
    const r = t ? RPt(e.quarter) : e.quarter;
    n.push(pi(r) ? r * 3 : `${r}*3`);
  } else
    n.push(0);
  if (e.date !== void 0)
    n.push(e.date);
  else if (e.day !== void 0) {
    const r = t ? $Pt(e.day) : e.day;
    n.push(pi(r) ? r + 1 : `${r}+1`);
  } else
    n.push(1);
  for (const r of ["hours", "minutes", "seconds", "milliseconds"]) {
    const i = e[r];
    n.push(typeof i > "u" ? 0 : i);
  }
  return n;
}
function YS(e) {
  const n = Ore(e, !0).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function PPt(e) {
  const n = Ore(e, !1).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function IPt(e) {
  const t = Ore(e, !0);
  return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t);
}
const c4e = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
}, Rre = yt(c4e);
function jPt(e) {
  return !!c4e[e];
}
function p2(e) {
  return Pt(e) ? e.binned : f4e(e);
}
function f4e(e) {
  return e && e.startsWith("binned");
}
function kre(e) {
  return e.startsWith("utc");
}
function LPt(e) {
  return e.substring(3);
}
const zPt = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function N8(e) {
  return Rre.filter((t) => h4e(e, t));
}
function d4e(e) {
  const t = N8(e);
  return t[t.length - 1];
}
function h4e(e, t) {
  const n = e.indexOf(t);
  return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f");
}
function FPt(e, t, { end: n } = { end: !1 }) {
  const r = xre(t), i = kre(e) ? "utc" : "";
  function o(u) {
    return u === "quarter" ? `(${i}quarter(${r})-1)` : `${i}${u}(${r})`;
  }
  let a;
  const s = {};
  for (const u of Rre)
    h4e(e, u) && (s[u] = o(u), a = u);
  return n && (s[a] += "+1"), PPt(s);
}
function p4e(e) {
  if (!e)
    return;
  const t = N8(e);
  return `timeUnitSpecifier(${mo(t)}, ${mo(zPt)})`;
}
function BPt(e, t, n) {
  if (!e)
    return;
  const r = p4e(e);
  return `${n || kre(e) ? "utc" : "time"}Format(${t}, ${r})`;
}
function bu(e) {
  if (!e)
    return;
  let t;
  return kt(e) ? f4e(e) ? t = {
    unit: e.substring(6),
    binned: !0
  } : t = {
    unit: e
  } : Pt(e) && (t = {
    ...e,
    ...e.unit ? { unit: e.unit } : {}
  }), kre(t.unit) && (t.utc = !0, t.unit = LPt(t.unit)), t;
}
function UPt(e) {
  const { utc: t, ...n } = bu(e);
  return n.unit ? (t ? "utc" : "") + yt(n).map((r) => oa(`${r === "unit" ? "" : `_${r}_`}${n[r]}`)).join("") : (t ? "utc" : "") + "timeunit" + yt(n).map((r) => oa(`_${r}_${n[r]}`)).join("");
}
function g4e(e, t = (n) => n) {
  const n = bu(e), r = d4e(n.unit);
  if (r && r !== "day") {
    const i = {
      year: 2001,
      // pick a non-leap year
      month: 1,
      date: 1,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    }, { step: o, part: a } = m4e(r, n.step), s = {
      ...i,
      [a]: +i[a] + o
    };
    return `${t(YS(s))} - ${t(YS(i))}`;
  }
}
const YPt = {
  year: 1,
  month: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
function HPt(e) {
  return !!YPt[e];
}
function m4e(e, t = 1) {
  if (HPt(e))
    return { part: e, step: t };
  switch (e) {
    case "day":
    case "dayofyear":
      return { part: "date", step: t };
    case "quarter":
      return { part: "month", step: t * 3 };
    case "week":
      return { part: "date", step: t * 7 };
  }
}
function VPt(e) {
  return e == null ? void 0 : e.param;
}
function $re(e) {
  return !!(e != null && e.field) && e.equal !== void 0;
}
function Pre(e) {
  return !!(e != null && e.field) && e.lt !== void 0;
}
function Ire(e) {
  return !!(e != null && e.field) && e.lte !== void 0;
}
function jre(e) {
  return !!(e != null && e.field) && e.gt !== void 0;
}
function Lre(e) {
  return !!(e != null && e.field) && e.gte !== void 0;
}
function zre(e) {
  if (e != null && e.field) {
    if (nt(e.range) && e.range.length === 2)
      return !0;
    if (an(e.range))
      return !0;
  }
  return !1;
}
function Fre(e) {
  return !!(e != null && e.field) && (nt(e.oneOf) || nt(e.in));
}
function WPt(e) {
  return !!(e != null && e.field) && e.valid !== void 0;
}
function y4e(e) {
  return Fre(e) || $re(e) || zre(e) || Pre(e) || jre(e) || Ire(e) || Lre(e);
}
function my(e, t) {
  return L8(e, { timeUnit: t, wrapTime: !0 });
}
function qPt(e, t) {
  return e.map((n) => my(n, t));
}
function v4e(e, t = !0) {
  const { field: n } = e, r = bu(e.timeUnit), { unit: i, binned: o } = r || {}, a = Mt(e, { expr: "datum" }), s = i ? (
    // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
    // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
    // TODO: support utc
    `time(${o ? a : FPt(i, n)})`
  ) : a;
  if ($re(e))
    return `${s}===${my(e.equal, i)}`;
  if (Pre(e)) {
    const u = e.lt;
    return `${s}<${my(u, i)}`;
  } else if (jre(e)) {
    const u = e.gt;
    return `${s}>${my(u, i)}`;
  } else if (Ire(e)) {
    const u = e.lte;
    return `${s}<=${my(u, i)}`;
  } else if (Lre(e)) {
    const u = e.gte;
    return `${s}>=${my(u, i)}`;
  } else {
    if (Fre(e))
      return `indexof([${qPt(e.oneOf, i).join(",")}], ${s}) !== -1`;
    if (WPt(e))
      return Bre(s, e.valid);
    if (zre(e)) {
      const { range: u } = e, l = an(u) ? { signal: `${u.signal}[0]` } : u[0], f = an(u) ? { signal: `${u.signal}[1]` } : u[1];
      if (l !== null && f !== null && t)
        return "inrange(" + s + ", [" + my(l, i) + ", " + my(f, i) + "])";
      const h = [];
      return l !== null && h.push(`${s} >= ${my(l, i)}`), f !== null && h.push(`${s} <= ${my(f, i)}`), h.length > 0 ? h.join(" && ") : "true";
    }
  }
  throw new Error(`Invalid field predicate: ${mo(e)}`);
}
function Bre(e, t = !0) {
  return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`;
}
function GPt(e) {
  return y4e(e) && e.timeUnit ? {
    ...e,
    timeUnit: bu(e.timeUnit)
  } : e;
}
const N4 = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function QPt(e) {
  return e === "quantitative" || e === "temporal";
}
function b4e(e) {
  return e === "ordinal" || e === "nominal";
}
const HS = N4.quantitative, Ure = N4.ordinal, BC = N4.temporal, Yre = N4.nominal, zN = N4.geojson;
function XPt(e) {
  if (e)
    switch (e = e.toLowerCase(), e) {
      case "q":
      case HS:
        return "quantitative";
      case "t":
      case BC:
        return "temporal";
      case "o":
      case Ure:
        return "ordinal";
      case "n":
      case Yre:
        return "nominal";
      case zN:
        return "geojson";
    }
}
const Sf = {
  // Continuous - Quantitative
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  SYMLOG: "symlog",
  IDENTITY: "identity",
  SEQUENTIAL: "sequential",
  // Continuous - Time
  TIME: "time",
  UTC: "utc",
  // Discretizing scales
  QUANTILE: "quantile",
  QUANTIZE: "quantize",
  THRESHOLD: "threshold",
  BIN_ORDINAL: "bin-ordinal",
  // Discrete scales
  ORDINAL: "ordinal",
  POINT: "point",
  BAND: "band"
}, tX = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  // TODO: should bin-ordinal support merging with other
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
function KPt(e, t) {
  const n = tX[e], r = tX[t];
  return n === r || n === "ordinal-position" && r === "time" || r === "ordinal-position" && n === "time";
}
const ZPt = {
  // numeric
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  // time
  time: 0,
  utc: 0,
  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
  point: 10,
  band: 11,
  // band has higher precedence as it is better for interaction
  // non grouped types
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function yye(e) {
  return ZPt[e];
}
const x4e = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]), w4e = /* @__PURE__ */ new Set([
  ...x4e,
  "time",
  "utc"
]);
function _4e(e) {
  return x4e.has(e);
}
const E4e = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]), JPt = /* @__PURE__ */ new Set([
  ...w4e,
  ...E4e,
  "sequential",
  "identity"
]), eIt = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function xu(e) {
  return eIt.has(e);
}
function Wd(e) {
  return JPt.has(e);
}
function jg(e) {
  return w4e.has(e);
}
function UC(e) {
  return E4e.has(e);
}
const tIt = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  // FIXME: revise if these *can* become ratios of width/height step
  minSize: 9,
  // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4,
  zero: !0
};
function nIt(e) {
  return !kt(e) && !!e.name;
}
function S4e(e) {
  return e == null ? void 0 : e.param;
}
function rIt(e) {
  return e == null ? void 0 : e.unionWith;
}
function iIt(e) {
  return Pt(e) && "field" in e;
}
const oIt = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  domainRaw: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  // Other properties
  reverse: 1,
  round: 1,
  // quantitative / time
  clamp: 1,
  nice: 1,
  // quantitative
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  // zero depends on domain
  // band/point
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
}, { type: G9t, domain: Q9t, range: X9t, rangeMax: K9t, rangeMin: Z9t, scheme: J9t, ...aIt } = oIt, sIt = yt(aIt);
function nX(e, t) {
  switch (t) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return !0;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(e);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(e);
    case "round":
      return jg(e) || e === "band" || e === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return jg(e) || ["point", "band"].includes(e);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(e);
    case "paddingInner":
      return e === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "domainRaw":
    case "clamp":
      return jg(e);
    case "nice":
      return jg(e) || e === "quantize" || e === "threshold";
    case "exponent":
      return e === "pow";
    case "base":
      return e === "log";
    case "constant":
      return e === "symlog";
    case "zero":
      return Wd(e) && !Kr([
        "log",
        // log scale cannot have zero value
        "time",
        "utc",
        // zero is not meaningful for time
        "threshold",
        // threshold requires custom domain so zero does not matter
        "quantile"
        // quantile depends on distribution so zero does not matter
      ], e);
  }
}
function M4e(e, t) {
  switch (t) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      return LT(e) ? void 0 : rPt(t);
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "domainRaw":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return;
  }
}
function uIt(e, t) {
  return Kr([Ure, Yre], t) ? e === void 0 || xu(e) : t === BC ? Kr([Sf.TIME, Sf.UTC, void 0], e) : t === HS ? _4e(e) || UC(e) || e === void 0 : !0;
}
function lIt(e, t, n = !1) {
  if (!Ob(e))
    return !1;
  switch (e) {
    case aa:
    case _u:
    case Lw:
    case LN:
    case Tp:
    case om:
      return jg(t) || t === "band" ? !0 : t === "point" ? !n : !1;
    case Db:
    case Bw:
    case Ab:
    case zw:
    case Fw:
    case c2:
      return jg(t) || UC(t) || Kr(["band", "point", "ordinal"], t);
    case Pf:
    case hv:
    case pv:
      return t !== "band";
    case Uw:
    case If:
      return t === "ordinal" || UC(t);
  }
}
function Hre(e) {
  const { channel: t, channelDef: n, markDef: r, scale: i, config: o } = e, a = Wre(e);
  return (
    // Only this for field def without counting aggregate (as count wouldn't be null)
    xt(n) && !V$e(n.aggregate) && // and only for continuous scale
    i && jg(i.get("type")) ? cIt({
      fieldDef: n,
      channel: t,
      markDef: r,
      ref: a,
      config: o
    }) : a
  );
}
function cIt({ fieldDef: e, channel: t, markDef: n, ref: r, config: i }) {
  return Fi("invalid", n, i) === null ? [fIt(e, t), r] : r;
}
function fIt(e, t) {
  const n = Vre(e, !0), i = f2(t) === "y" ? { field: { group: "height" } } : (
    // x / angle / radius can all use 0
    { value: 0 }
  );
  return { test: n, ...i };
}
function Vre(e, t = !0) {
  return Bre(kt(e) ? e : Mt(e, { expr: "datum" }), !t);
}
function dIt(e) {
  const { datum: t } = e;
  return h2(t) ? YS(t) : `${mo(t)}`;
}
function sS(e, t, n, r) {
  const i = {};
  if (t && (i.scale = t), yv(e)) {
    const { datum: o } = e;
    h2(o) ? i.signal = YS(o) : an(o) ? i.signal = o.signal : C4(o) ? i.signal = o.expr : i.value = o;
  } else
    i.field = Mt(e, n);
  if (r) {
    const { offset: o, band: a } = r;
    o && (i.offset = o), a && (i.band = a);
  }
  return i;
}
function dz({ scaleName: e, fieldOrDatumDef: t, fieldOrDatumDef2: n, offset: r, startSuffix: i, endSuffix: o = "end", bandPosition: a = 0.5 }) {
  const s = !an(a) && 0 < a && a < 1 ? "datum" : void 0, u = Mt(t, { expr: s, suffix: i }), l = n !== void 0 ? Mt(n, { expr: s }) : Mt(t, { suffix: o, expr: s }), f = {};
  if (a === 0 || a === 1) {
    f.scale = e;
    const h = a === 0 ? u : l;
    f.field = h;
  } else {
    const h = an(a) ? `(1-${a.signal}) * ${u} + ${a.signal} * ${l}` : `${1 - a} * ${u} + ${a} * ${l}`;
    f.signal = `scale("${e}", ${h})`;
  }
  return r && (f.offset = r), f;
}
function hIt({ scaleName: e, fieldDef: t }) {
  const n = Mt(t, { expr: "datum" }), r = Mt(t, { expr: "datum", suffix: "end" });
  return `abs(scale("${e}", ${r}) - scale("${e}", ${n}))`;
}
function Wre({ channel: e, channelDef: t, channel2Def: n, markDef: r, config: i, scaleName: o, scale: a, stack: s, offset: u, defaultRef: l, bandPosition: f }) {
  if (t) {
    if (or(t)) {
      const h = a == null ? void 0 : a.get("type");
      if (Pc(t)) {
        f ?? (f = mw({
          fieldDef: t,
          fieldDef2: n,
          markDef: r,
          config: i
        }));
        const { bin: p, timeUnit: g, type: y } = t;
        if (Lo(p) || f && g && y === BC)
          return s != null && s.impute ? sS(t, o, { binSuffix: "mid" }, { offset: u }) : f && !xu(h) ? dz({ scaleName: o, fieldOrDatumDef: t, bandPosition: f, offset: u }) : sS(t, o, R4(t, e) ? { binSuffix: "range" } : {}, {
            offset: u
          });
        if (Qu(p)) {
          if (xt(n))
            return dz({
              scaleName: o,
              fieldOrDatumDef: t,
              fieldOrDatumDef2: n,
              bandPosition: f,
              offset: u
            });
          bt(a4e(e === aa ? im : dv));
        }
      }
      return sS(
        t,
        o,
        xu(h) ? { binSuffix: "range" } : {},
        // no need for bin suffix if there is no scale
        {
          offset: u,
          // For band, to get mid point, need to offset by half of the band
          band: h === "band" ? f ?? t.bandPosition ?? 0.5 : void 0
        }
      );
    } else if (Qg(t)) {
      const h = t.value, p = u ? { offset: u } : {};
      return { ...qR(e, h), ...p };
    }
  }
  return pr(l) && (l = l()), l && {
    ...l,
    // only include offset when it is non-zero (zero = no offset)
    ...u ? { offset: u } : {}
  };
}
function qR(e, t) {
  return Kr(["x", "x2"], e) && t === "width" ? { field: { group: "width" } } : Kr(["y", "y2"], e) && t === "height" ? { field: { group: "height" } } : Vo(t);
}
function VS(e) {
  return e && e !== "number" && e !== "time";
}
function T4e(e, t, n) {
  return `${e}(${t}${n ? `, ${mo(n)}` : ""})`;
}
const pIt = " – ";
function qre({ fieldOrDatumDef: e, format: t, formatType: n, expr: r, normalizeStack: i, config: o }) {
  var u, l;
  if (VS(n))
    return Lg({
      fieldOrDatumDef: e,
      format: t,
      formatType: n,
      expr: r,
      config: o
    });
  const a = C4e(e, r, i), s = YC(e);
  if (t === void 0 && n === void 0 && o.customFormatTypes) {
    if (s === "quantitative") {
      if (i && o.normalizedNumberFormatType)
        return Lg({
          fieldOrDatumDef: e,
          format: o.normalizedNumberFormat,
          formatType: o.normalizedNumberFormatType,
          expr: r,
          config: o
        });
      if (o.numberFormatType)
        return Lg({
          fieldOrDatumDef: e,
          format: o.numberFormat,
          formatType: o.numberFormatType,
          expr: r,
          config: o
        });
    }
    if (s === "temporal" && o.timeFormatType && xt(e) && e.timeUnit === void 0)
      return Lg({
        fieldOrDatumDef: e,
        format: o.timeFormat,
        formatType: o.timeFormatType,
        expr: r,
        config: o
      });
  }
  if (VC(e)) {
    const f = mIt({
      field: a,
      timeUnit: xt(e) ? (u = bu(e.timeUnit)) == null ? void 0 : u.unit : void 0,
      format: t,
      formatType: o.timeFormatType,
      rawTimeFormat: o.timeFormat,
      isUTCScale: m2(e) && ((l = e.scale) == null ? void 0 : l.type) === Sf.UTC
    });
    return f ? { signal: f } : void 0;
  }
  if (t = rX({ type: s, specifiedFormat: t, config: o, normalizeStack: i }), xt(e) && Lo(e.bin)) {
    const f = Mt(e, { expr: r, binSuffix: "end" });
    return {
      signal: D4(a, f, t, n, o)
    };
  } else
    return t || YC(e) === "quantitative" ? {
      signal: `${A4e(a, t)}`
    } : { signal: `isValid(${a}) ? ${a} : ""+${a}` };
}
function C4e(e, t, n) {
  return xt(e) ? n ? `${Mt(e, { expr: t, suffix: "end" })}-${Mt(e, {
    expr: t,
    suffix: "start"
  })}` : Mt(e, { expr: t }) : dIt(e);
}
function Lg({ fieldOrDatumDef: e, format: t, formatType: n, expr: r, normalizeStack: i, config: o, field: a }) {
  if (a ?? (a = C4e(e, r, i)), a !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
  xt(e) && Lo(e.bin)) {
    const s = Mt(e, { expr: r, binSuffix: "end" });
    return {
      signal: D4(a, s, t, n, o)
    };
  }
  return { signal: T4e(n, a, t) };
}
function N4e(e, t, n, r, i, o) {
  var a;
  if (!(kt(r) && VS(r)) && !(n === void 0 && r === void 0 && i.customFormatTypes && YC(e) === "quantitative" && (i.normalizedNumberFormatType && HC(e) && e.stack === "normalize" || i.numberFormatType))) {
    if (HC(e) && e.stack === "normalize" && i.normalizedNumberFormat)
      return rX({
        type: "quantitative",
        config: i,
        normalizeStack: !0
      });
    if (VC(e)) {
      const s = xt(e) ? (a = bu(e.timeUnit)) == null ? void 0 : a.unit : void 0;
      return s === void 0 && i.customFormatTypes && i.timeFormatType ? void 0 : gIt({ specifiedFormat: n, timeUnit: s, config: i, omitTimeFormatConfig: o });
    }
    return rX({ type: t, specifiedFormat: n, config: i });
  }
}
function D4e(e, t, n) {
  var r;
  if (e && (an(e) || e === "number" || e === "time"))
    return e;
  if (VC(t) && n !== "time" && n !== "utc")
    return xt(t) && ((r = bu(t == null ? void 0 : t.timeUnit)) != null && r.utc) ? "utc" : "time";
}
function rX({ type: e, specifiedFormat: t, config: n, normalizeStack: r }) {
  if (kt(t))
    return t;
  if (e === HS)
    return r ? n.normalizedNumberFormat : n.numberFormat;
}
function gIt({ specifiedFormat: e, timeUnit: t, config: n, omitTimeFormatConfig: r }) {
  return e || (t ? {
    signal: p4e(t)
  } : r ? void 0 : n.timeFormat);
}
function A4e(e, t) {
  return `format(${e}, "${t || ""}")`;
}
function vye(e, t, n, r) {
  return VS(n) ? T4e(n, e, t) : A4e(e, (kt(t) ? t : void 0) ?? r.numberFormat);
}
function D4(e, t, n, r, i) {
  if (n === void 0 && r === void 0 && i.customFormatTypes && i.numberFormatType)
    return D4(e, t, i.numberFormat, i.numberFormatType, i);
  const o = vye(e, n, r, i), a = vye(t, n, r, i);
  return `${Bre(e, !1)} ? "null" : ${o} + "${pIt}" + ${a}`;
}
function mIt({ field: e, timeUnit: t, format: n, formatType: r, rawTimeFormat: i, isUTCScale: o }) {
  return !t || n ? !t && r ? `${r}(${e}, '${n}')` : (n = kt(n) ? n : i, `${o ? "utc" : "time"}Format(${e}, '${n}')`) : BPt(t, e, o);
}
const jc = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
}, O4e = jc.arc, D8 = jc.area, A8 = jc.bar, yIt = jc.image, O8 = jc.line, R8 = jc.point, vIt = jc.rect, hz = jc.rule, R4e = jc.text, Gre = jc.tick, bIt = jc.trail, Qre = jc.circle, Xre = jc.square, k4e = jc.geoshape;
function g2(e) {
  return ["line", "area", "trail"].includes(e);
}
function u$(e) {
  return [
    "rect",
    "bar",
    "image",
    "arc"
    /* arc is rect/interval in polar coordinate */
  ].includes(e);
}
const xIt = new Set(yt(jc));
function Zy(e) {
  return e.type;
}
const wIt = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
], _It = ["fill", "fillOpacity"], EIt = [...wIt, ..._It], SIt = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
}, bye = yt(SIt), MIt = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
}, TIt = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
}, CIt = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
}, $4e = yt(CIt);
function WS(e) {
  return e && e.band != null;
}
const NIt = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
}, P4e = 5, DIt = {
  binSpacing: 1,
  continuousBandSize: P4e,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, AIt = {
  binSpacing: 0,
  continuousBandSize: P4e,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, OIt = {
  thickness: 1
};
function RIt(e) {
  return Zy(e) ? e.type : e;
}
const k8 = "min", kIt = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function xye(e) {
  return e in kIt;
}
function I4e(e) {
  return !!(e != null && e.encoding);
}
function Uy(e) {
  return e && (e.op === "count" || !!e.field);
}
function j4e(e) {
  return e && nt(e);
}
function A4(e) {
  return "row" in e || "column" in e;
}
function Kre(e) {
  return !!e && "header" in e;
}
function $8(e) {
  return "facet" in e;
}
function $It(e) {
  return e.param;
}
function PIt(e) {
  return e && !kt(e) && "repeat" in e;
}
function wye(e) {
  const { field: t, timeUnit: n, bin: r, aggregate: i } = e;
  return {
    ...n ? { timeUnit: n } : {},
    ...r ? { bin: r } : {},
    ...i ? { aggregate: i } : {},
    field: t
  };
}
function Zre(e) {
  return "sort" in e;
}
function mw({ fieldDef: e, fieldDef2: t, markDef: n, config: r }) {
  if (or(e) && e.bandPosition !== void 0)
    return e.bandPosition;
  if (xt(e)) {
    const { timeUnit: i, bin: o } = e;
    if (i && !t)
      return gb("timeUnitBandPosition", n, r);
    if (Lo(o))
      return 0.5;
  }
}
function L4e({ channel: e, fieldDef: t, fieldDef2: n, markDef: r, config: i, scaleType: o, useVlSizeChannel: a }) {
  var l, f, h;
  const s = jf(e), u = Fi(a ? "size" : s, r, i, {
    vgChannel: s
  });
  if (u !== void 0)
    return u;
  if (xt(t)) {
    const { timeUnit: p, bin: g } = t;
    if (p && !n)
      return { band: gb("timeUnitBandSize", r, i) };
    if (Lo(g) && !xu(o))
      return { band: 1 };
  }
  if (u$(r.type))
    return o ? xu(o) ? ((l = i[r.type]) == null ? void 0 : l.discreteBandSize) || { band: 1 } : (f = i[r.type]) == null ? void 0 : f.continuousBandSize : (h = i[r.type]) == null ? void 0 : h.discreteBandSize;
}
function z4e(e, t, n, r) {
  return Lo(e.bin) || e.timeUnit && Pc(e) && e.type === "temporal" ? mw({ fieldDef: e, fieldDef2: t, markDef: n, config: r }) !== void 0 : !1;
}
function F4e(e) {
  return e && !!e.sort && !e.field;
}
function P8(e) {
  return e && "condition" in e;
}
function I8(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !nt(t) && xt(t);
}
function O4(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !nt(t) && or(t);
}
function IIt(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && (nt(t) || Qg(t));
}
function xt(e) {
  return e && (!!e.field || e.aggregate === "count");
}
function YC(e) {
  return e == null ? void 0 : e.type;
}
function yv(e) {
  return e && "datum" in e;
}
function kx(e) {
  return Pc(e) && !gz(e) || pz(e);
}
function _ye(e) {
  return Pc(e) && e.type === "quantitative" && !e.bin || pz(e);
}
function pz(e) {
  return yv(e) && pi(e.datum);
}
function or(e) {
  return xt(e) || yv(e);
}
function Pc(e) {
  return e && ("field" in e || e.aggregate === "count") && "type" in e;
}
function Qg(e) {
  return e && "value" in e && "value" in e;
}
function m2(e) {
  return e && ("scale" in e || "sort" in e);
}
function HC(e) {
  return e && ("axis" in e || "stack" in e || "impute" in e);
}
function B4e(e) {
  return e && "legend" in e;
}
function U4e(e) {
  return e && ("format" in e || "formatType" in e);
}
function jIt(e) {
  return Ef(e, ["legend", "axis", "header", "scale"]);
}
function LIt(e) {
  return "op" in e;
}
function Mt(e, t = {}) {
  let n = e.field;
  const r = t.prefix;
  let i = t.suffix, o = "";
  if (FIt(e))
    n = O$e("count");
  else {
    let a;
    if (!t.nofn)
      if (LIt(e))
        a = e.op;
      else {
        const { bin: s, aggregate: u, timeUnit: l } = e;
        Lo(s) ? (a = W$e(s), i = (t.binSuffix ?? "") + (t.suffix ?? "")) : u ? Yw(u) ? (o = `["${n}"]`, n = `argmax_${u.argmax}`) : pb(u) ? (o = `["${n}"]`, n = `argmin_${u.argmin}`) : a = String(u) : l && !p2(l) && (a = UPt(l), i = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""));
      }
    a && (n = n ? `${a}_${n}` : a);
  }
  return i && (n = `${n}_${i}`), r && (n = `${r}_${n}`), t.forAs ? jN(n) : t.expr ? N$e(n, t.expr) + o : _p(n) + o;
}
function gz(e) {
  switch (e.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return !0;
    case "quantitative":
      return xt(e) && !!e.bin;
    case "temporal":
      return !1;
  }
  throw new Error(n4e(e.type));
}
function zIt(e) {
  var t;
  return m2(e) && UC((t = e.scale) == null ? void 0 : t.type);
}
function FIt(e) {
  return e.aggregate === "count";
}
function BIt(e, t) {
  var a;
  const { field: n, bin: r, timeUnit: i, aggregate: o } = e;
  if (o === "count")
    return t.countTitle;
  if (Lo(r))
    return `${n} (binned)`;
  if (i && !p2(i)) {
    const s = (a = bu(i)) == null ? void 0 : a.unit;
    if (s)
      return `${n} (${N8(s).join("-")})`;
  } else if (o)
    return Yw(o) ? `${n} for max ${o.argmax}` : pb(o) ? `${n} for min ${o.argmin}` : `${E4(o)} of ${n}`;
  return n;
}
function UIt(e) {
  const { aggregate: t, bin: n, timeUnit: r, field: i } = e;
  if (Yw(t))
    return `${i} for argmax(${t.argmax})`;
  if (pb(t))
    return `${i} for argmin(${t.argmin})`;
  const o = r && !p2(r) ? bu(r) : void 0, a = t || (o == null ? void 0 : o.unit) || (o == null ? void 0 : o.maxbins) && "timeunit" || Lo(n) && "bin";
  return a ? `${a.toUpperCase()}(${i})` : i;
}
const Y4e = (e, t) => {
  switch (t.fieldTitle) {
    case "plain":
      return e.field;
    case "functional":
      return UIt(e);
    default:
      return BIt(e, t);
  }
};
let H4e = Y4e;
function V4e(e) {
  H4e = e;
}
function YIt() {
  V4e(Y4e);
}
function zT(e, t, { allowDisabling: n, includeDefault: r = !0 }) {
  var s;
  const i = (s = Jre(e)) == null ? void 0 : s.title;
  if (!xt(e))
    return i ?? e.title;
  const o = e, a = r ? eie(o, t) : void 0;
  return n ? rs(i, o.title, a) : i ?? o.title ?? a;
}
function Jre(e) {
  if (HC(e) && e.axis)
    return e.axis;
  if (B4e(e) && e.legend)
    return e.legend;
  if (Kre(e) && e.header)
    return e.header;
}
function eie(e, t) {
  return H4e(e, t);
}
function mz(e) {
  if (U4e(e)) {
    const { format: t, formatType: n } = e;
    return { format: t, formatType: n };
  } else {
    const t = Jre(e) ?? {}, { format: n, formatType: r } = t;
    return { format: n, formatType: r };
  }
}
function HIt(e, t) {
  var o;
  switch (t) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (Zre(e) && nt(e.sort))
    return "ordinal";
  const { aggregate: n, bin: r, timeUnit: i } = e;
  if (i)
    return "temporal";
  if (r || n && !Yw(n) && !pb(n))
    return "quantitative";
  if (m2(e) && ((o = e.scale) != null && o.type))
    switch (tX[e.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  return "nominal";
}
function Jy(e) {
  if (xt(e))
    return e;
  if (I8(e))
    return e.condition;
}
function Hs(e) {
  if (or(e))
    return e;
  if (O4(e))
    return e.condition;
}
function W4e(e, t, n, r = {}) {
  if (kt(e) || pi(e) || Pw(e)) {
    const i = kt(e) ? "string" : pi(e) ? "number" : "boolean";
    return bt(V4t(t, i, e)), { value: e };
  }
  return or(e) ? yz(e, t, n, r) : O4(e) ? {
    ...e,
    // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
    condition: yz(e.condition, t, n, r)
  } : e;
}
function yz(e, t, n, r) {
  if (U4e(e)) {
    const { format: i, formatType: o, ...a } = e;
    if (VS(o) && !n.customFormatTypes)
      return bt(pye(t)), yz(a, t, n, r);
  } else {
    const i = HC(e) ? "axis" : B4e(e) ? "legend" : Kre(e) ? "header" : null;
    if (i && e[i]) {
      const { format: o, formatType: a, ...s } = e[i];
      if (VS(a) && !n.customFormatTypes)
        return bt(pye(t)), yz({ ...e, [i]: s }, t, n, r);
    }
  }
  return xt(e) ? tie(e, t, r) : VIt(e);
}
function VIt(e) {
  let t = e.type;
  if (t)
    return e;
  const { datum: n } = e;
  return t = pi(n) ? "quantitative" : kt(n) ? "nominal" : h2(n) ? "temporal" : void 0, { ...e, type: t };
}
function tie(e, t, { compositeMark: n = !1 } = {}) {
  const { aggregate: r, timeUnit: i, bin: o, field: a } = e, s = { ...e };
  if (!n && r && !Nre(r) && !Yw(r) && !pb(r) && (bt(q4t(r)), delete s.aggregate), i && (s.timeUnit = bu(i)), a && (s.field = `${a}`), Lo(o) && (s.bin = j8(o, t)), Qu(o) && !is(t) && bt(MPt(t)), Pc(s)) {
    const { type: u } = s, l = XPt(u);
    u !== l && (s.type = l), u !== "quantitative" && V$e(r) && (bt(W4t(u, r)), s.type = "quantitative");
  } else if (!z$e(t)) {
    const u = HIt(s, t);
    s.type = u;
  }
  if (Pc(s)) {
    const { compatible: u, warning: l } = WIt(s, t) || {};
    u === !1 && bt(l);
  }
  if (Zre(s) && kt(s.sort)) {
    const { sort: u } = s;
    if (xye(u))
      return {
        ...s,
        sort: { encoding: u }
      };
    const l = u.substr(1);
    if (u.charAt(0) === "-" && xye(l))
      return {
        ...s,
        sort: { encoding: l, order: "descending" }
      };
  }
  if (Kre(s)) {
    const { header: u } = s;
    if (u) {
      const { orient: l, ...f } = u;
      if (l)
        return {
          ...s,
          header: {
            ...f,
            labelOrient: u.labelOrient || l,
            titleOrient: u.titleOrient || l
          }
        };
    }
  }
  return s;
}
function j8(e, t) {
  return Pw(e) ? { maxbins: oye(t) } : e === "binned" ? {
    binned: !0
  } : !e.maxbins && !e.step ? { ...e, maxbins: oye(t) } : e;
}
const KM = { compatible: !0 };
function WIt(e, t) {
  const n = e.type;
  if (n === "geojson" && t !== "shape")
    return {
      compatible: !1,
      warning: `Channel ${t} should not be used with a geojson data.`
    };
  switch (t) {
    case tb:
    case nb:
    case b8:
      return gz(e) ? KM : {
        compatible: !1,
        warning: K4t(t)
      };
    case aa:
    case _u:
    case Lw:
    case LN:
    case Pf:
    case hv:
    case pv:
    case S4:
    case M4:
    case x8:
    case US:
    case w8:
    case _8:
    case c2:
    case Tp:
    case om:
    case E8:
      return KM;
    case sm:
    case Ep:
    case am:
    case um:
      return n !== HS ? {
        compatible: !1,
        warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
      } : KM;
    case Ab:
    case zw:
    case Fw:
    case Bw:
    case Db:
    case Nb:
    case Cb:
    case im:
    case dv:
      return n === "nominal" && !e.sort ? {
        compatible: !1,
        warning: `Channel ${t} should not be used with an unsorted discrete field.`
      } : KM;
    case If:
    case Uw:
      return !gz(e) && !zIt(e) ? {
        compatible: !1,
        warning: Z4t(t)
      } : KM;
    case zC:
      return e.type === "nominal" && !("sort" in e) ? {
        compatible: !1,
        warning: "Channel order is inappropriate for nominal field, which has no inherent order."
      } : KM;
  }
}
function VC(e) {
  const { formatType: t } = mz(e);
  return t === "time" || !t && qIt(e);
}
function qIt(e) {
  return e && (e.type === "temporal" || xt(e) && !!e.timeUnit);
}
function L8(e, { timeUnit: t, type: n, wrapTime: r, undefinedIfExprNotRequired: i }) {
  var u;
  const o = t && ((u = bu(t)) == null ? void 0 : u.unit);
  let a = o || n === "temporal", s;
  return C4(e) ? s = e.expr : an(e) ? s = e.signal : h2(e) ? (a = !0, s = YS(e)) : (kt(e) || pi(e)) && a && (s = `datetime(${mo(e)})`, jPt(o) && (pi(e) && e < 1e4 || kt(e) && isNaN(Date.parse(e))) && (s = YS({ [o]: e }))), s ? r && a ? `time(${s})` : s : i ? void 0 : mo(e);
}
function q4e(e, t) {
  const { type: n } = e;
  return t.map((r) => {
    const i = xt(e) && !p2(e.timeUnit) ? e.timeUnit : void 0, o = L8(r, {
      timeUnit: i,
      type: n,
      undefinedIfExprNotRequired: !0
    });
    return o !== void 0 ? { signal: o } : r;
  });
}
function R4(e, t) {
  return Lo(e.bin) ? Ob(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
}
const Eye = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  // There is no fixed vgProp for tickSize, need to use signal.
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  // There is no fixed vgProp for tickSize, need to use signal.
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function k4(e) {
  return e == null ? void 0 : e.condition;
}
const G4e = ["domain", "grid", "labels", "ticks", "title"], GIt = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  // Need to be applied to grid axis too, so the grid will align with ticks.
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  // Need to be applied to grid axis too, so the grid will align with ticks.
  tickOpacity: "main",
  tickRound: "both",
  // Apply rounding to grid and ticks so they are aligned.
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  // we hide this in Vega-Lite
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
  // this is actually set afterward, so it doesn't matter
}, Q4e = {
  orient: 1,
  // other things can depend on orient
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
}, QIt = {
  ...Q4e,
  style: 1,
  labelExpr: 1,
  encoding: 1
};
function Sye(e) {
  return !!QIt[e];
}
const XIt = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
}, X4e = yt(XIt);
function Rb(e) {
  return "mark" in e;
}
class z8 {
  constructor(t, n) {
    this.name = t, this.run = n;
  }
  hasMatchingType(t) {
    return Rb(t) ? RIt(t.mark) === this.name : !1;
  }
}
function uS(e, t) {
  const n = e && e[t];
  return n ? nt(n) ? FS(n, (r) => !!r.field) : xt(n) || I8(n) : !1;
}
function K4e(e, t) {
  const n = e && e[t];
  return n ? nt(n) ? FS(n, (r) => !!r.field) : xt(n) || yv(n) || O4(n) : !1;
}
function Z4e(e, t) {
  if (is(t)) {
    const n = e[t];
    if ((xt(n) || yv(n)) && (b4e(n.type) || xt(n) && n.timeUnit)) {
      const r = Sre(t);
      return K4e(e, r);
    }
  }
  return !1;
}
function nie(e) {
  return FS(K$t, (t) => {
    if (uS(e, t)) {
      const n = e[t];
      if (nt(n))
        return FS(n, (r) => !!r.aggregate);
      {
        const r = Jy(n);
        return r && !!r.aggregate;
      }
    }
    return !1;
  });
}
function J4e(e, t) {
  const n = [], r = [], i = [], o = [], a = {};
  return rie(e, (s, u) => {
    if (xt(s)) {
      const { field: l, aggregate: f, bin: h, timeUnit: p, ...g } = s;
      if (f || p || h) {
        const y = Jre(s), b = y == null ? void 0 : y.title;
        let _ = Mt(s, { forAs: !0 });
        const S = {
          // Only add title if it doesn't exist
          ...b ? [] : { title: zT(s, t, { allowDisabling: !0 }) },
          ...g,
          // Always overwrite field
          field: _
        };
        if (f) {
          let C;
          if (Yw(f) ? (C = "argmax", _ = Mt({ op: "argmax", field: f.argmax }, { forAs: !0 }), S.field = `${_}.${l}`) : pb(f) ? (C = "argmin", _ = Mt({ op: "argmin", field: f.argmin }, { forAs: !0 }), S.field = `${_}.${l}`) : f !== "boxplot" && f !== "errorbar" && f !== "errorband" && (C = f), C) {
            const A = {
              op: C,
              as: _
            };
            l && (A.field = l), o.push(A);
          }
        } else if (n.push(_), Pc(s) && Lo(h)) {
          if (r.push({ bin: h, field: l, as: _ }), n.push(Mt(s, { binSuffix: "end" })), R4(s, u) && n.push(Mt(s, { binSuffix: "range" })), is(u)) {
            const C = {
              field: `${_}_end`
            };
            a[`${u}2`] = C;
          }
          S.bin = "binned", z$e(u) || (S.type = HS);
        } else if (p && !p2(p)) {
          i.push({
            timeUnit: p,
            field: l,
            as: _
          });
          const C = Pc(s) && s.type !== BC && "time";
          C && (u === S4 || u === US ? S.formatType = C : s4t(u) ? S.legend = {
            formatType: C,
            ...S.legend
          } : is(u) && (S.axis = {
            formatType: C,
            ...S.axis
          }));
        }
        a[u] = S;
      } else
        n.push(l), a[u] = e[u];
    } else
      a[u] = e[u];
  }), {
    bins: r,
    timeUnits: i,
    aggregate: o,
    groupby: n,
    encoding: a
  };
}
function KIt(e, t, n) {
  const r = l4t(t, n);
  if (r) {
    if (r === "binned") {
      const i = e[t === im ? aa : _u];
      return !!(xt(i) && xt(e[t]) && Qu(i.bin));
    }
  } else
    return !1;
  return !0;
}
function ZIt(e, t, n, r) {
  const i = {};
  for (const o of yt(e))
    L$e(o) || bt(X4t(o));
  for (let o of r4t) {
    if (!e[o])
      continue;
    const a = e[o];
    if (T4(o)) {
      const s = n4t(o), u = i[s];
      if (xt(u) && QPt(u.type) && xt(a) && !u.timeUnit) {
        bt(H4t(s));
        continue;
      }
    }
    if (o === "angle" && t === "arc" && !e.theta && (bt(Y4t), o = Tp), !KIt(e, o, t)) {
      bt(C8(o, t));
      continue;
    }
    if (o === Db && t === "line") {
      const s = Jy(e[o]);
      if (s != null && s.aggregate) {
        bt(Q4t);
        continue;
      }
    }
    if (o === Pf && (n ? "fill" in e : "stroke" in e)) {
      bt(r4e("encoding", { fill: "fill" in e, stroke: "stroke" in e }));
      continue;
    }
    if (o === M4 || o === zC && !nt(a) && !Qg(a) || o === US && nt(a)) {
      if (a) {
        if (o === zC) {
          const s = e[o];
          if (F4e(s)) {
            i[o] = s;
            continue;
          }
        }
        i[o] = Rt(a).reduce((s, u) => (xt(u) ? s.push(tie(u, o)) : bt(eX(u, o)), s), []);
      }
    } else {
      if (o === US && a === null)
        i[o] = null;
      else if (!xt(a) && !yv(a) && !Qg(a) && !P8(a) && !an(a)) {
        bt(eX(a, o));
        continue;
      }
      i[o] = W4e(a, o, r);
    }
  }
  return i;
}
function F8(e, t) {
  const n = {};
  for (const r of yt(e)) {
    const i = W4e(e[r], r, t, { compositeMark: !0 });
    n[r] = i;
  }
  return n;
}
function JIt(e) {
  const t = [];
  for (const n of yt(e))
    if (uS(e, n)) {
      const r = e[n], i = Rt(r);
      for (const o of i)
        xt(o) ? t.push(o) : I8(o) && t.push(o.condition);
    }
  return t;
}
function rie(e, t, n) {
  if (e)
    for (const r of yt(e)) {
      const i = e[r];
      if (nt(i))
        for (const o of i)
          t.call(n, o, r);
      else
        t.call(n, i, r);
    }
}
function e3t(e, t, n, r) {
  return e ? yt(e).reduce((i, o) => {
    const a = e[o];
    return nt(a) ? a.reduce((s, u) => t.call(r, s, u, o), i) : t.call(r, i, a, o);
  }, n) : n;
}
function ePe(e, t) {
  return yt(t).reduce((n, r) => {
    switch (r) {
      case aa:
      case _u:
      case w8:
      case E8:
      case _8:
      case im:
      case dv:
      case Lw:
      case LN:
      case Tp:
      case Nb:
      case om:
      case Cb:
      case am:
      case sm:
      case um:
      case Ep:
      case S4:
      case If:
      case c2:
      case US:
        return n;
      case zC:
        if (e === "line" || e === "trail")
          return n;
      case M4:
      case x8: {
        const i = t[r];
        if (nt(i) || xt(i))
          for (const o of Rt(i))
            o.aggregate || n.push(Mt(o, {}));
        return n;
      }
      case Db:
        if (e === "trail")
          return n;
      case Pf:
      case hv:
      case pv:
      case Ab:
      case zw:
      case Fw:
      case Uw:
      case Bw: {
        const i = Jy(t[r]);
        return i && !i.aggregate && n.push(Mt(i, {})), n;
      }
    }
  }, []);
}
function t3t(e) {
  const { tooltip: t, ...n } = e;
  if (!t)
    return { filteredEncoding: n };
  let r, i;
  if (nt(t)) {
    for (const o of t)
      o.aggregate ? (r || (r = []), r.push(o)) : (i || (i = []), i.push(o));
    r && (n.tooltip = r);
  } else
    t.aggregate ? n.tooltip = t : i = t;
  return nt(i) && i.length === 1 && (i = i[0]), { customTooltipWithoutAggregatedField: i, filteredEncoding: n };
}
function iX(e, t, n, r = !0) {
  if ("tooltip" in n)
    return { tooltip: n.tooltip };
  const i = e.map(({ fieldPrefix: a, titlePrefix: s }) => {
    const u = r ? ` of ${iie(t)}` : "";
    return {
      field: a + t.field,
      type: t.type,
      title: an(s) ? { signal: `${s}"${escape(u)}"` } : s + u
    };
  }), o = JIt(n).map(jIt);
  return {
    tooltip: [
      ...i,
      // need to cast because TextFieldDef supports fewer types of bin
      ...$y(o, Xr)
    ]
  };
}
function iie(e) {
  const { title: t, field: n } = e;
  return rs(t, n);
}
function oie(e, t, n, r, i) {
  const { scale: o, axis: a } = n;
  return ({ partName: s, mark: u, positionPrefix: l, endPositionPrefix: f = void 0, extraEncoding: h = {} }) => {
    const p = iie(n);
    return tPe(e, s, i, {
      mark: u,
      // TODO better remove this method and just have mark as a parameter of the method
      encoding: {
        [t]: {
          field: `${l}_${n.field}`,
          type: n.type,
          ...p !== void 0 ? { title: p } : {},
          ...o !== void 0 ? { scale: o } : {},
          ...a !== void 0 ? { axis: a } : {}
        },
        ...kt(f) ? {
          [`${t}2`]: {
            field: `${f}_${n.field}`
          }
        } : {},
        ...r,
        ...h
      }
    });
  };
}
function tPe(e, t, n, r) {
  const { clip: i, color: o, opacity: a } = e, s = e.type;
  return e[t] || e[t] === void 0 && n[t] ? [
    {
      ...r,
      mark: {
        ...n[t],
        ...i ? { clip: i } : {},
        ...o ? { color: o } : {},
        ...a ? { opacity: a } : {},
        ...Zy(r.mark) ? r.mark : { type: r.mark },
        style: `${s}-${String(t)}`,
        ...Pw(e[t]) ? {} : e[t]
      }
    }
  ] : [];
}
function nPe(e, t, n) {
  const { encoding: r } = e, i = t === "vertical" ? "y" : "x", o = r[i], a = r[`${i}2`], s = r[`${i}Error`], u = r[`${i}Error2`];
  return {
    continuousAxisChannelDef: P3(o, n),
    continuousAxisChannelDef2: P3(a, n),
    continuousAxisChannelDefError: P3(s, n),
    continuousAxisChannelDefError2: P3(u, n),
    continuousAxis: i
  };
}
function P3(e, t) {
  if (e != null && e.aggregate) {
    const { aggregate: n, ...r } = e;
    return n !== t && bt(SPt(n, t)), r;
  } else
    return e;
}
function rPe(e, t) {
  const { mark: n, encoding: r } = e, { x: i, y: o } = r;
  if (Zy(n) && n.orient)
    return n.orient;
  if (kx(i)) {
    if (kx(o)) {
      const a = xt(i) && i.aggregate, s = xt(o) && o.aggregate;
      if (!a && s === t)
        return "vertical";
      if (!s && a === t)
        return "horizontal";
      if (a === t && s === t)
        throw new Error("Both x and y cannot have aggregate");
      return VC(o) && !VC(i) ? "horizontal" : "vertical";
    }
    return "horizontal";
  } else {
    if (kx(o))
      return "vertical";
    throw new Error(`Need a valid continuous axis for ${t}s`);
  }
}
const vz = "boxplot", n3t = ["box", "median", "outliers", "rule", "ticks"], r3t = new z8(vz, oPe);
function iPe(e) {
  return pi(e) ? "tukey" : e;
}
function oPe(e, { config: t }) {
  e = {
    ...e,
    encoding: F8(e.encoding, t)
  };
  const { mark: n, encoding: r, params: i, projection: o, ...a } = e, s = Zy(n) ? n : { type: n };
  i && bt(t4e("boxplot"));
  const u = s.extent ?? t.boxplot.extent, l = Fi(
    "size",
    s,
    // TODO: https://github.com/vega/vega-lite/issues/6245
    t
  ), f = s.invalid, h = iPe(u), { bins: p, timeUnits: g, transform: y, continuousAxisChannelDef: b, continuousAxis: _, groupby: S, aggregate: C, encodingWithoutContinuousAxis: A, ticksOrient: O, boxOrient: R, customTooltipWithoutAggregatedField: j } = i3t(e, u, t), $ = jN(b.field), { color: z, size: W, ...Y } = A, V = (mn) => oie(s, _, b, mn, t.boxplot), ee = V(Y), K = V(A), Q = (Pt(t.boxplot.box) ? t.boxplot.box.color : t.mark.color) || "#4c78a8", q = V({
    ...Y,
    ...W ? { size: W } : {},
    color: {
      condition: {
        test: `datum['lower_box_${b.field}'] >= datum['upper_box_${b.field}']`,
        ...z || { value: Q }
      }
    }
  }), te = iX([
    { fieldPrefix: h === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: h === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], b, A), X = { type: "tick", color: "black", opacity: 1, orient: O, invalid: f, aria: !1 }, Z = h === "min-max" ? te : (
    // for tukey / k-IQR, just show upper/lower-whisker
    iX([
      { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
      { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
    ], b, A)
  ), se = [
    ...ee({
      partName: "rule",
      mark: { type: "rule", invalid: f, aria: !1 },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: Z
    }),
    ...ee({
      partName: "rule",
      mark: { type: "rule", invalid: f, aria: !1 },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: Z
    }),
    ...ee({
      partName: "ticks",
      mark: X,
      positionPrefix: "lower_whisker",
      extraEncoding: Z
    }),
    ...ee({
      partName: "ticks",
      mark: X,
      positionPrefix: "upper_whisker",
      extraEncoding: Z
    })
  ], H = [
    ...h !== "tukey" ? se : [],
    ...K({
      partName: "box",
      mark: {
        type: "bar",
        ...l ? { size: l } : {},
        orient: R,
        invalid: f,
        ariaRoleDescription: "box"
      },
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: te
    }),
    ...q({
      partName: "median",
      mark: {
        type: "tick",
        invalid: f,
        ...Pt(t.boxplot.median) && t.boxplot.median.color ? { color: t.boxplot.median.color } : {},
        ...l ? { size: l } : {},
        orient: O,
        aria: !1
      },
      positionPrefix: "mid_box",
      extraEncoding: te
    })
  ];
  if (h === "min-max")
    return {
      ...a,
      transform: (a.transform ?? []).concat(y),
      layer: H
    };
  const ie = `datum["lower_box_${b.field}"]`, he = `datum["upper_box_${b.field}"]`, ye = `(${he} - ${ie})`, _e = `${ie} - ${u} * ${ye}`, Ne = `${he} + ${u} * ${ye}`, Oe = `datum["${b.field}"]`, ke = {
    joinaggregate: aPe(b.field),
    groupby: S
  }, Me = {
    transform: [
      {
        filter: `(${_e} <= ${Oe}) && (${Oe} <= ${Ne})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: b.field,
            as: `lower_whisker_${$}`
          },
          {
            op: "max",
            field: b.field,
            as: `upper_whisker_${$}`
          },
          // preserve lower_box / upper_box
          {
            op: "min",
            field: `lower_box_${b.field}`,
            as: `lower_box_${$}`
          },
          {
            op: "max",
            field: `upper_box_${b.field}`,
            as: `upper_box_${$}`
          },
          ...C
        ],
        groupby: S
      }
    ],
    layer: se
  }, { tooltip: we, ...Ye } = Y, { scale: ze, axis: fe } = b, Qe = iie(b), $e = Ef(fe, ["title"]), pt = tPe(s, "outliers", t.boxplot, {
    transform: [{ filter: `(${Oe} < ${_e}) || (${Oe} > ${Ne})` }],
    mark: "point",
    encoding: {
      [_]: {
        field: b.field,
        type: b.type,
        ...Qe !== void 0 ? { title: Qe } : {},
        ...ze !== void 0 ? { scale: ze } : {},
        // add axis without title since we already added the title above
        ...go($e) ? {} : { axis: $e }
      },
      ...Ye,
      ...z ? { color: z } : {},
      ...j ? { tooltip: j } : {}
    }
  })[0];
  let _t;
  const Ot = [...p, ...g, ke];
  return pt ? _t = {
    transform: Ot,
    layer: [pt, Me]
  } : (_t = Me, _t.transform.unshift(...Ot)), {
    ...a,
    layer: [
      _t,
      {
        // boxplot
        transform: y,
        layer: H
      }
    ]
  };
}
function aPe(e) {
  const t = jN(e);
  return [
    {
      op: "q1",
      field: e,
      as: `lower_box_${t}`
    },
    {
      op: "q3",
      field: e,
      as: `upper_box_${t}`
    }
  ];
}
function i3t(e, t, n) {
  const r = rPe(e, vz), { continuousAxisChannelDef: i, continuousAxis: o } = nPe(e, r, vz), a = i.field, s = jN(a), u = iPe(t), l = [
    ...aPe(a),
    {
      op: "median",
      field: a,
      as: `mid_box_${s}`
    },
    {
      op: "min",
      field: a,
      as: (u === "min-max" ? "lower_whisker_" : "min_") + s
    },
    {
      op: "max",
      field: a,
      as: (u === "min-max" ? "upper_whisker_" : "max_") + s
    }
  ], f = u === "min-max" || u === "tukey" ? [] : [
    // This is for the  original k-IQR, which we do not expose
    {
      calculate: `datum["upper_box_${s}"] - datum["lower_box_${s}"]`,
      as: `iqr_${s}`
    },
    {
      calculate: `min(datum["upper_box_${s}"] + datum["iqr_${s}"] * ${t}, datum["max_${s}"])`,
      as: `upper_whisker_${s}`
    },
    {
      calculate: `max(datum["lower_box_${s}"] - datum["iqr_${s}"] * ${t}, datum["min_${s}"])`,
      as: `lower_whisker_${s}`
    }
  ], { [o]: h, ...p } = e.encoding, { customTooltipWithoutAggregatedField: g, filteredEncoding: y } = t3t(p), { bins: b, timeUnits: _, aggregate: S, groupby: C, encoding: A } = J4e(y, n), O = r === "vertical" ? "horizontal" : "vertical", R = r, j = [
    ...b,
    ..._,
    {
      aggregate: [...S, ...l],
      groupby: C
    },
    ...f
  ];
  return {
    bins: b,
    timeUnits: _,
    transform: j,
    groupby: C,
    aggregate: S,
    continuousAxisChannelDef: i,
    continuousAxis: o,
    encodingWithoutContinuousAxis: A,
    ticksOrient: O,
    boxOrient: R,
    customTooltipWithoutAggregatedField: g
  };
}
const aie = "errorbar", o3t = ["ticks", "rule"], a3t = new z8(aie, sPe);
function sPe(e, { config: t }) {
  e = {
    ...e,
    encoding: F8(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: r, continuousAxis: i, encodingWithoutContinuousAxis: o, ticksOrient: a, markDef: s, outerSpec: u, tooltipEncoding: l } = uPe(e, aie, t);
  delete o.size;
  const f = oie(s, i, r, o, t.errorbar), h = s.thickness, p = s.size, g = {
    type: "tick",
    orient: a,
    aria: !1,
    ...h !== void 0 ? { thickness: h } : {},
    ...p !== void 0 ? { size: p } : {}
  }, y = [
    ...f({
      partName: "ticks",
      mark: g,
      positionPrefix: "lower",
      extraEncoding: l
    }),
    ...f({
      partName: "ticks",
      mark: g,
      positionPrefix: "upper",
      extraEncoding: l
    }),
    ...f({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar",
        ...h !== void 0 ? { size: h } : {}
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: l
    })
  ];
  return {
    ...u,
    transform: n,
    ...y.length > 1 ? { layer: y } : { ...y[0] }
  };
}
function s3t(e, t) {
  const { encoding: n } = e;
  if (u3t(n))
    return {
      orient: rPe(e, t),
      inputType: "raw"
    };
  const r = l3t(n), i = c3t(n), o = n.x, a = n.y;
  if (r) {
    if (i)
      throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
    const s = n.x2, u = n.y2;
    if (or(s) && or(u))
      throw new Error(`${t} cannot have both x2 and y2`);
    if (or(s)) {
      if (kx(o))
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      throw new Error(`Both x and x2 have to be quantitative in ${t}`);
    } else if (or(u)) {
      if (kx(a))
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      throw new Error(`Both y and y2 have to be quantitative in ${t}`);
    }
    throw new Error("No ranged axis");
  } else {
    const s = n.xError, u = n.xError2, l = n.yError, f = n.yError2;
    if (or(u) && !or(s))
      throw new Error(`${t} cannot have xError2 without xError`);
    if (or(f) && !or(l))
      throw new Error(`${t} cannot have yError2 without yError`);
    if (or(s) && or(l))
      throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
    if (or(s)) {
      if (kx(o))
        return { orient: "horizontal", inputType: "aggregated-error" };
      throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
    } else if (or(l)) {
      if (kx(a))
        return { orient: "vertical", inputType: "aggregated-error" };
      throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
    }
    throw new Error("No ranged axis");
  }
}
function u3t(e) {
  return (or(e.x) || or(e.y)) && !or(e.x2) && !or(e.y2) && !or(e.xError) && !or(e.xError2) && !or(e.yError) && !or(e.yError2);
}
function l3t(e) {
  return or(e.x2) || or(e.y2);
}
function c3t(e) {
  return or(e.xError) || or(e.xError2) || or(e.yError) || or(e.yError2);
}
function uPe(e, t, n) {
  const { mark: r, encoding: i, params: o, projection: a, ...s } = e, u = Zy(r) ? r : { type: r };
  o && bt(t4e(t));
  const { orient: l, inputType: f } = s3t(e, t), { continuousAxisChannelDef: h, continuousAxisChannelDef2: p, continuousAxisChannelDefError: g, continuousAxisChannelDefError2: y, continuousAxis: b } = nPe(e, l, t), { errorBarSpecificAggregate: _, postAggregateCalculates: S, tooltipSummary: C, tooltipTitleWithFieldName: A } = f3t(u, h, p, g, y, f, t, n), { [b]: O, [b === "x" ? "x2" : "y2"]: R, [b === "x" ? "xError" : "yError"]: j, [b === "x" ? "xError2" : "yError2"]: $, ...z } = i, { bins: W, timeUnits: Y, aggregate: V, groupby: ee, encoding: K } = J4e(z, n), Q = [...V, ..._], q = f !== "raw" ? [] : ee, te = iX(C, h, K, A);
  return {
    transform: [
      ...s.transform ?? [],
      ...W,
      ...Y,
      ...Q.length === 0 ? [] : [{ aggregate: Q, groupby: q }],
      ...S
    ],
    groupby: q,
    continuousAxisChannelDef: h,
    continuousAxis: b,
    encodingWithoutContinuousAxis: K,
    ticksOrient: l === "vertical" ? "horizontal" : "vertical",
    markDef: u,
    outerSpec: s,
    tooltipEncoding: te
  };
}
function f3t(e, t, n, r, i, o, a, s) {
  let u = [], l = [];
  const f = t.field;
  let h, p = !1;
  if (o === "raw") {
    const g = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : s.errorbar.center, y = e.extent ? e.extent : g === "mean" ? "stderr" : "iqr";
    if (g === "median" != (y === "iqr") && bt(EPt(g, y, a)), y === "stderr" || y === "stdev")
      u = [
        { op: y, field: f, as: `extent_${f}` },
        { op: g, field: f, as: `center_${f}` }
      ], l = [
        {
          calculate: `datum["center_${f}"] + datum["extent_${f}"]`,
          as: `upper_${f}`
        },
        {
          calculate: `datum["center_${f}"] - datum["extent_${f}"]`,
          as: `lower_${f}`
        }
      ], h = [
        { fieldPrefix: "center_", titlePrefix: E4(g) },
        { fieldPrefix: "upper_", titlePrefix: Mye(g, y, "+") },
        { fieldPrefix: "lower_", titlePrefix: Mye(g, y, "-") }
      ], p = !0;
    else {
      let b, _, S;
      y === "ci" ? (b = "mean", _ = "ci0", S = "ci1") : (b = "median", _ = "q1", S = "q3"), u = [
        { op: _, field: f, as: `lower_${f}` },
        { op: S, field: f, as: `upper_${f}` },
        { op: b, field: f, as: `center_${f}` }
      ], h = [
        {
          fieldPrefix: "upper_",
          titlePrefix: zT({ field: f, aggregate: S, type: "quantitative" }, s, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: zT({ field: f, aggregate: _, type: "quantitative" }, s, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: zT({ field: f, aggregate: b, type: "quantitative" }, s, {
            allowDisabling: !1
          })
        }
      ];
    }
  } else {
    (e.center || e.extent) && bt(_Pt(e.center, e.extent)), o === "aggregated-upper-lower" ? (h = [], l = [
      { calculate: `datum["${n.field}"]`, as: `upper_${f}` },
      { calculate: `datum["${f}"]`, as: `lower_${f}` }
    ]) : o === "aggregated-error" && (h = [{ fieldPrefix: "", titlePrefix: f }], l = [
      {
        calculate: `datum["${f}"] + datum["${r.field}"]`,
        as: `upper_${f}`
      }
    ], i ? l.push({
      calculate: `datum["${f}"] + datum["${i.field}"]`,
      as: `lower_${f}`
    }) : l.push({
      calculate: `datum["${f}"] - datum["${r.field}"]`,
      as: `lower_${f}`
    }));
    for (const g of l)
      h.push({
        fieldPrefix: g.as.substring(0, 6),
        titlePrefix: BS(BS(g.calculate, 'datum["', ""), '"]', "")
      });
  }
  return { postAggregateCalculates: l, errorBarSpecificAggregate: u, tooltipSummary: h, tooltipTitleWithFieldName: p };
}
function Mye(e, t, n) {
  return `${E4(e)} ${n} ${t}`;
}
const sie = "errorband", d3t = ["band", "borders"], h3t = new z8(sie, lPe);
function lPe(e, { config: t }) {
  e = {
    ...e,
    encoding: F8(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: r, continuousAxis: i, encodingWithoutContinuousAxis: o, markDef: a, outerSpec: s, tooltipEncoding: u } = uPe(e, sie, t), l = a, f = oie(l, i, r, o, t.errorband), h = e.encoding.x !== void 0 && e.encoding.y !== void 0;
  let p = { type: h ? "area" : "rect" }, g = { type: h ? "line" : "rule" };
  const y = {
    ...l.interpolate ? { interpolate: l.interpolate } : {},
    ...l.tension && l.interpolate ? { tension: l.tension } : {}
  };
  return h ? (p = {
    ...p,
    ...y,
    ariaRoleDescription: "errorband"
  }, g = {
    ...g,
    ...y,
    aria: !1
  }) : l.interpolate ? bt(mye("interpolate")) : l.tension && bt(mye("tension")), {
    ...s,
    transform: n,
    layer: [
      ...f({
        partName: "band",
        mark: p,
        positionPrefix: "lower",
        endPositionPrefix: "upper",
        extraEncoding: u
      }),
      ...f({
        partName: "borders",
        mark: g,
        positionPrefix: "lower",
        extraEncoding: u
      }),
      ...f({
        partName: "borders",
        mark: g,
        positionPrefix: "upper",
        extraEncoding: u
      })
    ]
  };
}
const cPe = {};
function uie(e, t, n) {
  const r = new z8(e, t);
  cPe[e] = { normalizer: r, parts: n };
}
function p3t() {
  return yt(cPe);
}
uie(vz, oPe, n3t);
uie(aie, sPe, o3t);
uie(sie, lPe, d3t);
const g3t = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
], fPe = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
}, dPe = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
}, m3t = yt(fPe), y3t = yt(dPe), v3t = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
}, hPe = yt(v3t), pPe = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
], b3t = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  // This is Vega's minimum.
  unselectedOpacity: 0.35
}, x3t = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
}, Xg = "_vgsid_", w3t = {
  point: {
    on: "click",
    fields: [Xg],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[pointerdown, window:pointerup] > window:pointermove!",
    encodings: ["x", "y"],
    translate: "[pointerdown, window:pointerup] > window:pointermove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function lie(e) {
  return e === "legend" || !!(e != null && e.legend);
}
function AV(e) {
  return lie(e) && Pt(e);
}
function cie(e) {
  return !!(e != null && e.select);
}
function gPe(e) {
  const t = [];
  for (const n of e || []) {
    if (cie(n))
      continue;
    const { expr: r, bind: i, ...o } = n;
    if (i && r) {
      const a = {
        ...o,
        bind: i,
        init: r
      };
      t.push(a);
    } else {
      const a = {
        ...o,
        ...r ? { update: r } : {},
        ...i ? { bind: i } : {}
      };
      t.push(a);
    }
  }
  return t;
}
function _3t(e) {
  return B8(e) || die(e) || fie(e);
}
function fie(e) {
  return "concat" in e;
}
function B8(e) {
  return "vconcat" in e;
}
function die(e) {
  return "hconcat" in e;
}
function mPe({ step: e, offsetIsDiscrete: t }) {
  return t ? e.for ?? "offset" : "position";
}
function ev(e) {
  return Pt(e) && e.step !== void 0;
}
function Tye(e) {
  return e.view || e.width || e.height;
}
const Cye = 20, E3t = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
}, S3t = yt(E3t);
function M3t(e, t, n) {
  const r = n[t], i = {}, { spacing: o, columns: a } = r;
  o !== void 0 && (i.spacing = o), a !== void 0 && ($8(e) && !A4(e.facet) || fie(e)) && (i.columns = a), B8(e) && (i.columns = 1);
  for (const s of S3t)
    if (e[s] !== void 0)
      if (s === "spacing") {
        const u = e[s];
        i[s] = pi(u) ? u : {
          row: u.row ?? o,
          column: u.column ?? o
        };
      } else
        i[s] = e[s];
  return i;
}
function oX(e, t) {
  return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"];
}
function bz(e, t) {
  const n = xz(e, t);
  return ev(n) ? n.step : yPe;
}
function xz(e, t) {
  const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
  return rs(n, { step: e.step });
}
const yPe = 20, T3t = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: yPe
}, C3t = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: T3t,
  mark: TIt,
  arc: {},
  area: {},
  bar: DIt,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: AIt,
  rule: { color: "black" },
  // Need this to override default color in mark config
  square: {},
  text: { color: "black" },
  // Need this to override default color in mark config
  tick: OIt,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: !0,
    ticks: !1
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: !1
  },
  scale: tIt,
  projection: {},
  legend: b3t,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: w3t,
  style: {},
  title: {},
  facet: { spacing: Cye },
  concat: { spacing: Cye },
  normalizedNumberFormat: ".0%"
}, $0 = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
], Nye = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
}, Dye = {
  blue: $0[0],
  orange: $0[1],
  red: $0[2],
  teal: $0[3],
  green: $0[4],
  yellow: $0[5],
  purple: $0[6],
  pink: $0[7],
  brown: $0[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function N3t(e = {}) {
  return {
    signals: [
      {
        name: "color",
        value: Pt(e) ? { ...Dye, ...e } : Dye
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function D3t(e) {
  return {
    signals: [
      {
        name: "fontSize",
        value: Pt(e) ? { ...Nye, ...e } : Nye
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function A3t(e) {
  return {
    text: { font: e },
    style: {
      "guide-label": { font: e },
      "guide-title": { font: e },
      "group-title": { font: e },
      "group-subtitle": { font: e }
    }
  };
}
function vPe(e) {
  const t = yt(e || {}), n = {};
  for (const r of t) {
    const i = e[r];
    n[r] = k4(i) ? G$e(i) : Sd(i);
  }
  return n;
}
function O3t(e) {
  const t = yt(e), n = {};
  for (const r of t)
    n[r] = vPe(e[r]);
  return n;
}
const R3t = [
  ...$4e,
  ...X4e,
  ...hPe,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function bPe(e = {}) {
  const { color: t, font: n, fontSize: r, selection: i, ...o } = e, a = MN({}, Kn(C3t), n ? A3t(n) : {}, t ? N3t(t) : {}, r ? D3t(r) : {}, o || {});
  i && TN(a, "selection", i, !0);
  const s = Ef(a, R3t);
  for (const u of ["background", "lineBreak", "padding"])
    a[u] && (s[u] = Sd(a[u]));
  for (const u of $4e)
    a[u] && (s[u] = yf(a[u]));
  for (const u of X4e)
    a[u] && (s[u] = vPe(a[u]));
  for (const u of hPe)
    a[u] && (s[u] = yf(a[u]));
  return a.legend && (s.legend = yf(a.legend)), a.scale && (s.scale = yf(a.scale)), a.style && (s.style = O3t(a.style)), a.title && (s.title = yf(a.title)), a.view && (s.view = yf(a.view)), s;
}
const k3t = /* @__PURE__ */ new Set(["view", ...xIt]), $3t = [
  "color",
  "fontSize",
  "background",
  // We apply background to the spec directly.
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
  // FIXME: Redesign and unhide this
], P3t = {
  view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
  ...MIt
};
function I3t(e) {
  e = Kn(e);
  for (const t of $3t)
    delete e[t];
  if (e.axis)
    for (const t in e.axis)
      k4(e.axis[t]) && delete e.axis[t];
  if (e.legend)
    for (const t of g3t)
      delete e.legend[t];
  if (e.mark) {
    for (const t of bye)
      delete e.mark[t];
    e.mark.tooltip && Pt(e.mark.tooltip) && delete e.mark.tooltip;
  }
  e.params && (e.signals = (e.signals || []).concat(gPe(e.params)), delete e.params);
  for (const t of k3t) {
    for (const r of bye)
      delete e[t][r];
    const n = P3t[t];
    if (n)
      for (const r of n)
        delete e[t][r];
    L3t(e, t);
  }
  for (const t of p3t())
    delete e[t];
  j3t(e);
  for (const t in e)
    Pt(e[t]) && go(e[t]) && delete e[t];
  return go(e) ? void 0 : e;
}
function j3t(e) {
  const { titleMarkConfig: t, subtitleMarkConfig: n, subtitle: r } = q$e(e.title);
  go(t) || (e.style["group-title"] = {
    ...e.style["group-title"],
    ...t
    // config.title has higher precedence than config.style.group-title in Vega
  }), go(n) || (e.style["group-subtitle"] = {
    ...e.style["group-subtitle"],
    ...n
  }), go(r) ? delete e.title : e.title = r;
}
function L3t(e, t, n, r) {
  const i = r ? e[t][r] : e[t];
  t === "view" && (n = "cell");
  const o = {
    ...i,
    ...e.style[n ?? t]
  };
  go(o) || (e.style[n ?? t] = o), r || delete e[t];
}
function U8(e) {
  return "layer" in e;
}
function z3t(e) {
  return "repeat" in e;
}
function F3t(e) {
  return !nt(e.repeat) && e.repeat.layer;
}
class hie {
  map(t, n) {
    return $8(t) ? this.mapFacet(t, n) : z3t(t) ? this.mapRepeat(t, n) : die(t) ? this.mapHConcat(t, n) : B8(t) ? this.mapVConcat(t, n) : fie(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (U8(t))
      return this.mapLayer(t, n);
    if (Rb(t))
      return this.mapUnit(t, n);
    throw new Error(Dre(t));
  }
  mapLayer(t, n) {
    return {
      ...t,
      layer: t.layer.map((r) => this.mapLayerOrUnit(r, n))
    };
  }
  mapHConcat(t, n) {
    return {
      ...t,
      hconcat: t.hconcat.map((r) => this.map(r, n))
    };
  }
  mapVConcat(t, n) {
    return {
      ...t,
      vconcat: t.vconcat.map((r) => this.map(r, n))
    };
  }
  mapConcat(t, n) {
    const { concat: r, ...i } = t;
    return {
      ...i,
      concat: r.map((o) => this.map(o, n))
    };
  }
  mapFacet(t, n) {
    return {
      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef
      ...t,
      // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
      spec: this.map(t.spec, n)
    };
  }
  mapRepeat(t, n) {
    return {
      ...t,
      // as any is required here since TS cannot infer that the output type satisfies the input type
      spec: this.map(t.spec, n)
    };
  }
}
const B3t = {
  zero: 1,
  center: 1,
  normalize: 1
};
function U3t(e) {
  return e in B3t;
}
const Y3t = /* @__PURE__ */ new Set([O4e, A8, D8, hz, R8, Qre, Xre, O8, R4e, Gre]), H3t = /* @__PURE__ */ new Set([A8, D8, O4e]);
function ZM(e) {
  return xt(e) && YC(e) === "quantitative" && !e.bin;
}
function Aye(e, t, { orient: n, type: r }) {
  const i = t === "x" ? "y" : "radius", o = t === "x" && ["bar", "area"].includes(r), a = e[t], s = e[i];
  if (xt(a) && xt(s))
    if (ZM(a) && ZM(s)) {
      if (a.stack)
        return t;
      if (s.stack)
        return i;
      const u = xt(a) && !!a.aggregate, l = xt(s) && !!s.aggregate;
      if (u !== l)
        return u ? t : i;
      if (o) {
        if (n === "vertical")
          return i;
        if (n === "horizontal")
          return t;
      }
    } else {
      if (ZM(a))
        return t;
      if (ZM(s))
        return i;
    }
  else {
    if (ZM(a))
      return o && n === "vertical" ? void 0 : t;
    if (ZM(s))
      return o && n === "horizontal" ? void 0 : i;
  }
}
function V3t(e) {
  switch (e) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function xPe(e, t) {
  var b, _;
  const n = Zy(e) ? e : { type: e }, r = n.type;
  if (!Y3t.has(r))
    return null;
  const i = Aye(t, "x", n) || Aye(t, "theta", n);
  if (!i)
    return null;
  const o = t[i], a = xt(o) ? Mt(o, {}) : void 0, s = V3t(i), u = [], l = /* @__PURE__ */ new Set();
  if (t[s]) {
    const S = t[s], C = xt(S) ? Mt(S, {}) : void 0;
    C && C !== a && (u.push(s), l.add(C));
  }
  const f = s === "x" ? "xOffset" : "yOffset", h = t[f], p = xt(h) ? Mt(h, {}) : void 0;
  p && p !== a && (u.push(f), l.add(p));
  const g = i4t.reduce((S, C) => {
    if (C !== "tooltip" && uS(t, C)) {
      const A = t[C];
      for (const O of Rt(A)) {
        const R = Jy(O);
        if (R.aggregate)
          continue;
        const j = Mt(R, {});
        // if fielddef is a repeat, just include it in the stack by
        (!j || // otherwise, the field must be different from the groupBy fields.
        !l.has(j)) && S.push({ channel: C, fieldDef: R });
      }
    }
    return S;
  }, []);
  let y;
  return o.stack !== void 0 ? Pw(o.stack) ? y = o.stack ? "zero" : null : y = o.stack : H3t.has(r) && (y = "zero"), !y || !U3t(y) || nie(t) && g.length === 0 ? null : ((b = o == null ? void 0 : o.scale) != null && b.type && ((_ = o == null ? void 0 : o.scale) == null ? void 0 : _.type) !== Sf.LINEAR && o != null && o.stack && bt(bPt(o.scale.type)), or(t[gv(i)]) ? (o.stack !== void 0 && bt(vPt(i)), null) : (xt(o) && o.aggregate && !m4t.has(o.aggregate) && bt(xPt(o.aggregate)), {
    groupbyChannels: u,
    groupbyFields: l,
    fieldChannel: i,
    impute: o.impute === null ? !1 : g2(r),
    stackBy: g,
    offset: y
  }));
}
function wPe(e, t, n) {
  const r = yf(e), i = Fi("orient", r, n);
  if (r.orient = Q3t(r.type, t, i), i !== void 0 && i !== r.orient && bt(nPt(r.orient, i)), r.type === "bar" && r.orient) {
    const u = Fi("cornerRadiusEnd", r, n);
    if (u !== void 0) {
      const l = r.orient === "horizontal" && t.x2 || r.orient === "vertical" && t.y2 ? ["cornerRadius"] : NIt[r.orient];
      for (const f of l)
        r[f] = u;
      r.cornerRadiusEnd !== void 0 && delete r.cornerRadiusEnd;
    }
  }
  const o = Fi("opacity", r, n), a = Fi("fillOpacity", r, n);
  return o === void 0 && a === void 0 && (r.opacity = q3t(r.type, t)), Fi("cursor", r, n) === void 0 && (r.cursor = W3t(r, t, n)), r;
}
function W3t(e, t, n) {
  return t.href || e.href || Fi("href", e, n) ? "pointer" : e.cursor;
}
function q3t(e, t) {
  if (Kr([R8, Gre, Qre, Xre], e) && !nie(t))
    return 0.7;
}
function G3t(e, t, { graticule: n }) {
  if (n)
    return !1;
  const r = gb("filled", e, t), i = e.type;
  return rs(r, i !== R8 && i !== O8 && i !== hz);
}
function Q3t(e, t, n) {
  switch (e) {
    case R8:
    case Qre:
    case Xre:
    case R4e:
    case vIt:
    case yIt:
      return;
  }
  const { x: r, y: i, x2: o, y2: a } = t;
  switch (e) {
    case A8:
      if (xt(r) && (Qu(r.bin) || xt(i) && i.aggregate && !r.aggregate))
        return "vertical";
      if (xt(i) && (Qu(i.bin) || xt(r) && r.aggregate && !i.aggregate))
        return "horizontal";
      if (a || o) {
        if (n)
          return n;
        if (!o)
          return (xt(r) && r.type === HS && !Lo(r.bin) || pz(r)) && xt(i) && Qu(i.bin) ? "horizontal" : "vertical";
        if (!a)
          return (xt(i) && i.type === HS && !Lo(i.bin) || pz(i)) && xt(r) && Qu(r.bin) ? "vertical" : "horizontal";
      }
    case hz:
      if (o && !(xt(r) && Qu(r.bin)) && a && !(xt(i) && Qu(i.bin)))
        return;
    case D8:
      if (a)
        return xt(i) && Qu(i.bin) ? "horizontal" : "vertical";
      if (o)
        return xt(r) && Qu(r.bin) ? "vertical" : "horizontal";
      if (e === hz) {
        if (r && !i)
          return "vertical";
        if (i && !r)
          return "horizontal";
      }
    case O8:
    case Gre: {
      const s = _ye(r), u = _ye(i);
      if (n)
        return n;
      if (s && !u)
        return e !== "tick" ? "horizontal" : "vertical";
      if (!s && u)
        return e !== "tick" ? "vertical" : "horizontal";
      if (s && u)
        return "vertical";
      {
        const l = Pc(r) && r.type === BC, f = Pc(i) && i.type === BC;
        if (l && !f)
          return "vertical";
        if (!l && f)
          return "horizontal";
      }
      return;
    }
  }
  return "vertical";
}
function X3t(e) {
  const { point: t, line: n, ...r } = e;
  return yt(r).length > 1 ? r : r.type;
}
function K3t(e) {
  for (const t of ["line", "area", "rule", "trail"])
    e[t] && (e = {
      ...e,
      // TODO: remove as any
      [t]: Ef(e[t], ["point", "line"])
    });
  return e;
}
function OV(e, t = {}, n) {
  return e.point === "transparent" ? { opacity: 0 } : e.point ? Pt(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? Pt(t.point) ? t.point : {} : void 0;
}
function Oye(e, t = {}) {
  return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0;
}
class Z3t {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(t, n) {
    if (Rb(t)) {
      const { mark: r, encoding: i } = t, o = Zy(r) ? r : { type: r };
      switch (o.type) {
        case "line":
        case "rule":
        case "trail":
          return !!OV(o, n[o.type], i);
        case "area":
          return (
            // false / null are also included as we want to remove the properties
            !!OV(o, n[o.type], i) || !!Oye(o, n[o.type])
          );
      }
    }
    return !1;
  }
  run(t, n, r) {
    const { config: i } = n, { params: o, projection: a, mark: s, name: u, encoding: l, ...f } = t, h = F8(l, i), p = Zy(s) ? s : { type: s }, g = OV(p, i[p.type], h), y = p.type === "area" && Oye(p, i[p.type]), b = [
      {
        name: u,
        ...o ? { params: o } : {},
        mark: X3t({
          // TODO: extract this 0.7 to be shared with default opacity for point/tick/...
          ...p.type === "area" && p.opacity === void 0 && p.fillOpacity === void 0 ? { opacity: 0.7 } : {},
          ...p
        }),
        // drop shape from encoding as this might be used to trigger point overlay
        encoding: Ef(h, ["shape"])
      }
    ], _ = xPe(wPe(p, h, i), h);
    let S = h;
    if (_) {
      const { fieldChannel: C, offset: A } = _;
      S = {
        ...h,
        [C]: {
          ...h[C],
          ...A ? { stack: A } : {}
        }
      };
    }
    return S = Ef(S, ["y2", "x2"]), y && b.push({
      ...a ? { projection: a } : {},
      mark: {
        type: "line",
        ...jC(p, ["clip", "interpolate", "tension", "tooltip"]),
        ...y
      },
      encoding: S
    }), g && b.push({
      ...a ? { projection: a } : {},
      mark: {
        type: "point",
        opacity: 1,
        filled: !0,
        ...jC(p, ["clip", "tooltip"]),
        ...g
      },
      encoding: S
    }), r({
      ...f,
      layer: b
    }, {
      ...n,
      config: K3t(i)
    });
  }
}
function J3t(e, t) {
  return t ? A4(e) ? EPe(e, t) : _Pe(e, t) : e;
}
function RV(e, t) {
  return t ? EPe(e, t) : e;
}
function aX(e, t, n) {
  const r = t[e];
  if (PIt(r)) {
    if (r.repeat in n)
      return { ...t, [e]: n[r.repeat] };
    bt(I4t(r.repeat));
    return;
  }
  return t;
}
function _Pe(e, t) {
  if (e = aX("field", e, t), e !== void 0) {
    if (e === null)
      return null;
    if (Zre(e) && Uy(e.sort)) {
      const n = aX("field", e.sort, t);
      e = {
        ...e,
        ...n ? { sort: n } : {}
      };
    }
    return e;
  }
}
function Rye(e, t) {
  if (xt(e))
    return _Pe(e, t);
  {
    const n = aX("datum", e, t);
    return n !== e && !n.type && (n.type = "nominal"), n;
  }
}
function kye(e, t) {
  if (or(e)) {
    const n = Rye(e, t);
    if (n)
      return n;
    if (P8(e))
      return { condition: e.condition };
  } else {
    if (O4(e)) {
      const n = Rye(e.condition, t);
      if (n)
        return {
          ...e,
          condition: n
        };
      {
        const { condition: r, ...i } = e;
        return i;
      }
    }
    return e;
  }
}
function EPe(e, t) {
  const n = {};
  for (const r in e)
    if (wn(e, r)) {
      const i = e[r];
      if (nt(i))
        n[r] = i.map((o) => kye(o, t)).filter((o) => o);
      else {
        const o = kye(i, t);
        o !== void 0 && (n[r] = o);
      }
    }
  return n;
}
class ejt {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(t) {
    if (Rb(t)) {
      const { encoding: n, mark: r } = t;
      if (r === "line" || Zy(r) && r.type === "line")
        for (const i of t4t) {
          const o = f2(i), a = n[o];
          if (n[i] && (xt(a) && !Qu(a.bin) || yv(a)))
            return !0;
        }
    }
    return !1;
  }
  run(t, n, r) {
    const { encoding: i, mark: o } = t;
    return bt(tPt(!!i.x2, !!i.y2)), r({
      ...t,
      mark: Pt(o) ? { ...o, type: "rule" } : "rule"
    }, n);
  }
}
class tjt extends hie {
  constructor() {
    super(...arguments), this.nonFacetUnitNormalizers = [
      r3t,
      a3t,
      h3t,
      new Z3t(),
      new ejt()
    ];
  }
  map(t, n) {
    if (Rb(t)) {
      const r = uS(t.encoding, tb), i = uS(t.encoding, nb), o = uS(t.encoding, b8);
      if (r || i || o)
        return this.mapFacetedUnit(t, n);
    }
    return super.map(t, n);
  }
  // This is for normalizing non-facet unit
  mapUnit(t, n) {
    const { parentEncoding: r, parentProjection: i } = n, o = RV(t.encoding, n.repeater), a = {
      ...t,
      ...t.name ? { name: [n.repeaterPrefix, t.name].filter((u) => u).join("_") } : {},
      ...o ? { encoding: o } : {}
    };
    if (r || i)
      return this.mapUnitWithParentEncodingOrProjection(a, n);
    const s = this.mapLayerOrUnit.bind(this);
    for (const u of this.nonFacetUnitNormalizers)
      if (u.hasMatchingType(a, n.config))
        return u.run(a, n, s);
    return a;
  }
  mapRepeat(t, n) {
    return F3t(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n);
  }
  mapLayerRepeat(t, n) {
    const { repeat: r, spec: i, ...o } = t, { row: a, column: s, layer: u } = r, { repeater: l = {}, repeaterPrefix: f = "" } = n;
    return a || s ? this.mapRepeat({
      ...t,
      repeat: {
        ...a ? { row: a } : {},
        ...s ? { column: s } : {}
      },
      spec: {
        repeat: { layer: u },
        spec: i
      }
    }, n) : {
      ...o,
      layer: u.map((h) => {
        const p = {
          ...l,
          layer: h
        }, g = `${(i.name ? `${i.name}_` : "") + f}child__layer_${oa(h)}`, y = this.mapLayerOrUnit(i, { ...n, repeater: p, repeaterPrefix: g });
        return y.name = g, y;
      })
    };
  }
  mapNonLayerRepeat(t, n) {
    const { repeat: r, spec: i, data: o, ...a } = t;
    !nt(r) && t.columns && (t = Ef(t, ["columns"]), bt(dye("repeat")));
    const s = [], { repeater: u = {}, repeaterPrefix: l = "" } = n, f = !nt(r) && r.row || [u ? u.row : null], h = !nt(r) && r.column || [u ? u.column : null], p = nt(r) && r || [u ? u.repeat : null];
    for (const y of p)
      for (const b of f)
        for (const _ of h) {
          const S = {
            repeat: y,
            row: b,
            column: _,
            layer: u.layer
          }, C = (i.name ? `${i.name}_` : "") + l + "child__" + (nt(r) ? `${oa(y)}` : (r.row ? `row_${oa(b)}` : "") + (r.column ? `column_${oa(_)}` : "")), A = this.map(i, { ...n, repeater: S, repeaterPrefix: C });
          A.name = C, s.push(Ef(A, ["data"]));
        }
    const g = nt(r) ? t.columns : r.column ? r.column.length : 1;
    return {
      data: i.data ?? o,
      // data from child spec should have precedence
      align: "all",
      ...a,
      columns: g,
      concat: s
    };
  }
  mapFacet(t, n) {
    const { facet: r } = t;
    return A4(r) && t.columns && (t = Ef(t, ["columns"]), bt(dye("facet"))), super.mapFacet(t, n);
  }
  mapUnitWithParentEncodingOrProjection(t, n) {
    const { encoding: r, projection: i } = t, { parentEncoding: o, parentProjection: a, config: s } = n, u = Pye({ parentProjection: a, projection: i }), l = $ye({
      parentEncoding: o,
      encoding: RV(r, n.repeater)
    });
    return this.mapUnit({
      ...t,
      ...u ? { projection: u } : {},
      ...l ? { encoding: l } : {}
    }, { config: s });
  }
  mapFacetedUnit(t, n) {
    const { row: r, column: i, facet: o, ...a } = t.encoding, { mark: s, width: u, projection: l, height: f, view: h, params: p, encoding: g, ...y } = t, { facetMapping: b, layout: _ } = this.getFacetMappingAndLayout({ row: r, column: i, facet: o }, n), S = RV(a, n.repeater);
    return this.mapFacet({
      ...y,
      ..._,
      // row / column has higher precedence than facet
      facet: b,
      spec: {
        ...u ? { width: u } : {},
        ...f ? { height: f } : {},
        ...h ? { view: h } : {},
        ...l ? { projection: l } : {},
        mark: s,
        encoding: S,
        ...p ? { params: p } : {}
      }
    }, n);
  }
  getFacetMappingAndLayout(t, n) {
    const { row: r, column: i, facet: o } = t;
    if (r || i) {
      o && bt(J4t([...r ? [tb] : [], ...i ? [nb] : []]));
      const a = {}, s = {};
      for (const u of [tb, nb]) {
        const l = t[u];
        if (l) {
          const { align: f, center: h, spacing: p, columns: g, ...y } = l;
          a[u] = y;
          for (const b of ["align", "center", "spacing"])
            l[b] !== void 0 && (s[b] ?? (s[b] = {}), s[b][u] = l[b]);
        }
      }
      return { facetMapping: a, layout: s };
    } else {
      const { align: a, center: s, spacing: u, columns: l, ...f } = o;
      return {
        facetMapping: J3t(f, n.repeater),
        layout: {
          ...a ? { align: a } : {},
          ...s ? { center: s } : {},
          ...u ? { spacing: u } : {},
          ...l ? { columns: l } : {}
        }
      };
    }
  }
  mapLayer(t, { parentEncoding: n, parentProjection: r, ...i }) {
    const { encoding: o, projection: a, ...s } = t, u = {
      ...i,
      parentEncoding: $ye({ parentEncoding: n, encoding: o, layer: !0 }),
      parentProjection: Pye({ parentProjection: r, projection: a })
    };
    return super.mapLayer({
      ...s,
      ...t.name ? { name: [u.repeaterPrefix, t.name].filter((l) => l).join("_") } : {}
    }, u);
  }
}
function $ye({ parentEncoding: e, encoding: t = {}, layer: n }) {
  let r = {};
  if (e) {
    const i = /* @__PURE__ */ new Set([...yt(e), ...yt(t)]);
    for (const o of i) {
      const a = t[o], s = e[o];
      if (or(a)) {
        const u = {
          ...s,
          ...a
        };
        r[o] = u;
      } else
        O4(a) ? r[o] = {
          ...a,
          condition: {
            ...s,
            ...a.condition
          }
        } : a || a === null ? r[o] = a : (n || Qg(s) || an(s) || or(s) || nt(s)) && (r[o] = s);
    }
  } else
    r = t;
  return !r || go(r) ? void 0 : r;
}
function Pye(e) {
  const { parentProjection: t, projection: n } = e;
  return t && n && bt(U4t({ parentProjection: t, projection: n })), n ?? t;
}
function pie(e) {
  return "filter" in e;
}
function njt(e) {
  return (e == null ? void 0 : e.stop) !== void 0;
}
function SPe(e) {
  return "lookup" in e;
}
function rjt(e) {
  return "data" in e;
}
function ijt(e) {
  return "param" in e;
}
function ojt(e) {
  return "pivot" in e;
}
function ajt(e) {
  return "density" in e;
}
function sjt(e) {
  return "quantile" in e;
}
function ujt(e) {
  return "regression" in e;
}
function ljt(e) {
  return "loess" in e;
}
function cjt(e) {
  return "sample" in e;
}
function fjt(e) {
  return "window" in e;
}
function djt(e) {
  return "joinaggregate" in e;
}
function hjt(e) {
  return "flatten" in e;
}
function pjt(e) {
  return "calculate" in e;
}
function MPe(e) {
  return "bin" in e;
}
function gjt(e) {
  return "impute" in e;
}
function mjt(e) {
  return "timeUnit" in e;
}
function yjt(e) {
  return "aggregate" in e;
}
function vjt(e) {
  return "stack" in e;
}
function bjt(e) {
  return "fold" in e;
}
function xjt(e) {
  return "extent" in e && !("density" in e) && !("regression" in e);
}
function wjt(e) {
  return e.map((t) => pie(t) ? {
    filter: jT(t.filter, GPt)
  } : t);
}
class _jt extends hie {
  map(t, n) {
    return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = Iye(t, n), super.map(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (t = Iye(t, n), t.encoding) {
      const r = {};
      for (const [i, o] of pw(t.encoding))
        r[i] = TPe(o, n);
      t = { ...t, encoding: r };
    }
    return super.mapLayerOrUnit(t, n);
  }
  mapUnit(t, n) {
    const { selection: r, ...i } = t;
    return r ? {
      ...i,
      params: pw(r).map(([o, a]) => {
        const { init: s, bind: u, empty: l, ...f } = a;
        f.type === "single" ? (f.type = "point", f.toggle = !1) : f.type === "multi" && (f.type = "point"), n.emptySelections[o] = l !== "none";
        for (const h of il(n.selectionPredicates[o] ?? {}))
          h.empty = l !== "none";
        return { name: o, value: s, select: f, bind: u };
      })
    } : t;
  }
}
function Iye(e, t) {
  const { transform: n, ...r } = e;
  if (n) {
    const i = n.map((o) => {
      if (pie(o))
        return { filter: sX(o, t) };
      if (MPe(o) && d2(o.bin))
        return {
          ...o,
          bin: CPe(o.bin)
        };
      if (SPe(o)) {
        const { selection: a, ...s } = o.from;
        return a ? {
          ...o,
          from: { param: a, ...s }
        } : o;
      }
      return o;
    });
    return { ...r, transform: i };
  }
  return e;
}
function TPe(e, t) {
  var r, i;
  const n = Kn(e);
  if (xt(n) && d2(n.bin) && (n.bin = CPe(n.bin)), m2(n) && ((i = (r = n.scale) == null ? void 0 : r.domain) != null && i.selection)) {
    const { selection: o, ...a } = n.scale.domain;
    n.scale.domain = { ...a, ...o ? { param: o } : {} };
  }
  if (P8(n))
    if (nt(n.condition))
      n.condition = n.condition.map((o) => {
        const { selection: a, param: s, test: u, ...l } = o;
        return s ? o : { ...l, test: sX(o, t) };
      });
    else {
      const { selection: o, param: a, test: s, ...u } = TPe(n.condition, t);
      n.condition = a ? n.condition : {
        ...u,
        test: sX(n.condition, t)
      };
    }
  return n;
}
function CPe(e) {
  const t = e.extent;
  if (t != null && t.selection) {
    const { selection: n, ...r } = t;
    return { ...e, extent: { ...r, param: n } };
  }
  return e;
}
function sX(e, t) {
  const n = (r) => jT(r, (i) => {
    var o;
    const a = t.emptySelections[i] ?? !0, s = { param: i, empty: a };
    return (o = t.selectionPredicates)[i] ?? (o[i] = []), t.selectionPredicates[i].push(s), s;
  });
  return e.selection ? n(e.selection) : jT(e.test || e.filter, (r) => r.selection ? n(r.selection) : r);
}
class uX extends hie {
  map(t, n) {
    const r = n.selections ?? [];
    if (t.params && !Rb(t)) {
      const i = [];
      for (const o of t.params)
        cie(o) ? r.push(o) : i.push(o);
      t.params = i;
    }
    return n.selections = r, super.map(t, n);
  }
  mapUnit(t, n) {
    const r = n.selections;
    if (!r || !r.length)
      return t;
    const i = (n.path ?? []).concat(t.name), o = [];
    for (const a of r)
      if (!a.views || !a.views.length)
        o.push(a);
      else
        for (const s of a.views)
          (kt(s) && (s === t.name || i.includes(s)) || nt(s) && // logic for backwards compatibility with view paths before we had unique names
          // @ts-ignore
          s.map((u) => i.indexOf(u)).every((u, l, f) => u !== -1 && (l === 0 || u > f[l - 1]))) && o.push(a);
    return o.length && (t.params = o), t;
  }
}
for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const t = uX.prototype[e];
  uX.prototype[e] = function(n, r) {
    return t.call(this, n, Ejt(n, r));
  };
}
function Ejt(e, t) {
  return e.name ? {
    ...t,
    path: (t.path ?? []).concat(e.name)
  } : t;
}
function NPe(e, t) {
  t === void 0 && (t = bPe(e.config));
  const n = Cjt(e, t), { width: r, height: i } = e, o = Njt(n, { width: r, height: i, autosize: e.autosize }, t);
  return {
    ...n,
    ...o ? { autosize: o } : {}
  };
}
const Sjt = new tjt(), Mjt = new _jt(), Tjt = new uX();
function Cjt(e, t = {}) {
  const n = { config: t };
  return Tjt.map(Sjt.map(Mjt.map(e, n), n), n);
}
function jye(e) {
  return kt(e) ? { type: e } : e ?? {};
}
function Njt(e, t, n) {
  let { width: r, height: i } = t;
  const o = Rb(e) || U8(e), a = {};
  o ? r == "container" && i == "container" ? (a.type = "fit", a.contains = "padding") : r == "container" ? (a.type = "fit-x", a.contains = "padding") : i == "container" && (a.type = "fit-y", a.contains = "padding") : (r == "container" && (bt(uye("width")), r = void 0), i == "container" && (bt(uye("height")), i = void 0));
  const s = {
    type: "pad",
    ...a,
    ...n ? jye(n.autosize) : {},
    ...jye(e.autosize)
  };
  if (s.type === "fit" && !o && (bt(M4t), s.type = "pad"), r == "container" && !(s.type == "fit" || s.type == "fit-x") && bt(lye("width")), i == "container" && !(s.type == "fit" || s.type == "fit-y") && bt(lye("height")), !Dd(s, { type: "pad" }))
    return s;
}
function Djt(e) {
  return e === "fit" || e === "fit-x" || e === "fit-y";
}
function Ajt(e) {
  return e ? `fit-${S8(e)}` : "fit";
}
const Ojt = [
  "background",
  "padding"
  // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
];
function Lye(e, t) {
  const n = {};
  for (const r of Ojt)
    e && e[r] !== void 0 && (n[r] = Sd(e[r]));
  return t && (n.params = e.params), n;
}
class kb {
  constructor(t = {}, n = {}) {
    this.explicit = t, this.implicit = n;
  }
  clone() {
    return new kb(Kn(this.explicit), Kn(this.implicit));
  }
  combine() {
    return {
      ...this.explicit,
      // Explicit properties comes first
      ...this.implicit
    };
  }
  get(t) {
    return rs(this.explicit[t], this.implicit[t]);
  }
  getWithExplicit(t) {
    return this.explicit[t] !== void 0 ? { explicit: !0, value: this.explicit[t] } : this.implicit[t] !== void 0 ? { explicit: !1, value: this.implicit[t] } : { explicit: !1, value: void 0 };
  }
  setWithExplicit(t, { value: n, explicit: r }) {
    n !== void 0 && this.set(t, n, r);
  }
  set(t, n, r) {
    return delete this[r ? "implicit" : "explicit"][t], this[r ? "explicit" : "implicit"][t] = n, this;
  }
  copyKeyFromSplit(t, { explicit: n, implicit: r }) {
    n[t] !== void 0 ? this.set(t, n[t], !0) : r[t] !== void 0 && this.set(t, r[t], !1);
  }
  copyKeyFromObject(t, n) {
    n[t] !== void 0 && this.set(t, n[t], !0);
  }
  /**
   * Merge split object into this split object. Properties from the other split
   * overwrite properties from this split.
   */
  copyAll(t) {
    for (const n of yt(t.combine())) {
      const r = t.getWithExplicit(n);
      this.setWithExplicit(n, r);
    }
  }
}
function wy(e) {
  return {
    explicit: !0,
    value: e
  };
}
function yd(e) {
  return {
    explicit: !1,
    value: e
  };
}
function DPe(e) {
  return (t, n, r, i) => {
    const o = e(t.value, n.value);
    return o > 0 ? t : o < 0 ? n : Y8(t, n, r, i);
  };
}
function Y8(e, t, n, r) {
  return e.explicit && t.explicit && bt(fPt(n, r, e.value, t.value)), e;
}
function yw(e, t, n, r, i = Y8) {
  return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Dd(e.value, t.value) ? e : i(e, t, n, r);
}
class Rjt extends kb {
  constructor(t = {}, n = {}, r = !1) {
    super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = r;
  }
  clone() {
    const t = super.clone();
    return t.parseNothing = this.parseNothing, t;
  }
}
function WC(e) {
  return "url" in e;
}
function l$(e) {
  return "values" in e;
}
function APe(e) {
  return "name" in e && !WC(e) && !l$(e) && !Yx(e);
}
function Yx(e) {
  return e && (OPe(e) || RPe(e) || gie(e));
}
function OPe(e) {
  return "sequence" in e;
}
function RPe(e) {
  return "sphere" in e;
}
function gie(e) {
  return "graticule" in e;
}
var ra;
(function(e) {
  e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup";
})(ra || (ra = {}));
function kPe(e) {
  const { signals: t, hasLegend: n, index: r, ...i } = e;
  return i.field = _p(i.field), i;
}
function qS(e, t = !0, n = ql) {
  if (nt(e)) {
    const r = e.map((i) => qS(i, t, n));
    return t ? `[${r.join(", ")}]` : r;
  } else if (h2(e))
    return n(t ? YS(e) : IPt(e));
  return t ? n(mo(e)) : e;
}
function kjt(e, t) {
  for (const n of il(e.component.selection ?? {})) {
    const r = n.name;
    let i = `${r}${bw}, ${n.resolve === "global" ? "true" : `{unit: ${lS(e)}}`}`;
    for (const o of q8)
      o.defined(n) && (o.signals && (t = o.signals(e, n, t)), o.modifyExpr && (i = o.modifyExpr(e, n, i)));
    t.push({
      name: r + fLt,
      on: [
        {
          events: { signal: n.name + bw },
          update: `modify(${Et(n.name + GS)}, ${i})`
        }
      ]
    });
  }
  return mie(t);
}
function $jt(e, t) {
  if (e.component.selection && yt(e.component.selection).length) {
    const n = Et(e.getName("cell"));
    t.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: jw("pointermove", "scope"),
          update: `isTuple(facet) ? facet : group(${n}).datum`
        }
      ]
    });
  }
  return mie(t);
}
function Pjt(e, t) {
  let n = !1;
  for (const r of il(e.component.selection ?? {})) {
    const i = r.name, o = Et(i + GS);
    if (t.filter((s) => s.name === i).length === 0) {
      const s = r.resolve === "global" ? "union" : r.resolve, u = r.type === "point" ? ", true, true)" : ")";
      t.push({
        name: r.name,
        update: `${KPe}(${o}, ${Et(s)}${u}`
      });
    }
    n = !0;
    for (const s of q8)
      s.defined(r) && s.topLevelSignals && (t = s.topLevelSignals(e, r, t));
  }
  return n && t.filter((i) => i.name === "unit").length === 0 && t.unshift({
    name: "unit",
    value: {},
    on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }]
  }), mie(t);
}
function Ijt(e, t) {
  const n = [...t], r = lS(e, { escape: !1 });
  for (const i of il(e.component.selection ?? {})) {
    const o = { name: i.name + GS };
    if (i.project.hasSelectionId && (o.transform = [{ type: "collect", sort: { field: Xg } }]), i.init) {
      const s = i.project.items.map(kPe);
      o.values = i.project.hasSelectionId ? i.init.map((u) => ({ unit: r, [Xg]: qS(u, !1)[0] })) : i.init.map((u) => ({ unit: r, fields: s, values: qS(u, !1) }));
    }
    n.filter((s) => s.name === i.name + GS).length || n.push(o);
  }
  return n;
}
function $Pe(e, t) {
  for (const n of il(e.component.selection ?? {}))
    for (const r of q8)
      r.defined(n) && r.marks && (t = r.marks(e, n, t));
  return t;
}
function jjt(e, t) {
  for (const n of e.children)
    za(n) && (t = $Pe(n, t));
  return t;
}
function Ljt(e, t, n, r) {
  const i = nIe(e, t.param, t);
  return {
    signal: Wd(n.get("type")) && nt(r) && r[0] > r[1] ? `isValid(${i}) && reverse(${i})` : i
  };
}
function mie(e) {
  return e.map((t) => (t.on && !t.on.length && delete t.on, t));
}
class oo {
  constructor(t, n) {
    this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t);
  }
  /**
   * Clone this node with a deep copy but don't clone links to children or parents.
   */
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the node and also add this node to the parent's children.
   */
  set parent(t) {
    this._parent = t, t && t.addChild(this);
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(t, n) {
    if (this._children.includes(t)) {
      bt(z4t);
      return;
    }
    n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t);
  }
  removeChild(t) {
    const n = this._children.indexOf(t);
    return this._children.splice(n, 1), n;
  }
  /**
   * Remove node from the dataflow.
   */
  remove() {
    let t = this._parent.removeChild(this);
    for (const n of this._children)
      n._parent = this._parent, this._parent.addChild(n, t++);
  }
  /**
   * Insert another node as a parent of this node.
   */
  insertAsParentOf(t) {
    const n = t.parent;
    n.removeChild(this), this.parent = n, t.parent = this;
  }
  swapWithParent() {
    const t = this._parent, n = t.parent;
    for (const i of this._children)
      i.parent = t;
    this._children = [], t.removeChild(this);
    const r = t.parent.removeChild(t);
    this._parent = n, n.addChild(this, r), t.parent = this;
  }
}
class Mf extends oo {
  clone() {
    const t = new this.constructor();
    return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
  }
  /**
   * @param source The name of the source. Will change in assemble.
   * @param type The type of the output node.
   * @param refCounts A global ref counter map.
   */
  constructor(t, n, r, i) {
    super(t, n), this.type = r, this.refCounts = i, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return this._hash === void 0 && (this._hash = `Output ${A$e()}`), this._hash;
  }
  /**
   * Request the datasource name and increase the ref counter.
   *
   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
   * It is crucial to request the name from an output node to mark it as a required node.
   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
   *
   * In the assemble phase, this will return the correct name.
   */
  getSource() {
    return this.refCounts[this._name]++, this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(t) {
    this._source = t;
  }
}
function kV(e) {
  return e.as !== void 0;
}
function zye(e) {
  return `${e}_end`;
}
class Yy extends oo {
  clone() {
    return new Yy(null, Kn(this.timeUnits));
  }
  constructor(t, n) {
    super(t), this.timeUnits = n;
  }
  static makeFromEncoding(t, n) {
    const r = n.reduceFieldDef((i, o, a) => {
      const { field: s, timeUnit: u } = o;
      if (u) {
        let l;
        if (p2(u)) {
          if (za(n)) {
            const { mark: f, markDef: h, config: p } = n, g = mw({ fieldDef: o, markDef: h, config: p });
            (u$(f) || g) && (l = {
              timeUnit: bu(u),
              field: s
            });
          }
        } else
          l = {
            as: Mt(o, { forAs: !0 }),
            field: s,
            timeUnit: u
          };
        if (za(n)) {
          const { mark: f, markDef: h, config: p } = n, g = mw({ fieldDef: o, markDef: h, config: p });
          u$(f) && is(a) && g !== 0.5 && (l.rectBandPosition = g);
        }
        l && (i[Xr(l)] = l);
      }
      return i;
    }, {});
    return go(r) ? null : new Yy(t, r);
  }
  static makeFromTransform(t, n) {
    const { timeUnit: r, ...i } = { ...n }, o = bu(r), a = {
      ...i,
      timeUnit: o
    };
    return new Yy(t, {
      [Xr(a)]: a
    });
  }
  /**
   * Merge together TimeUnitNodes assigning the children of `other` to `this`
   * and removing `other`.
   */
  merge(t) {
    this.timeUnits = { ...this.timeUnits };
    for (const n in t.timeUnits)
      this.timeUnits[n] || (this.timeUnits[n] = t.timeUnits[n]);
    for (const n of t.children)
      t.removeChild(n), n.parent = this;
    t.remove();
  }
  /**
   * Remove time units coming from the other node.
   */
  removeFormulas(t) {
    const n = {};
    for (const [r, i] of pw(this.timeUnits)) {
      const o = kV(i) ? i.as : `${i.field}_end`;
      t.has(o) || (n[r] = i);
    }
    this.timeUnits = n;
  }
  producedFields() {
    return new Set(il(this.timeUnits).map((t) => kV(t) ? t.as : zye(t.field)));
  }
  dependentFields() {
    return new Set(il(this.timeUnits).map((t) => t.field));
  }
  hash() {
    return `TimeUnit ${Xr(this.timeUnits)}`;
  }
  assemble() {
    const t = [];
    for (const n of il(this.timeUnits)) {
      const { rectBandPosition: r } = n, i = bu(n.timeUnit);
      if (kV(n)) {
        const { field: o, as: a } = n, { unit: s, utc: u, ...l } = i, f = [a, `${a}_end`];
        t.push({
          field: _p(o),
          type: "timeunit",
          ...s ? { units: N8(s) } : {},
          ...u ? { timezone: "utc" } : {},
          ...l,
          as: f
        }), t.push(...Fye(f, r, i));
      } else if (n) {
        const { field: o } = n, a = o.replaceAll("\\.", "."), s = PPe({ timeUnit: i, field: a }), u = zye(a);
        t.push({
          type: "formula",
          expr: s,
          as: u
        }), t.push(...Fye([a, u], r, i));
      }
    }
    return t;
  }
}
const H8 = "offsetted_rect_start", V8 = "offsetted_rect_end";
function PPe({ timeUnit: e, field: t, reverse: n }) {
  const { unit: r, utc: i } = e, o = d4e(r), { part: a, step: s } = m4e(o, e.step);
  return `${i ? "utcOffset" : "timeOffset"}('${a}', datum['${t}'], ${n ? -s : s})`;
}
function Fye([e, t], n, r) {
  if (n !== void 0 && n !== 0.5) {
    const i = `datum['${e}']`, o = `datum['${t}']`;
    return [
      {
        type: "formula",
        expr: Bye([
          PPe({
            timeUnit: r,
            field: e,
            reverse: !0
          }),
          i
        ], n + 0.5),
        as: `${e}_${H8}`
      },
      {
        type: "formula",
        expr: Bye([i, o], n + 0.5),
        as: `${e}_${V8}`
      }
    ];
  }
  return [];
}
function Bye([e, t], n) {
  return `${1 - n} * ${e} + ${n} * ${t}`;
}
const $4 = "_tuple_fields";
class zjt {
  constructor(...t) {
    this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;
  }
}
const Fjt = {
  defined: () => !0,
  parse: (e, t, n) => {
    const r = t.name, i = t.project ?? (t.project = new zjt()), o = {}, a = {}, s = /* @__PURE__ */ new Set(), u = (y, b) => {
      const _ = b === "visual" ? y.channel : y.field;
      let S = oa(`${r}_${_}`);
      for (let C = 1; s.has(S); C++)
        S = oa(`${r}_${_}_${C}`);
      return s.add(S), { [b]: S };
    }, l = t.type, f = e.config.selection[l], h = n.value !== void 0 ? Rt(n.value) : null;
    let { fields: p, encodings: g } = Pt(n.select) ? n.select : {};
    if (!p && !g && h) {
      for (const y of h)
        if (Pt(y))
          for (const b of yt(y))
            e4t(b) ? (g || (g = [])).push(b) : l === "interval" ? (bt(P4t), g = f.encodings) : (p ?? (p = [])).push(b);
    }
    !p && !g && (g = f.encodings, "fields" in f && (p = f.fields));
    for (const y of g ?? []) {
      const b = e.fieldDef(y);
      if (b) {
        let _ = b.field;
        if (b.aggregate) {
          bt(T4t(y, b.aggregate));
          continue;
        } else if (!_) {
          bt(fye(y));
          continue;
        }
        if (b.timeUnit && !p2(b.timeUnit)) {
          _ = e.vgField(y);
          const S = {
            timeUnit: b.timeUnit,
            as: _,
            field: b.field
          };
          a[Xr(S)] = S;
        }
        if (!o[_]) {
          const S = l === "interval" && Ob(y) && Wd(e.getScaleComponent(y).get("type")) ? "R" : b.bin ? "R-RE" : "E", C = { field: _, channel: y, type: S, index: i.items.length };
          C.signals = { ...u(C, "data"), ...u(C, "visual") }, i.items.push(o[_] = C), i.hasField[_] = o[_], i.hasSelectionId = i.hasSelectionId || _ === Xg, I$e(y) ? (C.geoChannel = y, C.channel = P$e(y), i.hasChannel[C.channel] = o[_]) : i.hasChannel[y] = o[_];
        }
      } else
        bt(fye(y));
    }
    for (const y of p ?? []) {
      if (i.hasField[y])
        continue;
      const b = { type: "E", field: y, index: i.items.length };
      b.signals = { ...u(b, "data") }, i.items.push(b), i.hasField[y] = b, i.hasSelectionId = i.hasSelectionId || y === Xg;
    }
    h && (t.init = h.map((y) => i.items.map((b) => Pt(y) ? y[b.geoChannel || b.channel] !== void 0 ? y[b.geoChannel || b.channel] : y[b.field] : y))), go(a) || (i.timeUnit = new Yy(null, a));
  },
  signals: (e, t, n) => {
    const r = t.name + $4;
    return n.filter((o) => o.name === r).length > 0 || t.project.hasSelectionId ? n : n.concat({
      name: r,
      value: t.project.items.map(kPe)
    });
  }
}, rb = {
  defined: (e) => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
  parse: (e, t) => {
    const n = t.scales = [];
    for (const r of t.project.items) {
      const i = r.channel;
      if (!Ob(i))
        continue;
      const o = e.getScaleComponent(i), a = o ? o.get("type") : void 0;
      if (a == "sequential" && bt(A4t), !o || !Wd(a)) {
        bt(D4t);
        continue;
      }
      o.set("selectionExtent", { param: t.name, field: r.field }, !0), n.push(r);
    }
  },
  topLevelSignals: (e, t, n) => {
    const r = t.scales.filter((a) => n.filter((s) => s.name === a.signals.data).length === 0);
    if (!e.parent || Uye(e) || r.length === 0)
      return n;
    const i = n.filter((a) => a.name === t.name)[0];
    let o = i.update;
    if (o.indexOf(KPe) >= 0)
      i.update = `{${r.map((a) => `${Et(_p(a.field))}: ${a.signals.data}`).join(", ")}}`;
    else {
      for (const a of r) {
        const s = `${Et(_p(a.field))}: ${a.signals.data}`;
        o.includes(s) || (o = `${o.substring(0, o.length - 1)}, ${s}}`);
      }
      i.update = o;
    }
    return n.concat(r.map((a) => ({ name: a.signals.data })));
  },
  signals: (e, t, n) => {
    if (e.parent && !Uye(e))
      for (const r of t.scales) {
        const i = n.find((o) => o.name === r.signals.data);
        i.push = "outer", delete i.value, delete i.update;
      }
    return n;
  }
};
function lX(e, t) {
  return `domain(${Et(e.scaleName(t))})`;
}
function Uye(e) {
  return e.parent && HN(e.parent) && !e.parent.parent;
}
const FT = "_brush", IPe = "_scale_trigger", gO = "geo_interval_init_tick", jPe = "_init", Bjt = "_center", Ujt = {
  defined: (e) => e.type === "interval",
  parse: (e, t, n) => {
    var r;
    if (e.hasProjection) {
      const i = { ...Pt(n.select) ? n.select : {} };
      i.fields = [Xg], i.encodings || (i.encodings = n.value ? yt(n.value) : [sm, am]), n.select = { type: "interval", ...i };
    }
    if (t.translate && !rb.defined(t)) {
      const i = `!event.item || event.item.mark.name !== ${Et(t.name + FT)}`;
      for (const o of t.events) {
        if (!o.between) {
          bt(`${o} is not an ordered event stream for interval selections.`);
          continue;
        }
        const a = Rt((r = o.between[0]).filter ?? (r.filter = []));
        a.indexOf(i) < 0 && a.push(i);
      }
    }
  },
  signals: (e, t, n) => {
    const r = t.name, i = r + bw, o = il(t.project.hasChannel).filter((s) => s.channel === aa || s.channel === _u), a = t.init ? t.init[0] : null;
    if (n.push(...o.reduce((s, u) => s.concat(Yjt(e, t, u, a && a[u.index])), [])), e.hasProjection) {
      const s = Et(e.projectionName()), u = e.projectionName() + Bjt, { x: l, y: f } = t.project.hasChannel, h = l && l.signals.visual, p = f && f.signals.visual, g = l ? a && a[l.index] : `${u}[0]`, y = f ? a && a[f.index] : `${u}[1]`, b = (R) => e.getSizeSignalRef(R).signal, _ = `[[${h ? h + "[0]" : "0"}, ${p ? p + "[0]" : "0"}],[${h ? h + "[1]" : b("width")}, ${p ? p + "[1]" : b("height")}]]`;
      a && (n.unshift({
        name: r + jPe,
        init: `[scale(${s}, [${l ? g[0] : g}, ${f ? y[0] : y}]), scale(${s}, [${l ? g[1] : g}, ${f ? y[1] : y}])]`
      }), (!l || !f) && (n.find((j) => j.name === u) || n.unshift({
        name: u,
        update: `invert(${s}, [${b("width")}/2, ${b("height")}/2])`
      })));
      const S = `intersect(${_}, {markname: ${Et(e.getName("marks"))}}, unit.mark)`, C = `{unit: ${lS(e)}}`, A = `vlSelectionTuples(${S}, ${C})`, O = o.map((R) => R.signals.visual);
      return n.concat({
        name: i,
        on: [
          {
            events: [
              ...O.length ? [{ signal: O.join(" || ") }] : [],
              ...a ? [{ signal: gO }] : []
            ],
            update: A
          }
        ]
      });
    } else {
      if (!rb.defined(t)) {
        const l = r + IPe, f = o.map((h) => {
          const p = h.channel, { data: g, visual: y } = h.signals, b = Et(e.scaleName(p)), _ = e.getScaleComponent(p).get("type"), S = Wd(_) ? "+" : "";
          return `(!isArray(${g}) || (${S}invert(${b}, ${y})[0] === ${S}${g}[0] && ${S}invert(${b}, ${y})[1] === ${S}${g}[1]))`;
        });
        f.length && n.push({
          name: l,
          value: {},
          on: [
            {
              events: o.map((h) => ({ scale: e.scaleName(h.channel) })),
              update: f.join(" && ") + ` ? ${l} : {}`
            }
          ]
        });
      }
      const s = o.map((l) => l.signals.data), u = `unit: ${lS(e)}, fields: ${r + $4}, values`;
      return n.concat({
        name: i,
        ...a ? { init: `{${u}: ${qS(a)}}` } : {},
        ...s.length ? {
          on: [
            {
              events: [{ signal: s.join(" || ") }],
              // Prevents double invocation, see https://github.com/vega/vega/issues/1672.
              update: `${s.join(" && ")} ? {${u}: [${s}]} : null`
            }
          ]
        } : {}
      });
    }
  },
  topLevelSignals: (e, t, n) => (za(e) && e.hasProjection && t.init && (n.filter((i) => i.name === gO).length || n.unshift({
    name: gO,
    value: null,
    on: [
      {
        events: "timer{1}",
        update: `${gO} === null ? {} : ${gO}`
      }
    ]
  })), n),
  marks: (e, t, n) => {
    const r = t.name, { x: i, y: o } = t.project.hasChannel, a = i == null ? void 0 : i.signals.visual, s = o == null ? void 0 : o.signals.visual, u = `data(${Et(t.name + GS)})`;
    if (rb.defined(t) || !i && !o)
      return n;
    const l = {
      x: i !== void 0 ? { signal: `${a}[0]` } : { value: 0 },
      y: o !== void 0 ? { signal: `${s}[0]` } : { value: 0 },
      x2: i !== void 0 ? { signal: `${a}[1]` } : { field: { group: "width" } },
      y2: o !== void 0 ? { signal: `${s}[1]` } : { field: { group: "height" } }
    };
    if (t.resolve === "global")
      for (const _ of yt(l))
        l[_] = [
          {
            test: `${u}.length && ${u}[0].unit === ${lS(e)}`,
            ...l[_]
          },
          { value: 0 }
        ];
    const { fill: f, fillOpacity: h, cursor: p, ...g } = t.mark, y = yt(g).reduce((_, S) => (_[S] = [
      {
        test: [i !== void 0 && `${a}[0] !== ${a}[1]`, o !== void 0 && `${s}[0] !== ${s}[1]`].filter((C) => C).join(" && "),
        value: g[S]
      },
      { value: null }
    ], _), {}), b = p ?? (t.translate ? "move" : null);
    return [
      {
        name: `${r + FT}_bg`,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            fill: { value: f },
            fillOpacity: { value: h }
          },
          update: l
        }
      },
      ...n,
      {
        name: r + FT,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            ...b ? { cursor: { value: b } } : {},
            fill: { value: "transparent" }
          },
          update: { ...l, ...y }
        }
      }
    ];
  }
};
function Yjt(e, t, n, r) {
  const i = !e.hasProjection, o = n.channel, a = n.signals.visual, s = Et(i ? e.scaleName(o) : e.projectionName()), u = (p) => `scale(${s}, ${p})`, l = e.getSizeSignalRef(o === aa ? "width" : "height").signal, f = `${o}(unit)`, h = t.events.reduce((p, g) => [
    ...p,
    { events: g.between[0], update: `[${f}, ${f}]` },
    // Brush Start
    { events: g, update: `[${a}[0], clamp(${f}, 0, ${l})]` }
    // Brush End
  ], []);
  if (i) {
    const p = n.signals.data, g = rb.defined(t), y = e.getScaleComponent(o), b = y ? y.get("type") : void 0, _ = r ? { init: qS(r, !0, u) } : { value: [] };
    return h.push({
      events: { signal: t.name + IPe },
      update: Wd(b) ? `[${u(`${p}[0]`)}, ${u(`${p}[1]`)}]` : "[0, 0]"
    }), g ? [{ name: p, on: [] }] : [
      { name: a, ..._, on: h },
      {
        name: p,
        ...r ? { init: qS(r) } : {},
        // Cannot be `value` as `init` may require datetime exprs.
        on: [
          {
            events: { signal: a },
            update: `${a}[0] === ${a}[1] ? null : invert(${s}, ${a})`
          }
        ]
      }
    ];
  } else {
    const p = o === aa ? 0 : 1, g = t.name + jPe, y = r ? { init: `[${g}[0][${p}], ${g}[1][${p}]]` } : { value: [] };
    return [{ name: a, ...y, on: h }];
  }
}
const Hjt = {
  defined: (e) => e.type === "point",
  signals: (e, t, n) => {
    const r = t.name, i = r + $4, o = t.project, a = "(item().isVoronoi ? datum.datum : datum)", s = il(e.component.selection ?? {}).reduce((h, p) => p.type === "interval" ? h.concat(p.name + FT) : h, []).map((h) => `indexof(item().mark.name, '${h}') < 0`).join(" && "), u = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${s ? ` && ${s}` : ""}`;
    let l = `unit: ${lS(e)}, `;
    if (t.project.hasSelectionId)
      l += `${Xg}: ${a}[${Et(Xg)}]`;
    else {
      const h = o.items.map((p) => {
        const g = e.fieldDef(p.channel);
        return g != null && g.bin ? `[${a}[${Et(e.vgField(p.channel, {}))}], ${a}[${Et(e.vgField(p.channel, { binSuffix: "end" }))}]]` : `${a}[${Et(p.field)}]`;
      }).join(", ");
      l += `fields: ${i}, values: [${h}]`;
    }
    const f = t.events;
    return n.concat([
      {
        name: r + bw,
        on: f ? [
          {
            events: f,
            update: `${u} ? {${l}} : null`,
            force: !0
          }
        ] : []
      }
    ]);
  }
};
function FN(e, t, n, r) {
  const i = P8(t) && t.condition, o = r(t);
  if (i) {
    const s = Rt(i).map((u) => {
      const l = r(u);
      if ($It(u)) {
        const { param: f, empty: h } = u;
        return { test: tIe(e, { param: f, empty: h }), ...l };
      } else
        return { test: Ez(e, u.test), ...l };
    });
    return {
      [n]: [...s, ...o !== void 0 ? [o] : []]
    };
  } else
    return o !== void 0 ? { [n]: o } : {};
}
function yie(e, t = "text") {
  const n = e.encoding[t];
  return FN(e, n, t, (r) => W8(r, e.config));
}
function W8(e, t, n = "datum") {
  if (e) {
    if (Qg(e))
      return Vo(e.value);
    if (or(e)) {
      const { format: r, formatType: i } = mz(e);
      return qre({ fieldOrDatumDef: e, format: r, formatType: i, expr: n, config: t });
    }
  }
}
function LPe(e, t = {}) {
  const { encoding: n, markDef: r, config: i, stack: o } = e, a = n.tooltip;
  if (nt(a))
    return { tooltip: Yye({ tooltip: a }, o, i, t) };
  {
    const s = t.reactiveGeom ? "datum.datum" : "datum";
    return FN(e, a, "tooltip", (u) => {
      const l = W8(u, i, s);
      if (l)
        return l;
      if (u === null)
        return;
      let f = Fi("tooltip", r, i);
      if (f === !0 && (f = { content: "encoding" }), kt(f))
        return { value: f };
      if (Pt(f))
        return an(f) ? f : f.content === "encoding" ? Yye(n, o, i, t) : { signal: s };
    });
  }
}
function zPe(e, t, n, { reactiveGeom: r } = {}) {
  const i = { ...n, ...n.tooltipFormat }, o = {}, a = r ? "datum.datum" : "datum", s = [];
  function u(f, h) {
    const p = f2(h), g = Pc(f) ? f : {
      ...f,
      type: e[p].type
      // for secondary field def, copy type from main channel
    }, y = g.title || eie(g, i), b = Rt(y).join(", ").replaceAll(/"/g, '\\"');
    let _;
    if (is(h)) {
      const S = h === "x" ? "x2" : "y2", C = Jy(e[S]);
      if (Qu(g.bin) && C) {
        const A = Mt(g, { expr: a }), O = Mt(C, { expr: a }), { format: R, formatType: j } = mz(g);
        _ = D4(A, O, R, j, i), o[S] = !0;
      }
    }
    if ((is(h) || h === Tp || h === om) && t && t.fieldChannel === h && t.offset === "normalize") {
      const { format: S, formatType: C } = mz(g);
      _ = qre({
        fieldOrDatumDef: g,
        format: S,
        formatType: C,
        expr: a,
        config: i,
        normalizeStack: !0
      }).signal;
    }
    _ ?? (_ = W8(g, i, a).signal), s.push({ channel: h, key: b, value: _ });
  }
  rie(e, (f, h) => {
    xt(f) ? u(f, h) : I8(f) && u(f.condition, h);
  });
  const l = {};
  for (const { channel: f, key: h, value: p } of s)
    !o[f] && !l[h] && (l[h] = p);
  return l;
}
function Yye(e, t, n, { reactiveGeom: r } = {}) {
  const i = zPe(e, t, n, { reactiveGeom: r }), o = pw(i).map(([a, s]) => `"${a}": ${s}`);
  return o.length > 0 ? { signal: `{${o.join(", ")}}` } : void 0;
}
function Vjt(e) {
  const { markDef: t, config: n } = e, r = Fi("aria", t, n);
  return r === !1 ? {} : {
    ...r ? { aria: r } : {},
    ...Wjt(e),
    ...qjt(e)
  };
}
function Wjt(e) {
  const { mark: t, markDef: n, config: r } = e;
  if (r.aria === !1)
    return {};
  const i = Fi("ariaRoleDescription", n, r);
  return i != null ? { ariaRoleDescription: { value: i } } : t in _4t ? {} : { ariaRoleDescription: { value: t } };
}
function qjt(e) {
  const { encoding: t, markDef: n, config: r, stack: i } = e, o = t.description;
  if (o)
    return FN(e, o, "description", (u) => W8(u, e.config));
  const a = Fi("description", n, r);
  if (a != null)
    return {
      description: Vo(a)
    };
  if (r.aria === !1)
    return {};
  const s = zPe(t, i, r);
  if (!go(s))
    return {
      description: {
        signal: pw(s).map(([u, l], f) => `"${f > 0 ? "; " : ""}${u}: " + (${l})`).join(" + ")
      }
    };
}
function hu(e, t, n = {}) {
  const { markDef: r, encoding: i, config: o } = t, { vgChannel: a } = n;
  let { defaultRef: s, defaultValue: u } = n;
  s === void 0 && (u ?? (u = Fi(e, r, o, { vgChannel: a, ignoreVgConfig: !0 })), u !== void 0 && (s = Vo(u)));
  const l = i[e];
  return FN(t, l, a ?? e, (f) => Wre({
    channel: e,
    channelDef: f,
    markDef: r,
    config: o,
    scaleName: t.scaleName(e),
    scale: t.getScaleComponent(e),
    stack: null,
    // No need to provide stack for non-position as it does not affect mid point
    defaultRef: s
  }));
}
function FPe(e, t = { filled: void 0 }) {
  const { markDef: n, encoding: r, config: i } = e, { type: o } = n, a = t.filled ?? Fi("filled", n, i), s = Kr(["bar", "point", "circle", "square", "geoshape"], o) ? "transparent" : void 0, u = Fi(a === !0 ? "color" : void 0, n, i, { vgChannel: "fill" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  i.mark[a === !0 && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
  // with transparent fills https://github.com/vega/vega-lite/issues/1316
  s, l = Fi(a === !1 ? "color" : void 0, n, i, { vgChannel: "stroke" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  i.mark[a === !1 && "color"], f = a ? "fill" : "stroke", h = {
    ...u ? { fill: Vo(u) } : {},
    ...l ? { stroke: Vo(l) } : {}
  };
  return n.color && (a ? n.fill : n.stroke) && bt(r4e("property", { fill: "fill" in n, stroke: "stroke" in n })), {
    ...h,
    ...hu("color", e, {
      vgChannel: f,
      defaultValue: a ? u : l
    }),
    ...hu("fill", e, {
      // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
      defaultValue: r.fill ? u : void 0
    }),
    ...hu("stroke", e, {
      // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
      defaultValue: r.stroke ? l : void 0
    })
  };
}
function Gjt(e) {
  const { encoding: t, mark: n } = e, r = t.order;
  return !g2(n) && Qg(r) ? FN(e, r, "zindex", (i) => Vo(i.value)) : {};
}
function qC({ channel: e, markDef: t, encoding: n = {}, model: r, bandPosition: i }) {
  const o = `${e}Offset`, a = t[o], s = n[o];
  if ((o === "xOffset" || o === "yOffset") && s)
    return { offsetType: "encoding", offset: Wre({
      channel: o,
      channelDef: s,
      markDef: t,
      config: r == null ? void 0 : r.config,
      scaleName: r.scaleName(o),
      scale: r.getScaleComponent(o),
      stack: null,
      defaultRef: Vo(a),
      bandPosition: i
    }) };
  const u = t[o];
  return u ? { offsetType: "visual", offset: u } : {};
}
function Bl(e, t, { defaultPos: n, vgChannel: r }) {
  const { encoding: i, markDef: o, config: a, stack: s } = t, u = i[e], l = i[gv(e)], f = t.scaleName(e), h = t.getScaleComponent(e), { offset: p, offsetType: g } = qC({
    channel: e,
    markDef: o,
    encoding: i,
    model: t,
    bandPosition: 0.5
  }), y = vie({
    model: t,
    defaultPos: n,
    channel: e,
    scaleName: f,
    scale: h
  }), b = !u && is(e) && (i.latitude || i.longitude) ? (
    // use geopoint output if there are lat/long and there is no point position overriding lat/long.
    { field: t.getName(e) }
  ) : Qjt({
    channel: e,
    channelDef: u,
    channel2Def: l,
    markDef: o,
    config: a,
    scaleName: f,
    scale: h,
    stack: s,
    offset: p,
    defaultRef: y,
    bandPosition: g === "encoding" ? 0 : void 0
  });
  return b ? { [r || e]: b } : void 0;
}
function Qjt(e) {
  const { channel: t, channelDef: n, scaleName: r, stack: i, offset: o, markDef: a } = e;
  if (or(n) && i && t === i.fieldChannel) {
    if (xt(n)) {
      let s = n.bandPosition;
      if (s === void 0 && a.type === "text" && (t === "radius" || t === "theta") && (s = 0.5), s !== void 0)
        return dz({
          scaleName: r,
          fieldOrDatumDef: n,
          // positionRef always have type
          startSuffix: "start",
          bandPosition: s,
          offset: o
        });
    }
    return sS(n, r, { suffix: "end" }, { offset: o });
  }
  return Hre(e);
}
function vie({ model: e, defaultPos: t, channel: n, scaleName: r, scale: i }) {
  const { markDef: o, config: a } = e;
  return () => {
    const s = f2(n), u = gw(n), l = Fi(n, o, a, { vgChannel: u });
    if (l !== void 0)
      return qR(n, l);
    switch (t) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (r) {
          const f = i.get("type");
          if (!Kr([Sf.LOG, Sf.TIME, Sf.UTC], f)) {
            if (i.domainDefinitelyIncludesZero())
              return {
                scale: r,
                value: 0
              };
          }
        }
        if (t === "zeroOrMin")
          return s === "y" ? { field: { group: "height" } } : { value: 0 };
        switch (s) {
          case "radius":
            return {
              signal: `min(${e.width.signal},${e.height.signal})/2`
            };
          case "theta":
            return { signal: "2*PI" };
          case "x":
            return { field: { group: "width" } };
          case "y":
            return { value: 0 };
        }
        break;
      case "mid":
        return { ...e[jf(n)], mult: 0.5 };
    }
  };
}
const Xjt = {
  left: "x",
  center: "xc",
  right: "x2"
}, Kjt = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function BPe(e, t, n, r = "middle") {
  if (e === "radius" || e === "theta")
    return gw(e);
  const i = e === "x" ? "align" : "baseline", o = Fi(i, t, n);
  let a;
  return an(o) ? (bt(ePt(i)), a = void 0) : a = o, e === "x" ? Xjt[a || (r === "top" ? "left" : "center")] : Kjt[a || r];
}
function wz(e, t, { defaultPos: n, defaultPos2: r, range: i }) {
  return i ? UPe(e, t, { defaultPos: n, defaultPos2: r }) : Bl(e, t, { defaultPos: n });
}
function UPe(e, t, { defaultPos: n, defaultPos2: r }) {
  const { markDef: i, config: o } = t, a = gv(e), s = jf(e), u = Zjt(t, r, a), l = u[s] ? (
    // If there is width/height, we need to position the marks based on the alignment.
    BPe(e, i, o)
  ) : (
    // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
    gw(e)
  );
  return {
    ...Bl(e, t, { defaultPos: n, vgChannel: l }),
    ...u
  };
}
function Zjt(e, t, n) {
  const { encoding: r, mark: i, markDef: o, stack: a, config: s } = e, u = f2(n), l = jf(n), f = gw(n), h = r[u], p = e.scaleName(u), g = e.getScaleComponent(u), { offset: y } = n in r || n in o ? qC({ channel: n, markDef: o, encoding: r, model: e }) : qC({ channel: u, markDef: o, encoding: r, model: e });
  if (!h && (n === "x2" || n === "y2") && (r.latitude || r.longitude)) {
    const _ = jf(n), S = e.markDef[_];
    return S != null ? {
      [_]: { value: S }
    } : {
      [f]: { field: e.getName(n) }
    };
  }
  const b = Jjt({
    channel: n,
    channelDef: h,
    channel2Def: r[n],
    markDef: o,
    config: s,
    scaleName: p,
    scale: g,
    stack: a,
    offset: y,
    defaultRef: void 0
  });
  return b !== void 0 ? { [f]: b } : I3(n, o) || I3(n, {
    [n]: cz(n, o, s.style),
    [l]: cz(l, o, s.style)
  }) || I3(n, s[i]) || I3(n, s.mark) || {
    [f]: vie({
      model: e,
      defaultPos: t,
      channel: n,
      scaleName: p,
      scale: g
    })()
  };
}
function Jjt({ channel: e, channelDef: t, channel2Def: n, markDef: r, config: i, scaleName: o, scale: a, stack: s, offset: u, defaultRef: l }) {
  return or(t) && s && // If fieldChannel is X and channel is X2 (or Y and Y2)
  e.charAt(0) === s.fieldChannel.charAt(0) ? sS(t, o, { suffix: "start" }, { offset: u }) : Hre({
    channel: e,
    channelDef: n,
    scaleName: o,
    scale: a,
    stack: s,
    markDef: r,
    config: i,
    offset: u,
    defaultRef: l
  });
}
function I3(e, t) {
  const n = jf(e), r = gw(e);
  if (t[r] !== void 0)
    return { [r]: qR(e, t[r]) };
  if (t[e] !== void 0)
    return { [r]: qR(e, t[e]) };
  if (t[n]) {
    const i = t[n];
    if (WS(i))
      bt(G4t(n));
    else
      return { [n]: qR(e, i) };
  }
}
function vw(e, t) {
  const { config: n, encoding: r, markDef: i } = e, o = i.type, a = gv(t), s = jf(t), u = r[t], l = r[a], f = e.getScaleComponent(t), h = f ? f.get("type") : void 0, p = i.orient, g = r[s] ?? r.size ?? Fi("size", i, n, { vgChannel: s }), y = F$e(t), b = o === "bar" && (t === "x" ? p === "vertical" : p === "horizontal");
  return xt(u) && (Lo(u.bin) || Qu(u.bin) || u.timeUnit && !l) && !(g && !WS(g)) && !r[y] && !xu(h) ? nLt({
    fieldDef: u,
    fieldDef2: l,
    channel: t,
    model: e
  }) : (or(u) && xu(h) || b) && !l ? tLt(u, t, e) : UPe(t, e, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
}
function eLt(e, t, n, r, i, o, a) {
  if (WS(i))
    if (n) {
      const u = n.get("type");
      if (u === "band") {
        let l = `bandwidth('${t}')`;
        i.band !== 1 && (l = `${i.band} * ${l}`);
        const f = gb("minBandSize", { type: a }, r);
        return { signal: f ? `max(${Ig(f)}, ${l})` : l };
      } else
        i.band !== 1 && (bt(iPt(u)), i = void 0);
    } else
      return {
        mult: i.band,
        field: { group: e }
      };
  else {
    if (an(i))
      return i;
    if (i)
      return { value: i };
  }
  if (n) {
    const u = n.get("range");
    if (Hw(u) && pi(u.step))
      return { value: u.step - 2 };
  }
  if (!o) {
    const { bandPaddingInner: u, barBandPaddingInner: l, rectBandPaddingInner: f } = r.scale, h = rs(u, a === "bar" ? l : f);
    if (an(h))
      return { signal: `(1 - (${h.signal})) * ${e}` };
    if (pi(h))
      return { signal: `${1 - h} * ${e}` };
  }
  return { value: bz(r.view, e) - 2 };
}
function tLt(e, t, n) {
  var W, Y;
  const { markDef: r, encoding: i, config: o, stack: a } = n, s = r.orient, u = n.scaleName(t), l = n.getScaleComponent(t), f = jf(t), h = gv(t), p = F$e(t), g = n.scaleName(p), y = n.getScaleComponent(Sre(t)), b = s === "horizontal" && t === "y" || s === "vertical" && t === "x";
  let _;
  (i.size || r.size) && (b ? _ = hu("size", n, {
    vgChannel: f,
    defaultRef: Vo(r.size)
  }) : bt(uPt(r.type)));
  const S = !!_, C = L4e({
    channel: t,
    fieldDef: e,
    markDef: r,
    config: o,
    scaleType: (W = l || y) == null ? void 0 : W.get("type"),
    useVlSizeChannel: b
  });
  _ = _ || {
    [f]: eLt(f, g || u, y || l, o, C, !!e, r.type)
  };
  const A = ((Y = l || y) == null ? void 0 : Y.get("type")) === "band" && WS(C) && !S ? "top" : "middle", O = BPe(t, r, o, A), R = O === "xc" || O === "yc", { offset: j, offsetType: $ } = qC({ channel: t, markDef: r, encoding: i, model: n, bandPosition: R ? 0.5 : 0 }), z = Hre({
    channel: t,
    channelDef: e,
    markDef: r,
    config: o,
    scaleName: u,
    scale: l,
    stack: a,
    offset: j,
    defaultRef: vie({ model: n, defaultPos: "mid", channel: t, scaleName: u, scale: l }),
    bandPosition: R ? $ === "encoding" ? 0 : 0.5 : an(C) ? { signal: `(1-${C})/2` } : WS(C) ? (1 - C.band) / 2 : 0
  });
  if (f)
    return { [O]: z, ..._ };
  {
    const V = gw(h), ee = _[f], K = j ? { ...ee, offset: j } : ee;
    return {
      [O]: z,
      // posRef might be an array that wraps position invalid test
      [V]: nt(z) ? [z[0], { ...z[1], offset: K }] : {
        ...z,
        offset: K
      }
    };
  }
}
function Hye(e, t, n, r, i, o, a) {
  if ($$e(e))
    return 0;
  const s = e === "x" || e === "y2", u = s ? -t / 2 : t / 2;
  if (an(n) || an(i) || an(r) || o) {
    const l = Ig(n), f = Ig(i), h = Ig(r), p = Ig(o), y = o ? `(${a} < ${p} ? ${s ? "" : "-"}0.5 * (${p} - (${a})) : ${u})` : u, b = h ? `${h} + ` : "", _ = l ? `(${l} ? -1 : 1) * ` : "", S = f ? `(${f} + ${y})` : y;
    return {
      signal: b + _ + S
    };
  } else
    return i = i || 0, r + (n ? -i - u : +i + u);
}
function nLt({ fieldDef: e, fieldDef2: t, channel: n, model: r }) {
  var Y;
  const { config: i, markDef: o, encoding: a } = r, s = r.getScaleComponent(n), u = r.scaleName(n), l = s ? s.get("type") : void 0, f = s.get("reverse"), h = L4e({ channel: n, fieldDef: e, markDef: o, config: i, scaleType: l }), p = (Y = r.component.axes[n]) == null ? void 0 : Y[0], g = (p == null ? void 0 : p.get("translate")) ?? 0.5, y = is(n) ? Fi("binSpacing", o, i) ?? 0 : 0, b = gv(n), _ = gw(n), S = gw(b), C = gb("minBandSize", o, i), { offset: A } = qC({ channel: n, markDef: o, encoding: a, model: r, bandPosition: 0 }), { offset: O } = qC({ channel: b, markDef: o, encoding: a, model: r, bandPosition: 0 }), R = hIt({ fieldDef: e, scaleName: u }), j = Hye(n, y, f, g, A, C, R), $ = Hye(b, y, f, g, O ?? A, C, R), z = an(h) ? { signal: `(1-${h.signal})/2` } : WS(h) ? (1 - h.band) / 2 : 0.5, W = mw({ fieldDef: e, fieldDef2: t, markDef: o, config: i });
  if (Lo(e.bin) || e.timeUnit) {
    const V = e.timeUnit && W !== 0.5;
    return {
      [S]: Vye({
        fieldDef: e,
        scaleName: u,
        bandPosition: z,
        offset: $,
        useRectOffsetField: V
      }),
      [_]: Vye({
        fieldDef: e,
        scaleName: u,
        bandPosition: an(z) ? { signal: `1-${z.signal}` } : 1 - z,
        offset: j,
        useRectOffsetField: V
      })
    };
  } else if (Qu(e.bin)) {
    const V = sS(e, u, {}, { offset: $ });
    if (xt(t))
      return {
        [S]: V,
        [_]: sS(t, u, {}, { offset: j })
      };
    if (d2(e.bin) && e.bin.step)
      return {
        [S]: V,
        [_]: {
          signal: `scale("${u}", ${Mt(e, { expr: "datum" })} + ${e.bin.step})`,
          offset: j
        }
      };
  }
  bt(a4e(b));
}
function Vye({ fieldDef: e, scaleName: t, bandPosition: n, offset: r, useRectOffsetField: i }) {
  return dz({
    scaleName: t,
    fieldOrDatumDef: e,
    bandPosition: n,
    offset: r,
    ...i ? {
      startSuffix: H8,
      endSuffix: V8
    } : {}
  });
}
const rLt = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function Cp(e, t) {
  const { fill: n = void 0, stroke: r = void 0 } = t.color === "include" ? FPe(e) : {};
  return {
    ...iLt(e.markDef, t),
    ...Wye(e, "fill", n),
    ...Wye(e, "stroke", r),
    ...hu("opacity", e),
    ...hu("fillOpacity", e),
    ...hu("strokeOpacity", e),
    ...hu("strokeWidth", e),
    ...hu("strokeDash", e),
    ...Gjt(e),
    ...LPe(e),
    ...yie(e, "href"),
    ...Vjt(e)
  };
}
function Wye(e, t, n) {
  const { config: r, mark: i, markDef: o } = e;
  if (Fi("invalid", o, r) === "hide" && n && !g2(i)) {
    const s = oLt(e, { invalid: !0, channels: M8 });
    if (s)
      return {
        [t]: [
          // prepend the invalid case
          // TODO: support custom value
          { test: s, value: null },
          ...Rt(n)
        ]
      };
  }
  return n ? { [t]: n } : {};
}
function iLt(e, t) {
  return w4t.reduce((n, r) => (!rLt.has(r) && e[r] !== void 0 && t[r] !== "ignore" && (n[r] = Vo(e[r])), n), {});
}
function oLt(e, { invalid: t = !1, channels: n }) {
  const r = n.reduce((o, a) => {
    const s = e.getScaleComponent(a);
    if (s) {
      const u = s.get("type"), l = e.vgField(a, { expr: "datum" });
      l && Wd(u) && (o[l] = !0);
    }
    return o;
  }, {}), i = yt(r);
  if (i.length > 0) {
    const o = t ? "||" : "&&";
    return i.map((a) => Vre(a, t)).join(` ${o} `);
  }
}
function bie(e) {
  const { config: t, markDef: n } = e;
  if (Fi("invalid", n, t)) {
    const i = aLt(e, { channels: mv });
    if (i)
      return { defined: { signal: i } };
  }
  return {};
}
function aLt(e, { invalid: t = !1, channels: n }) {
  const r = n.reduce((o, a) => {
    var u;
    const s = e.getScaleComponent(a);
    if (s) {
      const l = s.get("type"), f = e.vgField(a, { expr: "datum", binSuffix: (u = e.stack) != null && u.impute ? "mid" : void 0 });
      f && Wd(l) && (o[f] = !0);
    }
    return o;
  }, {}), i = yt(r);
  if (i.length > 0) {
    const o = t ? "||" : "&&";
    return i.map((a) => Vre(a, t)).join(` ${o} `);
  }
}
function qye(e, t) {
  if (t !== void 0)
    return { [e]: Vo(t) };
}
const $V = "voronoi", YPe = {
  defined: (e) => e.type === "point" && e.nearest,
  parse: (e, t) => {
    if (t.events)
      for (const n of t.events)
        n.markname = e.getName($V);
  },
  marks: (e, t, n) => {
    const { x: r, y: i } = t.project.hasChannel, o = e.mark;
    if (g2(o))
      return bt(C4t(o)), n;
    const a = {
      name: e.getName($V),
      type: "path",
      interactive: !0,
      from: { data: e.getName("marks") },
      encode: {
        update: {
          fill: { value: "transparent" },
          strokeWidth: { value: 0.35 },
          stroke: { value: "transparent" },
          isVoronoi: { value: !0 },
          ...LPe(e, { reactiveGeom: !0 })
        }
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: r || !i ? "datum.datum.x || 0" : "0" },
          y: { expr: i || !r ? "datum.datum.y || 0" : "0" },
          size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
        }
      ]
    };
    let s = 0, u = !1;
    return n.forEach((l, f) => {
      const h = l.name ?? "";
      h === e.component.mark[0].name ? s = f : h.indexOf($V) >= 0 && (u = !0);
    }), u || n.splice(s + 1, 0, a), n;
  }
}, HPe = {
  defined: (e) => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !lie(e.bind),
  parse: (e, t, n) => ZPe(t, n),
  topLevelSignals: (e, t, n) => {
    const r = t.name, i = t.project, o = t.bind, a = t.init && t.init[0], s = YPe.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    return i.items.forEach((u, l) => {
      const f = oa(`${r}_${u.field}`);
      n.filter((p) => p.name === f).length || n.unshift({
        name: f,
        ...a ? { init: qS(a[l]) } : { value: null },
        on: t.events ? [
          {
            events: t.events,
            update: `datum && item().mark.marktype !== 'group' ? ${s}[${Et(u.field)}] : null`
          }
        ] : [],
        bind: o[u.field] ?? o[u.channel] ?? o
      });
    }), n;
  },
  signals: (e, t, n) => {
    const r = t.name, i = t.project, o = n.filter((l) => l.name === r + bw)[0], a = r + $4, s = i.items.map((l) => oa(`${r}_${l.field}`)), u = s.map((l) => `${l} !== null`).join(" && ");
    return s.length && (o.update = `${u} ? {fields: ${a}, values: [${s.join(", ")}]} : null`), delete o.value, delete o.on, n;
  }
}, _z = "_toggle", VPe = {
  defined: (e) => e.type === "point" && !!e.toggle,
  signals: (e, t, n) => n.concat({
    name: t.name + _z,
    value: !1,
    on: [{ events: t.events, update: t.toggle }]
  }),
  modifyExpr: (e, t) => {
    const n = t.name + bw, r = t.name + _z;
    return `${r} ? null : ${n}, ` + (t.resolve === "global" ? `${r} ? null : true, ` : `${r} ? null : {unit: ${lS(e)}}, `) + `${r} ? ${n} : null`;
  }
}, sLt = {
  defined: (e) => e.clear !== void 0 && e.clear !== !1,
  parse: (e, t) => {
    t.clear && (t.clear = kt(t.clear) ? jw(t.clear, "view") : t.clear);
  },
  topLevelSignals: (e, t, n) => {
    if (HPe.defined(t))
      for (const r of t.project.items) {
        const i = n.findIndex((o) => o.name === oa(`${t.name}_${r.field}`));
        i !== -1 && n[i].on.push({ events: t.clear, update: "null" });
      }
    return n;
  },
  signals: (e, t, n) => {
    function r(i, o) {
      i !== -1 && n[i].on && n[i].on.push({ events: t.clear, update: o });
    }
    if (t.type === "interval")
      for (const i of t.project.items) {
        const o = n.findIndex((a) => a.name === i.signals.visual);
        if (r(o, "[0, 0]"), o === -1) {
          const a = n.findIndex((s) => s.name === i.signals.data);
          r(a, "null");
        }
      }
    else {
      let i = n.findIndex((o) => o.name === t.name + bw);
      r(i, "null"), VPe.defined(t) && (i = n.findIndex((o) => o.name === t.name + _z), r(i, "false"));
    }
    return n;
  }
}, WPe = {
  defined: (e) => {
    const t = e.resolve === "global" && e.bind && lie(e.bind), n = e.project.items.length === 1 && e.project.items[0].field !== Xg;
    return t && !n && bt(O4t), t && n;
  },
  parse: (e, t, n) => {
    const r = Kn(n);
    if (r.select = kt(r.select) ? { type: r.select, toggle: t.toggle } : { ...r.select, toggle: t.toggle }, ZPe(t, r), Pt(n.select) && (n.select.on || n.select.clear)) {
      const a = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const s of t.events)
        s.filter = Rt(s.filter ?? []), s.filter.includes(a) || s.filter.push(a);
    }
    const i = AV(t.bind) ? t.bind.legend : "click", o = kt(i) ? jw(i, "view") : Rt(i);
    t.bind = { legend: { merge: o } };
  },
  topLevelSignals: (e, t, n) => {
    const r = t.name, i = AV(t.bind) && t.bind.legend, o = (a) => (s) => {
      const u = Kn(s);
      return u.markname = a, u;
    };
    for (const a of t.project.items) {
      if (!a.hasLegend)
        continue;
      const s = `${oa(a.field)}_legend`, u = `${r}_${s}`;
      if (n.filter((f) => f.name === u).length === 0) {
        const f = i.merge.map(o(`${s}_symbols`)).concat(i.merge.map(o(`${s}_labels`))).concat(i.merge.map(o(`${s}_entries`)));
        n.unshift({
          name: u,
          ...t.init ? {} : { value: null },
          on: [
            // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
            {
              events: f,
              update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
              force: !0
            },
            { events: i.merge, update: `!event.item || !datum ? null : ${u}`, force: !0 }
          ]
        });
      }
    }
    return n;
  },
  signals: (e, t, n) => {
    const r = t.name, i = t.project, o = n.find((p) => p.name === r + bw), a = r + $4, s = i.items.filter((p) => p.hasLegend).map((p) => oa(`${r}_${oa(p.field)}_legend`)), l = `${s.map((p) => `${p} !== null`).join(" && ")} ? {fields: ${a}, values: [${s.join(", ")}]} : null`;
    t.events && s.length > 0 ? o.on.push({
      events: s.map((p) => ({ signal: p })),
      update: l
    }) : s.length > 0 && (o.update = l, delete o.value, delete o.on);
    const f = n.find((p) => p.name === r + _z), h = AV(t.bind) && t.bind.legend;
    return f && (t.events ? f.on.push({ ...f.on[0], events: h }) : f.on[0].events = h), n;
  }
};
function uLt(e, t, n) {
  var i;
  const r = (i = e.fieldDef(t)) == null ? void 0 : i.field;
  for (const o of il(e.component.selection ?? {})) {
    const a = o.project.hasField[r] ?? o.project.hasChannel[t];
    if (a && WPe.defined(o)) {
      const s = n.get("selections") ?? [];
      s.push(o.name), n.set("selections", s, !1), a.hasLegend = !0;
    }
  }
}
const qPe = "_translate_anchor", GPe = "_translate_delta", lLt = {
  defined: (e) => e.type === "interval" && e.translate,
  signals: (e, t, n) => {
    const r = t.name, i = rb.defined(t), o = r + qPe, { x: a, y: s } = t.project.hasChannel;
    let u = jw(t.translate, "scope");
    return i || (u = u.map((l) => (l.between[0].markname = r + FT, l))), n.push({
      name: o,
      value: {},
      on: [
        {
          events: u.map((l) => l.between[0]),
          update: "{x: x(unit), y: y(unit)" + (a !== void 0 ? `, extent_x: ${i ? lX(e, aa) : `slice(${a.signals.visual})`}` : "") + (s !== void 0 ? `, extent_y: ${i ? lX(e, _u) : `slice(${s.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: r + GPe,
      value: {},
      on: [
        {
          events: u,
          update: `{x: ${o}.x - x(unit), y: ${o}.y - y(unit)}`
        }
      ]
    }), a !== void 0 && Gye(e, t, a, "width", n), s !== void 0 && Gye(e, t, s, "height", n), n;
  }
};
function Gye(e, t, n, r, i) {
  const o = t.name, a = o + qPe, s = o + GPe, u = n.channel, l = rb.defined(t), f = i.filter((R) => R.name === n.signals[l ? "data" : "visual"])[0], h = e.getSizeSignalRef(r).signal, p = e.getScaleComponent(u), g = p && p.get("type"), y = p && p.get("reverse"), b = l ? u === aa ? y ? "" : "-" : y ? "-" : "" : "", _ = `${a}.extent_${u}`, S = `${b}${s}.${u} / ${l ? `${h}` : `span(${_})`}`, C = !l || !p ? "panLinear" : g === "log" ? "panLog" : g === "symlog" ? "panSymlog" : g === "pow" ? "panPow" : "panLinear", A = l ? g === "pow" ? `, ${p.get("exponent") ?? 1}` : g === "symlog" ? `, ${p.get("constant") ?? 1}` : "" : "", O = `${C}(${_}, ${S}${A})`;
  f.on.push({
    events: { signal: s },
    update: l ? O : `clampRange(${O}, 0, ${h})`
  });
}
const QPe = "_zoom_anchor", XPe = "_zoom_delta", cLt = {
  defined: (e) => e.type === "interval" && e.zoom,
  signals: (e, t, n) => {
    const r = t.name, i = rb.defined(t), o = r + XPe, { x: a, y: s } = t.project.hasChannel, u = Et(e.scaleName(aa)), l = Et(e.scaleName(_u));
    let f = jw(t.zoom, "scope");
    return i || (f = f.map((h) => (h.markname = r + FT, h))), n.push({
      name: r + QPe,
      on: [
        {
          events: f,
          update: i ? "{" + [u ? `x: invert(${u}, x(unit))` : "", l ? `y: invert(${l}, y(unit))` : ""].filter((h) => h).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
        }
      ]
    }, {
      name: o,
      on: [
        {
          events: f,
          force: !0,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    }), a !== void 0 && Qye(e, t, a, "width", n), s !== void 0 && Qye(e, t, s, "height", n), n;
  }
};
function Qye(e, t, n, r, i) {
  const o = t.name, a = n.channel, s = rb.defined(t), u = i.filter((C) => C.name === n.signals[s ? "data" : "visual"])[0], l = e.getSizeSignalRef(r).signal, f = e.getScaleComponent(a), h = f && f.get("type"), p = s ? lX(e, a) : u.name, g = o + XPe, y = `${o}${QPe}.${a}`, b = !s || !f ? "zoomLinear" : h === "log" ? "zoomLog" : h === "symlog" ? "zoomSymlog" : h === "pow" ? "zoomPow" : "zoomLinear", _ = s ? h === "pow" ? `, ${f.get("exponent") ?? 1}` : h === "symlog" ? `, ${f.get("constant") ?? 1}` : "" : "", S = `${b}(${p}, ${y}, ${g}${_})`;
  u.on.push({
    events: { signal: g },
    update: s ? S : `clampRange(${S}, 0, ${l})`
  });
}
const GS = "_store", bw = "_tuple", fLt = "_modify", KPe = "vlSelectionResolve", q8 = [
  Hjt,
  Ujt,
  Fjt,
  VPe,
  // Bindings may disable direct manipulation.
  HPe,
  rb,
  WPe,
  sLt,
  lLt,
  cLt,
  YPe
];
function dLt(e) {
  let t = e.parent;
  for (; t && !Id(t); )
    t = t.parent;
  return t;
}
function lS(e, { escape: t } = { escape: !0 }) {
  let n = t ? Et(e.name) : e.name;
  const r = dLt(e);
  if (r) {
    const { facet: i } = r;
    for (const o of rp)
      i[o] && (n += ` + '__facet_${o}_' + (facet[${Et(r.vgField(o))}])`);
  }
  return n;
}
function xie(e) {
  return il(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
}
function ZPe(e, t) {
  (kt(t.select) || !t.select.on) && delete e.events, (kt(t.select) || !t.select.clear) && delete e.clear, (kt(t.select) || !t.select.toggle) && delete e.toggle;
}
function cX(e) {
  const t = [];
  return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...cX(e.object)), t.push(...cX(e.property))), t);
}
function JPe(e) {
  return e.object.type === "MemberExpression" ? JPe(e.object) : e.object.name === "datum";
}
function eIe(e) {
  const t = Fne(e), n = /* @__PURE__ */ new Set();
  return t.visit((r) => {
    r.type === "MemberExpression" && JPe(r) && n.add(cX(r).slice(1).join("."));
  }), n;
}
class BN extends oo {
  clone() {
    return new BN(null, this.model, Kn(this.filter));
  }
  constructor(t, n, r) {
    super(t), this.model = n, this.filter = r, this.expr = Ez(this.model, this.filter, this), this._dependentFields = eIe(this.expr);
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
}
function hLt(e, t) {
  const n = {}, r = e.config.selection;
  if (!t || !t.length)
    return n;
  for (const i of t) {
    const o = oa(i.name), a = i.select, s = kt(a) ? a : a.type, u = Pt(a) ? Kn(a) : { type: s }, l = r[s];
    for (const p in l)
      p === "fields" || p === "encodings" || (p === "mark" && (u[p] = { ...l[p], ...u[p] }), (u[p] === void 0 || u[p] === !0) && (u[p] = Kn(l[p] ?? u[p])));
    const f = n[o] = {
      ...u,
      name: o,
      type: s,
      init: i.value,
      bind: i.bind,
      events: kt(u.on) ? jw(u.on, "scope") : Rt(Kn(u.on))
    }, h = Kn(i);
    for (const p of q8)
      p.defined(f) && p.parse && p.parse(e, f, h);
  }
  return n;
}
function tIe(e, t, n, r = "datum") {
  const i = kt(t) ? t : t.param, o = oa(i), a = Et(o + GS);
  let s;
  try {
    s = e.getSelectionComponent(o, i);
  } catch {
    return `!!${o}`;
  }
  if (s.project.timeUnit) {
    const p = n ?? e.component.data.raw, g = s.project.timeUnit.clone();
    p.parent ? g.insertAsParentOf(p) : p.parent = g;
  }
  const u = s.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(", l = s.resolve === "global" ? ")" : `, ${Et(s.resolve)})`, f = `${u}${a}, ${r}${l}`, h = `length(data(${a}))`;
  return t.empty === !1 ? `${h} && ${f}` : `!${h} || ${f}`;
}
function nIe(e, t, n) {
  const r = oa(t), i = n.encoding;
  let o = n.field, a;
  try {
    a = e.getSelectionComponent(r, t);
  } catch {
    return r;
  }
  if (!i && !o)
    o = a.project.items[0].field, a.project.items.length > 1 && bt(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${Et(o)}.`);
  else if (i && !o) {
    const s = a.project.items.filter((u) => u.channel === i);
    !s.length || s.length > 1 ? (o = a.project.items[0].field, bt((s.length ? "Multiple " : "No ") + `matching ${Et(i)} encoding found for selection ${Et(n.param)}. Using "field": ${Et(o)}.`)) : o = s[0].field;
  }
  return `${a.name}[${Et(_p(o))}]`;
}
function pLt(e, t) {
  for (const [n, r] of pw(e.component.selection ?? {})) {
    const i = e.getName(`lookup_${n}`);
    e.component.data.outputNodes[i] = r.materialized = new Mf(new BN(t, e, { param: n }), i, ra.Lookup, e.component.data.outputNodeRefCounts);
  }
}
function Ez(e, t, n) {
  return WR(t, (r) => kt(r) ? r : VPt(r) ? tIe(e, r, n) : v4e(r));
}
function gLt(e, t) {
  if (e)
    return nt(e) && !gx(e) ? e.map((n) => eie(n, t)).join(", ") : e;
}
function PV(e, t, n, r) {
  var i, o;
  e.encode ?? (e.encode = {}), (i = e.encode)[t] ?? (i[t] = {}), (o = e.encode[t]).update ?? (o.update = {}), e.encode[t].update[n] = r;
}
function iR(e, t, n, r = { header: !1 }) {
  var h, p;
  const { disable: i, orient: o, scale: a, labelExpr: s, title: u, zindex: l, ...f } = e.combine();
  if (!i) {
    for (const g in f) {
      const y = GIt[g], b = f[g];
      if (y && y !== t && y !== "both")
        delete f[g];
      else if (k4(b)) {
        const { condition: _, ...S } = b, C = Rt(_), A = Eye[g];
        if (A) {
          const { vgProp: O, part: R } = A, j = [
            ...C.map(($) => {
              const { test: z, ...W } = $;
              return {
                test: Ez(null, z),
                ...W
              };
            }),
            S
          ];
          PV(f, R, O, j), delete f[g];
        } else if (A === null) {
          const O = {
            signal: C.map((R) => {
              const { test: j, ...$ } = R;
              return `${Ez(null, j)} ? ${sye($)} : `;
            }).join("") + sye(S)
          };
          f[g] = O;
        }
      } else if (an(b)) {
        const _ = Eye[g];
        if (_) {
          const { vgProp: S, part: C } = _;
          PV(f, C, S, b), delete f[g];
        }
      }
      Kr(["labelAlign", "labelBaseline"], g) && f[g] === null && delete f[g];
    }
    if (t === "grid") {
      if (!f.grid)
        return;
      if (f.encode) {
        const { grid: g } = f.encode;
        f.encode = {
          ...g ? { grid: g } : {}
        }, go(f.encode) && delete f.encode;
      }
      return {
        scale: a,
        orient: o,
        ...f,
        domain: !1,
        labels: !1,
        aria: !1,
        // always hide grid axis
        // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
        // would not affect gridAxis
        maxExtent: 0,
        minExtent: 0,
        ticks: !1,
        zindex: rs(l, 0)
        // put grid behind marks by default
      };
    } else {
      if (!r.header && e.mainExtracted)
        return;
      if (s !== void 0) {
        let y = s;
        (p = (h = f.encode) == null ? void 0 : h.labels) != null && p.update && an(f.encode.labels.update.text) && (y = BS(s, "datum.label", f.encode.labels.update.text.signal)), PV(f, "labels", "text", { signal: y });
      }
      if (f.labelAlign === null && delete f.labelAlign, f.encode) {
        for (const y of G4e)
          e.hasAxisPart(y) || delete f.encode[y];
        go(f.encode) && delete f.encode;
      }
      const g = gLt(u, n);
      return {
        scale: a,
        orient: o,
        grid: !1,
        ...g ? { title: g } : {},
        ...f,
        ...n.aria === !1 ? { aria: !1 } : {},
        zindex: rs(l, 0)
        // put axis line above marks by default
      };
    }
  }
}
function rIe(e) {
  const { axes: t } = e.component, n = [];
  for (const r of mv)
    if (t[r]) {
      for (const i of t[r])
        if (!i.get("disable") && !i.get("gridScale")) {
          const o = r === "x" ? "height" : "width", a = e.getSizeSignalRef(o).signal;
          o !== a && n.push({
            name: o,
            update: a
          });
        }
    }
  return n;
}
function mLt(e, t) {
  const { x: n = [], y: r = [] } = e;
  return [
    ...n.map((i) => iR(i, "grid", t)),
    ...r.map((i) => iR(i, "grid", t)),
    ...n.map((i) => iR(i, "main", t)),
    ...r.map((i) => iR(i, "main", t))
  ].filter((i) => i);
}
function Xye(e, t, n, r) {
  return Object.assign.apply(null, [
    {},
    ...e.map((i) => {
      if (i === "axisOrient") {
        const o = n === "x" ? "bottom" : "left", a = t[n === "x" ? "axisBottom" : "axisLeft"] || {}, s = t[n === "x" ? "axisTop" : "axisRight"] || {}, u = /* @__PURE__ */ new Set([...yt(a), ...yt(s)]), l = {};
        for (const f of u.values())
          l[f] = {
            // orient is surely signal in this case
            signal: `${r.signal} === "${o}" ? ${Ig(a[f])} : ${Ig(s[f])}`
          };
        return l;
      }
      return t[i];
    })
  ]);
}
function yLt(e, t, n, r) {
  const i = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : _4e(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [], o = e === "x" ? "axisX" : "axisY", a = an(n) ? "axisOrient" : `axis${E4(n)}`, s = [
    // technically Vega does have axisBand, but if we make another separation here,
    // it will further introduce complexity in the code
    ...i,
    ...i.map((l) => o + l.substr(4))
  ], u = ["axis", a, o];
  return {
    vlOnlyAxisConfig: Xye(s, r, e, n),
    vgAxisConfig: Xye(u, r, e, n),
    axisConfigStyle: vLt([...u, ...s], r)
  };
}
function vLt(e, t) {
  var r;
  const n = [{}];
  for (const i of e) {
    let o = (r = t[i]) == null ? void 0 : r.style;
    if (o) {
      o = Rt(o);
      for (const a of o)
        n.push(t.style[a]);
    }
  }
  return Object.assign.apply(null, n);
}
function fX(e, t, n, r = {}) {
  var o;
  const i = X$e(e, n, t);
  if (i !== void 0)
    return {
      configFrom: "style",
      configValue: i
    };
  for (const a of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
    if (((o = r[a]) == null ? void 0 : o[e]) !== void 0)
      return { configFrom: a, configValue: r[a][e] };
  return {};
}
const Kye = {
  scale: ({ model: e, channel: t }) => e.scaleName(t),
  format: ({ format: e }) => e,
  // we already calculate this in parse
  formatType: ({ formatType: e }) => e,
  // we already calculate this in parse
  grid: ({ fieldOrDatumDef: e, axis: t, scaleType: n }) => t.grid ?? bLt(n, e),
  gridScale: ({ model: e, channel: t }) => xLt(e, t),
  labelAlign: ({ axis: e, labelAngle: t, orient: n, channel: r }) => e.labelAlign || oIe(t, n, r),
  labelAngle: ({ labelAngle: e }) => e,
  // we already calculate this in parse
  labelBaseline: ({ axis: e, labelAngle: t, orient: n, channel: r }) => e.labelBaseline || iIe(t, n, r),
  labelFlush: ({ axis: e, fieldOrDatumDef: t, channel: n }) => e.labelFlush ?? _Lt(t.type, n),
  labelOverlap: ({ axis: e, fieldOrDatumDef: t, scaleType: n }) => e.labelOverlap ?? ELt(t.type, n, xt(t) && !!t.timeUnit, xt(t) ? t.sort : void 0),
  // we already calculate orient in parse
  orient: ({ orient: e }) => e,
  // Need to cast until Vega supports signal
  tickCount: ({ channel: e, model: t, axis: n, fieldOrDatumDef: r, scaleType: i }) => {
    const o = e === "x" ? "width" : e === "y" ? "height" : void 0, a = o ? t.getSizeSignalRef(o) : void 0;
    return n.tickCount ?? MLt({ fieldOrDatumDef: r, scaleType: i, size: a, values: n.values });
  },
  tickMinStep: TLt,
  title: ({ axis: e, model: t, channel: n }) => {
    if (e.title !== void 0)
      return e.title;
    const r = aIe(t, n);
    if (r !== void 0)
      return r;
    const i = t.typedFieldDef(n), o = n === "x" ? "x2" : "y2", a = t.fieldDef(o);
    return Z$e(i ? [wye(i)] : [], xt(a) ? [wye(a)] : []);
  },
  values: ({ axis: e, fieldOrDatumDef: t }) => CLt(e, t),
  zindex: ({ axis: e, fieldOrDatumDef: t, mark: n }) => e.zindex ?? NLt(n, t)
};
function bLt(e, t) {
  return !xu(e) && xt(t) && !Lo(t == null ? void 0 : t.bin) && !Qu(t == null ? void 0 : t.bin);
}
function xLt(e, t) {
  const n = t === "x" ? "y" : "x";
  if (e.getScaleComponent(n))
    return e.scaleName(n);
}
function wLt(e, t, n, r, i) {
  const o = t == null ? void 0 : t.labelAngle;
  if (o !== void 0)
    return an(o) ? o : s$(o);
  {
    const { configValue: a } = fX("labelAngle", r, t == null ? void 0 : t.style, i);
    return a !== void 0 ? s$(a) : n === aa && Kr([Yre, Ure], e.type) && !(xt(e) && e.timeUnit) ? 270 : void 0;
  }
}
function dX(e) {
  return `(((${e.signal} % 360) + 360) % 360)`;
}
function iIe(e, t, n, r) {
  if (e !== void 0)
    if (n === "x") {
      if (an(e)) {
        const i = dX(e), o = an(t) ? `(${t.signal} === "top")` : t === "top";
        return {
          signal: `(45 < ${i} && ${i} < 135) || (225 < ${i} && ${i} < 315) ? "middle" :(${i} <= 45 || 315 <= ${i}) === ${o} ? "bottom" : "top"`
        };
      }
      if (45 < e && e < 135 || 225 < e && e < 315)
        return "middle";
      if (an(t)) {
        const i = e <= 45 || 315 <= e ? "===" : "!==";
        return { signal: `${t.signal} ${i} "top" ? "bottom" : "top"` };
      }
      return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top";
    } else {
      if (an(e)) {
        const i = dX(e), o = an(t) ? `(${t.signal} === "left")` : t === "left";
        return {
          signal: `${i} <= 45 || 315 <= ${i} || (135 <= ${i} && ${i} <= 225) ? ${r ? '"middle"' : "null"} : (45 <= ${i} && ${i} <= 135) === ${o} ? "top" : "bottom"`
        };
      }
      if (e <= 45 || 315 <= e || 135 <= e && e <= 225)
        return r ? "middle" : null;
      if (an(t)) {
        const i = 45 <= e && e <= 135 ? "===" : "!==";
        return { signal: `${t.signal} ${i} "left" ? "top" : "bottom"` };
      }
      return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom";
    }
}
function oIe(e, t, n) {
  if (e === void 0)
    return;
  const r = n === "x", i = r ? 0 : 90, o = r ? "bottom" : "left";
  if (an(e)) {
    const a = dX(e), s = an(t) ? `(${t.signal} === "${o}")` : t === o;
    return {
      signal: `(${i ? `(${a} + 90)` : a} % 180 === 0) ? ${r ? null : '"center"'} :(${i} < ${a} && ${a} < ${180 + i}) === ${s} ? "left" : "right"`
    };
  }
  if ((e + i) % 180 === 0)
    return r ? null : "center";
  if (an(t)) {
    const a = i < e && e < 180 + i ? "===" : "!==";
    return {
      signal: `${`${t.signal} ${a} "${o}"`} ? "left" : "right"`
    };
  }
  return (i < e && e < 180 + i) == (t === o) ? "left" : "right";
}
function _Lt(e, t) {
  if (t === "x" && Kr(["quantitative", "temporal"], e))
    return !0;
}
function ELt(e, t, n, r) {
  if (n && !Pt(r) || e !== "nominal" && e !== "ordinal")
    return t === "log" || t === "symlog" ? "greedy" : !0;
}
function SLt(e) {
  return e === "x" ? "bottom" : "left";
}
function MLt({ fieldOrDatumDef: e, scaleType: t, size: n, values: r }) {
  var i;
  if (!r && !xu(t) && t !== "log") {
    if (xt(e)) {
      if (Lo(e.bin))
        return { signal: `ceil(${n.signal}/10)` };
      if (e.timeUnit && Kr(["month", "hours", "day", "quarter"], (i = bu(e.timeUnit)) == null ? void 0 : i.unit))
        return;
    }
    return { signal: `ceil(${n.signal}/40)` };
  }
}
function TLt({ format: e, fieldOrDatumDef: t }) {
  if (e === "d")
    return 1;
  if (xt(t)) {
    const { timeUnit: n } = t;
    if (n) {
      const r = g4e(n);
      if (r)
        return { signal: r };
    }
  }
}
function aIe(e, t) {
  const n = t === "x" ? "x2" : "y2", r = e.fieldDef(t), i = e.fieldDef(n), o = r ? r.title : void 0, a = i ? i.title : void 0;
  if (o && a)
    return J$e(o, a);
  if (o)
    return o;
  if (a)
    return a;
  if (o !== void 0)
    return o;
  if (a !== void 0)
    return a;
}
function CLt(e, t) {
  const n = e.values;
  if (nt(n))
    return q4e(t, n);
  if (an(n))
    return n;
}
function NLt(e, t) {
  return e === "rect" && gz(t) ? 1 : 0;
}
class GC extends oo {
  clone() {
    return new GC(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this._dependentFields = eIe(this.transform.calculate);
  }
  static parseAllForSortIndex(t, n) {
    return n.forEachFieldDef((r, i) => {
      if (m2(r) && j4e(r.sort)) {
        const { field: o, timeUnit: a } = r, s = r.sort, u = s.map((l, f) => `${v4e({ field: o, timeUnit: a, equal: l })} ? ${f} : `).join("") + s.length;
        t = new GC(t, {
          calculate: u,
          as: QC(r, i, { forAs: !0 })
        });
      }
    }), t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${Xr(this.transform)}`;
  }
}
function QC(e, t, n) {
  return Mt(e, { prefix: t, suffix: "sort_index", ...n });
}
function G8(e, t) {
  return Kr(["top", "bottom"], t) ? "column" : Kr(["left", "right"], t) || e === "row" ? "row" : "column";
}
function XC(e, t, n, r) {
  const i = r === "row" ? n.headerRow : r === "column" ? n.headerColumn : n.headerFacet;
  return rs((t || {})[e], i[e], n.header[e]);
}
function Q8(e, t, n, r) {
  const i = {};
  for (const o of e) {
    const a = XC(o, t || {}, n, r);
    a !== void 0 && (i[o] = a);
  }
  return i;
}
const wie = ["row", "column"], _ie = ["header", "footer"];
function DLt(e, t) {
  const n = e.component.layoutHeaders[t].title, r = e.config ? e.config : void 0, i = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0, { titleAnchor: o, titleAngle: a, titleOrient: s } = Q8(["titleAnchor", "titleAngle", "titleOrient"], i.header, r, t), u = G8(t, s), l = s$(a);
  return {
    name: `${t}-title`,
    type: "group",
    role: `${u}-title`,
    title: {
      text: n,
      ...t === "row" ? { orient: "left" } : {},
      style: "guide-title",
      ...uIe(l, u),
      ...sIe(u, l, o),
      ...lIe(r, i, t, m3t, fPe)
    }
  };
}
function sIe(e, t, n = "middle") {
  switch (n) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const r = oIe(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
  return r ? { align: r } : {};
}
function uIe(e, t) {
  const n = iIe(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
  return n ? { baseline: n } : {};
}
function ALt(e, t) {
  const n = e.component.layoutHeaders[t], r = [];
  for (const i of _ie)
    if (n[i])
      for (const o of n[i]) {
        const a = RLt(e, t, i, n, o);
        a != null && r.push(a);
      }
  return r;
}
function OLt(e, t) {
  const { sort: n } = e;
  return Uy(n) ? {
    field: Mt(n, { expr: "datum" }),
    order: n.order ?? "ascending"
  } : nt(n) ? {
    field: QC(e, t, { expr: "datum" }),
    order: "ascending"
  } : {
    field: Mt(e, { expr: "datum" }),
    order: n ?? "ascending"
  };
}
function hX(e, t, n) {
  const { format: r, formatType: i, labelAngle: o, labelAnchor: a, labelOrient: s, labelExpr: u } = Q8(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), l = qre({
    fieldOrDatumDef: e,
    format: r,
    formatType: i,
    expr: "parent",
    config: n
  }).signal, f = G8(t, s);
  return {
    text: {
      signal: u ? BS(BS(u, "datum.label", l), "datum.value", Mt(e, { expr: "parent" })) : l
    },
    ...t === "row" ? { orient: "left" } : {},
    style: "guide-label",
    frame: "group",
    ...uIe(o, f),
    ...sIe(f, o, a),
    ...lIe(n, e, t, y3t, dPe)
  };
}
function RLt(e, t, n, r, i) {
  if (i) {
    let o = null;
    const { facetFieldDef: a } = r, s = e.config ? e.config : void 0;
    if (a && i.labels) {
      const { labelOrient: h } = Q8(["labelOrient"], a.header, s, t);
      (t === "row" && !Kr(["top", "bottom"], h) || t === "column" && !Kr(["left", "right"], h)) && (o = hX(a, t, s));
    }
    const u = Id(e) && !A4(e.facet), l = i.axes, f = (l == null ? void 0 : l.length) > 0;
    if (o || f) {
      const h = t === "row" ? "height" : "width";
      return {
        name: e.getName(`${t}_${n}`),
        type: "group",
        role: `${t}-${n}`,
        ...r.facetFieldDef ? {
          from: { data: e.getName(`${t}_domain`) },
          sort: OLt(a, t)
        } : {},
        ...f && u ? {
          from: { data: e.getName(`facet_domain_${t}`) }
        } : {},
        ...o ? { title: o } : {},
        ...i.sizeSignal ? {
          encode: {
            update: {
              [h]: i.sizeSignal
            }
          }
        } : {},
        ...f ? { axes: l } : {}
      };
    }
  }
  return null;
}
const kLt = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function $Lt(e, t) {
  return kLt[t][e];
}
function PLt(e, t) {
  const n = {};
  for (const r of rp) {
    const i = e[r];
    if (i != null && i.facetFieldDef) {
      const { titleAnchor: o, titleOrient: a } = Q8(["titleAnchor", "titleOrient"], i.facetFieldDef.header, t, r), s = G8(r, a), u = $Lt(o, s);
      u !== void 0 && (n[s] = u);
    }
  }
  return go(n) ? void 0 : n;
}
function lIe(e, t, n, r, i) {
  const o = {};
  for (const a of r) {
    if (!i[a])
      continue;
    const s = XC(a, t == null ? void 0 : t.header, e, n);
    s !== void 0 && (o[i[a]] = s);
  }
  return o;
}
function Eie(e) {
  return [
    ...j3(e, "width"),
    ...j3(e, "height"),
    ...j3(e, "childWidth"),
    ...j3(e, "childHeight")
  ];
}
function j3(e, t) {
  const n = t === "width" ? "x" : "y", r = e.component.layoutSize.get(t);
  if (!r || r === "merged")
    return [];
  const i = e.getSizeSignalRef(t).signal;
  if (r === "step") {
    const o = e.getScaleComponent(n);
    if (o) {
      const a = o.get("type"), s = o.get("range");
      if (xu(a) && Hw(s)) {
        const u = e.scaleName(n);
        return Id(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [Zye(u, s)] : [
          Zye(u, s),
          {
            name: i,
            update: cIe(u, o, `domain('${u}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (r == "container") {
    const o = i.endsWith("width"), a = o ? "containerSize()[0]" : "containerSize()[1]", s = oX(e.config.view, o ? "width" : "height"), u = `isFinite(${a}) ? ${a} : ${s}`;
    return [{ name: i, init: u, on: [{ update: u, events: "window:resize" }] }];
  } else
    return [
      {
        name: i,
        value: r
      }
    ];
}
function Zye(e, t) {
  const n = `${e}_step`;
  return an(t.step) ? { name: n, update: t.step.signal } : { name: n, value: t.step };
}
function cIe(e, t, n) {
  const r = t.get("type"), i = t.get("padding"), o = rs(t.get("paddingOuter"), i);
  let a = t.get("paddingInner");
  return a = r === "band" ? (
    // only band has real paddingInner
    a !== void 0 ? a : i
  ) : (
    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
    1
  ), `bandspace(${n}, ${Ig(a)}, ${Ig(o)}) * ${e}_step`;
}
function fIe(e) {
  return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e;
}
function dIe(e, t) {
  return yt(e).reduce((n, r) => {
    const i = e[r];
    return {
      ...n,
      ...FN(t, i, r, (o) => Vo(o.value))
    };
  }, {});
}
function hIe(e, t) {
  if (Id(t))
    return e === "theta" ? "independent" : "shared";
  if (HN(t))
    return "shared";
  if (Aie(t))
    return is(e) || e === "theta" || e === "radius" ? "independent" : "shared";
  throw new Error("invalid model type for resolve");
}
function Sie(e, t) {
  const n = e.scale[t], r = is(t) ? "axis" : "legend";
  return n === "independent" ? (e[r][t] === "shared" && bt(hPt(t)), "independent") : e[r][t] || "shared";
}
const ILt = {
  ...x3t,
  disable: 1,
  labelExpr: 1,
  selections: 1,
  // channel scales
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  // encode
  encode: 1
}, pIe = yt(ILt);
class jLt extends kb {
}
const Jye = {
  symbols: LLt,
  gradient: zLt,
  labels: FLt,
  entries: BLt
};
function LLt(e, { fieldOrDatumDef: t, model: n, channel: r, legendCmpt: i, legendType: o }) {
  if (o !== "symbol")
    return;
  const { markDef: a, encoding: s, config: u, mark: l } = n, f = a.filled && l !== "trail";
  let h = {
    ...S4t({}, n, EIt),
    ...FPe(n, { filled: f })
  };
  const p = i.get("symbolOpacity") ?? u.legend.symbolOpacity, g = i.get("symbolFillColor") ?? u.legend.symbolFillColor, y = i.get("symbolStrokeColor") ?? u.legend.symbolStrokeColor, b = p === void 0 ? gIe(s.opacity) ?? a.opacity : void 0;
  if (h.fill) {
    if (r === "fill" || f && r === Pf)
      delete h.fill;
    else if (h.fill.field)
      g ? delete h.fill : (h.fill = Vo(u.legend.symbolBaseFillColor ?? "black"), h.fillOpacity = Vo(b ?? 1));
    else if (nt(h.fill)) {
      const _ = pX(s.fill ?? s.color) ?? a.fill ?? (f && a.color);
      _ && (h.fill = Vo(_));
    }
  }
  if (h.stroke) {
    if (r === "stroke" || !f && r === Pf)
      delete h.stroke;
    else if (h.stroke.field || y)
      delete h.stroke;
    else if (nt(h.stroke)) {
      const _ = rs(pX(s.stroke || s.color), a.stroke, f ? a.color : void 0);
      _ && (h.stroke = { value: _ });
    }
  }
  if (r !== Ab) {
    const _ = xt(t) && yIe(n, i, t);
    _ ? h.opacity = [
      { test: _, ...Vo(b ?? 1) },
      Vo(u.legend.unselectedOpacity)
    ] : b && (h.opacity = Vo(b));
  }
  return h = { ...h, ...e }, go(h) ? void 0 : h;
}
function zLt(e, { model: t, legendType: n, legendCmpt: r }) {
  if (n !== "gradient")
    return;
  const { config: i, markDef: o, encoding: a } = t;
  let s = {};
  const l = (r.get("gradientOpacity") ?? i.legend.gradientOpacity) === void 0 ? gIe(a.opacity) || o.opacity : void 0;
  return l && (s.opacity = Vo(l)), s = { ...s, ...e }, go(s) ? void 0 : s;
}
function FLt(e, { fieldOrDatumDef: t, model: n, channel: r, legendCmpt: i }) {
  const o = n.legend(r) || {}, a = n.config, s = xt(t) ? yIe(n, i, t) : void 0, u = s ? [{ test: s, value: 1 }, { value: a.legend.unselectedOpacity }] : void 0, { format: l, formatType: f } = o;
  let h;
  VS(f) ? h = Lg({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: l,
    formatType: f,
    config: a
  }) : l === void 0 && f === void 0 && a.customFormatTypes && (t.type === "quantitative" && a.numberFormatType ? h = Lg({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: a.numberFormat,
    formatType: a.numberFormatType,
    config: a
  }) : t.type === "temporal" && a.timeFormatType && xt(t) && t.timeUnit === void 0 && (h = Lg({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: a.timeFormat,
    formatType: a.timeFormatType,
    config: a
  })));
  const p = {
    ...u ? { opacity: u } : {},
    ...h ? { text: h } : {},
    ...e
  };
  return go(p) ? void 0 : p;
}
function BLt(e, { legendCmpt: t }) {
  const n = t.get("selections");
  return n != null && n.length ? { ...e, fill: { value: "transparent" } } : e;
}
function gIe(e) {
  return mIe(e, (t, n) => Math.max(t, n.value));
}
function pX(e) {
  return mIe(e, (t, n) => rs(t, n.value));
}
function mIe(e, t) {
  if (IIt(e))
    return Rt(e.condition).reduce(t, e.value);
  if (Qg(e))
    return e.value;
}
function yIe(e, t, n) {
  const r = t.get("selections");
  if (!(r != null && r.length))
    return;
  const i = Et(n.field);
  return r.map((o) => `(!length(data(${Et(oa(o) + GS)})) || (${o}[${i}] && indexof(${o}[${i}], datum.value) >= 0))`).join(" || ");
}
const eve = {
  direction: ({ direction: e }) => e,
  format: ({ fieldOrDatumDef: e, legend: t, config: n }) => {
    const { format: r, formatType: i } = t;
    return N4e(e, e.type, r, i, n, !1);
  },
  formatType: ({ legend: e, fieldOrDatumDef: t, scaleType: n }) => {
    const { formatType: r } = e;
    return D4e(r, t, n);
  },
  gradientLength: (e) => {
    const { legend: t, legendConfig: n } = e;
    return t.gradientLength ?? n.gradientLength ?? GLt(e);
  },
  labelOverlap: ({ legend: e, legendConfig: t, scaleType: n }) => e.labelOverlap ?? t.labelOverlap ?? QLt(n),
  symbolType: ({ legend: e, markDef: t, channel: n, encoding: r }) => e.symbolType ?? YLt(t.type, n, r.shape, t.shape),
  title: ({ fieldOrDatumDef: e, config: t }) => zT(e, t, { allowDisabling: !0 }),
  type: ({ legendType: e, scaleType: t, channel: n }) => {
    if (LT(n) && jg(t)) {
      if (e === "gradient")
        return;
    } else if (e === "symbol")
      return;
    return e;
  },
  // depended by other property, let's define upfront
  values: ({ fieldOrDatumDef: e, legend: t }) => ULt(t, e)
};
function ULt(e, t) {
  const n = e.values;
  if (nt(n))
    return q4e(t, n);
  if (an(n))
    return n;
}
function YLt(e, t, n, r) {
  if (t !== "shape") {
    const i = pX(n) ?? r;
    if (i)
      return i;
  }
  switch (e) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function HLt(e) {
  const { legend: t } = e;
  return rs(t.type, VLt(e));
}
function VLt({ channel: e, timeUnit: t, scaleType: n }) {
  if (LT(e)) {
    if (Kr(["quarter", "month", "day"], t))
      return "symbol";
    if (jg(n))
      return "gradient";
  }
  return "symbol";
}
function WLt({ legendConfig: e, legendType: t, orient: n, legend: r }) {
  return r.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? qLt(n, t);
}
function qLt(e, t) {
  switch (e) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return;
    default:
      return t === "gradient" ? "horizontal" : void 0;
  }
}
function GLt({ legendConfig: e, model: t, direction: n, orient: r, scaleType: i }) {
  const { gradientHorizontalMaxLength: o, gradientHorizontalMinLength: a, gradientVerticalMaxLength: s, gradientVerticalMinLength: u } = e;
  if (jg(i))
    return n === "horizontal" ? r === "top" || r === "bottom" ? tve(t, "width", a, o) : a : tve(t, "height", u, s);
}
function tve(e, t, n, r) {
  return { signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${r})` };
}
function QLt(e) {
  if (Kr(["quantile", "threshold", "log", "symlog"], e))
    return "greedy";
}
function vIe(e) {
  const t = za(e) ? XLt(e) : e5t(e);
  return e.component.legends = t, t;
}
function XLt(e) {
  const { encoding: t } = e, n = {};
  for (const r of [Pf, ...pPe]) {
    const i = Hs(t[r]);
    !i || !e.getScaleComponent(r) || r === If && xt(i) && i.type === zN || (n[r] = JLt(e, r));
  }
  return n;
}
function KLt(e, t) {
  const n = e.scaleName(t);
  if (e.mark === "trail") {
    if (t === "color")
      return { stroke: n };
    if (t === "size")
      return { strokeWidth: n };
  }
  return t === "color" ? e.markDef.filled ? { fill: n } : { stroke: n } : { [t]: n };
}
function ZLt(e, t, n, r) {
  switch (t) {
    case "disable":
      return n !== void 0;
    case "values":
      return !!(n != null && n.values);
    case "title":
      if (t === "title" && e === (r == null ? void 0 : r.title))
        return !0;
  }
  return e === (n || {})[t];
}
function JLt(e, t) {
  var O;
  let n = e.legend(t);
  const { markDef: r, encoding: i, config: o } = e, a = o.legend, s = new jLt({}, KLt(e, t));
  uLt(e, t, s);
  const u = n !== void 0 ? !n : a.disable;
  if (s.set("disable", u, n !== void 0), u)
    return s;
  n = n || {};
  const l = e.getScaleComponent(t).get("type"), f = Hs(i[t]), h = xt(f) ? (O = bu(f.timeUnit)) == null ? void 0 : O.unit : void 0, p = n.orient || o.legend.orient || "right", g = HLt({ legend: n, channel: t, timeUnit: h, scaleType: l }), y = WLt({ legend: n, legendType: g, orient: p, legendConfig: a }), b = {
    legend: n,
    channel: t,
    model: e,
    markDef: r,
    encoding: i,
    fieldOrDatumDef: f,
    legendConfig: a,
    config: o,
    scaleType: l,
    orient: p,
    legendType: g,
    direction: y
  };
  for (const R of pIe) {
    if (g === "gradient" && R.startsWith("symbol") || g === "symbol" && R.startsWith("gradient"))
      continue;
    const j = R in eve ? eve[R](b) : n[R];
    if (j !== void 0) {
      const $ = ZLt(j, R, n, e.fieldDef(t));
      ($ || o.legend[R] === void 0) && s.set(R, j, $);
    }
  }
  const _ = (n == null ? void 0 : n.encoding) ?? {}, S = s.get("selections"), C = {}, A = { fieldOrDatumDef: f, model: e, channel: t, legendCmpt: s, legendType: g };
  for (const R of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const j = dIe(_[R] ?? {}, e), $ = R in Jye ? Jye[R](j, A) : j;
    $ !== void 0 && !go($) && (C[R] = {
      ...S != null && S.length && xt(f) ? { name: `${oa(f.field)}_legend_${R}` } : {},
      ...S != null && S.length ? { interactive: !!S } : {},
      update: $
    });
  }
  return go(C) || s.set("encode", C, !!(n != null && n.encoding)), s;
}
function e5t(e) {
  const { legends: t, resolve: n } = e.component;
  for (const r of e.children) {
    vIe(r);
    for (const i of yt(r.component.legends))
      n.legend[i] = Sie(e.component.resolve, i), n.legend[i] === "shared" && (t[i] = bIe(t[i], r.component.legends[i]), t[i] || (n.legend[i] = "independent", delete t[i]));
  }
  for (const r of yt(t))
    for (const i of e.children)
      i.component.legends[r] && n.legend[r] === "shared" && delete i.component.legends[r];
  return t;
}
function bIe(e, t) {
  var o, a, s, u;
  if (!e)
    return t.clone();
  const n = e.getWithExplicit("orient"), r = t.getWithExplicit("orient");
  if (n.explicit && r.explicit && n.value !== r.value)
    return;
  let i = !1;
  for (const l of pIe) {
    const f = yw(
      e.getWithExplicit(l),
      t.getWithExplicit(l),
      l,
      "legend",
      // Tie breaker function
      (h, p) => {
        switch (l) {
          case "symbolType":
            return t5t(h, p);
          case "title":
            return e4e(h, p);
          case "type":
            return i = !0, yd("symbol");
        }
        return Y8(h, p, l, "legend");
      }
    );
    e.setWithExplicit(l, f);
  }
  return i && ((a = (o = e.implicit) == null ? void 0 : o.encode) != null && a.gradient && lz(e.implicit, ["encode", "gradient"]), (u = (s = e.explicit) == null ? void 0 : s.encode) != null && u.gradient && lz(e.explicit, ["encode", "gradient"])), e;
}
function t5t(e, t) {
  return t.value === "circle" ? t : e;
}
function n5t(e, t, n, r) {
  var i, o;
  e.encode ?? (e.encode = {}), (i = e.encode)[t] ?? (i[t] = {}), (o = e.encode[t]).update ?? (o.update = {}), e.encode[t].update[n] = r;
}
function xIe(e) {
  const t = e.component.legends, n = {};
  for (const i of yt(t)) {
    const o = e.getScaleComponent(i), a = mo(o.get("domains"));
    if (n[a])
      for (const s of n[a])
        bIe(s, t[i]) || n[a].push(t[i]);
    else
      n[a] = [t[i].clone()];
  }
  return il(n).flat().map((i) => r5t(i, e.config)).filter((i) => i !== void 0);
}
function r5t(e, t) {
  var a, s, u;
  const { disable: n, labelExpr: r, selections: i, ...o } = e.combine();
  if (!n) {
    if (t.aria === !1 && o.aria == null && (o.aria = !1), (a = o.encode) != null && a.symbols) {
      const l = o.encode.symbols.update;
      l.fill && l.fill.value !== "transparent" && !l.stroke && !o.stroke && (l.stroke = { value: "transparent" });
      for (const f of pPe)
        o[f] && delete l[f];
    }
    if (o.title || delete o.title, r !== void 0) {
      let l = r;
      (u = (s = o.encode) == null ? void 0 : s.labels) != null && u.update && an(o.encode.labels.update.text) && (l = BS(r, "datum.label", o.encode.labels.update.text.signal)), n5t(o, "labels", "text", { signal: l });
    }
    return o;
  }
}
function i5t(e) {
  return HN(e) || Aie(e) ? o5t(e) : wIe(e);
}
function o5t(e) {
  return e.children.reduce((t, n) => t.concat(n.assembleProjections()), wIe(e));
}
function wIe(e) {
  const t = e.component.projection;
  if (!t || t.merged)
    return [];
  const n = t.combine(), { name: r } = n;
  if (t.data) {
    const i = {
      signal: `[${t.size.map((a) => a.signal).join(", ")}]`
    }, o = t.data.reduce((a, s) => {
      const u = an(s) ? s.signal : `data('${e.lookupDataSource(s)}')`;
      return Kr(a, u) || a.push(u), a;
    }, []);
    if (o.length <= 0)
      throw new Error("Projection's fit didn't find any data sources");
    return [
      {
        name: r,
        size: i,
        fit: {
          signal: o.length > 1 ? `[${o.join(", ")}]` : o[0]
        },
        ...n
      }
    ];
  } else
    return [
      {
        name: r,
        // translate to center by default
        translate: { signal: "[width / 2, height / 2]" },
        // parameters, overwrite default translate if specified
        ...n
      }
    ];
}
const a5t = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
class _Ie extends kb {
  constructor(t, n, r, i) {
    super(
      { ...n },
      // all explicit properties of projection
      { name: t }
      // name as initial implicit property
    ), this.specifiedProjection = n, this.size = r, this.data = i, this.merged = !1;
  }
  /**
   * Whether the projection parameters should fit provided data.
   */
  get isFit() {
    return !!this.data;
  }
}
function EIe(e) {
  e.component.projection = za(e) ? s5t(e) : c5t(e);
}
function s5t(e) {
  if (e.hasProjection) {
    const t = yf(e.specifiedProjection), n = !(t && (t.scale != null || t.translate != null)), r = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0, i = n ? u5t(e) : void 0, o = new _Ie(e.projectionName(!0), {
      ...yf(e.config.projection),
      ...t
    }, r, i);
    return o.get("type") || o.set("type", "equalEarth", !1), o;
  }
}
function u5t(e) {
  const t = [], { encoding: n } = e;
  for (const r of [
    [sm, am],
    [Ep, um]
  ])
    (Hs(n[r[0]]) || Hs(n[r[1]])) && t.push({
      signal: e.getName(`geojson_${t.length}`)
    });
  return e.channelHasField(If) && e.typedFieldDef(If).type === zN && t.push({
    signal: e.getName(`geojson_${t.length}`)
  }), t.length === 0 && t.push(e.requestDataName(ra.Main)), t;
}
function l5t(e, t) {
  const n = yre(a5t, (i) => !!(!wn(e.explicit, i) && !wn(t.explicit, i) || wn(e.explicit, i) && wn(t.explicit, i) && // some properties might be signals or objects and require hashing for comparison
  Dd(e.get(i), t.get(i))));
  if (Dd(e.size, t.size)) {
    if (n)
      return e;
    if (Dd(e.explicit, {}))
      return t;
    if (Dd(t.explicit, {}))
      return e;
  }
  return null;
}
function c5t(e) {
  if (e.children.length === 0)
    return;
  let t;
  for (const r of e.children)
    EIe(r);
  const n = yre(e.children, (r) => {
    const i = r.component.projection;
    if (i)
      if (t) {
        const o = l5t(t, i);
        return o && (t = o), !!o;
      } else
        return t = i, !0;
    else
      return !0;
  });
  if (t && n) {
    const r = e.projectionName(!0), i = new _Ie(r, t.specifiedProjection, t.size, Kn(t.data));
    for (const o of e.children) {
      const a = o.component.projection;
      a && (a.isFit && i.data.push(...o.component.projection.data), o.renameProjection(a.get("name"), r), a.merged = !0);
    }
    return i;
  }
}
function f5t(e, t, n, r) {
  if (R4(t, n)) {
    const i = za(e) ? e.axis(n) ?? e.legend(n) ?? {} : {}, o = Mt(t, { expr: "datum" }), a = Mt(t, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: Mt(t, { binSuffix: "range", forAs: !0 }),
      formula: D4(o, a, i.format, i.formatType, r)
    };
  }
  return {};
}
function SIe(e, t) {
  return `${W$e(e)}_${t}`;
}
function d5t(e, t) {
  return {
    signal: e.getName(`${t}_bins`),
    extentSignal: e.getName(`${t}_extent`)
  };
}
function Mie(e, t, n) {
  const r = j8(n, void 0) ?? {}, i = SIe(r, t);
  return e.getName(`${i}_bins`);
}
function h5t(e) {
  return "as" in e;
}
function nve(e, t, n) {
  let r, i;
  h5t(e) ? r = kt(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : r = [Mt(e, { forAs: !0 }), Mt(e, { binSuffix: "end", forAs: !0 })];
  const o = { ...j8(t, void 0) }, a = SIe(o, e.field), { signal: s, extentSignal: u } = d5t(n, a);
  if (T8(o.extent)) {
    const f = o.extent;
    i = nIe(n, f.param, f), delete o.extent;
  }
  const l = {
    bin: o,
    field: e.field,
    as: [r],
    ...s ? { signal: s } : {},
    ...u ? { extentSignal: u } : {},
    ...i ? { span: i } : {}
  };
  return { key: a, binComponent: l };
}
class Hy extends oo {
  clone() {
    return new Hy(null, Kn(this.bins));
  }
  constructor(t, n) {
    super(t), this.bins = n;
  }
  static makeFromEncoding(t, n) {
    const r = n.reduceFieldDef((i, o, a) => {
      if (Pc(o) && Lo(o.bin)) {
        const { key: s, binComponent: u } = nve(o, o.bin, n);
        i[s] = {
          ...u,
          ...i[s],
          ...f5t(n, o, a, n.config)
        };
      }
      return i;
    }, {});
    return go(r) ? null : new Hy(t, r);
  }
  /**
   * Creates a bin node from BinTransform.
   * The optional parameter should provide
   */
  static makeFromTransform(t, n, r) {
    const { key: i, binComponent: o } = nve(n, n.bin, r);
    return new Hy(t, {
      [i]: o
    });
  }
  /**
   * Merge bin nodes. This method either integrates the bin config from the other node
   * or if this node already has a bin config, renames the corresponding signal in the model.
   */
  merge(t, n) {
    for (const r of yt(t.bins))
      r in this.bins ? (n(t.bins[r].signal, this.bins[r].signal), this.bins[r].as = $y([...this.bins[r].as, ...t.bins[r].as], Xr)) : this.bins[r] = t.bins[r];
    for (const r of t.children)
      t.removeChild(r), r.parent = this;
    t.remove();
  }
  producedFields() {
    return new Set(il(this.bins).map((t) => t.as).flat(2));
  }
  dependentFields() {
    return new Set(il(this.bins).map((t) => t.field));
  }
  hash() {
    return `Bin ${Xr(this.bins)}`;
  }
  assemble() {
    return il(this.bins).flatMap((t) => {
      const n = [], [r, ...i] = t.as, { extent: o, ...a } = t.bin, s = {
        type: "bin",
        field: _p(t.field),
        as: r,
        signal: t.signal,
        ...T8(o) ? { extent: null } : { extent: o },
        ...t.span ? { span: { signal: `span(${t.span})` } } : {},
        ...a
      };
      !o && t.extentSignal && (n.push({
        type: "extent",
        field: _p(t.field),
        signal: t.extentSignal
      }), s.extent = { signal: t.extentSignal }), n.push(s);
      for (const u of i)
        for (let l = 0; l < 2; l++)
          n.push({
            type: "formula",
            expr: Mt({ field: r[l] }, { expr: "datum" }),
            as: u[l]
          });
      return t.formula && n.push({
        type: "formula",
        expr: t.formula,
        as: t.formulaAs
      }), n;
    });
  }
}
function p5t(e, t, n, r) {
  var o;
  const i = za(r) ? r.encoding[gv(t)] : void 0;
  if (Pc(n) && za(r) && z4e(n, i, r.markDef, r.config)) {
    e.add(Mt(n, {})), e.add(Mt(n, { suffix: "end" }));
    const { mark: a, markDef: s, config: u } = r, l = mw({ fieldDef: n, markDef: s, config: u });
    u$(a) && l !== 0.5 && is(t) && (e.add(Mt(n, { suffix: H8 })), e.add(Mt(n, { suffix: V8 }))), n.bin && R4(n, t) && e.add(Mt(n, { binSuffix: "range" }));
  } else if (I$e(t)) {
    const a = P$e(t);
    e.add(r.getName(a));
  } else
    e.add(Mt(n));
  return m2(n) && iIt((o = n.scale) == null ? void 0 : o.range) && e.add(n.scale.range.field), e;
}
function g5t(e, t) {
  for (const n of yt(t)) {
    const r = t[n];
    for (const i of yt(r))
      n in e ? e[n][i] = /* @__PURE__ */ new Set([...e[n][i] ?? [], ...r[i]]) : e[n] = { [i]: r[i] };
  }
}
class Ug extends oo {
  clone() {
    return new Ug(null, new Set(this.dimensions), Kn(this.measures));
  }
  /**
   * @param dimensions string set for dimensions
   * @param measures dictionary mapping field name => dict of aggregation functions and names to use
   */
  constructor(t, n, r) {
    super(t), this.dimensions = n, this.measures = r;
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(t, n) {
    let r = !1;
    n.forEachFieldDef((a) => {
      a.aggregate && (r = !0);
    });
    const i = {}, o = /* @__PURE__ */ new Set();
    return !r || (n.forEachFieldDef((a, s) => {
      const { aggregate: u, field: l } = a;
      if (u)
        if (u === "count")
          i["*"] ?? (i["*"] = {}), i["*"].count = /* @__PURE__ */ new Set([Mt(a, { forAs: !0 })]);
        else {
          if (pb(u) || Yw(u)) {
            const f = pb(u) ? "argmin" : "argmax", h = u[f];
            i[h] ?? (i[h] = {}), i[h][f] = /* @__PURE__ */ new Set([Mt({ op: f, field: h }, { forAs: !0 })]);
          } else
            i[l] ?? (i[l] = {}), i[l][u] = /* @__PURE__ */ new Set([Mt(a, { forAs: !0 })]);
          Ob(s) && n.scaleDomain(s) === "unaggregated" && (i[l] ?? (i[l] = {}), i[l].min = /* @__PURE__ */ new Set([Mt({ field: l, aggregate: "min" }, { forAs: !0 })]), i[l].max = /* @__PURE__ */ new Set([Mt({ field: l, aggregate: "max" }, { forAs: !0 })]));
        }
      else
        p5t(o, s, a, n);
    }), o.size + yt(i).length === 0) ? null : new Ug(t, o, i);
  }
  static makeFromTransform(t, n) {
    const r = /* @__PURE__ */ new Set(), i = {};
    for (const o of n.aggregate) {
      const { op: a, field: s, as: u } = o;
      a && (a === "count" ? (i["*"] ?? (i["*"] = {}), i["*"].count = /* @__PURE__ */ new Set([u || Mt(o, { forAs: !0 })])) : (i[s] ?? (i[s] = {}), i[s][a] = /* @__PURE__ */ new Set([u || Mt(o, { forAs: !0 })])));
    }
    for (const o of n.groupby ?? [])
      r.add(o);
    return r.size + yt(i).length === 0 ? null : new Ug(t, r, i);
  }
  merge(t) {
    return C$e(this.dimensions, t.dimensions) ? (g5t(this.measures, t.measures), !0) : (DPt("different dimensions, cannot merge"), !1);
  }
  addDimensions(t) {
    t.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...yt(this.measures)]);
  }
  producedFields() {
    const t = /* @__PURE__ */ new Set();
    for (const n of yt(this.measures))
      for (const r of yt(this.measures[n])) {
        const i = this.measures[n][r];
        i.size === 0 ? t.add(`${r}_${n}`) : i.forEach(t.add, t);
      }
    return t;
  }
  hash() {
    return `Aggregate ${Xr({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const t = [], n = [], r = [];
    for (const o of yt(this.measures))
      for (const a of yt(this.measures[o]))
        for (const s of this.measures[o][a])
          r.push(s), t.push(a), n.push(o === "*" ? null : _p(o));
    return {
      type: "aggregate",
      groupby: [...this.dimensions].map(_p),
      ops: t,
      fields: n,
      as: r
    };
  }
}
class UN extends oo {
  /**
   * @param model The facet model.
   * @param name The name that this facet source will have.
   * @param data The source data for this facet data.
   */
  constructor(t, n, r, i) {
    super(t), this.model = n, this.name = r, this.data = i;
    for (const o of rp) {
      const a = n.facet[o];
      if (a) {
        const { bin: s, sort: u } = a;
        this[o] = {
          name: n.getName(`${o}_domain`),
          fields: [Mt(a), ...Lo(s) ? [Mt(a, { binSuffix: "end" })] : []],
          ...Uy(u) ? { sortField: u } : nt(u) ? { sortIndexField: QC(a, o) } : {}
        };
      }
    }
    this.childModel = n.child;
  }
  hash() {
    let t = "Facet";
    for (const n of rp)
      this[n] && (t += ` ${n.charAt(0)}:${Xr(this[n])}`);
    return t;
  }
  get fields() {
    var n;
    const t = [];
    for (const r of rp)
      (n = this[r]) != null && n.fields && t.push(...this[r].fields);
    return t;
  }
  dependentFields() {
    const t = new Set(this.fields);
    for (const n of rp)
      this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
    return t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  /**
   * The name to reference this source is its name.
   */
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const t = {};
    for (const n of mv) {
      const r = this.childModel.component.scales[n];
      if (r && !r.merged) {
        const i = r.get("type"), o = r.get("range");
        if (xu(i) && Hw(o)) {
          const a = X8(this.childModel, n), s = Die(a);
          s ? t[n] = s : bt(Are(n));
        }
      }
    }
    return t;
  }
  assembleRowColumnHeaderData(t, n, r) {
    const i = { row: "y", column: "x", facet: void 0 }[t], o = [], a = [], s = [];
    i && r && r[i] && (n ? (o.push(`distinct_${r[i]}`), a.push("max")) : (o.push(r[i]), a.push("distinct")), s.push(`distinct_${r[i]}`));
    const { sortField: u, sortIndexField: l } = this[t];
    if (u) {
      const { op: f = k8, field: h } = u;
      o.push(h), a.push(f), s.push(Mt(u, { forAs: !0 }));
    } else
      l && (o.push(l), a.push("max"), s.push(l));
    return {
      name: this[t].name,
      // Use data from the crossed one if it exist
      source: n ?? this.data,
      transform: [
        {
          type: "aggregate",
          groupby: this[t].fields,
          ...o.length ? {
            fields: o,
            ops: a,
            as: s
          } : {}
        }
      ]
    };
  }
  assembleFacetHeaderData(t) {
    var u;
    const { columns: n } = this.model.layout, { layoutHeaders: r } = this.model.component, i = [], o = {};
    for (const l of wie) {
      for (const f of _ie) {
        const h = (r[l] && r[l][f]) ?? [];
        for (const p of h)
          if (((u = p.axes) == null ? void 0 : u.length) > 0) {
            o[l] = !0;
            break;
          }
      }
      if (o[l]) {
        const f = `length(data("${this.facet.name}"))`, h = l === "row" ? n ? { signal: `ceil(${f} / ${n})` } : 1 : n ? { signal: `min(${f}, ${n})` } : { signal: f };
        i.push({
          name: `${this.facet.name}_${l}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: h
            }
          ]
        });
      }
    }
    const { row: a, column: s } = o;
    return (a || s) && i.unshift(this.assembleRowColumnHeaderData("facet", null, t)), i;
  }
  assemble() {
    const t = [];
    let n = null;
    const r = this.getChildIndependentFieldsWithStep(), { column: i, row: o, facet: a } = this;
    if (i && o && (r.x || r.y)) {
      n = `cross_${this.column.name}_${this.row.name}`;
      const s = [].concat(r.x ?? [], r.y ?? []), u = s.map(() => "distinct");
      t.push({
        name: n,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields: s,
            ops: u
          }
        ]
      });
    }
    for (const s of [nb, tb])
      this[s] && t.push(this.assembleRowColumnHeaderData(s, n, r));
    if (a) {
      const s = this.assembleFacetHeaderData(r);
      s && t.push(...s);
    }
    return t;
  }
}
function rve(e) {
  return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;
}
function m5t(e, t) {
  const n = xre(e);
  if (t === "number")
    return `toNumber(${n})`;
  if (t === "boolean")
    return `toBoolean(${n})`;
  if (t === "string")
    return `toString(${n})`;
  if (t === "date")
    return `toDate(${n})`;
  if (t === "flatten")
    return n;
  if (t.startsWith("date:")) {
    const r = rve(t.slice(5, t.length));
    return `timeParse(${n},'${r}')`;
  } else if (t.startsWith("utc:")) {
    const r = rve(t.slice(4, t.length));
    return `utcParse(${n},'${r}')`;
  } else
    return bt(L4t(t)), null;
}
function y5t(e) {
  const t = {};
  return Rj(e.filter, (n) => {
    if (y4e(n)) {
      let r = null;
      $re(n) ? r = Sd(n.equal) : Ire(n) ? r = Sd(n.lte) : Pre(n) ? r = Sd(n.lt) : jre(n) ? r = Sd(n.gt) : Lre(n) ? r = Sd(n.gte) : zre(n) ? r = n.range[0] : Fre(n) && (r = (n.oneOf ?? n.in)[0]), r && (h2(r) ? t[n.field] = "date" : pi(r) ? t[n.field] = "number" : kt(r) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
    }
  }), t;
}
function v5t(e) {
  const t = {};
  function n(r) {
    VC(r) ? t[r.field] = "date" : r.type === "quantitative" && g4t(r.aggregate) ? t[r.field] = "number" : LC(r.field) > 1 ? r.field in t || (t[r.field] = "flatten") : m2(r) && Uy(r.sort) && LC(r.sort.field) > 1 && (r.sort.field in t || (t[r.sort.field] = "flatten"));
  }
  if ((za(e) || Id(e)) && e.forEachFieldDef((r, i) => {
    if (Pc(r))
      n(r);
    else {
      const o = f2(i), a = e.fieldDef(o);
      n({
        ...r,
        type: a.type
      });
    }
  }), za(e)) {
    const { mark: r, markDef: i, encoding: o } = e;
    if (g2(r) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
    !e.encoding.order) {
      const a = i.orient === "horizontal" ? "y" : "x", s = o[a];
      xt(s) && s.type === "quantitative" && !(s.field in t) && (t[s.field] = "number");
    }
  }
  return t;
}
function b5t(e) {
  const t = {};
  if (za(e) && e.component.selection)
    for (const n of yt(e.component.selection)) {
      const r = e.component.selection[n];
      for (const i of r.project.items)
        !i.channel && LC(i.field) > 1 && (t[i.field] = "flatten");
    }
  return t;
}
class Ul extends oo {
  clone() {
    return new Ul(null, Kn(this._parse));
  }
  constructor(t, n) {
    super(t), this._parse = n;
  }
  hash() {
    return `Parse ${Xr(this._parse)}`;
  }
  /**
   * Creates a parse node from a data.format.parse and updates ancestorParse.
   */
  static makeExplicit(t, n, r) {
    var a;
    let i = {};
    const o = n.data;
    return !Yx(o) && ((a = o == null ? void 0 : o.format) != null && a.parse) && (i = o.format.parse), this.makeWithAncestors(t, i, {}, r);
  }
  /**
   * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
   */
  static makeWithAncestors(t, n, r, i) {
    for (const s of yt(r)) {
      const u = i.getWithExplicit(s);
      u.value !== void 0 && (u.explicit || u.value === r[s] || u.value === "derived" || r[s] === "flatten" ? delete r[s] : bt(hye(s, r[s], u.value)));
    }
    for (const s of yt(n)) {
      const u = i.get(s);
      u !== void 0 && (u === n[s] ? delete n[s] : bt(hye(s, n[s], u)));
    }
    const o = new kb(n, r);
    i.copyAll(o);
    const a = {};
    for (const s of yt(o.combine())) {
      const u = o.get(s);
      u !== null && (a[s] = u);
    }
    return yt(a).length === 0 || i.parseNothing ? null : new Ul(t, a);
  }
  get parse() {
    return this._parse;
  }
  merge(t) {
    this._parse = { ...this._parse, ...t.parse }, t.remove();
  }
  /**
   * Assemble an object for Vega's format.parse property.
   */
  assembleFormatParse() {
    const t = {};
    for (const n of yt(this._parse)) {
      const r = this._parse[n];
      LC(n) === 1 && (t[n] = r);
    }
    return t;
  }
  // format parse depends and produces all fields in its parse
  producedFields() {
    return new Set(yt(this._parse));
  }
  dependentFields() {
    return new Set(yt(this._parse));
  }
  assembleTransforms(t = !1) {
    return yt(this._parse).filter((n) => t ? LC(n) > 1 : !0).map((n) => {
      const r = m5t(n, this._parse[n]);
      return r ? {
        type: "formula",
        expr: r,
        as: jN(n)
        // Vega output is always flattened
      } : null;
    }).filter((n) => n !== null);
  }
}
class xw extends oo {
  clone() {
    return new xw(null);
  }
  constructor(t) {
    super(t);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([Xg]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: Xg };
  }
}
class P4 extends oo {
  clone() {
    return new P4(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  hash() {
    return `Graticule ${Xr(this.params)}`;
  }
  assemble() {
    return {
      type: "graticule",
      ...this.params === !0 ? {} : this.params
    };
  }
}
class I4 extends oo {
  clone() {
    return new I4(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.params.as ?? "data"]);
  }
  hash() {
    return `Hash ${Xr(this.params)}`;
  }
  assemble() {
    return {
      type: "sequence",
      ...this.params
    };
  }
}
class QS extends oo {
  constructor(t) {
    super(null), t ?? (t = { name: "source" });
    let n;
    if (Yx(t) || (n = t.format ? { ...Ef(t.format, ["parse"]) } : {}), l$(t))
      this._data = { values: t.values };
    else if (WC(t)) {
      if (this._data = { url: t.url }, !n.type) {
        let r = /(?:\.([^.]+))?$/.exec(t.url)[1];
        Kr(["json", "csv", "tsv", "dsv", "topojson"], r) || (r = "json"), n.type = r;
      }
    } else
      RPe(t) ? this._data = { values: [{ type: "Sphere" }] } : (APe(t) || Yx(t)) && (this._data = {});
    this._generator = Yx(t), t.name && (this._name = t.name), n && !go(n) && (this._data.format = n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(t) {
    this._name = t;
  }
  set parent(t) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return {
      name: this._name,
      ...this._data,
      transform: []
    };
  }
}
var ive = globalThis && globalThis.__classPrivateFieldSet || function(e, t, n, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n;
}, x5t = globalThis && globalThis.__classPrivateFieldGet || function(e, t, n, r) {
  if (n === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}, oR;
function Tie(e) {
  return e instanceof QS || e instanceof P4 || e instanceof I4;
}
class Cie {
  constructor() {
    oR.set(this, void 0), ive(this, oR, !1, "f");
  }
  // Once true, #modified is never set to false
  setModified() {
    ive(this, oR, !0, "f");
  }
  get modifiedFlag() {
    return x5t(this, oR, "f");
  }
}
oR = /* @__PURE__ */ new WeakMap();
class y2 extends Cie {
  /**
   * Compute a map of node depths that we can use to determine a topological sort order.
   */
  getNodeDepths(t, n, r) {
    r.set(t, n);
    for (const i of t.children)
      this.getNodeDepths(i, n + 1, r);
    return r;
  }
  /**
   * Run the optimizer on all nodes starting from the leaves.
   */
  optimize(t) {
    const r = [...this.getNodeDepths(t, 0, /* @__PURE__ */ new Map()).entries()].sort((i, o) => o[1] - i[1]);
    for (const i of r)
      this.run(i[0]);
    return this.modifiedFlag;
  }
}
class Nie extends Cie {
  /**
   * Run the optimizer depth first on all nodes starting from the roots.
   */
  optimize(t) {
    this.run(t);
    for (const n of t.children)
      this.optimize(n);
    return this.modifiedFlag;
  }
}
class w5t extends Nie {
  mergeNodes(t, n) {
    const r = n.shift();
    for (const i of n)
      t.removeChild(i), i.parent = r, i.remove();
  }
  run(t) {
    const n = t.children.map((i) => i.hash()), r = {};
    for (let i = 0; i < n.length; i++)
      r[n[i]] === void 0 ? r[n[i]] = [t.children[i]] : r[n[i]].push(t.children[i]);
    for (const i of yt(r))
      r[i].length > 1 && (this.setModified(), this.mergeNodes(t, r[i]));
  }
}
class _5t extends Nie {
  constructor(t) {
    super(), this.requiresSelectionId = t && xie(t);
  }
  run(t) {
    t instanceof xw && (this.requiresSelectionId && (Tie(t.parent) || t.parent instanceof Ug || t.parent instanceof Ul) || (this.setModified(), t.remove()));
  }
}
class E5t extends Cie {
  optimize(t) {
    return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
  }
  run(t, n) {
    let r = /* @__PURE__ */ new Set();
    t instanceof Yy && (r = t.producedFields(), vre(r, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
    for (const i of t.children)
      this.run(i, /* @__PURE__ */ new Set([...n, ...r]));
  }
}
class S5t extends Nie {
  constructor() {
    super();
  }
  run(t) {
    t instanceof Mf && !t.isRequired() && (this.setModified(), t.remove());
  }
}
class M5t extends y2 {
  run(t) {
    if (!Tie(t) && !(t.numChildren() > 1)) {
      for (const n of t.children)
        if (n instanceof Ul)
          if (t instanceof Ul)
            this.setModified(), t.merge(n);
          else {
            if (bre(t.producedFields(), n.dependentFields()))
              continue;
            this.setModified(), n.swapWithParent();
          }
    }
  }
}
class T5t extends y2 {
  run(t) {
    const n = [...t.children], r = t.children.filter((i) => i instanceof Ul);
    if (t.numChildren() > 1 && r.length >= 1) {
      const i = {}, o = /* @__PURE__ */ new Set();
      for (const a of r) {
        const s = a.parse;
        for (const u of yt(s))
          u in i ? i[u] !== s[u] && o.add(u) : i[u] = s[u];
      }
      for (const a of o)
        delete i[a];
      if (!go(i)) {
        this.setModified();
        const a = new Ul(t, i);
        for (const s of n) {
          if (s instanceof Ul)
            for (const u of yt(i))
              delete s.parse[u];
          t.removeChild(s), s.parent = a, s instanceof Ul && yt(s.parse).length === 0 && s.remove();
        }
      }
    }
  }
}
class C5t extends y2 {
  run(t) {
    t instanceof Mf || t.numChildren() > 0 || t instanceof UN || t instanceof QS || (this.setModified(), t.remove());
  }
}
class N5t extends y2 {
  run(t) {
    const n = t.children.filter((i) => i instanceof Yy), r = n.pop();
    for (const i of n)
      this.setModified(), r.merge(i);
  }
}
class D5t extends y2 {
  run(t) {
    const n = t.children.filter((i) => i instanceof Ug), r = {};
    for (const i of n) {
      const o = Xr(i.groupBy);
      o in r || (r[o] = []), r[o].push(i);
    }
    for (const i of yt(r)) {
      const o = r[i];
      if (o.length > 1) {
        const a = o.pop();
        for (const s of o)
          a.merge(s) && (t.removeChild(s), s.parent = a, s.remove(), this.setModified());
      }
    }
  }
}
class A5t extends y2 {
  constructor(t) {
    super(), this.model = t;
  }
  run(t) {
    const n = !(Tie(t) || t instanceof BN || t instanceof Ul || t instanceof xw), r = [], i = [];
    for (const o of t.children)
      o instanceof Hy && (n && !bre(t.producedFields(), o.dependentFields()) ? r.push(o) : i.push(o));
    if (r.length > 0) {
      const o = r.pop();
      for (const a of r)
        o.merge(a, this.model.renameSignal.bind(this.model));
      this.setModified(), t instanceof Hy ? t.merge(o, this.model.renameSignal.bind(this.model)) : o.swapWithParent();
    }
    if (i.length > 1) {
      const o = i.pop();
      for (const a of i)
        o.merge(a, this.model.renameSignal.bind(this.model));
      this.setModified();
    }
  }
}
class O5t extends y2 {
  run(t) {
    const n = [...t.children];
    if (!FS(n, (a) => a instanceof Mf) || t.numChildren() <= 1)
      return;
    const i = [];
    let o;
    for (const a of n)
      if (a instanceof Mf) {
        let s = a;
        for (; s.numChildren() === 1; ) {
          const [u] = s.children;
          if (u instanceof Mf)
            s = u;
          else
            break;
        }
        i.push(...s.children), o ? (t.removeChild(a), a.parent = o.parent, o.parent.removeChild(o), o.parent = s, this.setModified()) : o = s;
      } else
        i.push(a);
    if (i.length) {
      this.setModified();
      for (const a of i)
        a.parent.removeChild(a), a.parent = o;
    }
  }
}
class v2 extends oo {
  clone() {
    return new v2(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = $y(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(t) {
    return t.as ?? Mt(t);
  }
  hash() {
    return `JoinAggregateTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], r = [];
    for (const o of this.transform.joinaggregate)
      n.push(o.op), r.push(this.getDefaultName(o)), t.push(o.field === void 0 ? null : o.field);
    const i = this.transform.groupby;
    return {
      type: "joinaggregate",
      as: r,
      ops: n,
      fields: t,
      ...i !== void 0 ? { groupby: i } : {}
    };
  }
}
function R5t(e) {
  return e.stack.stackBy.reduce((t, n) => {
    const r = n.fieldDef, i = Mt(r);
    return i && t.push(i), t;
  }, []);
}
function k5t(e) {
  return nt(e) && e.every((t) => kt(t)) && e.length > 1;
}
class ib extends oo {
  clone() {
    return new ib(null, Kn(this._stack));
  }
  constructor(t, n) {
    super(t), this._stack = n;
  }
  static makeFromTransform(t, n) {
    const { stack: r, groupby: i, as: o, offset: a = "zero" } = n, s = [], u = [];
    if (n.sort !== void 0)
      for (const h of n.sort)
        s.push(h.field), u.push(rs(h.order, "ascending"));
    const l = {
      field: s,
      order: u
    };
    let f;
    return k5t(o) ? f = o : kt(o) ? f = [o, `${o}_end`] : f = [`${n.stack}_start`, `${n.stack}_end`], new ib(t, {
      dimensionFieldDefs: [],
      stackField: r,
      groupby: i,
      offset: a,
      sort: l,
      facetby: [],
      as: f
    });
  }
  static makeFromEncoding(t, n) {
    const r = n.stack, { encoding: i } = n;
    if (!r)
      return null;
    const { groupbyChannels: o, fieldChannel: a, offset: s, impute: u } = r, l = o.map((g) => {
      const y = i[g];
      return Jy(y);
    }).filter((g) => !!g), f = R5t(n), h = n.encoding.order;
    let p;
    if (nt(h) || xt(h))
      p = K$e(h);
    else {
      const g = F4e(h) ? h.sort : a === "y" ? "descending" : "ascending";
      p = f.reduce((y, b) => (y.field.includes(b) || (y.field.push(b), y.order.push(g)), y), { field: [], order: [] });
    }
    return new ib(t, {
      dimensionFieldDefs: l,
      stackField: n.vgField(a),
      facetby: [],
      stackby: f,
      sort: p,
      offset: s,
      impute: u,
      as: [
        n.vgField(a, { suffix: "start", forAs: !0 }),
        n.vgField(a, { suffix: "end", forAs: !0 })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(t) {
    this._stack.facetby.push(...t);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${Xr(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs: t, impute: n, groupby: r } = this._stack;
    return t.length > 0 ? t.map((i) => i.bin ? n ? [Mt(i, { binSuffix: "mid" })] : [
      // For binned group by field without impute, we need both bin (start) and bin_end
      Mt(i, {}),
      Mt(i, { binSuffix: "end" })
    ] : [Mt(i)]).flat() : r ?? [];
  }
  assemble() {
    const t = [], { facetby: n, dimensionFieldDefs: r, stackField: i, stackby: o, sort: a, offset: s, impute: u, as: l } = this._stack;
    if (u)
      for (const f of r) {
        const { bandPosition: h = 0.5, bin: p } = f;
        if (p) {
          const g = Mt(f, { expr: "datum" }), y = Mt(f, { expr: "datum", binSuffix: "end" });
          t.push({
            type: "formula",
            expr: `${h}*${g}+${1 - h}*${y}`,
            as: Mt(f, { binSuffix: "mid", forAs: !0 })
          });
        }
        t.push({
          type: "impute",
          field: i,
          groupby: [...o, ...n],
          key: Mt(f, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    return t.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...n],
      field: i,
      sort: a,
      as: l,
      offset: s
    }), t;
  }
}
class YN extends oo {
  clone() {
    return new YN(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = $y(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach((n) => t.add(n.field)), this.transform.window.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(t) {
    return t.as ?? Mt(t);
  }
  hash() {
    return `WindowTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], r = [], i = [];
    for (const h of this.transform.window)
      n.push(h.op), r.push(this.getDefaultName(h)), i.push(h.param === void 0 ? null : h.param), t.push(h.field === void 0 ? null : h.field);
    const o = this.transform.frame, a = this.transform.groupby;
    if (o && o[0] === null && o[1] === null && n.every((h) => Nre(h)))
      return {
        type: "joinaggregate",
        as: r,
        ops: n,
        fields: t,
        ...a !== void 0 ? { groupby: a } : {}
      };
    const s = [], u = [];
    if (this.transform.sort !== void 0)
      for (const h of this.transform.sort)
        s.push(h.field), u.push(h.order ?? "ascending");
    const l = {
      field: s,
      order: u
    }, f = this.transform.ignorePeers;
    return {
      type: "window",
      params: i,
      as: r,
      ops: n,
      fields: t,
      sort: l,
      ...f !== void 0 ? { ignorePeers: f } : {},
      ...a !== void 0 ? { groupby: a } : {},
      ...o !== void 0 ? { frame: o } : {}
    };
  }
}
function $5t(e) {
  function t(n) {
    if (!(n instanceof UN)) {
      const r = n.clone();
      if (r instanceof Mf) {
        const i = mX + r.getSource();
        r.setSource(i), e.model.component.data.outputNodes[i] = r;
      } else
        (r instanceof Ug || r instanceof ib || r instanceof YN || r instanceof v2) && r.addDimensions(e.fields);
      for (const i of n.children.flatMap(t))
        i.parent = r;
      return [r];
    }
    return n.children.flatMap(t);
  }
  return t;
}
function gX(e) {
  if (e instanceof UN)
    if (e.numChildren() === 1 && !(e.children[0] instanceof Mf)) {
      const t = e.children[0];
      (t instanceof Ug || t instanceof ib || t instanceof YN || t instanceof v2) && t.addDimensions(e.fields), t.swapWithParent(), gX(e);
    } else {
      const t = e.model.component.data.main;
      MIe(t);
      const n = $5t(e), r = e.children.map(n).flat();
      for (const i of r)
        i.parent = t;
    }
  else
    e.children.map(gX);
}
function MIe(e) {
  if (e instanceof Mf && e.type === ra.Main && e.numChildren() === 1) {
    const t = e.children[0];
    t instanceof UN || (t.swapWithParent(), MIe(e));
  }
}
const mX = "scale_", L3 = 5;
function yX(e) {
  for (const t of e) {
    for (const n of t.children)
      if (n.parent !== t)
        return !1;
    if (!yX(t.children))
      return !1;
  }
  return !0;
}
function yg(e, t) {
  let n = !1;
  for (const r of t)
    n = e.optimize(r) || n;
  return n;
}
function ove(e, t, n) {
  let r = e.sources, i = !1;
  return i = yg(new S5t(), r) || i, i = yg(new _5t(t), r) || i, r = r.filter((o) => o.numChildren() > 0), i = yg(new C5t(), r) || i, r = r.filter((o) => o.numChildren() > 0), n || (i = yg(new M5t(), r) || i, i = yg(new A5t(t), r) || i, i = yg(new E5t(), r) || i, i = yg(new T5t(), r) || i, i = yg(new D5t(), r) || i, i = yg(new N5t(), r) || i, i = yg(new w5t(), r) || i, i = yg(new O5t(), r) || i), e.sources = r, i;
}
function P5t(e, t) {
  yX(e.sources);
  let n = 0, r = 0;
  for (let i = 0; i < L3 && ove(e, t, !0); i++)
    n++;
  e.sources.map(gX);
  for (let i = 0; i < L3 && ove(e, t, !1); i++)
    r++;
  yX(e.sources), Math.max(n, r) === L3 && bt(`Maximum optimization runs(${L3}) reached.`);
}
class du {
  constructor(t) {
    Object.defineProperty(this, "signal", {
      enumerable: !0,
      get: t
    });
  }
  static fromName(t, n) {
    return new du(() => t(n));
  }
}
function TIe(e) {
  za(e) ? I5t(e) : j5t(e);
}
function I5t(e) {
  const t = e.component.scales;
  for (const n of yt(t)) {
    const r = z5t(e, n);
    if (t[n].setWithExplicit("domains", r), B5t(e, n), e.component.data.isFaceted) {
      let o = e;
      for (; !Id(o) && o.parent; )
        o = o.parent;
      if (o.component.resolve.scale[n] === "shared")
        for (const s of r.value)
          Q0(s) && (s.data = mX + s.data.replace(mX, ""));
    }
  }
}
function j5t(e) {
  for (const n of e.children)
    TIe(n);
  const t = e.component.scales;
  for (const n of yt(t)) {
    let r, i = null;
    for (const o of e.children) {
      const a = o.component.scales[n];
      if (a) {
        r === void 0 ? r = a.getWithExplicit("domains") : r = yw(r, a.getWithExplicit("domains"), "domains", "scale", vX);
        const s = a.get("selectionExtent");
        i && s && i.param !== s.param && bt($4t), i = s;
      }
    }
    t[n].setWithExplicit("domains", r), i && t[n].set("selectionExtent", i, !0);
  }
}
function L5t(e, t, n, r) {
  if (e === "unaggregated") {
    const { valid: i, reason: o } = ave(t, n);
    if (!i) {
      bt(o);
      return;
    }
  } else if (e === void 0 && r.useUnaggregatedDomain) {
    const { valid: i } = ave(t, n);
    if (i)
      return "unaggregated";
  }
  return e;
}
function z5t(e, t) {
  const n = e.getScaleComponent(t).get("type"), { encoding: r } = e, i = L5t(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
  return i !== e.scaleDomain(t) && (e.specifiedScales[t] = {
    ...e.specifiedScales[t],
    domain: i
  }), t === "x" && Hs(r.x2) ? Hs(r.x) ? yw(ux(n, i, e, "x"), ux(n, i, e, "x2"), "domain", "scale", vX) : ux(n, i, e, "x2") : t === "y" && Hs(r.y2) ? Hs(r.y) ? yw(ux(n, i, e, "y"), ux(n, i, e, "y2"), "domain", "scale", vX) : ux(n, i, e, "y2") : ux(n, i, e, t);
}
function F5t(e, t, n) {
  return e.map((r) => ({ signal: `{data: ${L8(r, { timeUnit: n, type: t })}}` }));
}
function IV(e, t, n) {
  var i;
  const r = (i = bu(n)) == null ? void 0 : i.unit;
  return t === "temporal" || r ? F5t(e, t, r) : [e];
}
function ux(e, t, n, r) {
  const { encoding: i, markDef: o, mark: a, config: s, stack: u } = n, l = Hs(i[r]), { type: f } = l, h = l.timeUnit;
  if (rIt(t)) {
    const y = ux(e, void 0, n, r), b = IV(t.unionWith, f, h);
    return wy([...b, ...y.value]);
  } else {
    if (an(t))
      return wy([t]);
    if (t && t !== "unaggregated" && !S4e(t))
      return wy(IV(t, f, h));
  }
  if (u && r === u.fieldChannel) {
    if (u.offset === "normalize")
      return yd([[0, 1]]);
    const y = n.requestDataName(ra.Main);
    return yd([
      {
        data: y,
        field: n.vgField(r, { suffix: "start" })
      },
      {
        data: y,
        field: n.vgField(r, { suffix: "end" })
      }
    ]);
  }
  const p = Ob(r) && xt(l) ? U5t(n, r, e) : void 0;
  if (yv(l)) {
    const y = IV([l.datum], f, h);
    return yd(y);
  }
  const g = l;
  if (t === "unaggregated") {
    const y = n.requestDataName(ra.Main), { field: b } = l;
    return yd([
      {
        data: y,
        field: Mt({ field: b, aggregate: "min" })
      },
      {
        data: y,
        field: Mt({ field: b, aggregate: "max" })
      }
    ]);
  } else if (Lo(g.bin)) {
    if (xu(e))
      return yd(e === "bin-ordinal" ? [] : [
        {
          // If sort by aggregation of a specified sort field, we need to use RAW table,
          // so we can aggregate values for the scale independently from the main aggregation.
          data: a$(p) ? n.requestDataName(ra.Main) : n.requestDataName(ra.Raw),
          // Use range if we added it and the scale does not support computing a range as a signal.
          field: n.vgField(r, R4(g, r) ? { binSuffix: "range" } : {}),
          // we have to use a sort object if sort = true to make the sort correct by bin start
          sort: p === !0 || !Pt(p) ? {
            field: n.vgField(r, {}),
            op: "min"
            // min or max doesn't matter since we sort by the start of the bin range
          } : p
        }
      ]);
    {
      const { bin: y } = g;
      if (Lo(y)) {
        const b = Mie(n, g.field, y);
        return yd([
          new du(() => {
            const _ = n.getSignalName(b);
            return `[${_}.start, ${_}.stop]`;
          })
        ]);
      } else
        return yd([
          {
            data: n.requestDataName(ra.Main),
            field: n.vgField(r, {})
          }
        ]);
    }
  } else if (g.timeUnit && Kr(["time", "utc"], e)) {
    const y = i[gv(r)];
    if (z4e(g, y, o, s)) {
      const b = n.requestDataName(ra.Main), _ = mw({ fieldDef: g, fieldDef2: y, markDef: o, config: s }), S = u$(a) && _ !== 0.5 && is(r);
      return yd([
        {
          data: b,
          field: n.vgField(r, S ? { suffix: H8 } : {})
        },
        {
          data: b,
          field: n.vgField(r, { suffix: S ? V8 : "end" })
        }
      ]);
    }
  }
  return yd(p ? [
    {
      // If sort by aggregation of a specified sort field, we need to use RAW table,
      // so we can aggregate values for the scale independently from the main aggregation.
      data: a$(p) ? n.requestDataName(ra.Main) : n.requestDataName(ra.Raw),
      field: n.vgField(r),
      sort: p
    }
  ] : [
    {
      data: n.requestDataName(ra.Main),
      field: n.vgField(r)
    }
  ]);
}
function jV(e, t) {
  const { op: n, field: r, order: i } = e;
  return {
    // Apply default op
    op: n ?? (t ? "sum" : k8),
    // flatten nested fields
    ...r ? { field: _p(r) } : {},
    ...i ? { order: i } : {}
  };
}
function B5t(e, t) {
  var s;
  const n = e.component.scales[t], r = e.specifiedScales[t].domain, i = (s = e.fieldDef(t)) == null ? void 0 : s.bin, o = S4e(r) && r, a = d2(i) && T8(i.extent) && i.extent;
  (o || a) && n.set("selectionExtent", o ?? a, !0);
}
function U5t(e, t, n) {
  if (!xu(n))
    return;
  const r = e.fieldDef(t), i = r.sort;
  if (j4e(i))
    return {
      op: "min",
      field: QC(r, t),
      order: "ascending"
    };
  const { stack: o } = e, a = o ? /* @__PURE__ */ new Set([...o.groupbyFields, ...o.stackBy.map((s) => s.fieldDef.field)]) : void 0;
  if (Uy(i)) {
    const s = o && !a.has(i.field);
    return jV(i, s);
  } else if (I4e(i)) {
    const { encoding: s, order: u } = i, l = e.fieldDef(s), { aggregate: f, field: h } = l, p = o && !a.has(h);
    if (pb(f) || Yw(f))
      return jV({
        field: Mt(l),
        order: u
      }, p);
    if (Nre(f) || !f)
      return jV({
        op: f,
        // can't be argmin/argmax since we don't support them in encoding field def
        field: h,
        order: u
      }, p);
  } else {
    if (i === "descending")
      return {
        op: "min",
        field: e.vgField(t),
        order: "descending"
      };
    if (Kr([
      "ascending",
      void 0
      /* default =ascending*/
    ], i))
      return !0;
  }
}
function ave(e, t) {
  const { aggregate: n, type: r } = e;
  return n ? kt(n) && !y4t.has(n) ? {
    valid: !1,
    reason: aPt(n)
  } : r === "quantitative" && t === "log" ? {
    valid: !1,
    reason: sPt(e)
  } : { valid: !0 } : {
    valid: !1,
    reason: oPt(e)
  };
}
function vX(e, t, n, r) {
  return e.explicit && t.explicit && bt(dPt(n, r, e.value, t.value)), { explicit: e.explicit, value: [...e.value, ...t.value] };
}
function Y5t(e) {
  const t = $y(e.map((a) => {
    if (Q0(a)) {
      const { sort: s, ...u } = a;
      return u;
    }
    return a;
  }), Xr), n = $y(e.map((a) => {
    if (Q0(a)) {
      const s = a.sort;
      return s !== void 0 && !a$(s) && ("op" in s && s.op === "count" && delete s.field, s.order === "ascending" && delete s.order), s;
    }
  }).filter((a) => a !== void 0), Xr);
  if (t.length === 0)
    return;
  if (t.length === 1) {
    const a = e[0];
    if (Q0(a) && n.length > 0) {
      let s = n[0];
      if (n.length > 1) {
        bt(gye);
        const u = n.filter((l) => Pt(l) && "op" in l && l.op !== "min");
        n.every((l) => Pt(l) && "op" in l) && u.length === 1 ? s = u[0] : s = !0;
      } else if (Pt(s) && "field" in s) {
        const u = s.field;
        a.field === u && (s = s.order ? { order: s.order } : !0);
      }
      return {
        ...a,
        sort: s
      };
    }
    return a;
  }
  const r = $y(n.map((a) => a$(a) || !("op" in a) || kt(a.op) && a.op in h4t ? a : (bt(pPt(a)), !0)), Xr);
  let i;
  r.length === 1 ? i = r[0] : r.length > 1 && (bt(gye), i = !0);
  const o = $y(e.map((a) => Q0(a) ? a.data : null), (a) => a);
  return o.length === 1 && o[0] !== null ? {
    data: o[0],
    fields: t.map((s) => s.field),
    ...i ? { sort: i } : {}
  } : { fields: t, ...i ? { sort: i } : {} };
}
function Die(e) {
  if (Q0(e) && kt(e.field))
    return e.field;
  if (v4t(e)) {
    let t;
    for (const n of e.fields)
      if (Q0(n) && kt(n.field)) {
        if (!t)
          t = n.field;
        else if (t !== n.field)
          return bt(gPt), t;
      }
    return bt(mPt), t;
  } else if (b4t(e)) {
    bt(yPt);
    const t = e.fields[0];
    return kt(t) ? t : void 0;
  }
}
function X8(e, t) {
  const r = e.component.scales[t].get("domains").map((i) => (Q0(i) && (i.data = e.lookupDataSource(i.data)), i));
  return Y5t(r);
}
function CIe(e) {
  return HN(e) || Aie(e) ? e.children.reduce((t, n) => t.concat(CIe(n)), sve(e)) : sve(e);
}
function sve(e) {
  return yt(e.component.scales).reduce((t, n) => {
    const r = e.component.scales[n];
    if (r.merged)
      return t;
    const i = r.combine(), { name: o, type: a, selectionExtent: s, domains: u, range: l, reverse: f, ...h } = i, p = H5t(i.range, o, n, e), g = X8(e, n), y = s ? Ljt(e, s, r, g) : null;
    return t.push({
      name: o,
      type: a,
      ...g ? { domain: g } : {},
      ...y ? { domainRaw: y } : {},
      range: p,
      ...f !== void 0 ? { reverse: f } : {},
      ...h
    }), t;
  }, []);
}
function H5t(e, t, n, r) {
  if (is(n)) {
    if (Hw(e))
      return {
        step: { signal: `${t}_step` }
      };
  } else if (Pt(e) && Q0(e))
    return {
      ...e,
      data: r.lookupDataSource(e.data)
    };
  return e;
}
class NIe extends kb {
  constructor(t, n) {
    super(
      {},
      // no initial explicit property
      { name: t }
      // name as initial implicit property
    ), this.merged = !1, this.setWithExplicit("type", n);
  }
  /**
   * Whether the scale definitely includes zero in the domain
   */
  domainDefinitelyIncludesZero() {
    return this.get("zero") !== !1 ? !0 : FS(this.get("domains"), (t) => nt(t) && t.length === 2 && pi(t[0]) && t[0] <= 0 && pi(t[1]) && t[1] >= 0);
  }
}
const V5t = ["range", "scheme"];
function W5t(e) {
  const t = e.component.scales;
  for (const n of M8) {
    const r = t[n];
    if (!r)
      continue;
    const i = q5t(n, e);
    r.setWithExplicit("range", i);
  }
}
function uve(e, t) {
  const n = e.fieldDef(t);
  if (n != null && n.bin) {
    const { bin: r, field: i } = n, o = jf(t), a = e.getName(o);
    if (Pt(r) && r.binned && r.step !== void 0)
      return new du(() => {
        const s = e.scaleName(t), u = `(domain("${s}")[1] - domain("${s}")[0]) / ${r.step}`;
        return `${e.getSignalName(a)} / (${u})`;
      });
    if (Lo(r)) {
      const s = Mie(e, i, r);
      return new du(() => {
        const u = e.getSignalName(s), l = `(${u}.stop - ${u}.start) / ${u}.step`;
        return `${e.getSignalName(a)} / (${l})`;
      });
    }
  }
}
function q5t(e, t) {
  const n = t.specifiedScales[e], { size: r } = t, o = t.getScaleComponent(e).get("type");
  for (const h of V5t)
    if (n[h] !== void 0) {
      const p = nX(o, h), g = M4e(e, h);
      if (!p)
        bt(i4e(o, h, e));
      else if (g)
        bt(g);
      else
        switch (h) {
          case "range": {
            const y = n.range;
            if (nt(y)) {
              if (is(e))
                return wy(y.map((b) => {
                  if (b === "width" || b === "height") {
                    const _ = t.getName(b), S = t.getSignalName.bind(t);
                    return du.fromName(S, _);
                  }
                  return b;
                }));
            } else if (Pt(y))
              return wy({
                data: t.requestDataName(ra.Main),
                field: y.field,
                sort: { op: "min", field: t.vgField(e) }
              });
            return wy(y);
          }
          case "scheme":
            return wy(G5t(n[h]));
        }
    }
  const a = e === aa || e === "xOffset" ? "width" : "height", s = r[a];
  if (ev(s)) {
    if (is(e))
      if (xu(o)) {
        const h = AIe(s, t, e);
        if (h)
          return wy({ step: h });
      } else
        bt(o4e(a));
    else if (T4(e)) {
      const h = e === Lw ? "x" : "y";
      if (t.getScaleComponent(h).get("type") === "band") {
        const y = OIe(s, o);
        if (y)
          return wy(y);
      }
    }
  }
  const { rangeMin: u, rangeMax: l } = n, f = Q5t(e, t);
  return (u !== void 0 || l !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
  nX(o, "rangeMin") && nt(f) && f.length === 2 ? wy([u ?? f[0], l ?? f[1]]) : yd(f);
}
function G5t(e) {
  return nIt(e) ? {
    scheme: e.name,
    ...Ef(e, ["name"])
  } : { scheme: e };
}
function DIe(e, t, n, { center: r } = {}) {
  const i = jf(e), o = t.getName(i), a = t.getSignalName.bind(t);
  return e === _u && Wd(n) ? r ? [
    du.fromName((s) => `${a(s)}/2`, o),
    du.fromName((s) => `-${a(s)}/2`, o)
  ] : [du.fromName(a, o), 0] : r ? [
    du.fromName((s) => `-${a(s)}/2`, o),
    du.fromName((s) => `${a(s)}/2`, o)
  ] : [0, du.fromName(a, o)];
}
function Q5t(e, t) {
  const { size: n, config: r, mark: i, encoding: o } = t, { type: a } = Hs(o[e]), u = t.getScaleComponent(e).get("type"), { domain: l, domainMid: f } = t.specifiedScales[e];
  switch (e) {
    case aa:
    case _u: {
      if (Kr(["point", "band"], u)) {
        const h = RIe(e, n, r.view);
        if (ev(h))
          return { step: AIe(h, t, e) };
      }
      return DIe(e, t, u);
    }
    case Lw:
    case LN:
      return X5t(e, t, u);
    case Db: {
      const h = t.component.scales[e].get("zero"), p = kIe(i, h, r), g = J5t(i, n, t, r);
      return UC(u) ? Z5t(p, g, K5t(u, r, l, e)) : [p, g];
    }
    case Tp:
      return [0, Math.PI * 2];
    case c2:
      return [0, 360];
    case om:
      return [
        0,
        new du(() => {
          const h = t.getSignalName(Id(t.parent) ? "child_width" : "width"), p = t.getSignalName(Id(t.parent) ? "child_height" : "height");
          return `min(${h},${p})/2`;
        })
      ];
    case Bw:
      return [r.scale.minStrokeWidth, r.scale.maxStrokeWidth];
    case Uw:
      return [
        // TODO: add this to Vega's config.range?
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case If:
      return "symbol";
    case Pf:
    case hv:
    case pv:
      return u === "ordinal" ? a === "nominal" ? "category" : "ordinal" : f !== void 0 ? "diverging" : i === "rect" || i === "geoshape" ? "heatmap" : "ramp";
    case Ab:
    case zw:
    case Fw:
      return [r.scale.minOpacity, r.scale.maxOpacity];
  }
}
function AIe(e, t, n) {
  const { encoding: r } = t, i = t.getScaleComponent(n), o = Sre(n), a = r[o];
  if (mPe({ step: e, offsetIsDiscrete: or(a) && b4e(a.type) }) === "offset" && K4e(r, o)) {
    const u = t.getScaleComponent(o);
    let f = `domain('${t.scaleName(o)}').length`;
    if (u.get("type") === "band") {
      const p = u.get("paddingInner") ?? u.get("padding") ?? 0, g = u.get("paddingOuter") ?? u.get("padding") ?? 0;
      f = `bandspace(${f}, ${p}, ${g})`;
    }
    const h = i.get("paddingInner") ?? i.get("padding");
    return {
      signal: `${e.step} * ${f} / (1-${E4t(h)})`
    };
  } else
    return e.step;
}
function OIe(e, t) {
  if (mPe({ step: e, offsetIsDiscrete: xu(t) }) === "offset")
    return { step: e.step };
}
function X5t(e, t, n) {
  const r = e === Lw ? "x" : "y", i = t.getScaleComponent(r);
  if (!i)
    return DIe(r, t, n, { center: !0 });
  const o = i.get("type"), a = t.scaleName(r), { markDef: s, config: u } = t;
  if (o === "band") {
    const l = RIe(r, t.size, t.config.view);
    if (ev(l)) {
      const f = OIe(l, n);
      if (f)
        return f;
    }
    return [0, { signal: `bandwidth('${a}')` }];
  } else {
    const l = t.encoding[r];
    if (xt(l) && l.timeUnit) {
      const f = g4e(l.timeUnit, (y) => `scale('${a}', ${y})`), h = t.config.scale.bandWithNestedOffsetPaddingInner, p = mw({
        fieldDef: l,
        markDef: s,
        config: u
      }) - 0.5, g = p !== 0 ? ` + ${p}` : "";
      if (h) {
        const y = an(h) ? `${h.signal}/2` + g : `${h / 2 + p}`, b = an(h) ? `(1 - ${h.signal}/2)` + g : `${1 - h / 2 + p}`;
        return [{ signal: `${y} * (${f})` }, { signal: `${b} * (${f})` }];
      }
      return [0, { signal: f }];
    }
    return M$e(`Cannot use ${e} scale if ${r} scale is not discrete.`);
  }
}
function RIe(e, t, n) {
  const r = e === aa ? "width" : "height", i = t[r];
  return i || xz(n, r);
}
function K5t(e, t, n, r) {
  switch (e) {
    case "quantile":
      return t.scale.quantileCount;
    case "quantize":
      return t.scale.quantizeCount;
    case "threshold":
      return n !== void 0 && nt(n) ? n.length + 1 : (bt(TPt(r)), 3);
  }
}
function Z5t(e, t, n) {
  const r = () => {
    const i = Ig(t), o = Ig(e), a = `(${i} - ${o}) / (${n} - 1)`;
    return `sequence(${o}, ${i} + ${a}, ${a})`;
  };
  return an(t) ? new du(r) : { signal: r() };
}
function kIe(e, t, n) {
  if (t)
    return an(t) ? { signal: `${t.signal} ? 0 : ${kIe(e, !1, n)}` } : 0;
  switch (e) {
    case "bar":
    case "tick":
      return n.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return n.scale.minStrokeWidth;
    case "text":
      return n.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return n.scale.minSize;
  }
  throw new Error(C8("size", e));
}
const lve = 0.95;
function J5t(e, t, n, r) {
  const i = {
    x: uve(n, "x"),
    y: uve(n, "y")
  };
  switch (e) {
    case "bar":
    case "tick": {
      if (r.scale.maxBandSize !== void 0)
        return r.scale.maxBandSize;
      const o = cve(t, i, r.view);
      return pi(o) ? o - 1 : new du(() => `${o.signal} - 1`);
    }
    case "line":
    case "trail":
    case "rule":
      return r.scale.maxStrokeWidth;
    case "text":
      return r.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (r.scale.maxSize)
        return r.scale.maxSize;
      const o = cve(t, i, r.view);
      return pi(o) ? Math.pow(lve * o, 2) : new du(() => `pow(${lve} * ${o.signal}, 2)`);
    }
  }
  throw new Error(C8("size", e));
}
function cve(e, t, n) {
  const r = ev(e.width) ? e.width.step : bz(n, "width"), i = ev(e.height) ? e.height.step : bz(n, "height");
  return t.x || t.y ? new du(() => `min(${[
    t.x ? t.x.signal : r,
    t.y ? t.y.signal : i
  ].join(", ")})`) : Math.min(r, i);
}
function $Ie(e, t) {
  za(e) ? ezt(e, t) : IIe(e, t);
}
function ezt(e, t) {
  const n = e.component.scales, { config: r, encoding: i, markDef: o, specifiedScales: a } = e;
  for (const s of yt(n)) {
    const u = a[s], l = n[s], f = e.getScaleComponent(s), h = Hs(i[s]), p = u[t], g = f.get("type"), y = f.get("padding"), b = f.get("paddingInner"), _ = nX(g, t), S = M4e(s, t);
    if (p !== void 0 && (_ ? S && bt(S) : bt(i4e(g, t, s))), _ && S === void 0)
      if (p !== void 0) {
        const C = h.timeUnit, A = h.type;
        switch (t) {
          case "domainMax":
          case "domainMin":
            h2(u[t]) || A === "temporal" || C ? l.set(t, { signal: L8(u[t], { type: A, timeUnit: C }) }, !0) : l.set(t, u[t], !0);
            break;
          default:
            l.copyKeyFromObject(t, u);
        }
      } else {
        const C = t in fve ? fve[t]({
          model: e,
          channel: s,
          fieldOrDatumDef: h,
          scaleType: g,
          scalePadding: y,
          scalePaddingInner: b,
          domain: u.domain,
          domainMin: u.domainMin,
          domainMax: u.domainMax,
          markDef: o,
          config: r,
          hasNestedOffsetScale: Z4e(i, s),
          hasSecondaryRangeChannel: !!i[gv(s)]
        }) : r.scale[t];
        C !== void 0 && l.set(t, C, !1);
      }
  }
}
const fve = {
  bins: ({ model: e, fieldOrDatumDef: t }) => xt(t) ? tzt(e, t) : void 0,
  interpolate: ({ channel: e, fieldOrDatumDef: t }) => nzt(e, t.type),
  nice: ({ scaleType: e, channel: t, domain: n, domainMin: r, domainMax: i, fieldOrDatumDef: o }) => rzt(e, t, n, r, i, o),
  padding: ({ channel: e, scaleType: t, fieldOrDatumDef: n, markDef: r, config: i }) => izt(e, t, i.scale, n, r, i.bar),
  paddingInner: ({ scalePadding: e, channel: t, markDef: n, scaleType: r, config: i, hasNestedOffsetScale: o }) => ozt(e, t, n.type, r, i.scale, o),
  paddingOuter: ({ scalePadding: e, channel: t, scaleType: n, scalePaddingInner: r, config: i, hasNestedOffsetScale: o }) => azt(e, t, n, r, i.scale, o),
  reverse: ({ fieldOrDatumDef: e, scaleType: t, channel: n, config: r }) => {
    const i = xt(e) ? e.sort : void 0;
    return szt(t, i, n, r.scale);
  },
  zero: ({ channel: e, fieldOrDatumDef: t, domain: n, markDef: r, scaleType: i, config: o, hasSecondaryRangeChannel: a }) => uzt(e, t, n, r, i, o.scale, a)
};
function PIe(e) {
  za(e) ? W5t(e) : IIe(e, "range");
}
function IIe(e, t) {
  const n = e.component.scales;
  for (const r of e.children)
    t === "range" ? PIe(r) : $Ie(r, t);
  for (const r of yt(n)) {
    let i;
    for (const o of e.children) {
      const a = o.component.scales[r];
      if (a) {
        const s = a.getWithExplicit(t);
        i = yw(i, s, t, "scale", DPe((u, l) => {
          switch (t) {
            case "range":
              return u.step && l.step ? u.step - l.step : 0;
          }
          return 0;
        }));
      }
    }
    n[r].setWithExplicit(t, i);
  }
}
function tzt(e, t) {
  const n = t.bin;
  if (Lo(n)) {
    const r = Mie(e, t.field, n);
    return new du(() => e.getSignalName(r));
  } else if (Qu(n) && d2(n) && n.step !== void 0)
    return {
      step: n.step
    };
}
function nzt(e, t) {
  if (Kr([Pf, hv, pv], e) && t !== "nominal")
    return "hcl";
}
function rzt(e, t, n, r, i, o) {
  var a;
  if (!((a = Jy(o)) != null && a.bin || nt(n) || i != null || r != null || Kr([Sf.TIME, Sf.UTC], e)))
    return is(t) ? !0 : void 0;
}
function izt(e, t, n, r, i, o) {
  if (is(e)) {
    if (jg(t)) {
      if (n.continuousPadding !== void 0)
        return n.continuousPadding;
      const { type: a, orient: s } = i;
      if (a === "bar" && !(xt(r) && (r.bin || r.timeUnit)) && (s === "vertical" && e === "x" || s === "horizontal" && e === "y"))
        return o.continuousBandSize;
    }
    if (t === Sf.POINT)
      return n.pointPadding;
  }
}
function ozt(e, t, n, r, i, o = !1) {
  if (e === void 0) {
    if (is(t)) {
      const { bandPaddingInner: a, barBandPaddingInner: s, rectBandPaddingInner: u, bandWithNestedOffsetPaddingInner: l } = i;
      return o ? l : rs(a, n === "bar" ? s : u);
    } else if (T4(t) && r === Sf.BAND)
      return i.offsetBandPaddingInner;
  }
}
function azt(e, t, n, r, i, o = !1) {
  if (e === void 0) {
    if (is(t)) {
      const { bandPaddingOuter: a, bandWithNestedOffsetPaddingOuter: s } = i;
      if (o)
        return s;
      if (n === Sf.BAND)
        return rs(
          a,
          /* By default, paddingOuter is paddingInner / 2. The reason is that
            size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
            and we want the width/height to be integer by default.
            Note that step (by default) and cardinality are integers.) */
          an(r) ? { signal: `${r.signal}/2` } : r / 2
        );
    } else if (T4(t)) {
      if (n === Sf.POINT)
        return 0.5;
      if (n === Sf.BAND)
        return i.offsetBandPaddingOuter;
    }
  }
}
function szt(e, t, n, r) {
  if (n === "x" && r.xReverse !== void 0)
    return Wd(e) && t === "descending" ? an(r.xReverse) ? { signal: `!${r.xReverse.signal}` } : !r.xReverse : r.xReverse;
  if (Wd(e) && t === "descending")
    return !0;
}
function uzt(e, t, n, r, i, o, a) {
  if (!!n && n !== "unaggregated" && Wd(i)) {
    if (nt(n)) {
      const u = n[0], l = n[n.length - 1];
      if (pi(u) && u <= 0 && pi(l) && l >= 0)
        return !0;
    }
    return !1;
  }
  if (e === "size" && t.type === "quantitative" && !UC(i))
    return !0;
  if (!(xt(t) && t.bin) && Kr([...mv, ...o4t], e)) {
    const { orient: u, type: l } = r;
    return Kr(["bar", "area", "line", "trail"], l) && (u === "horizontal" && e === "y" || u === "vertical" && e === "x") ? !1 : Kr(["bar", "area"], l) && !a ? !0 : o == null ? void 0 : o.zero;
  }
  return !1;
}
function lzt(e, t, n, r, i = !1) {
  const o = czt(t, n, r, i), { type: a } = e;
  return Ob(t) ? a !== void 0 ? lIt(t, a) ? xt(n) && !uIt(a, n.type) ? (bt(cPt(a, o)), o) : a : (bt(lPt(t, a, o)), o) : o : null;
}
function czt(e, t, n, r) {
  var i;
  switch (t.type) {
    case "nominal":
    case "ordinal": {
      if (LT(e) || NV(e) === "discrete")
        return e === "shape" && t.type === "ordinal" && bt(DV(e, "ordinal")), "ordinal";
      if (is(e) || T4(e)) {
        if (Kr(["rect", "bar", "image", "rule"], n.type) || r)
          return "band";
      } else if (n.type === "arc" && e in Cre)
        return "band";
      const o = n[jf(e)];
      return WS(o) || HC(t) && ((i = t.axis) != null && i.tickBand) ? "band" : "point";
    }
    case "temporal":
      return LT(e) ? "time" : NV(e) === "discrete" ? (bt(DV(e, "temporal")), "ordinal") : xt(t) && t.timeUnit && bu(t.timeUnit).utc ? "utc" : "time";
    case "quantitative":
      return LT(e) ? xt(t) && Lo(t.bin) ? "bin-ordinal" : "linear" : NV(e) === "discrete" ? (bt(DV(e, "quantitative")), "ordinal") : "linear";
    case "geojson":
      return;
  }
  throw new Error(n4e(t.type));
}
function fzt(e, { ignoreRange: t } = {}) {
  jIe(e), TIe(e);
  for (const n of sIt)
    $Ie(e, n);
  t || PIe(e);
}
function jIe(e) {
  za(e) ? e.component.scales = dzt(e) : e.component.scales = pzt(e);
}
function dzt(e) {
  const { encoding: t, mark: n, markDef: r } = e, i = {};
  for (const o of M8) {
    const a = Hs(t[o]);
    if (a && n === k4e && o === If && a.type === zN)
      continue;
    let s = a && a.scale;
    if (a && s !== null && s !== !1) {
      s ?? (s = {});
      const u = Z4e(t, o), l = lzt(s, o, a, r, u);
      i[o] = new NIe(e.scaleName(`${o}`, !0), {
        value: l,
        explicit: s.type === l
      });
    }
  }
  return i;
}
const hzt = DPe((e, t) => yye(e) - yye(t));
function pzt(e) {
  var t;
  const n = e.component.scales = {}, r = {}, i = e.component.resolve;
  for (const o of e.children) {
    jIe(o);
    for (const a of yt(o.component.scales))
      if ((t = i.scale)[a] ?? (t[a] = hIe(a, e)), i.scale[a] === "shared") {
        const s = r[a], u = o.component.scales[a].getWithExplicit("type");
        s ? KPt(s.value, u.value) ? r[a] = yw(s, u, "type", "scale", hzt) : (i.scale[a] = "independent", delete r[a]) : r[a] = u;
      }
  }
  for (const o of yt(r)) {
    const a = e.scaleName(o, !0), s = r[o];
    n[o] = new NIe(a, s);
    for (const u of e.children) {
      const l = u.component.scales[o];
      l && (u.renameScale(l.get("name"), a), l.merged = !0);
    }
  }
  return n;
}
class LV {
  constructor() {
    this.nameMap = {};
  }
  rename(t, n) {
    this.nameMap[t] = n;
  }
  has(t) {
    return this.nameMap[t] !== void 0;
  }
  get(t) {
    for (; this.nameMap[t] && t !== this.nameMap[t]; )
      t = this.nameMap[t];
    return t;
  }
}
function za(e) {
  return (e == null ? void 0 : e.type) === "unit";
}
function Id(e) {
  return (e == null ? void 0 : e.type) === "facet";
}
function Aie(e) {
  return (e == null ? void 0 : e.type) === "concat";
}
function HN(e) {
  return (e == null ? void 0 : e.type) === "layer";
}
class Oie {
  constructor(t, n, r, i, o, a, s) {
    this.type = n, this.parent = r, this.config = o, this.correctDataNames = (u) => {
      var l, f, h;
      return (l = u.from) != null && l.data && (u.from.data = this.lookupDataSource(u.from.data)), (h = (f = u.from) == null ? void 0 : f.facet) != null && h.data && (u.from.facet.data = this.lookupDataSource(u.from.facet.data)), u;
    }, this.parent = r, this.config = o, this.view = yf(s), this.name = t.name ?? i, this.title = gx(t.title) ? { text: t.title } : t.title ? yf(t.title) : void 0, this.scaleNameMap = r ? r.scaleNameMap : new LV(), this.projectionNameMap = r ? r.projectionNameMap : new LV(), this.signalNameMap = r ? r.signalNameMap : new LV(), this.data = t.data, this.description = t.description, this.transforms = wjt(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : M3t(t, n, o), this.component = {
      data: {
        sources: r ? r.component.data.sources : [],
        outputNodes: r ? r.component.data.outputNodes : {},
        outputNodeRefCounts: r ? r.component.data.outputNodeRefCounts : {},
        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
        isFaceted: $8(t) || (r == null ? void 0 : r.component.data.isFaceted) && t.data === void 0
      },
      layoutSize: new kb(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: {
        scale: {},
        axis: {},
        legend: {},
        ...a ? Kn(a) : {}
      },
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();
  }
  parseScale() {
    fzt(this);
  }
  parseProjection() {
    EIe(this);
  }
  /**
   * Rename top-level spec's size to be just width / height, ignoring model name.
   * This essentially merges the top-level spec's width/height signals with the width/height signals
   * to help us reduce redundant signals declaration.
   */
  renameTopLevelLayoutSizeSignal() {
    this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
  }
  parseLegends() {
    vIe(this);
  }
  assembleEncodeFromView(t) {
    const { style: n, ...r } = t, i = {};
    for (const o of yt(r)) {
      const a = r[o];
      a !== void 0 && (i[o] = Vo(a));
    }
    return i;
  }
  assembleGroupEncodeEntry(t) {
    let n = {};
    return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = Vo(this.description)), this.type === "unit" || this.type === "layer") ? {
      width: this.getSizeSignalRef("width"),
      height: this.getSizeSignalRef("height"),
      ...n
    } : go(n) ? void 0 : n;
  }
  assembleLayout() {
    if (!this.layout)
      return;
    const { spacing: t, ...n } = this.layout, { component: r, config: i } = this, o = PLt(r.layoutHeaders, i);
    return {
      padding: t,
      ...this.assembleDefaultLayout(),
      ...n,
      ...o ? { titleBand: o } : {}
    };
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: t } = this.component;
    let n = [];
    for (const r of rp)
      t[r].title && n.push(DLt(this, r));
    for (const r of wie)
      n = n.concat(ALt(this, r));
    return n;
  }
  assembleAxes() {
    return mLt(this.component.axes, this.config);
  }
  assembleLegends() {
    return xIe(this);
  }
  assembleProjections() {
    return i5t(this);
  }
  assembleTitle() {
    const { encoding: t, ...n } = this.title ?? {}, r = {
      ...q$e(this.config.title).nonMarkTitleProperties,
      ...n,
      ...t ? { encode: { update: t } } : {}
    };
    if (r.text)
      return Kr(["unit", "layer"], this.type) ? Kr(["middle", void 0], r.anchor) && (r.frame ?? (r.frame = "group")) : r.anchor ?? (r.anchor = "start"), go(r) ? void 0 : r;
  }
  /**
   * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
   */
  assembleGroup(t = []) {
    const n = {};
    t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
    const r = this.assembleLayout();
    r && (n.layout = r), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const i = !this.parent || Id(this.parent) ? CIe(this) : [];
    i.length > 0 && (n.scales = i);
    const o = this.assembleAxes();
    o.length > 0 && (n.axes = o);
    const a = this.assembleLegends();
    return a.length > 0 && (n.legends = a), n;
  }
  getName(t) {
    return oa((this.name ? `${this.name}_` : "") + t);
  }
  getDataName(t) {
    return this.getName(ra[t].toLowerCase());
  }
  /**
   * Request a data source name for the given data source type and mark that data source as required.
   * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
   * You can lookup the correct dataset name in assemble with `lookupDataSource`.
   */
  requestDataName(t) {
    const n = this.getDataName(t), r = this.component.data.outputNodeRefCounts;
    return r[n] = (r[n] || 0) + 1, n;
  }
  getSizeSignalRef(t) {
    if (Id(this.parent)) {
      const n = fIe(t), r = S8(n), i = this.component.scales[r];
      if (i && !i.merged) {
        const o = i.get("type"), a = i.get("range");
        if (xu(o) && Hw(a)) {
          const s = i.get("name"), u = X8(this, r), l = Die(u);
          if (l) {
            const f = Mt({ aggregate: "distinct", field: l }, { expr: "datum" });
            return {
              signal: cIe(s, i, f)
            };
          } else
            return bt(Are(r)), null;
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(t))
    };
  }
  /**
   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
   */
  lookupDataSource(t) {
    const n = this.component.data.outputNodes[t];
    return n ? n.getSource() : t;
  }
  getSignalName(t) {
    return this.signalNameMap.get(t);
  }
  renameSignal(t, n) {
    this.signalNameMap.rename(t, n);
  }
  renameScale(t, n) {
    this.scaleNameMap.rename(t, n);
  }
  renameProjection(t, n) {
    this.projectionNameMap.rename(t, n);
  }
  /**
   * @return scale name for a given channel after the scale has been parsed and named.
   */
  scaleName(t, n) {
    if (n)
      return this.getName(t);
    if (
      // If there is a scale for the channel, there should be a local scale component for it
      L$e(t) && Ob(t) && this.component.scales[t] || // in the scale name map (the scale get merged by its parent)
      this.scaleNameMap.has(this.getName(t))
    )
      return this.scaleNameMap.get(this.getName(t));
  }
  /**
   * @return projection name after the projection has been parsed and named.
   */
  projectionName(t) {
    if (t)
      return this.getName("projection");
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")))
      return this.projectionNameMap.get(this.getName("projection"));
  }
  /**
   * Traverse a model's hierarchy to get the scale component for a particular channel.
   */
  getScaleComponent(t) {
    if (!this.component.scales)
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    const n = this.component.scales[t];
    return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
  }
  /**
   * Traverse a model's hierarchy to get a particular selection component.
   */
  getSelectionComponent(t, n) {
    let r = this.component.selection[t];
    if (!r && this.parent && (r = this.parent.getSelectionComponent(t, n)), !r)
      throw new Error(N4t(n));
    return r;
  }
  /**
   * Returns true if the model has a signalRef for an axis orient.
   */
  hasAxisOrientSignalRef() {
    var t, n;
    return ((t = this.component.axes.x) == null ? void 0 : t.some((r) => r.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some((r) => r.hasOrientSignalRef()));
  }
}
class LIe extends Oie {
  /** Get "field" reference for Vega */
  vgField(t, n = {}) {
    const r = this.fieldDef(t);
    if (r)
      return Mt(r, n);
  }
  reduceFieldDef(t, n) {
    return e3t(this.getMapping(), (r, i, o) => {
      const a = Jy(i);
      return a ? t(r, a, o) : r;
    }, n);
  }
  forEachFieldDef(t, n) {
    rie(this.getMapping(), (r, i) => {
      const o = Jy(r);
      o && t(o, i);
    }, n);
  }
}
class K8 extends oo {
  clone() {
    return new K8(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
    const r = this.transform.as ?? [void 0, void 0];
    this.transform.as = [r[0] ?? "value", r[1] ?? "density"];
    const i = this.transform.resolve ?? "shared";
    this.transform.resolve = i;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.density, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { density: t, ...n } = this.transform, r = {
      type: "kde",
      field: t,
      ...n
    };
    return r.resolve = this.transform.resolve, r;
  }
}
class Z8 extends oo {
  clone() {
    return new Z8(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.extent]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([]);
  }
  hash() {
    return `ExtentTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { extent: t, param: n } = this.transform;
    return {
      type: "extent",
      field: t,
      signal: n
    };
  }
}
class c$ extends oo {
  clone() {
    return new c$(null, { ...this.filter });
  }
  constructor(t, n) {
    super(t), this.filter = n;
  }
  static make(t, n) {
    const { config: r, mark: i, markDef: o } = n;
    if (Fi("invalid", o, r) !== "filter")
      return null;
    const s = n.reduceFieldDef((u, l, f) => {
      const h = Ob(f) && n.getScaleComponent(f);
      if (h) {
        const p = h.get("type");
        Wd(p) && l.aggregate !== "count" && !g2(i) && (u[l.field] = l);
      }
      return u;
    }, {});
    return yt(s).length ? new c$(t, s) : null;
  }
  dependentFields() {
    return new Set(yt(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${Xr(this.filter)}`;
  }
  /**
   * Create the VgTransforms for each of the filtered fields.
   */
  assemble() {
    const t = yt(this.filter).reduce((n, r) => {
      const i = this.filter[r], o = Mt(i, { expr: "datum" });
      return i !== null && (i.type === "temporal" ? n.push(`(isDate(${o}) || (isValid(${o}) && isFinite(+${o})))`) : i.type === "quantitative" && (n.push(`isValid(${o})`), n.push(`isFinite(+${o})`))), n;
    }, []);
    return t.length > 0 ? {
      type: "filter",
      expr: t.join(" && ")
    } : null;
  }
}
class J8 extends oo {
  clone() {
    return new J8(this.parent, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
    const { flatten: r, as: i = [] } = this.transform;
    this.transform.as = r.map((o, a) => i[a] ?? o);
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { flatten: t, as: n } = this.transform;
    return {
      type: "flatten",
      fields: t,
      as: n
    };
  }
}
class e9 extends oo {
  clone() {
    return new e9(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
    const r = this.transform.as ?? [void 0, void 0];
    this.transform.as = [r[0] ?? "key", r[1] ?? "value"];
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { fold: t, as: n } = this.transform;
    return {
      type: "fold",
      fields: t,
      as: n
    };
  }
}
class BT extends oo {
  clone() {
    return new BT(null, Kn(this.fields), this.geojson, this.signal);
  }
  static parseAll(t, n) {
    if (n.component.projection && !n.component.projection.isFit)
      return t;
    let r = 0;
    for (const i of [
      [sm, am],
      [Ep, um]
    ]) {
      const o = i.map((a) => {
        const s = Hs(n.encoding[a]);
        return xt(s) ? s.field : yv(s) ? { expr: `${s.datum}` } : Qg(s) ? { expr: `${s.value}` } : void 0;
      });
      (o[0] || o[1]) && (t = new BT(t, o, null, n.getName(`geojson_${r++}`)));
    }
    if (n.channelHasField(If)) {
      const i = n.typedFieldDef(If);
      i.type === zN && (t = new BT(t, null, i.field, n.getName(`geojson_${r++}`)));
    }
    return t;
  }
  constructor(t, n, r, i) {
    super(t), this.fields = n, this.geojson = r, this.signal = i;
  }
  dependentFields() {
    const t = (this.fields ?? []).filter(kt);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...t]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${Xr(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      {
        type: "geojson",
        ...this.fields ? { fields: this.fields } : {},
        ...this.geojson ? { geojson: this.geojson } : {},
        signal: this.signal
      }
    ];
  }
}
class f$ extends oo {
  clone() {
    return new f$(null, this.projection, Kn(this.fields), Kn(this.as));
  }
  constructor(t, n, r, i) {
    super(t), this.projection = n, this.fields = r, this.as = i;
  }
  static parseAll(t, n) {
    if (!n.projectionName())
      return t;
    for (const r of [
      [sm, am],
      [Ep, um]
    ]) {
      const i = r.map((a) => {
        const s = Hs(n.encoding[a]);
        return xt(s) ? s.field : yv(s) ? { expr: `${s.datum}` } : Qg(s) ? { expr: `${s.value}` } : void 0;
      }), o = r[0] === Ep ? "2" : "";
      (i[0] || i[1]) && (t = new f$(t, n.projectionName(), i, [
        n.getName(`x${o}`),
        n.getName(`y${o}`)
      ]));
    }
    return t;
  }
  dependentFields() {
    return new Set(this.fields.filter(kt));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${Xr(this.fields)} ${Xr(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
}
class cS extends oo {
  clone() {
    return new cS(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(t) {
    const { start: n = 0, stop: r, step: i } = t;
    return { signal: `sequence(${[n, r, ...i ? [i] : []].join(",")})` };
  }
  static makeFromTransform(t, n) {
    return new cS(t, n);
  }
  static makeFromEncoding(t, n) {
    const r = n.encoding, i = r.x, o = r.y;
    if (xt(i) && xt(o)) {
      const a = i.impute ? i : o.impute ? o : void 0;
      if (a === void 0)
        return;
      const s = i.impute ? o : o.impute ? i : void 0, { method: u, value: l, frame: f, keyvals: h } = a.impute, p = ePe(n.mark, r);
      return new cS(t, {
        impute: a.field,
        key: s.field,
        ...u ? { method: u } : {},
        ...l !== void 0 ? { value: l } : {},
        ...f ? { frame: f } : {},
        ...h !== void 0 ? { keyvals: h } : {},
        ...p.length ? { groupby: p } : {}
      });
    }
    return null;
  }
  hash() {
    return `Impute ${Xr(this.transform)}`;
  }
  assemble() {
    const { impute: t, key: n, keyvals: r, method: i, groupby: o, value: a, frame: s = [null, null] } = this.transform, u = {
      type: "impute",
      field: t,
      key: n,
      ...r ? { keyvals: njt(r) ? this.processSequence(r) : r } : {},
      method: "value",
      ...o ? { groupby: o } : {},
      value: !i || i === "value" ? a : null
    };
    if (i && i !== "value") {
      const l = {
        type: "window",
        as: [`imputed_${t}_value`],
        ops: [i],
        fields: [t],
        frame: s,
        ignorePeers: !1,
        ...o ? { groupby: o } : {}
      }, f = {
        type: "formula",
        expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
        as: t
      };
      return [u, l, f];
    } else
      return [u];
  }
}
class t9 extends oo {
  clone() {
    return new t9(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
    const r = this.transform.as ?? [void 0, void 0];
    this.transform.as = [r[0] ?? n.on, r[1] ?? n.loess];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { loess: t, on: n, ...r } = this.transform;
    return {
      type: "loess",
      x: n,
      y: t,
      ...r
    };
  }
}
class d$ extends oo {
  clone() {
    return new d$(null, Kn(this.transform), this.secondary);
  }
  constructor(t, n, r) {
    super(t), this.transform = n, this.secondary = r;
  }
  static make(t, n, r, i) {
    const o = n.component.data.sources, { from: a } = r;
    let s = null;
    if (rjt(a)) {
      let u = BIe(a.data, o);
      u || (u = new QS(a.data), o.push(u));
      const l = n.getName(`lookup_${i}`);
      s = new Mf(u, l, ra.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[l] = s;
    } else if (ijt(a)) {
      const u = a.param;
      r = { as: u, ...r };
      let l;
      try {
        l = n.getSelectionComponent(oa(u), u);
      } catch {
        throw new Error(R4t(u));
      }
      if (s = l.materialized, !s)
        throw new Error(k4t(u));
    }
    return new d$(t, r, s.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? Rt(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${Xr({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let t;
    if (this.transform.from.fields)
      t = {
        values: this.transform.from.fields,
        ...this.transform.as ? { as: Rt(this.transform.as) } : {}
      };
    else {
      let n = this.transform.as;
      kt(n) || (bt(B4t), n = "_lookup"), t = {
        as: [n]
      };
    }
    return {
      type: "lookup",
      from: this.secondary,
      key: this.transform.from.key,
      fields: [this.transform.lookup],
      ...t,
      ...this.transform.default ? { default: this.transform.default } : {}
    };
  }
}
class n9 extends oo {
  clone() {
    return new n9(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
    const r = this.transform.as ?? [void 0, void 0];
    this.transform.as = [r[0] ?? "prob", r[1] ?? "value"];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { quantile: t, ...n } = this.transform;
    return {
      type: "quantile",
      field: t,
      ...n
    };
  }
}
class r9 extends oo {
  clone() {
    return new r9(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = Kn(n);
    const r = this.transform.as ?? [void 0, void 0];
    this.transform.as = [r[0] ?? n.on, r[1] ?? n.regression];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { regression: t, on: n, ...r } = this.transform;
    return {
      type: "regression",
      x: n,
      y: t,
      ...r
    };
  }
}
class i9 extends oo {
  clone() {
    return new i9(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = $y((this.transform.groupby ?? []).concat(t), (n) => n);
  }
  producedFields() {
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []]);
  }
  hash() {
    return `PivotTransform ${Xr(this.transform)}`;
  }
  assemble() {
    const { pivot: t, value: n, groupby: r, limit: i, op: o } = this.transform;
    return {
      type: "pivot",
      field: t,
      value: n,
      ...i !== void 0 ? { limit: i } : {},
      ...o !== void 0 ? { op: o } : {},
      ...r !== void 0 ? { groupby: r } : {}
    };
  }
}
class o9 extends oo {
  clone() {
    return new o9(null, Kn(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${Xr(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
}
function zIe(e) {
  let t = 0;
  function n(r, i) {
    if (r instanceof QS && !r.isGenerator && !WC(r.data) && (e.push(i), i = {
      name: null,
      source: i.name,
      transform: []
    }), r instanceof Ul && (r.parent instanceof QS && !i.source ? (i.format = {
      ...i.format,
      parse: r.assembleFormatParse()
    }, i.transform.push(...r.assembleTransforms(!0))) : i.transform.push(...r.assembleTransforms())), r instanceof UN) {
      i.name || (i.name = `data_${t++}`), !i.source || i.transform.length > 0 ? (e.push(i), r.data = i.name) : r.data = i.source, e.push(...r.assemble());
      return;
    }
    switch ((r instanceof P4 || r instanceof I4 || r instanceof c$ || r instanceof BN || r instanceof GC || r instanceof f$ || r instanceof Ug || r instanceof d$ || r instanceof YN || r instanceof v2 || r instanceof e9 || r instanceof J8 || r instanceof K8 || r instanceof t9 || r instanceof n9 || r instanceof r9 || r instanceof xw || r instanceof o9 || r instanceof i9 || r instanceof Z8) && i.transform.push(r.assemble()), (r instanceof Hy || r instanceof Yy || r instanceof cS || r instanceof ib || r instanceof BT) && i.transform.push(...r.assemble()), r instanceof Mf && (i.source && i.transform.length === 0 ? r.setSource(i.source) : r.parent instanceof Mf ? r.setSource(i.name) : (i.name || (i.name = `data_${t++}`), r.setSource(i.name), r.numChildren() === 1 && (e.push(i), i = {
      name: null,
      source: i.name,
      transform: []
    }))), r.numChildren()) {
      case 0:
        r instanceof Mf && (!i.source || i.transform.length > 0) && e.push(i);
        break;
      case 1:
        n(r.children[0], i);
        break;
      default: {
        i.name || (i.name = `data_${t++}`);
        let o = i.name;
        !i.source || i.transform.length > 0 ? e.push(i) : o = i.source;
        for (const a of r.children)
          n(a, {
            name: null,
            source: o,
            transform: []
          });
        break;
      }
    }
  }
  return n;
}
function gzt(e) {
  const t = [], n = zIe(t);
  for (const r of e.children)
    n(r, {
      source: e.name,
      name: null,
      transform: []
    });
  return t;
}
function mzt(e, t) {
  const n = [], r = zIe(n);
  let i = 0;
  for (const a of e.sources) {
    a.hasName() || (a.dataName = `source_${i++}`);
    const s = a.assemble();
    r(a, s);
  }
  for (const a of n)
    a.transform.length === 0 && delete a.transform;
  let o = 0;
  for (const [a, s] of n.entries())
    (s.transform ?? []).length === 0 && !s.source && n.splice(o++, 0, n.splice(a, 1)[0]);
  for (const a of n)
    for (const s of a.transform ?? [])
      s.type === "lookup" && (s.from = e.outputNodes[s.from].getSource());
  for (const a of n)
    a.name in t && (a.values = t[a.name]);
  return n;
}
function yzt(e) {
  return e === "top" || e === "left" || an(e) ? "header" : "footer";
}
function vzt(e) {
  for (const t of rp)
    bzt(e, t);
  dve(e, "x"), dve(e, "y");
}
function bzt(e, t) {
  var a;
  const { facet: n, config: r, child: i, component: o } = e;
  if (e.channelHasField(t)) {
    const s = n[t], u = XC("title", null, r, t);
    let l = zT(s, r, {
      allowDisabling: !0,
      includeDefault: u === void 0 || !!u
    });
    i.component.layoutHeaders[t].title && (l = nt(l) ? l.join(", ") : l, l += ` / ${i.component.layoutHeaders[t].title}`, i.component.layoutHeaders[t].title = null);
    const f = XC("labelOrient", s.header, r, t), h = s.header !== null ? rs((a = s.header) == null ? void 0 : a.labels, r.header.labels, !0) : !1, p = Kr(["bottom", "right"], f) ? "footer" : "header";
    o.layoutHeaders[t] = {
      title: s.header !== null ? l : null,
      facetFieldDef: s,
      [p]: t === "facet" ? [] : [FIe(e, t, h)]
    };
  }
}
function FIe(e, t, n) {
  const r = t === "row" ? "height" : "width";
  return {
    labels: n,
    sizeSignal: e.child.component.layoutSize.get(r) ? e.child.getSizeSignalRef(r) : void 0,
    axes: []
  };
}
function dve(e, t) {
  const { child: n } = e;
  if (n.component.axes[t]) {
    const { layoutHeaders: r, resolve: i } = e.component;
    if (i.axis[t] = Sie(i, t), i.axis[t] === "shared") {
      const o = t === "x" ? "column" : "row", a = r[o];
      for (const s of n.component.axes[t]) {
        const u = yzt(s.get("orient"));
        a[u] ?? (a[u] = [FIe(e, o, !1)]);
        const l = iR(s, "main", e.config, { header: !0 });
        l && a[u][0].axes.push(l), s.mainExtracted = !0;
      }
    }
  }
}
function xzt(e) {
  Rie(e), Sz(e, "width"), Sz(e, "height");
}
function wzt(e) {
  Rie(e);
  const t = e.layout.columns === 1 ? "width" : "childWidth", n = e.layout.columns === void 0 ? "height" : "childHeight";
  Sz(e, t), Sz(e, n);
}
function Rie(e) {
  for (const t of e.children)
    t.parseLayoutSize();
}
function Sz(e, t) {
  const n = fIe(t), r = S8(n), i = e.component.resolve, o = e.component.layoutSize;
  let a;
  for (const s of e.children) {
    const u = s.component.layoutSize.getWithExplicit(n), l = i.scale[r] ?? hIe(r, e);
    if (l === "independent" && u.value === "step") {
      a = void 0;
      break;
    }
    if (a) {
      if (l === "independent" && a.value !== u.value) {
        a = void 0;
        break;
      }
      a = yw(a, u, n, "");
    } else
      a = u;
  }
  if (a) {
    for (const s of e.children)
      e.renameSignal(s.getName(n), e.getName(t)), s.component.layoutSize.set(n, "merged", !1);
    o.setWithExplicit(t, a);
  } else
    o.setWithExplicit(t, {
      explicit: !1,
      value: void 0
    });
}
function _zt(e) {
  const { size: t, component: n } = e;
  for (const r of mv) {
    const i = jf(r);
    if (t[i]) {
      const o = t[i];
      n.layoutSize.set(i, ev(o) ? "step" : o, !0);
    } else {
      const o = Ezt(e, i);
      n.layoutSize.set(i, o, !1);
    }
  }
}
function Ezt(e, t) {
  const n = t === "width" ? "x" : "y", r = e.config, i = e.getScaleComponent(n);
  if (i) {
    const o = i.get("type"), a = i.get("range");
    if (xu(o)) {
      const s = xz(r.view, t);
      return Hw(a) || ev(s) ? "step" : s;
    } else
      return oX(r.view, t);
  } else {
    if (e.hasProjection || e.mark === "arc")
      return oX(r.view, t);
    {
      const o = xz(r.view, t);
      return ev(o) ? o.step : o;
    }
  }
}
function bX(e, t, n) {
  return Mt(t, { suffix: `by_${Mt(e)}`, ...n });
}
class GR extends LIe {
  constructor(t, n, r, i) {
    super(t, "facet", n, r, i, t.resolve), this.child = jie(t.spec, this, this.getName("child"), void 0, i), this.children = [this.child], this.facet = this.initFacet(t.facet);
  }
  initFacet(t) {
    if (!A4(t))
      return { facet: this.initFacetFieldDef(t, "facet") };
    const n = yt(t), r = {};
    for (const i of n) {
      if (![tb, nb].includes(i)) {
        bt(C8(i, "facet"));
        break;
      }
      const o = t[i];
      if (o.field === void 0) {
        bt(eX(o, i));
        break;
      }
      r[i] = this.initFacetFieldDef(o, i);
    }
    return r;
  }
  initFacetFieldDef(t, n) {
    const r = tie(t, n);
    return r.header ? r.header = yf(r.header) : r.header === null && (r.header = null), r;
  }
  channelHasField(t) {
    return !!this.facet[t];
  }
  fieldDef(t) {
    return this.facet[t];
  }
  parseData() {
    this.component.data = a9(this), this.child.parseData();
  }
  parseLayoutSize() {
    Rie(this);
  }
  parseSelections() {
    this.child.parseSelections(), this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders(), vzt(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.child.assembleSelectionTopLevelSignals(t);
  }
  assembleSignals() {
    return this.child.assembleSignals(), [];
  }
  assembleSelectionData(t) {
    return this.child.assembleSelectionData(t);
  }
  getHeaderLayoutMixins() {
    const t = {};
    for (const n of rp)
      for (const r of _ie) {
        const i = this.component.layoutHeaders[n], o = i[r], { facetFieldDef: a } = i;
        if (a) {
          const s = XC("titleOrient", a.header, this.config, n);
          if (["right", "bottom"].includes(s)) {
            const u = G8(n, s);
            t.titleAnchor ?? (t.titleAnchor = {}), t.titleAnchor[u] = "end";
          }
        }
        if (o != null && o[0]) {
          const s = n === "row" ? "height" : "width", u = r === "header" ? "headerBand" : "footerBand";
          n !== "facet" && !this.child.component.layoutSize.get(s) && (t[u] ?? (t[u] = {}), t[u][n] = 0.5), i.title && (t.offset ?? (t.offset = {}), t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10);
        }
      }
    return t;
  }
  assembleDefaultLayout() {
    const { column: t, row: n } = this.facet, r = t ? this.columnDistinctSignal() : n ? 1 : void 0;
    let i = "all";
    return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (i = "none"), {
      ...this.getHeaderLayoutMixins(),
      ...r ? { columns: r } : {},
      bounds: "full",
      align: i
    };
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (!(this.parent && this.parent instanceof GR))
      return { signal: `length(data('${this.getName("column_domain")}'))` };
  }
  assembleGroupStyle() {
  }
  assembleGroup(t) {
    return this.parent && this.parent instanceof GR ? {
      ...this.channelHasField("column") ? {
        encode: {
          update: {
            // TODO(https://github.com/vega/vega-lite/issues/2759):
            // Correct the signal for facet of concat of facet_column
            columns: { field: Mt(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {},
      ...super.assembleGroup(t)
    } : super.assembleGroup(t);
  }
  /**
   * Aggregate cardinality for calculating size
   */
  getCardinalityAggregateForChild() {
    const t = [], n = [], r = [];
    if (this.child instanceof GR) {
      if (this.child.channelHasField("column")) {
        const i = Mt(this.child.facet.column);
        t.push(i), n.push("distinct"), r.push(`distinct_${i}`);
      }
    } else
      for (const i of mv) {
        const o = this.child.component.scales[i];
        if (o && !o.merged) {
          const a = o.get("type"), s = o.get("range");
          if (xu(a) && Hw(s)) {
            const u = X8(this.child, i), l = Die(u);
            l ? (t.push(l), n.push("distinct"), r.push(`distinct_${l}`)) : bt(Are(i));
          }
        }
      }
    return { fields: t, ops: n, as: r };
  }
  assembleFacet() {
    const { name: t, data: n } = this.component.data.facetRoot, { row: r, column: i } = this.facet, { fields: o, ops: a, as: s } = this.getCardinalityAggregateForChild(), u = [];
    for (const f of rp) {
      const h = this.facet[f];
      if (h) {
        u.push(Mt(h));
        const { bin: p, sort: g } = h;
        if (Lo(p) && u.push(Mt(h, { binSuffix: "end" })), Uy(g)) {
          const { field: y, op: b = k8 } = g, _ = bX(h, g);
          r && i ? (o.push(_), a.push("max"), s.push(_)) : (o.push(y), a.push(b), s.push(_));
        } else if (nt(g)) {
          const y = QC(h, f);
          o.push(y), a.push("max"), s.push(y);
        }
      }
    }
    const l = !!r && !!i;
    return {
      name: t,
      data: n,
      groupby: u,
      ...l || o.length > 0 ? {
        aggregate: {
          ...l ? { cross: l } : {},
          ...o.length ? { fields: o, ops: a, as: s } : {}
        }
      } : {}
    };
  }
  facetSortFields(t) {
    const { facet: n } = this, r = n[t];
    return r ? Uy(r.sort) ? [bX(r, r.sort, { expr: "datum" })] : nt(r.sort) ? [QC(r, t, { expr: "datum" })] : [Mt(r, { expr: "datum" })] : [];
  }
  facetSortOrder(t) {
    const { facet: n } = this, r = n[t];
    if (r) {
      const { sort: i } = r;
      return [(Uy(i) ? i.order : !nt(i) && i) || "ascending"];
    }
    return [];
  }
  assembleLabelTitle() {
    var i;
    const { facet: t, config: n } = this;
    if (t.facet)
      return hX(t.facet, "facet", n);
    const r = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const o of wie)
      if (t[o]) {
        const a = XC("labelOrient", (i = t[o]) == null ? void 0 : i.header, n, o);
        if (r[o].includes(a))
          return hX(t[o], o, n);
      }
  }
  assembleMarks() {
    const { child: t } = this, n = this.component.data.facetRoot, r = gzt(n), i = t.assembleGroupEncodeEntry(!1), o = this.assembleLabelTitle() || t.assembleTitle(), a = t.assembleGroupStyle();
    return [{
      name: this.getName("cell"),
      type: "group",
      ...o ? { title: o } : {},
      ...a ? { style: a } : {},
      from: {
        facet: this.assembleFacet()
      },
      // TODO: move this to after data
      sort: {
        field: rp.map((u) => this.facetSortFields(u)).flat(),
        order: rp.map((u) => this.facetSortOrder(u)).flat()
      },
      ...r.length > 0 ? { data: r } : {},
      ...i ? { encode: { update: i } } : {},
      ...t.assembleGroup($jt(this, []))
    }];
  }
  getMapping() {
    return this.facet;
  }
}
function Szt(e, t) {
  const { row: n, column: r } = t;
  if (n && r) {
    let i = null;
    for (const o of [n, r])
      if (Uy(o.sort)) {
        const { field: a, op: s = k8 } = o.sort;
        e = i = new v2(e, {
          joinaggregate: [
            {
              op: s,
              field: a,
              as: bX(o, o.sort, { forAs: !0 })
            }
          ],
          groupby: [Mt(o)]
        });
      }
    return i;
  }
  return null;
}
function BIe(e, t) {
  var n, r, i, o;
  for (const a of t) {
    const s = a.data;
    if (e.name && a.hasName() && e.name !== a.dataName)
      continue;
    const u = (n = e.format) == null ? void 0 : n.mesh, l = (r = s.format) == null ? void 0 : r.feature;
    if (u && l)
      continue;
    const f = (i = e.format) == null ? void 0 : i.feature;
    if ((f || l) && f !== l)
      continue;
    const h = (o = s.format) == null ? void 0 : o.mesh;
    if (!((u || h) && u !== h)) {
      if (l$(e) && l$(s)) {
        if (Dd(e.values, s.values))
          return a;
      } else if (WC(e) && WC(s)) {
        if (e.url === s.url)
          return a;
      } else if (APe(e) && e.name === a.dataName)
        return a;
    }
  }
  return null;
}
function Mzt(e, t) {
  if (e.data || !e.parent) {
    if (e.data === null) {
      const r = new QS({ values: [] });
      return t.push(r), r;
    }
    const n = BIe(e.data, t);
    if (n)
      return Yx(e.data) || (n.data.format = T$e({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n;
    {
      const r = new QS(e.data);
      return t.push(r), r;
    }
  } else
    return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main;
}
function Tzt(e, t, n) {
  let r = 0;
  for (const i of t.transforms) {
    let o, a;
    if (pjt(i))
      a = e = new GC(e, i), o = "derived";
    else if (pie(i)) {
      const s = y5t(i);
      a = e = Ul.makeWithAncestors(e, {}, s, n) ?? e, e = new BN(e, t, i.filter);
    } else if (MPe(i))
      a = e = Hy.makeFromTransform(e, i, t), o = "number";
    else if (mjt(i))
      o = "date", n.getWithExplicit(i.field).value === void 0 && (e = new Ul(e, { [i.field]: o }), n.set(i.field, o, !1)), a = e = Yy.makeFromTransform(e, i);
    else if (yjt(i))
      a = e = Ug.makeFromTransform(e, i), o = "number", xie(t) && (e = new xw(e));
    else if (SPe(i))
      a = e = d$.make(e, t, i, r++), o = "derived";
    else if (fjt(i))
      a = e = new YN(e, i), o = "number";
    else if (djt(i))
      a = e = new v2(e, i), o = "number";
    else if (vjt(i))
      a = e = ib.makeFromTransform(e, i), o = "derived";
    else if (bjt(i))
      a = e = new e9(e, i), o = "derived";
    else if (xjt(i))
      a = e = new Z8(e, i), o = "derived";
    else if (hjt(i))
      a = e = new J8(e, i), o = "derived";
    else if (ojt(i))
      a = e = new i9(e, i), o = "derived";
    else if (cjt(i))
      e = new o9(e, i);
    else if (gjt(i))
      a = e = cS.makeFromTransform(e, i), o = "derived";
    else if (ajt(i))
      a = e = new K8(e, i), o = "derived";
    else if (sjt(i))
      a = e = new n9(e, i), o = "derived";
    else if (ujt(i))
      a = e = new r9(e, i), o = "derived";
    else if (ljt(i))
      a = e = new t9(e, i), o = "derived";
    else {
      bt(F4t(i));
      continue;
    }
    if (a && o !== void 0)
      for (const s of a.producedFields() ?? [])
        n.set(s, o, !1);
  }
  return e;
}
function a9(e) {
  var g;
  let t = Mzt(e, e.component.data.sources);
  const { outputNodes: n, outputNodeRefCounts: r } = e.component.data, i = e.data, a = !(i && (Yx(i) || WC(i) || l$(i))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new Rjt();
  Yx(i) ? (OPe(i) ? t = new I4(t, i.sequence) : gie(i) && (t = new P4(t, i.graticule)), a.parseNothing = !0) : ((g = i == null ? void 0 : i.format) == null ? void 0 : g.parse) === null && (a.parseNothing = !0), t = Ul.makeExplicit(t, e, a) ?? t, t = new xw(t);
  const s = e.parent && HN(e.parent);
  (za(e) || Id(e)) && s && (t = Hy.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = Tzt(t, e, a));
  const u = b5t(e), l = v5t(e);
  t = Ul.makeWithAncestors(t, {}, { ...u, ...l }, a) ?? t, za(e) && (t = BT.parseAll(t, e), t = f$.parseAll(t, e)), (za(e) || Id(e)) && (s || (t = Hy.makeFromEncoding(t, e) ?? t), t = Yy.makeFromEncoding(t, e) ?? t, t = GC.parseAllForSortIndex(t, e));
  const f = t = hve(ra.Raw, e, t);
  if (za(e)) {
    const y = Ug.makeFromEncoding(t, e);
    y && (t = y, xie(e) && (t = new xw(t))), t = cS.makeFromEncoding(t, e) ?? t, t = ib.makeFromEncoding(t, e) ?? t;
  }
  za(e) && (t = c$.make(t, e) ?? t);
  const h = t = hve(ra.Main, e, t);
  za(e) && pLt(e, h);
  let p = null;
  if (Id(e)) {
    const y = e.getName("facet");
    t = Szt(t, e.facet) ?? t, p = new UN(t, e, y, h.getSource()), n[y] = p;
  }
  return {
    ...e.component.data,
    outputNodes: n,
    outputNodeRefCounts: r,
    raw: f,
    main: h,
    facetRoot: p,
    ancestorParse: a
  };
}
function hve(e, t, n) {
  const { outputNodes: r, outputNodeRefCounts: i } = t.component.data, o = t.getDataName(e), a = new Mf(n, o, e, i);
  return r[o] = a, a;
}
class Czt extends Oie {
  constructor(t, n, r, i) {
    var o, a, s, u;
    super(t, "concat", n, r, i, t.resolve), (((a = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : a.x) === "shared" || ((u = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : u.y) === "shared") && bt(j4t), this.children = this.getChildren(t).map((l, f) => jie(l, this, this.getName(`concat_${f}`), void 0, i));
  }
  parseData() {
    this.component.data = a9(this);
    for (const t of this.children)
      t.parseData();
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of yt(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    for (const t of this.children)
      t.parseAxesAndHeaders();
  }
  getChildren(t) {
    return B8(t) ? t.vconcat : die(t) ? t.hconcat : t.concat;
  }
  parseLayoutSize() {
    wzt(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, r) => r.assembleSelectionTopLevelSignals(n), t);
  }
  assembleSignals() {
    return this.children.forEach((t) => t.assembleSignals()), [];
  }
  assembleLayoutSignals() {
    const t = Eie(this);
    for (const n of this.children)
      t.push(...n.assembleLayoutSignals());
    return t;
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, r) => r.assembleSelectionData(n), t);
  }
  assembleMarks() {
    return this.children.map((t) => {
      const n = t.assembleTitle(), r = t.assembleGroupStyle(), i = t.assembleGroupEncodeEntry(!1);
      return {
        type: "group",
        name: t.getName("group"),
        ...n ? { title: n } : {},
        ...r ? { style: r } : {},
        ...i ? { encode: { update: i } } : {},
        ...t.assembleGroup()
      };
    });
  }
  assembleGroupStyle() {
  }
  assembleDefaultLayout() {
    const t = this.layout.columns;
    return {
      ...t != null ? { columns: t } : {},
      bounds: "full",
      // Use align each so it can work with multiple plots with different size
      align: "each"
    };
  }
}
function Nzt(e) {
  return e === !1 || e === null;
}
const Dzt = {
  disable: 1,
  gridScale: 1,
  scale: 1,
  ...Q4e,
  labelExpr: 1,
  encode: 1
}, UIe = yt(Dzt);
class kie extends kb {
  constructor(t = {}, n = {}, r = !1) {
    super(), this.explicit = t, this.implicit = n, this.mainExtracted = r;
  }
  clone() {
    return new kie(Kn(this.explicit), Kn(this.implicit), this.mainExtracted);
  }
  hasAxisPart(t) {
    return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !Nzt(this.get(t));
  }
  hasOrientSignalRef() {
    return an(this.explicit.orient);
  }
}
function Azt(e, t, n) {
  const { encoding: r, config: i } = e, o = Hs(r[t]) ?? Hs(r[gv(t)]), a = e.axis(t) || {}, { format: s, formatType: u } = a;
  if (VS(u))
    return {
      text: Lg({
        fieldOrDatumDef: o,
        field: "datum.value",
        format: s,
        formatType: u,
        config: i
      }),
      ...n
    };
  if (s === void 0 && u === void 0 && i.customFormatTypes) {
    if (YC(o) === "quantitative") {
      if (HC(o) && o.stack === "normalize" && i.normalizedNumberFormatType)
        return {
          text: Lg({
            fieldOrDatumDef: o,
            field: "datum.value",
            format: i.normalizedNumberFormat,
            formatType: i.normalizedNumberFormatType,
            config: i
          }),
          ...n
        };
      if (i.numberFormatType)
        return {
          text: Lg({
            fieldOrDatumDef: o,
            field: "datum.value",
            format: i.numberFormat,
            formatType: i.numberFormatType,
            config: i
          }),
          ...n
        };
    }
    if (YC(o) === "temporal" && i.timeFormatType && xt(o) && !o.timeUnit)
      return {
        text: Lg({
          fieldOrDatumDef: o,
          field: "datum.value",
          format: i.timeFormat,
          formatType: i.timeFormatType,
          config: i
        }),
        ...n
      };
  }
  return n;
}
function Ozt(e) {
  return mv.reduce((t, n) => (e.component.scales[n] && (t[n] = [Lzt(n, e)]), t), {});
}
const Rzt = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function kzt(e) {
  const { axes: t, resolve: n } = e.component, r = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const i of e.children) {
    i.parseAxesAndHeaders();
    for (const o of yt(i.component.axes))
      n.axis[o] = Sie(e.component.resolve, o), n.axis[o] === "shared" && (t[o] = $zt(t[o], i.component.axes[o]), t[o] || (n.axis[o] = "independent", delete t[o]));
  }
  for (const i of mv) {
    for (const o of e.children)
      if (o.component.axes[i]) {
        if (n.axis[i] === "independent") {
          t[i] = (t[i] ?? []).concat(o.component.axes[i]);
          for (const a of o.component.axes[i]) {
            const { value: s, explicit: u } = a.getWithExplicit("orient");
            if (!an(s)) {
              if (r[s] > 0 && !u) {
                const l = Rzt[s];
                r[s] > r[l] && a.set("orient", l, !1);
              }
              r[s]++;
            }
          }
        }
        delete o.component.axes[i];
      }
    if (n.axis[i] === "independent" && t[i] && t[i].length > 1)
      for (const [o, a] of (t[i] || []).entries())
        o > 0 && a.get("grid") && !a.explicit.grid && (a.implicit.grid = !1);
  }
}
function $zt(e, t) {
  if (e) {
    if (e.length !== t.length)
      return;
    const n = e.length;
    for (let r = 0; r < n; r++) {
      const i = e[r], o = t[r];
      if (!!i != !!o)
        return;
      if (i && o) {
        const a = i.getWithExplicit("orient"), s = o.getWithExplicit("orient");
        if (a.explicit && s.explicit && a.value !== s.value)
          return;
        e[r] = Pzt(i, o);
      }
    }
  } else
    return t.map((n) => n.clone());
  return e;
}
function Pzt(e, t) {
  for (const n of UIe) {
    const r = yw(
      e.getWithExplicit(n),
      t.getWithExplicit(n),
      n,
      "axis",
      // Tie breaker function
      (i, o) => {
        switch (n) {
          case "title":
            return e4e(i, o);
          case "gridScale":
            return {
              explicit: i.explicit,
              // keep the old explicit
              value: rs(i.value, o.value)
            };
        }
        return Y8(i, o, n, "axis");
      }
    );
    e.setWithExplicit(n, r);
  }
  return e;
}
function Izt(e, t, n, r, i) {
  if (t === "disable")
    return n !== void 0;
  switch (n = n || {}, t) {
    case "titleAngle":
    case "labelAngle":
      return e === (an(n.labelAngle) ? n.labelAngle : s$(n.labelAngle));
    case "values":
      return !!n.values;
    case "encode":
      return !!n.encoding || !!n.labelAngle;
    case "title":
      if (e === aIe(r, i))
        return !0;
  }
  return e === n[t];
}
const jzt = /* @__PURE__ */ new Set([
  "grid",
  // Grid is an exception because we need to set grid = true to generate another grid axis
  "translate",
  // translate has dependent logic for bar's bin position and it's 0.5 by default in Vega. If a config overrides this value, we need to know.
  // the rest are not axis configs in Vega, but are in VL, so we need to set too.
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function Lzt(e, t) {
  var S, C;
  let n = t.axis(e);
  const r = new kie(), i = Hs(t.encoding[e]), { mark: o, config: a } = t, s = (n == null ? void 0 : n.orient) || ((S = a[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : S.orient) || ((C = a.axis) == null ? void 0 : C.orient) || SLt(e), u = t.getScaleComponent(e).get("type"), l = yLt(e, u, s, t.config), f = n !== void 0 ? !n : fX("disable", a.style, n == null ? void 0 : n.style, l).configValue;
  if (r.set("disable", f, n !== void 0), f)
    return r;
  n = n || {};
  const h = wLt(i, n, e, a.style, l), p = D4e(n.formatType, i, u), g = N4e(i, i.type, n.format, n.formatType, a, !0), y = {
    fieldOrDatumDef: i,
    axis: n,
    channel: e,
    model: t,
    scaleType: u,
    orient: s,
    labelAngle: h,
    format: g,
    formatType: p,
    mark: o,
    config: a
  };
  for (const A of UIe) {
    const O = A in Kye ? Kye[A](y) : Sye(A) ? n[A] : void 0, R = O !== void 0, j = Izt(O, A, n, t, e);
    if (R && j)
      r.set(A, O, j);
    else {
      const { configValue: $ = void 0, configFrom: z = void 0 } = Sye(A) && A !== "values" ? fX(A, a.style, n.style, l) : {}, W = $ !== void 0;
      R && !W ? r.set(A, O, j) : (
        // Cases need implicit values
        // 1. Axis config that aren't available in Vega
        (z !== "vgAxisConfig" || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
        jzt.has(A) && W || // 3. Conditional axis values and signals
        k4($) || an($)) && r.set(A, $, !1)
      );
    }
  }
  const b = n.encoding ?? {}, _ = G4e.reduce((A, O) => {
    if (!r.hasAxisPart(O))
      return A;
    const R = dIe(b[O] ?? {}, t), j = O === "labels" ? Azt(t, e, R) : R;
    return j !== void 0 && !go(j) && (A[O] = { update: j }), A;
  }, {});
  return go(_) || r.set("encode", _, !!n.encoding || n.labelAngle !== void 0), r;
}
function zzt({ encoding: e, size: t }) {
  for (const n of mv) {
    const r = jf(n);
    ev(t[r]) && kx(e[n]) && (delete t[r], bt(o4e(r)));
  }
  return t;
}
const Fzt = {
  vgMark: "arc",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Bl("x", e, { defaultPos: "mid" }),
    ...Bl("y", e, { defaultPos: "mid" }),
    // arcs are rectangles in polar coordinates
    ...vw(e, "radius"),
    ...vw(e, "theta")
  })
}, Bzt = {
  vgMark: "area",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    }),
    ...wz("x", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "horizontal"
    }),
    ...wz("y", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "vertical"
    }),
    ...bie(e)
  })
}, Uzt = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...vw(e, "x"),
    ...vw(e, "y")
  })
}, Yzt = {
  vgMark: "shape",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })
  }),
  postEncodingTransform: (e) => {
    const { encoding: t } = e, n = t.shape;
    return [{
      type: "geoshape",
      projection: e.projectionName(),
      // as: 'shape',
      ...n && xt(n) && n.type === zN ? { field: Mt(n, { expr: "datum" }) } : {}
    }];
  }
}, Hzt = {
  vgMark: "image",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...vw(e, "x"),
    ...vw(e, "y"),
    ...yie(e, "url")
  })
}, Vzt = {
  vgMark: "line",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Bl("x", e, { defaultPos: "mid" }),
    ...Bl("y", e, { defaultPos: "mid" }),
    ...hu("size", e, {
      vgChannel: "strokeWidth"
      // VL's line size is strokeWidth
    }),
    ...bie(e)
  })
}, Wzt = {
  vgMark: "trail",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Bl("x", e, { defaultPos: "mid" }),
    ...Bl("y", e, { defaultPos: "mid" }),
    ...hu("size", e),
    ...bie(e)
  })
};
function $ie(e, t) {
  const { config: n } = e;
  return {
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Bl("x", e, { defaultPos: "mid" }),
    ...Bl("y", e, { defaultPos: "mid" }),
    ...hu("size", e),
    ...hu("angle", e),
    ...qzt(e, n, t)
  };
}
function qzt(e, t, n) {
  return n ? { shape: { value: n } } : hu("shape", e);
}
const Gzt = {
  vgMark: "symbol",
  encodeEntry: (e) => $ie(e)
}, Qzt = {
  vgMark: "symbol",
  encodeEntry: (e) => $ie(e, "circle")
}, Xzt = {
  vgMark: "symbol",
  encodeEntry: (e) => $ie(e, "square")
}, Kzt = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...Cp(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...vw(e, "x"),
    ...vw(e, "y")
  })
}, Zzt = {
  vgMark: "rule",
  encodeEntry: (e) => {
    const { markDef: t } = e, n = t.orient;
    return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
      ...Cp(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...wz("x", e, {
        defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "vertical"
        // include x2 for horizontal or line segment rule
      }),
      ...wz("y", e, {
        defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "horizontal"
        // include y2 for vertical or line segment rule
      }),
      ...hu("size", e, {
        vgChannel: "strokeWidth"
        // VL's rule size is strokeWidth
      })
    };
  }
}, Jzt = {
  vgMark: "text",
  encodeEntry: (e) => {
    const { config: t, encoding: n } = e;
    return {
      ...Cp(e, {
        align: "include",
        baseline: "include",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "include"
      }),
      ...Bl("x", e, { defaultPos: "mid" }),
      ...Bl("y", e, { defaultPos: "mid" }),
      ...yie(e),
      ...hu("size", e, {
        vgChannel: "fontSize"
        // VL's text size is fontSize
      }),
      ...hu("angle", e),
      ...qye("align", eFt(e.markDef, n, t)),
      ...qye("baseline", tFt(e.markDef, n, t)),
      ...Bl("radius", e, { defaultPos: null }),
      ...Bl("theta", e, { defaultPos: null })
    };
  }
};
function eFt(e, t, n) {
  if (Fi("align", e, n) === void 0)
    return "center";
}
function tFt(e, t, n) {
  if (Fi("baseline", e, n) === void 0)
    return "middle";
}
const nFt = {
  vgMark: "rect",
  encodeEntry: (e) => {
    const { config: t, markDef: n } = e, r = n.orient, i = r === "horizontal" ? "width" : "height", o = r === "horizontal" ? "height" : "width";
    return {
      ...Cp(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Bl("x", e, { defaultPos: "mid", vgChannel: "xc" }),
      ...Bl("y", e, { defaultPos: "mid", vgChannel: "yc" }),
      // size / thickness => width / height
      ...hu("size", e, {
        defaultValue: rFt(e),
        vgChannel: i
      }),
      [o]: Vo(Fi("thickness", n, t))
    };
  }
};
function rFt(e) {
  const { config: t, markDef: n } = e, { orient: r } = n, i = r === "horizontal" ? "width" : "height", o = e.getScaleComponent(r === "horizontal" ? "x" : "y"), a = Fi("size", n, t, { vgChannel: i }) ?? t.tick.bandSize;
  if (a !== void 0)
    return a;
  {
    const s = o ? o.get("range") : void 0;
    return s && Hw(s) && pi(s.step) ? s.step * 3 / 4 : bz(t.view, i) * 3 / 4;
  }
}
const z3 = {
  arc: Fzt,
  area: Bzt,
  bar: Uzt,
  circle: Qzt,
  geoshape: Yzt,
  image: Hzt,
  line: Vzt,
  point: Gzt,
  rect: Kzt,
  rule: Zzt,
  square: Xzt,
  text: Jzt,
  tick: nFt,
  trail: Wzt
};
function iFt(e) {
  if (Kr([O8, D8, bIt], e.mark)) {
    const t = ePe(e.mark, e.encoding);
    if (t.length > 0)
      return oFt(e, t);
  } else if (e.mark === A8) {
    const t = JQ.some((n) => Fi(n, e.markDef, e.config));
    if (e.stack && !e.fieldDef("size") && t)
      return aFt(e);
  }
  return Pie(e);
}
const pve = "faceted_path_";
function oFt(e, t) {
  return [
    {
      name: e.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: pve + e.requestDataName(ra.Main),
          data: e.requestDataName(ra.Main),
          groupby: t
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      // With subfacet for line/area group, need to use faceted data from above.
      marks: Pie(e, { fromPrefix: pve })
    }
  ];
}
const gve = "stack_group_";
function aFt(e) {
  var l;
  const [t] = Pie(e, { fromPrefix: gve }), n = e.scaleName(e.stack.fieldChannel), r = (f = {}) => e.vgField(e.stack.fieldChannel, f), i = (f, h) => {
    const p = [
      r({ prefix: "min", suffix: "start", expr: h }),
      r({ prefix: "max", suffix: "start", expr: h }),
      r({ prefix: "min", suffix: "end", expr: h }),
      r({ prefix: "max", suffix: "end", expr: h })
    ];
    return `${f}(${p.map((g) => `scale('${n}',${g})`).join(",")})`;
  };
  let o, a;
  e.stack.fieldChannel === "x" ? (o = {
    ...jC(t.encode.update, ["y", "yc", "y2", "height", ...JQ]),
    x: { signal: i("min", "datum") },
    x2: { signal: i("max", "datum") },
    clip: { value: !0 }
  }, a = {
    x: { field: { group: "x" }, mult: -1 },
    height: { field: { group: "height" } }
  }, t.encode.update = {
    ...Ef(t.encode.update, ["y", "yc", "y2"]),
    height: { field: { group: "height" } }
  }) : (o = {
    ...jC(t.encode.update, ["x", "xc", "x2", "width"]),
    y: { signal: i("min", "datum") },
    y2: { signal: i("max", "datum") },
    clip: { value: !0 }
  }, a = {
    y: { field: { group: "y" }, mult: -1 },
    width: { field: { group: "width" } }
  }, t.encode.update = {
    ...Ef(t.encode.update, ["x", "xc", "x2"]),
    width: { field: { group: "width" } }
  });
  for (const f of JQ) {
    const h = gb(f, e.markDef, e.config);
    t.encode.update[f] ? (o[f] = t.encode.update[f], delete t.encode.update[f]) : h && (o[f] = Vo(h)), h && (t.encode.update[f] = { value: 0 });
  }
  const s = [];
  if (((l = e.stack.groupbyChannels) == null ? void 0 : l.length) > 0)
    for (const f of e.stack.groupbyChannels) {
      const h = e.fieldDef(f), p = Mt(h);
      p && s.push(p), (h != null && h.bin || h != null && h.timeUnit) && s.push(Mt(h, { binSuffix: "end" }));
    }
  return o = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ].reduce((f, h) => {
    if (t.encode.update[h])
      return { ...f, [h]: t.encode.update[h] };
    {
      const p = gb(h, e.markDef, e.config);
      return p !== void 0 ? { ...f, [h]: Vo(p) } : f;
    }
  }, o), o.stroke && (o.strokeForeground = { value: !0 }, o.strokeOffset = { value: 0 }), [
    {
      type: "group",
      from: {
        facet: {
          data: e.requestDataName(ra.Main),
          name: gve + e.requestDataName(ra.Main),
          groupby: s,
          aggregate: {
            fields: [
              r({ suffix: "start" }),
              r({ suffix: "start" }),
              r({ suffix: "end" }),
              r({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: o
      },
      marks: [
        {
          type: "group",
          encode: { update: a },
          marks: [t]
        }
      ]
    }
  ];
}
function sFt(e) {
  var s;
  const { encoding: t, stack: n, mark: r, markDef: i, config: o } = e, a = t.order;
  if (!(!nt(a) && Qg(a) && KQ(a.value) || !a && KQ(Fi("order", i, o)))) {
    if ((nt(a) || xt(a)) && !n)
      return K$e(a, { expr: "datum" });
    if (g2(r)) {
      const u = i.orient === "horizontal" ? "y" : "x", l = t[u];
      if (xt(l)) {
        const f = l.sort;
        if (nt(f))
          return {
            field: Mt(l, { prefix: u, suffix: "sort_index", expr: "datum" })
          };
        if (Uy(f))
          return {
            field: Mt({
              // FIXME: this op might not already exist?
              // FIXME: what if dimensionChannel (x or y) contains custom domain?
              aggregate: nie(e.encoding) ? f.op : void 0,
              field: f.field
            }, { expr: "datum" })
          };
        if (I4e(f)) {
          const h = e.fieldDef(f.encoding);
          return {
            field: Mt(h, { expr: "datum" }),
            order: f.order
          };
        } else
          return f === null ? void 0 : {
            field: Mt(l, {
              // For stack with imputation, we only have bin_mid
              binSuffix: (s = e.stack) != null && s.impute ? "mid" : void 0,
              expr: "datum"
            })
          };
      }
      return;
    }
  }
}
function Pie(e, t = { fromPrefix: "" }) {
  const { mark: n, markDef: r, encoding: i, config: o } = e, a = rs(r.clip, uFt(e), lFt(e)), s = Q$e(r), u = i.key, l = sFt(e), f = cFt(e), h = Fi("aria", r, o), p = z3[n].postEncodingTransform ? z3[n].postEncodingTransform(e) : null;
  return [
    {
      name: e.getName("marks"),
      type: z3[n].vgMark,
      ...a ? { clip: a } : {},
      ...s ? { style: s } : {},
      ...u ? { key: u.field } : {},
      ...l ? { sort: l } : {},
      ...f || {},
      ...h === !1 ? { aria: h } : {},
      from: { data: t.fromPrefix + e.requestDataName(ra.Main) },
      encode: {
        update: z3[n].encodeEntry(e)
      },
      ...p ? {
        transform: p
      } : {}
    }
  ];
}
function uFt(e) {
  const t = e.getScaleComponent("x"), n = e.getScaleComponent("y");
  return t != null && t.get("selectionExtent") || n != null && n.get("selectionExtent") ? !0 : void 0;
}
function lFt(e) {
  const t = e.component.projection;
  return t && !t.isFit ? !0 : void 0;
}
function cFt(e) {
  if (!e.component.selection)
    return null;
  const t = yt(e.component.selection).length;
  let n = t, r = e.parent;
  for (; r && n === 0; )
    n = yt(r.component.selection).length, r = r.parent;
  return n ? {
    interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip || !!e.markDef.tooltip
  } : null;
}
class YIe extends LIe {
  constructor(t, n, r, i = {}, o) {
    super(t, "unit", n, r, o, void 0, Tye(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
    const a = Zy(t.mark) ? { ...t.mark } : { type: t.mark }, s = a.type;
    a.filled === void 0 && (a.filled = G3t(a, o, {
      graticule: t.data && gie(t.data)
    }));
    const u = this.encoding = ZIt(t.encoding || {}, s, a.filled, o);
    this.markDef = wPe(a, u, o), this.size = zzt({
      encoding: u,
      size: Tye(t) ? {
        ...i,
        ...t.width ? { width: t.width } : {},
        ...t.height ? { height: t.height } : {}
      } : i
    }), this.stack = xPe(this.markDef, u), this.specifiedScales = this.initScales(s, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter((l) => cie(l));
  }
  get hasProjection() {
    const { encoding: t } = this, n = this.mark === k4e, r = t && X$t.some((i) => or(t[i]));
    return n || r;
  }
  /**
   * Return specified Vega-Lite scale domain for a particular channel
   * @param channel
   */
  scaleDomain(t) {
    const n = this.specifiedScales[t];
    return n ? n.domain : void 0;
  }
  axis(t) {
    return this.specifiedAxes[t];
  }
  legend(t) {
    return this.specifiedLegends[t];
  }
  initScales(t, n) {
    return M8.reduce((r, i) => {
      const o = Hs(n[i]);
      return o && (r[i] = this.initScale(o.scale ?? {})), r;
    }, {});
  }
  initScale(t) {
    const { domain: n, range: r } = t, i = yf(t);
    return nt(n) && (i.domain = n.map(Sd)), nt(r) && (i.range = r.map(Sd)), i;
  }
  initAxes(t) {
    return mv.reduce((n, r) => {
      const i = t[r];
      if (or(i) || r === aa && or(t.x2) || r === _u && or(t.y2)) {
        const o = or(i) ? i.axis : void 0;
        n[r] = o && this.initAxis({ ...o });
      }
      return n;
    }, {});
  }
  initAxis(t) {
    const n = yt(t), r = {};
    for (const i of n) {
      const o = t[i];
      r[i] = k4(o) ? G$e(o) : Sd(o);
    }
    return r;
  }
  initLegends(t) {
    return a4t.reduce((n, r) => {
      const i = Hs(t[r]);
      if (i && u4t(r)) {
        const o = i.legend;
        n[r] = o && yf(o);
      }
      return n;
    }, {});
  }
  parseData() {
    this.component.data = a9(this);
  }
  parseLayoutSize() {
    _zt(this);
  }
  parseSelections() {
    this.component.selection = hLt(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = iFt(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = Ozt(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return Pjt(this, t);
  }
  assembleSignals() {
    return [...rIe(this), ...kjt(this, [])];
  }
  assembleSelectionData(t) {
    return Ijt(this, t);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return Eie(this);
  }
  assembleMarks() {
    let t = this.component.mark ?? [];
    return (!this.parent || !HN(this.parent)) && (t = $Pe(this, t)), t.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: t } = this.view || {};
    return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view";
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(t) {
    return uS(this.encoding, t);
  }
  fieldDef(t) {
    const n = this.encoding[t];
    return Jy(n);
  }
  typedFieldDef(t) {
    const n = this.fieldDef(t);
    return Pc(n) ? n : null;
  }
}
class Iie extends Oie {
  constructor(t, n, r, i, o) {
    super(t, "layer", n, r, o, t.resolve, t.view);
    const a = {
      ...i,
      ...t.width ? { width: t.width } : {},
      ...t.height ? { height: t.height } : {}
    };
    this.children = t.layer.map((s, u) => {
      if (U8(s))
        return new Iie(s, this, this.getName(`layer_${u}`), a, o);
      if (Rb(s))
        return new YIe(s, this, this.getName(`layer_${u}`), a, o);
      throw new Error(Dre(s));
    });
  }
  parseData() {
    this.component.data = a9(this);
    for (const t of this.children)
      t.parseData();
  }
  parseLayoutSize() {
    xzt(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of yt(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    kzt(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, r) => r.assembleSelectionTopLevelSignals(n), t);
  }
  // TODO: Support same named selections across children.
  assembleSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleSignals()), rIe(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), Eie(this));
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, r) => r.assembleSelectionData(n), t);
  }
  assembleGroupStyle() {
    const t = /* @__PURE__ */ new Set();
    for (const r of this.children)
      for (const i of Rt(r.assembleGroupStyle()))
        t.add(i);
    const n = Array.from(t);
    return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
  }
  assembleTitle() {
    let t = super.assembleTitle();
    if (t)
      return t;
    for (const n of this.children)
      if (t = n.assembleTitle(), t)
        return t;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return jjt(this, this.children.flatMap((t) => t.assembleMarks()));
  }
  assembleLegends() {
    return this.children.reduce((t, n) => t.concat(n.assembleLegends()), xIe(this));
  }
}
function jie(e, t, n, r, i) {
  if ($8(e))
    return new GR(e, t, n, i);
  if (U8(e))
    return new Iie(e, t, n, r, i);
  if (Rb(e))
    return new YIe(e, t, n, r, i);
  if (_3t(e))
    return new Czt(e, t, n, i);
  throw new Error(Dre(e));
}
function fFt(e, t = {}) {
  t.logger && CPt(t.logger), t.fieldTitle && V4e(t.fieldTitle);
  try {
    const n = bPe(MN(t.config, e.config)), r = NPe(e, n), i = jie(r, null, "", void 0, n);
    return i.parse(), P5t(i.component.data, i), {
      spec: hFt(i, dFt(e, r.autosize, n, i), e.datasets, e.usermeta),
      normalized: r
    };
  } finally {
    t.logger && NPt(), t.fieldTitle && YIt();
  }
}
function dFt(e, t, n, r) {
  const i = r.component.layoutSize.get("width"), o = r.component.layoutSize.get("height");
  if (t === void 0 ? (t = { type: "pad" }, r.hasAxisOrientSignalRef() && (t.resize = !0)) : kt(t) && (t = { type: t }), i && o && Djt(t.type)) {
    if (i === "step" && o === "step")
      bt(cye()), t.type = "pad";
    else if (i === "step" || o === "step") {
      const a = i === "step" ? "width" : "height";
      bt(cye(S8(a)));
      const s = a === "width" ? "height" : "width";
      t.type = Ajt(s);
    }
  }
  return {
    ...yt(t).length === 1 && t.type ? t.type === "pad" ? {} : { autosize: t.type } : { autosize: t },
    ...Lye(n, !1),
    ...Lye(e, !0)
  };
}
function hFt(e, t, n = {}, r) {
  const i = e.config ? I3t(e.config) : void 0, o = [].concat(
    e.assembleSelectionData([]),
    // only assemble data in the root
    mzt(e.component.data, n)
  ), a = e.assembleProjections(), s = e.assembleTitle(), u = e.assembleGroupStyle(), l = e.assembleGroupEncodeEntry(!0);
  let f = e.assembleLayoutSignals();
  f = f.filter((g) => (g.name === "width" || g.name === "height") && g.value !== void 0 ? (t[g.name] = +g.value, !1) : !0);
  const { params: h, ...p } = t;
  return {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    ...e.description ? { description: e.description } : {},
    ...p,
    ...s ? { title: s } : {},
    ...u ? { style: u } : {},
    ...l ? { encode: { update: l } } : {},
    data: o,
    ...a.length > 0 ? { projections: a } : {},
    ...e.assembleGroup([
      ...f,
      ...e.assembleSelectionTopLevelSignals([]),
      ...gPe(h)
    ]),
    ...i ? { config: i } : {},
    ...r ? { usermeta: r } : {}
  };
}
const pFt = H$t.version, gFt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accessPathDepth: LC,
  accessPathWithDatum: xre,
  compile: fFt,
  contains: Kr,
  deepEqual: Dd,
  deleteNestedProperty: lz,
  duplicate: Kn,
  entries: pw,
  every: yre,
  fieldIntersection: bre,
  flatAccessWithDatum: N$e,
  getFirstDefined: rs,
  hasIntersection: vre,
  hash: Xr,
  internalField: O$e,
  isBoolean: a$,
  isEmpty: go,
  isEqual: W$t,
  isInternalField: R$e,
  isNullOrFalse: KQ,
  isNumeric: v8,
  keys: yt,
  logicalExpr: WR,
  mergeDeep: T$e,
  never: M$e,
  normalize: NPe,
  normalizeAngle: s$,
  omit: Ef,
  pick: jC,
  prefixGenerator: ZQ,
  removePathFromField: jN,
  replaceAll: BS,
  replacePathInField: _p,
  resetIdCounter: G$t,
  setEqual: C$e,
  some: FS,
  stringify: mo,
  titleCase: E4,
  unique: $y,
  uniqueId: A$e,
  vals: il,
  varName: oa,
  version: pFt
}, Symbol.toStringTag, { value: "Module" }));
function HIe(e) {
  const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
  return { library: t, version: n };
}
var mFt = "vega-themes", yFt = "2.14.0", vFt = "Themes for stylized Vega and Vega-Lite visualizations.", bFt = ["vega", "vega-lite", "themes", "style"], xFt = "BSD-3-Clause", wFt = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
}, _Ft = [{
  name: "Emily Gu",
  url: "https://github.com/emilygu"
}, {
  name: "Arvind Satyanarayan",
  url: "http://arvindsatya.com"
}, {
  name: "Jeffrey Heer",
  url: "https://idl.cs.washington.edu"
}, {
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}], EFt = "build/vega-themes.js", SFt = "build/vega-themes.module.js", MFt = "build/vega-themes.min.js", TFt = "build/vega-themes.min.js", CFt = "build/vega-themes.module.d.ts", NFt = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
}, DFt = ["src", "build"], AFt = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  format: "eslint . --fix",
  lint: "eslint .",
  release: "release-it"
}, OFt = {
  "@babel/core": "^7.22.9",
  "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
  "@babel/plugin-proposal-json-strings": "^7.18.6",
  "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
  "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
  "@babel/plugin-transform-runtime": "^7.22.9",
  "@babel/preset-env": "^7.22.9",
  "@babel/preset-typescript": "^7.22.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.1.0",
  "@rollup/plugin-terser": "^0.4.3",
  "@typescript-eslint/eslint-plugin": "^6.0.0",
  "@typescript-eslint/parser": "^6.0.0",
  "browser-sync": "^2.29.3",
  concurrently: "^8.2.0",
  eslint: "^8.45.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-prettier": "^5.0.0",
  "gh-pages": "^5.0.0",
  prettier: "^3.0.0",
  "release-it": "^16.1.0",
  rollup: "^3.26.2",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-ts": "^3.2.0",
  typescript: "^5.1.6",
  vega: "^5.25.0",
  "vega-lite": "^5.9.3"
}, RFt = {
  vega: "*",
  "vega-lite": "*"
}, kFt = {}, $Ft = {
  name: mFt,
  version: yFt,
  description: vFt,
  keywords: bFt,
  license: xFt,
  author: wFt,
  contributors: _Ft,
  main: EFt,
  module: SFt,
  unpkg: MFt,
  jsdelivr: TFt,
  types: CFt,
  repository: NFt,
  files: DFt,
  scripts: AFt,
  devDependencies: OFt,
  peerDependencies: RFt,
  dependencies: kFt
};
const JM = "#fff", mve = "#888", PFt = {
  background: "#333",
  view: {
    stroke: mve
  },
  title: {
    color: JM,
    subtitleColor: JM
  },
  style: {
    "guide-label": {
      fill: JM
    },
    "guide-title": {
      fill: JM
    }
  },
  axis: {
    domainColor: JM,
    gridColor: mve,
    tickColor: JM
  }
}, pE = "#4572a7", IFt = {
  background: "#fff",
  arc: {
    fill: pE
  },
  area: {
    fill: pE
  },
  line: {
    stroke: pE,
    strokeWidth: 2
  },
  path: {
    stroke: pE
  },
  rect: {
    fill: pE
  },
  shape: {
    stroke: pE
  },
  symbol: {
    fill: pE,
    strokeWidth: 1.5,
    size: 50
  },
  axis: {
    bandPosition: 0.5,
    grid: !0,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: !1,
    tickExtra: !0
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
  }
}, gE = "#30a2da", zV = "#cbcbcb", jFt = "#999", LFt = "#333", yve = "#f0f0f0", vve = "#333", zFt = {
  arc: {
    fill: gE
  },
  area: {
    fill: gE
  },
  axis: {
    domainColor: zV,
    grid: !0,
    gridColor: zV,
    gridWidth: 1,
    labelColor: jFt,
    labelFontSize: 10,
    titleColor: LFt,
    tickColor: zV,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: !1
  },
  background: yve,
  group: {
    fill: yve
  },
  legend: {
    labelColor: vve,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: vve,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: gE,
    strokeWidth: 2
  },
  path: {
    stroke: gE,
    strokeWidth: 0.5
  },
  rect: {
    fill: gE
  },
  range: {
    category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: !0,
    shape: "circle"
  },
  shape: {
    stroke: gE
  },
  bar: {
    binSpacing: 2,
    fill: gE,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
}, mE = "#000", FFt = {
  group: {
    fill: "#e5e5e5"
  },
  arc: {
    fill: mE
  },
  area: {
    fill: mE
  },
  line: {
    stroke: mE
  },
  path: {
    stroke: mE
  },
  rect: {
    fill: mE
  },
  shape: {
    stroke: mE
  },
  symbol: {
    fill: mE,
    size: 40
  },
  axis: {
    domain: !1,
    grid: !0,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
  }
}, BFt = 22, UFt = "normal", bve = "Benton Gothic, sans-serif", xve = 11.5, YFt = "normal", yE = "#82c6df", FV = "Benton Gothic Bold, sans-serif", wve = "normal", _ve = 13, mO = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
}, HFt = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: FV,
    fontSize: BFt,
    fontWeight: UFt
  },
  arc: {
    fill: yE
  },
  area: {
    fill: yE
  },
  line: {
    stroke: yE,
    strokeWidth: 2
  },
  path: {
    stroke: yE
  },
  rect: {
    fill: yE
  },
  shape: {
    stroke: yE
  },
  symbol: {
    fill: yE,
    size: 30
  },
  axis: {
    labelFont: bve,
    labelFontSize: xve,
    labelFontWeight: YFt,
    titleFont: FV,
    titleFontSize: _ve,
    titleFontWeight: wve
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: bve,
    labelFontSize: xve,
    symbolType: "square",
    titleFont: FV,
    titleFontSize: _ve,
    titleFontWeight: wve
  },
  range: {
    category: mO["category-6"],
    diverging: mO["fireandice-6"],
    heatmap: mO["fire-7"],
    ordinal: mO["fire-7"],
    ramp: mO["fire-7"]
  }
}, vE = "#ab5787", F3 = "#979797", VFt = {
  background: "#f9f9f9",
  arc: {
    fill: vE
  },
  area: {
    fill: vE
  },
  line: {
    stroke: vE
  },
  path: {
    stroke: vE
  },
  rect: {
    fill: vE
  },
  shape: {
    stroke: vE
  },
  symbol: {
    fill: vE,
    size: 30
  },
  axis: {
    domainColor: F3,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: F3,
    tickColor: F3,
    tickWidth: 0.2,
    titleColor: F3
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    grid: !0,
    tickSize: 10
  },
  axisY: {
    domain: !1,
    grid: !0,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
  }
}, bE = "#3e5c69", WFt = {
  background: "#fff",
  arc: {
    fill: bE
  },
  area: {
    fill: bE
  },
  line: {
    stroke: bE
  },
  path: {
    stroke: bE
  },
  rect: {
    fill: bE
  },
  shape: {
    stroke: bE
  },
  symbol: {
    fill: bE
  },
  axis: {
    domainWidth: 0.5,
    grid: !0,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
}, Qh = "#1696d2", Eve = "#000000", qFt = "#FFFFFF", B3 = "Lato", BV = "Lato", GFt = "Lato", QFt = "#DEDDDD", XFt = 18, yO = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
}, KFt = {
  background: qFt,
  title: {
    anchor: "start",
    fontSize: XFt,
    font: B3
  },
  axisX: {
    domain: !0,
    domainColor: Eve,
    domainWidth: 1,
    grid: !1,
    labelFontSize: 12,
    labelFont: BV,
    labelAngle: 0,
    tickColor: Eve,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: B3
  },
  axisY: {
    domain: !1,
    domainWidth: 1,
    grid: !0,
    gridColor: QFt,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont: BV,
    labelPadding: 8,
    ticks: !1,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: B3,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont: BV,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: B3,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: yO["six-groups-cat-1"],
    diverging: yO["diverging-colors"],
    heatmap: yO["diverging-colors"],
    ordinal: yO["six-groups-seq"],
    ramp: yO["shades-blue"]
  },
  area: {
    fill: Qh
  },
  rect: {
    fill: Qh
  },
  line: {
    color: Qh,
    stroke: Qh,
    strokeWidth: 5
  },
  trail: {
    color: Qh,
    stroke: Qh,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: Qh,
    strokeWidth: 0.5
  },
  point: {
    filled: !0
  },
  text: {
    font: GFt,
    color: Qh,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: Qh,
      stroke: null
    }
  },
  arc: {
    fill: Qh
  },
  shape: {
    stroke: Qh
  },
  symbol: {
    fill: Qh,
    size: 30
  }
}, xE = "#3366CC", Sve = "#ccc", U3 = "Arial, sans-serif", ZFt = {
  arc: {
    fill: xE
  },
  area: {
    fill: xE
  },
  path: {
    stroke: xE
  },
  rect: {
    fill: xE
  },
  shape: {
    stroke: xE
  },
  symbol: {
    stroke: xE
  },
  circle: {
    fill: xE
  },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: U3,
      fontSize: 12
    },
    "guide-title": {
      font: U3,
      fontSize: 12
    },
    "group-title": {
      font: U3,
      fontSize: 12
    }
  },
  title: {
    font: U3,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor: Sve,
    tickColor: Sve,
    domain: !1,
    grid: !0
  },
  range: {
    category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
}, Lie = (e) => e * (1 / 3 + 1), Mve = Lie(9), Tve = Lie(10), Cve = Lie(12), vO = "Segoe UI", Nve = "wf_standard-font, helvetica, arial, sans-serif", Dve = "#252423", bO = "#605E5C", Ave = "transparent", JFt = "#C8C6C4", xg = "#118DFF", e6t = "#12239E", t6t = "#E66C37", n6t = "#6B007B", r6t = "#E044A7", i6t = "#744EC2", o6t = "#D9B300", a6t = "#D64550", VIe = xg, WIe = "#DEEFFF", Ove = [WIe, VIe], s6t = [WIe, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", VIe], u6t = {
  view: {
    stroke: Ave
  },
  background: Ave,
  font: vO,
  header: {
    titleFont: Nve,
    titleFontSize: Cve,
    titleColor: Dve,
    labelFont: vO,
    labelFontSize: Tve,
    labelColor: bO
  },
  axis: {
    ticks: !1,
    grid: !1,
    domain: !1,
    labelColor: bO,
    labelFontSize: Mve,
    titleFont: Nve,
    titleColor: Dve,
    titleFontSize: Cve,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: !0,
    gridColor: JFt,
    gridDash: [1, 5],
    labelFlush: !1
  },
  axisBand: {
    tickExtra: !0
  },
  axisX: {
    labelPadding: 5
  },
  axisY: {
    labelPadding: 10
  },
  bar: {
    fill: xg
  },
  line: {
    stroke: xg,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: {
    font: vO,
    fontSize: Mve,
    fill: bO
  },
  arc: {
    fill: xg
  },
  area: {
    fill: xg,
    line: !0,
    opacity: 0.6
  },
  path: {
    stroke: xg
  },
  rect: {
    fill: xg
  },
  point: {
    fill: xg,
    filled: !0,
    size: 75
  },
  shape: {
    stroke: xg
  },
  symbol: {
    fill: xg,
    strokeWidth: 1.5,
    size: 50
  },
  legend: {
    titleFont: vO,
    titleFontWeight: "bold",
    titleColor: bO,
    labelFont: vO,
    labelFontSize: Tve,
    labelColor: bO,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [xg, e6t, t6t, n6t, r6t, i6t, o6t, a6t],
    diverging: Ove,
    heatmap: Ove,
    ordinal: s6t
  }
}, UV = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', Rve = 400, l6t = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"], c6t = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
function s9({
  type: e,
  background: t
}) {
  const n = e === "dark" ? "#161616" : "#ffffff", r = e === "dark" ? "#f4f4f4" : "#161616", i = e === "dark" ? l6t : c6t, o = e === "dark" ? "#d4bbff" : "#6929c4";
  return {
    background: t,
    arc: {
      fill: o
    },
    area: {
      fill: o
    },
    path: {
      stroke: o
    },
    rect: {
      fill: o
    },
    shape: {
      stroke: o
    },
    symbol: {
      stroke: o
    },
    circle: {
      fill: o
    },
    view: {
      fill: n,
      stroke: n
    },
    group: {
      fill: n
    },
    title: {
      color: r,
      anchor: "start",
      dy: -15,
      fontSize: 16,
      font: UV,
      fontWeight: 600
    },
    axis: {
      labelColor: r,
      labelFontSize: 12,
      grid: !0,
      gridColor: "#525252",
      titleColor: r,
      labelAngle: 0
    },
    style: {
      "guide-label": {
        font: UV,
        fill: r,
        fontWeight: Rve
      },
      "guide-title": {
        font: UV,
        fill: r,
        fontWeight: Rve
      }
    },
    range: {
      category: i,
      diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
      heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
    }
  };
}
const f6t = s9({
  type: "light",
  background: "#ffffff"
}), d6t = s9({
  type: "light",
  background: "#f4f4f4"
}), h6t = s9({
  type: "dark",
  background: "#262626"
}), p6t = s9({
  type: "dark",
  background: "#161616"
}), g6t = $Ft.version, m6t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  carbong10: d6t,
  carbong100: p6t,
  carbong90: h6t,
  carbonwhite: f6t,
  dark: PFt,
  excel: IFt,
  fivethirtyeight: zFt,
  ggplot2: FFt,
  googlecharts: ZFt,
  latimes: HFt,
  powerbi: u6t,
  quartz: VFt,
  urbaninstitute: KFt,
  version: g6t,
  vox: WFt
}, Symbol.toStringTag, { value: "Module" }));
function y6t(e, t, n, r) {
  if (nt(e))
    return `[${e.map((i) => t(kt(i) ? i : kve(i, n))).join(", ")}]`;
  if (Pt(e)) {
    let i = "";
    const {
      title: o,
      image: a,
      ...s
    } = e;
    o && (i += `<h2>${t(o)}</h2>`), a && (i += `<img src="${new URL(t(a), r || location.href).href}">`);
    const u = Object.keys(s);
    if (u.length > 0) {
      i += "<table>";
      for (const l of u) {
        let f = s[l];
        f !== void 0 && (Pt(f) && (f = kve(f, n)), i += `<tr><td class="key">${t(l)}</td><td class="value">${t(f)}</td></tr>`);
      }
      i += "</table>";
    }
    return i || "{}";
  }
  return t(e);
}
function v6t(e) {
  const t = [];
  return function(n, r) {
    if (typeof r != "object" || r === null)
      return r;
    const i = t.indexOf(this) + 1;
    return t.length = i, t.length > e ? "[Object]" : t.indexOf(r) >= 0 ? "[Circular]" : (t.push(r), r);
  };
}
function kve(e, t) {
  return JSON.stringify(e, v6t(t));
}
var b6t = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
const qIe = "vg-tooltip-element", x6t = {
  /**
   * X offset.
   */
  offsetX: 10,
  /**
   * Y offset.
   */
  offsetY: 10,
  /**
   * ID of the tooltip element.
   */
  id: qIe,
  /**
   * ID of the tooltip CSS style.
   */
  styleId: "vega-tooltip-style",
  /**
   * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
   *
   * There are two predefined themes: "light" (default) and "dark".
   */
  theme: "light",
  /**
   * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
   */
  disableDefaultStyle: !1,
  /**
   * HTML sanitizer function that removes dangerous HTML to prevent XSS.
   *
   * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
   */
  sanitize: w6t,
  /**
   * The maximum recursion depth when printing objects in the tooltip.
   */
  maxDepth: 2,
  /**
   * A function to customize the rendered HTML of the tooltip.
   * @param value A value string, or object of value strings keyed by field
   * @param sanitize The `sanitize` function from `options.sanitize`
   * @param baseURL The `baseURL` from `options.baseURL`
   * @returns {string} The returned string will become the `innerHTML` of the tooltip element
   */
  formatTooltip: y6t,
  /**
   * The baseurl to use in image paths.
   */
  baseURL: ""
};
function w6t(e) {
  return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function _6t(e) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(e))
    throw new Error("Invalid HTML ID");
  return b6t.toString().replace(qIe, e);
}
function E6t(e, t, n, r) {
  let i = e.clientX + n;
  i + t.width > window.innerWidth && (i = +e.clientX - n - t.width);
  let o = e.clientY + r;
  return o + t.height > window.innerHeight && (o = +e.clientY - r - t.height), {
    x: i,
    y: o
  };
}
class S6t {
  /**
   * The handler function. We bind this to this function in the constructor.
   */
  /**
   * Complete tooltip options.
   */
  /**
   * The tooltip html element.
   */
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(t) {
    this.options = {
      ...x6t,
      ...t
    };
    const n = this.options.id;
    if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const r = document.createElement("style");
      r.setAttribute("id", this.options.styleId), r.innerHTML = _6t(n);
      const i = document.head;
      i.childNodes.length > 0 ? i.insertBefore(r, i.childNodes[0]) : i.appendChild(r);
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(t, n, r, i) {
    if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), i == null || i === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(i, this.options.sanitize, this.options.maxDepth, this.options.baseURL), this.el.classList.add("visible", `${this.options.theme}-theme`);
    const {
      x: o,
      y: a
    } = E6t(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.style.top = `${a}px`, this.el.style.left = `${o}px`;
  }
}
function M6t(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var YV, $ve;
function T6t() {
  return $ve || ($ve = 1, YV = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), YV;
}
var C6t = Ai;
Ai.Node = XS;
Ai.create = Ai;
function Ai(e) {
  var t = this;
  if (t instanceof Ai || (t = new Ai()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var n = 0, r = arguments.length; n < r; n++)
      t.push(arguments[n]);
  return t;
}
Ai.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, n = e.prev;
  return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
Ai.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
Ai.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
Ai.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    D6t(this, arguments[e]);
  return this.length;
};
Ai.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    A6t(this, arguments[e]);
  return this.length;
};
Ai.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
Ai.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
Ai.prototype.forEach = function(e, t) {
  t = t || this;
  for (var n = this.head, r = 0; n !== null; r++)
    e.call(t, n.value, r, this), n = n.next;
};
Ai.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var n = this.tail, r = this.length - 1; n !== null; r--)
    e.call(t, n.value, r, this), n = n.prev;
};
Ai.prototype.get = function(e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++)
    n = n.next;
  if (t === e && n !== null)
    return n.value;
};
Ai.prototype.getReverse = function(e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++)
    n = n.prev;
  if (t === e && n !== null)
    return n.value;
};
Ai.prototype.map = function(e, t) {
  t = t || this;
  for (var n = new Ai(), r = this.head; r !== null; )
    n.push(e.call(t, r.value, this)), r = r.next;
  return n;
};
Ai.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var n = new Ai(), r = this.tail; r !== null; )
    n.push(e.call(t, r.value, this)), r = r.prev;
  return n;
};
Ai.prototype.reduce = function(e, t) {
  var n, r = this.head;
  if (arguments.length > 1)
    n = t;
  else if (this.head)
    r = this.head.next, n = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; r !== null; i++)
    n = e(n, r.value, i), r = r.next;
  return n;
};
Ai.prototype.reduceReverse = function(e, t) {
  var n, r = this.tail;
  if (arguments.length > 1)
    n = t;
  else if (this.tail)
    r = this.tail.prev, n = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; r !== null; i--)
    n = e(n, r.value, i), r = r.prev;
  return n;
};
Ai.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    e[t] = n.value, n = n.next;
  return e;
};
Ai.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    e[t] = n.value, n = n.prev;
  return e;
};
Ai.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new Ai();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = 0, i = this.head; i !== null && r < e; r++)
    i = i.next;
  for (; i !== null && r < t; r++, i = i.next)
    n.push(i.value);
  return n;
};
Ai.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new Ai();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = this.length, i = this.tail; i !== null && r > t; r--)
    i = i.prev;
  for (; i !== null && r > e; r--, i = i.prev)
    n.push(i.value);
  return n;
};
Ai.prototype.splice = function(e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var r = 0, i = this.head; i !== null && r < e; r++)
    i = i.next;
  for (var o = [], r = 0; i && r < t; r++)
    o.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var r = 0; r < n.length; r++)
    i = N6t(this, i, n[r]);
  return o;
};
Ai.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var r = n.prev;
    n.prev = n.next, n.next = r;
  }
  return this.head = t, this.tail = e, this;
};
function N6t(e, t, n) {
  var r = t === e.head ? new XS(n, null, t, e) : new XS(n, t, t.next, e);
  return r.next === null && (e.tail = r), r.prev === null && (e.head = r), e.length++, r;
}
function D6t(e, t) {
  e.tail = new XS(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function A6t(e, t) {
  e.head = new XS(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function XS(e, t, n, r) {
  if (!(this instanceof XS))
    return new XS(e, t, n, r);
  this.list = r, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
}
try {
  T6t()(Ai);
} catch {
}
const O6t = C6t, zE = Symbol("max"), U0 = Symbol("length"), eT = Symbol("lengthCalculator"), QR = Symbol("allowStale"), qE = Symbol("maxAge"), L0 = Symbol("dispose"), Pve = Symbol("noDisposeOnSet"), fu = Symbol("lruList"), wg = Symbol("cache"), GIe = Symbol("updateAgeOnGet"), HV = () => 1;
class R6t {
  constructor(t) {
    if (typeof t == "number" && (t = {
      max: t
    }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[zE] = t.max || 1 / 0;
    const n = t.length || HV;
    if (this[eT] = typeof n != "function" ? HV : n, this[QR] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[qE] = t.maxAge || 0, this[L0] = t.dispose, this[Pve] = t.noDisposeOnSet || !1, this[GIe] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[zE] = t || 1 / 0, xO(this);
  }
  get max() {
    return this[zE];
  }
  set allowStale(t) {
    this[QR] = !!t;
  }
  get allowStale() {
    return this[QR];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[qE] = t, xO(this);
  }
  get maxAge() {
    return this[qE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = HV), t !== this[eT] && (this[eT] = t, this[U0] = 0, this[fu].forEach((n) => {
      n.length = this[eT](n.value, n.key), this[U0] += n.length;
    })), xO(this);
  }
  get lengthCalculator() {
    return this[eT];
  }
  get length() {
    return this[U0];
  }
  get itemCount() {
    return this[fu].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let r = this[fu].tail; r !== null; ) {
      const i = r.prev;
      Ive(this, t, r, n), r = i;
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let r = this[fu].head; r !== null; ) {
      const i = r.next;
      Ive(this, t, r, n), r = i;
    }
  }
  keys() {
    return this[fu].toArray().map((t) => t.key);
  }
  values() {
    return this[fu].toArray().map((t) => t.value);
  }
  reset() {
    this[L0] && this[fu] && this[fu].length && this[fu].forEach((t) => this[L0](t.key, t.value)), this[wg] = /* @__PURE__ */ new Map(), this[fu] = new O6t(), this[U0] = 0;
  }
  dump() {
    return this[fu].map((t) => Mz(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[fu];
  }
  set(t, n, r) {
    if (r = r || this[qE], r && typeof r != "number")
      throw new TypeError("maxAge must be a number");
    const i = r ? Date.now() : 0, o = this[eT](n, t);
    if (this[wg].has(t)) {
      if (o > this[zE])
        return UT(this, this[wg].get(t)), !1;
      const u = this[wg].get(t).value;
      return this[L0] && (this[Pve] || this[L0](t, u.value)), u.now = i, u.maxAge = r, u.value = n, this[U0] += o - u.length, u.length = o, this.get(t), xO(this), !0;
    }
    const a = new k6t(t, n, o, i, r);
    return a.length > this[zE] ? (this[L0] && this[L0](t, n), !1) : (this[U0] += a.length, this[fu].unshift(a), this[wg].set(t, this[fu].head), xO(this), !0);
  }
  has(t) {
    if (!this[wg].has(t))
      return !1;
    const n = this[wg].get(t).value;
    return !Mz(this, n);
  }
  get(t) {
    return VV(this, t, !0);
  }
  peek(t) {
    return VV(this, t, !1);
  }
  pop() {
    const t = this[fu].tail;
    return t ? (UT(this, t), t.value) : null;
  }
  del(t) {
    UT(this, this[wg].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let r = t.length - 1; r >= 0; r--) {
      const i = t[r], o = i.e || 0;
      if (o === 0)
        this.set(i.k, i.v);
      else {
        const a = o - n;
        a > 0 && this.set(i.k, i.v, a);
      }
    }
  }
  prune() {
    this[wg].forEach((t, n) => VV(this, n, !1));
  }
}
const VV = (e, t, n) => {
  const r = e[wg].get(t);
  if (r) {
    const i = r.value;
    if (Mz(e, i)) {
      if (UT(e, r), !e[QR])
        return;
    } else
      n && (e[GIe] && (r.value.now = Date.now()), e[fu].unshiftNode(r));
    return i.value;
  }
}, Mz = (e, t) => {
  if (!t || !t.maxAge && !e[qE])
    return !1;
  const n = Date.now() - t.now;
  return t.maxAge ? n > t.maxAge : e[qE] && n > e[qE];
}, xO = (e) => {
  if (e[U0] > e[zE])
    for (let t = e[fu].tail; e[U0] > e[zE] && t !== null; ) {
      const n = t.prev;
      UT(e, t), t = n;
    }
}, UT = (e, t) => {
  if (t) {
    const n = t.value;
    e[L0] && e[L0](n.key, n.value), e[U0] -= n.length, e[wg].delete(n.key), e[fu].removeNode(t);
  }
};
class k6t {
  constructor(t, n, r, i, o) {
    this.key = t, this.value = n, this.length = r, this.now = i, this.maxAge = o || 0;
  }
}
const Ive = (e, t, n, r) => {
  let i = n.value;
  Mz(e, i) && (UT(e, n), e[QR] || (i = void 0)), i && t.call(r, i.value, i.key, e);
};
var $6t = R6t;
const P6t = Object.freeze({
  loose: !0
}), I6t = Object.freeze({}), j6t = (e) => e ? typeof e != "object" ? P6t : e : I6t;
var zie = j6t, xX = { exports: {} };
const L6t = "2.0.0", QIe = 256, z6t = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, F6t = 16, B6t = QIe - 6, U6t = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
var Fie = {
  MAX_LENGTH: QIe,
  MAX_SAFE_COMPONENT_LENGTH: F6t,
  MAX_SAFE_BUILD_LENGTH: B6t,
  MAX_SAFE_INTEGER: z6t,
  RELEASE_TYPES: U6t,
  SEMVER_SPEC_VERSION: L6t,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const Y6t = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var u9 = Y6t;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: r,
    MAX_LENGTH: i
  } = Fie, o = u9;
  t = e.exports = {};
  const a = t.re = [], s = t.safeRe = [], u = t.src = [], l = t.t = {};
  let f = 0;
  const h = "[a-zA-Z0-9-]", p = [["\\s", 1], ["\\d", i], [h, r]], g = (b) => {
    for (const [_, S] of p)
      b = b.split(`${_}*`).join(`${_}{0,${S}}`).split(`${_}+`).join(`${_}{1,${S}}`);
    return b;
  }, y = (b, _, S) => {
    const C = g(_), A = f++;
    o(b, A, _), l[b] = A, u[A] = _, a[A] = new RegExp(_, S ? "g" : void 0), s[A] = new RegExp(C, S ? "g" : void 0);
  };
  y("NUMERICIDENTIFIER", "0|[1-9]\\d*"), y("NUMERICIDENTIFIERLOOSE", "\\d+"), y("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`), y("MAINVERSION", `(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})`), y("MAINVERSIONLOOSE", `(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})`), y("PRERELEASEIDENTIFIER", `(?:${u[l.NUMERICIDENTIFIER]}|${u[l.NONNUMERICIDENTIFIER]})`), y("PRERELEASEIDENTIFIERLOOSE", `(?:${u[l.NUMERICIDENTIFIERLOOSE]}|${u[l.NONNUMERICIDENTIFIER]})`), y("PRERELEASE", `(?:-(${u[l.PRERELEASEIDENTIFIER]}(?:\\.${u[l.PRERELEASEIDENTIFIER]})*))`), y("PRERELEASELOOSE", `(?:-?(${u[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[l.PRERELEASEIDENTIFIERLOOSE]})*))`), y("BUILDIDENTIFIER", `${h}+`), y("BUILD", `(?:\\+(${u[l.BUILDIDENTIFIER]}(?:\\.${u[l.BUILDIDENTIFIER]})*))`), y("FULLPLAIN", `v?${u[l.MAINVERSION]}${u[l.PRERELEASE]}?${u[l.BUILD]}?`), y("FULL", `^${u[l.FULLPLAIN]}$`), y("LOOSEPLAIN", `[v=\\s]*${u[l.MAINVERSIONLOOSE]}${u[l.PRERELEASELOOSE]}?${u[l.BUILD]}?`), y("LOOSE", `^${u[l.LOOSEPLAIN]}$`), y("GTLT", "((?:<|>)?=?)"), y("XRANGEIDENTIFIERLOOSE", `${u[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), y("XRANGEIDENTIFIER", `${u[l.NUMERICIDENTIFIER]}|x|X|\\*`), y("XRANGEPLAIN", `[v=\\s]*(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:${u[l.PRERELEASE]})?${u[l.BUILD]}?)?)?`), y("XRANGEPLAINLOOSE", `[v=\\s]*(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:${u[l.PRERELEASELOOSE]})?${u[l.BUILD]}?)?)?`), y("XRANGE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAIN]}$`), y("XRANGELOOSE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAINLOOSE]}$`), y("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), y("COERCE", `${u[l.COERCEPLAIN]}(?:$|[^\\d])`), y("COERCEFULL", u[l.COERCEPLAIN] + `(?:${u[l.PRERELEASE]})?(?:${u[l.BUILD]})?(?:$|[^\\d])`), y("COERCERTL", u[l.COERCE], !0), y("COERCERTLFULL", u[l.COERCEFULL], !0), y("LONETILDE", "(?:~>?)"), y("TILDETRIM", `(\\s*)${u[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", y("TILDE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAIN]}$`), y("TILDELOOSE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAINLOOSE]}$`), y("LONECARET", "(?:\\^)"), y("CARETTRIM", `(\\s*)${u[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", y("CARET", `^${u[l.LONECARET]}${u[l.XRANGEPLAIN]}$`), y("CARETLOOSE", `^${u[l.LONECARET]}${u[l.XRANGEPLAINLOOSE]}$`), y("COMPARATORLOOSE", `^${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]})$|^$`), y("COMPARATOR", `^${u[l.GTLT]}\\s*(${u[l.FULLPLAIN]})$|^$`), y("COMPARATORTRIM", `(\\s*)${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]}|${u[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", y("HYPHENRANGE", `^\\s*(${u[l.XRANGEPLAIN]})\\s+-\\s+(${u[l.XRANGEPLAIN]})\\s*$`), y("HYPHENRANGELOOSE", `^\\s*(${u[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[l.XRANGEPLAINLOOSE]})\\s*$`), y("STAR", "(<|>)?=?\\s*\\*"), y("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), y("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(xX, xX.exports);
var Bie = xX.exports;
const jve = /^[0-9]+$/, XIe = (e, t) => {
  const n = jve.test(e), r = jve.test(t);
  return n && r && (e = +e, t = +t), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;
}, H6t = (e, t) => XIe(t, e);
var V6t = {
  compareIdentifiers: XIe,
  rcompareIdentifiers: H6t
};
const Y3 = u9, {
  MAX_LENGTH: Lve,
  MAX_SAFE_INTEGER: H3
} = Fie, {
  safeRe: zve,
  t: Fve
} = Bie, W6t = zie, {
  compareIdentifiers: tT
} = V6t;
let q6t = class yy {
  constructor(t, n) {
    if (n = W6t(n), t instanceof yy) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > Lve)
      throw new TypeError(`version is longer than ${Lve} characters`);
    Y3("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    const r = t.trim().match(n.loose ? zve[Fve.LOOSE] : zve[Fve.FULL]);
    if (!r)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > H3 || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > H3 || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > H3 || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const o = +i;
        if (o >= 0 && o < H3)
          return o;
      }
      return i;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Y3("SemVer.compare", this.version, this.options, t), !(t instanceof yy)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new yy(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof yy || (t = new yy(t, this.options)), tT(this.major, t.major) || tT(this.minor, t.minor) || tT(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof yy || (t = new yy(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let n = 0;
    do {
      const r = this.prerelease[n], i = t.prerelease[n];
      if (Y3("prerelease compare", n, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return tT(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof yy || (t = new yy(t, this.options));
    let n = 0;
    do {
      const r = this.build[n], i = t.build[n];
      if (Y3("prerelease compare", n, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return tT(r, i);
    } while (++n);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, n, r) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, r);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, r);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n, r), this.inc("pre", n, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, r), this.inc("pre", n, r);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (!n && r === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let o = this.prerelease.length;
          for (; --o >= 0; )
            typeof this.prerelease[o] == "number" && (this.prerelease[o]++, o = -2);
          if (o === -1) {
            if (n === this.prerelease.join(".") && r === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (n) {
          let o = [n, i];
          r === !1 && (o = [n]), tT(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = o) : this.prerelease = o;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var Uie = q6t;
const Bve = Uie, G6t = (e, t, n) => new Bve(e, n).compare(new Bve(t, n));
var VN = G6t;
const Q6t = VN, X6t = (e, t, n) => Q6t(e, t, n) === 0;
var K6t = X6t;
const Z6t = VN, J6t = (e, t, n) => Z6t(e, t, n) !== 0;
var e8t = J6t;
const t8t = VN, n8t = (e, t, n) => t8t(e, t, n) > 0;
var r8t = n8t;
const i8t = VN, o8t = (e, t, n) => i8t(e, t, n) >= 0;
var a8t = o8t;
const s8t = VN, u8t = (e, t, n) => s8t(e, t, n) < 0;
var l8t = u8t;
const c8t = VN, f8t = (e, t, n) => c8t(e, t, n) <= 0;
var d8t = f8t;
const h8t = K6t, p8t = e8t, g8t = r8t, m8t = a8t, y8t = l8t, v8t = d8t, b8t = (e, t, n, r) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
    case "":
    case "=":
    case "==":
      return h8t(e, n, r);
    case "!=":
      return p8t(e, n, r);
    case ">":
      return g8t(e, n, r);
    case ">=":
      return m8t(e, n, r);
    case "<":
      return y8t(e, n, r);
    case "<=":
      return v8t(e, n, r);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var x8t = b8t, WV, Uve;
function w8t() {
  if (Uve)
    return WV;
  Uve = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(f, h) {
      if (h = n(h), f instanceof t) {
        if (f.loose === !!h.loose)
          return f;
        f = f.value;
      }
      f = f.trim().split(/\s+/).join(" "), a("comparator", f, h), this.options = h, this.loose = !!h.loose, this.parse(f), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, a("comp", this);
    }
    parse(f) {
      const h = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR], p = f.match(h);
      if (!p)
        throw new TypeError(`Invalid comparator: ${f}`);
      this.operator = p[1] !== void 0 ? p[1] : "", this.operator === "=" && (this.operator = ""), p[2] ? this.semver = new s(p[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (a("Comparator.test", f, this.options.loose), this.semver === e || f === e)
        return !0;
      if (typeof f == "string")
        try {
          f = new s(f, this.options);
        } catch {
          return !1;
        }
      return o(f, this.operator, this.semver, this.options);
    }
    intersects(f, h) {
      if (!(f instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new u(f.value, h).test(this.value) : f.operator === "" ? f.value === "" ? !0 : new u(this.value, h).test(f.semver) : (h = n(h), h.includePrerelease && (this.value === "<0.0.0-0" || f.value === "<0.0.0-0") || !h.includePrerelease && (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && f.operator.startsWith(">") || this.operator.startsWith("<") && f.operator.startsWith("<") || this.semver.version === f.semver.version && this.operator.includes("=") && f.operator.includes("=") || o(this.semver, "<", f.semver, h) && this.operator.startsWith(">") && f.operator.startsWith("<") || o(this.semver, ">", f.semver, h) && this.operator.startsWith("<") && f.operator.startsWith(">")));
    }
  }
  WV = t;
  const n = zie, {
    safeRe: r,
    t: i
  } = Bie, o = x8t, a = u9, s = Uie, u = KIe();
  return WV;
}
var qV, Yve;
function KIe() {
  if (Yve)
    return qV;
  Yve = 1;
  class e {
    constructor(Q, q) {
      if (q = r(q), Q instanceof e)
        return Q.loose === !!q.loose && Q.includePrerelease === !!q.includePrerelease ? Q : new e(Q.raw, q);
      if (Q instanceof i)
        return this.raw = Q.value, this.set = [[Q]], this.format(), this;
      if (this.options = q, this.loose = !!q.loose, this.includePrerelease = !!q.includePrerelease, this.raw = Q.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((te) => this.parseRange(te.trim())).filter((te) => te.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const te = this.set[0];
        if (this.set = this.set.filter((X) => !y(X[0])), this.set.length === 0)
          this.set = [te];
        else if (this.set.length > 1) {
          for (const X of this.set)
            if (X.length === 1 && b(X[0])) {
              this.set = [X];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((Q) => Q.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(Q) {
      const te = ((this.options.includePrerelease && p) | (this.options.loose && g)) + ":" + Q, X = n.get(te);
      if (X)
        return X;
      const Z = this.options.loose, se = Z ? s[u.HYPHENRANGELOOSE] : s[u.HYPHENRANGE];
      Q = Q.replace(se, V(this.options.includePrerelease)), o("hyphen replace", Q), Q = Q.replace(s[u.COMPARATORTRIM], l), o("comparator trim", Q), Q = Q.replace(s[u.TILDETRIM], f), o("tilde trim", Q), Q = Q.replace(s[u.CARETTRIM], h), o("caret trim", Q);
      let H = Q.split(" ").map((_e) => S(_e, this.options)).join(" ").split(/\s+/).map((_e) => Y(_e, this.options));
      Z && (H = H.filter((_e) => (o("loose invalid filter", _e, this.options), !!_e.match(s[u.COMPARATORLOOSE])))), o("range list", H);
      const ie = /* @__PURE__ */ new Map(), he = H.map((_e) => new i(_e, this.options));
      for (const _e of he) {
        if (y(_e))
          return [_e];
        ie.set(_e.value, _e);
      }
      ie.size > 1 && ie.has("") && ie.delete("");
      const ye = [...ie.values()];
      return n.set(te, ye), ye;
    }
    intersects(Q, q) {
      if (!(Q instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((te) => _(te, q) && Q.set.some((X) => _(X, q) && te.every((Z) => X.every((se) => Z.intersects(se, q)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(Q) {
      if (!Q)
        return !1;
      if (typeof Q == "string")
        try {
          Q = new a(Q, this.options);
        } catch {
          return !1;
        }
      for (let q = 0; q < this.set.length; q++)
        if (ee(this.set[q], Q, this.options))
          return !0;
      return !1;
    }
  }
  qV = e;
  const t = $6t, n = new t({
    max: 1e3
  }), r = zie, i = w8t(), o = u9, a = Uie, {
    safeRe: s,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: f,
    caretTrimReplace: h
  } = Bie, {
    FLAG_INCLUDE_PRERELEASE: p,
    FLAG_LOOSE: g
  } = Fie, y = (K) => K.value === "<0.0.0-0", b = (K) => K.value === "", _ = (K, Q) => {
    let q = !0;
    const te = K.slice();
    let X = te.pop();
    for (; q && te.length; )
      q = te.every((Z) => X.intersects(Z, Q)), X = te.pop();
    return q;
  }, S = (K, Q) => (o("comp", K, Q), K = R(K, Q), o("caret", K), K = A(K, Q), o("tildes", K), K = $(K, Q), o("xrange", K), K = W(K, Q), o("stars", K), K), C = (K) => !K || K.toLowerCase() === "x" || K === "*", A = (K, Q) => K.trim().split(/\s+/).map((q) => O(q, Q)).join(" "), O = (K, Q) => {
    const q = Q.loose ? s[u.TILDELOOSE] : s[u.TILDE];
    return K.replace(q, (te, X, Z, se, H) => {
      o("tilde", K, te, X, Z, se, H);
      let ie;
      return C(X) ? ie = "" : C(Z) ? ie = `>=${X}.0.0 <${+X + 1}.0.0-0` : C(se) ? ie = `>=${X}.${Z}.0 <${X}.${+Z + 1}.0-0` : H ? (o("replaceTilde pr", H), ie = `>=${X}.${Z}.${se}-${H} <${X}.${+Z + 1}.0-0`) : ie = `>=${X}.${Z}.${se} <${X}.${+Z + 1}.0-0`, o("tilde return", ie), ie;
    });
  }, R = (K, Q) => K.trim().split(/\s+/).map((q) => j(q, Q)).join(" "), j = (K, Q) => {
    o("caret", K, Q);
    const q = Q.loose ? s[u.CARETLOOSE] : s[u.CARET], te = Q.includePrerelease ? "-0" : "";
    return K.replace(q, (X, Z, se, H, ie) => {
      o("caret", K, X, Z, se, H, ie);
      let he;
      return C(Z) ? he = "" : C(se) ? he = `>=${Z}.0.0${te} <${+Z + 1}.0.0-0` : C(H) ? Z === "0" ? he = `>=${Z}.${se}.0${te} <${Z}.${+se + 1}.0-0` : he = `>=${Z}.${se}.0${te} <${+Z + 1}.0.0-0` : ie ? (o("replaceCaret pr", ie), Z === "0" ? se === "0" ? he = `>=${Z}.${se}.${H}-${ie} <${Z}.${se}.${+H + 1}-0` : he = `>=${Z}.${se}.${H}-${ie} <${Z}.${+se + 1}.0-0` : he = `>=${Z}.${se}.${H}-${ie} <${+Z + 1}.0.0-0`) : (o("no pr"), Z === "0" ? se === "0" ? he = `>=${Z}.${se}.${H}${te} <${Z}.${se}.${+H + 1}-0` : he = `>=${Z}.${se}.${H}${te} <${Z}.${+se + 1}.0-0` : he = `>=${Z}.${se}.${H} <${+Z + 1}.0.0-0`), o("caret return", he), he;
    });
  }, $ = (K, Q) => (o("replaceXRanges", K, Q), K.split(/\s+/).map((q) => z(q, Q)).join(" ")), z = (K, Q) => {
    K = K.trim();
    const q = Q.loose ? s[u.XRANGELOOSE] : s[u.XRANGE];
    return K.replace(q, (te, X, Z, se, H, ie) => {
      o("xRange", K, te, X, Z, se, H, ie);
      const he = C(Z), ye = he || C(se), _e = ye || C(H), Ne = _e;
      return X === "=" && Ne && (X = ""), ie = Q.includePrerelease ? "-0" : "", he ? X === ">" || X === "<" ? te = "<0.0.0-0" : te = "*" : X && Ne ? (ye && (se = 0), H = 0, X === ">" ? (X = ">=", ye ? (Z = +Z + 1, se = 0, H = 0) : (se = +se + 1, H = 0)) : X === "<=" && (X = "<", ye ? Z = +Z + 1 : se = +se + 1), X === "<" && (ie = "-0"), te = `${X + Z}.${se}.${H}${ie}`) : ye ? te = `>=${Z}.0.0${ie} <${+Z + 1}.0.0-0` : _e && (te = `>=${Z}.${se}.0${ie} <${Z}.${+se + 1}.0-0`), o("xRange return", te), te;
    });
  }, W = (K, Q) => (o("replaceStars", K, Q), K.trim().replace(s[u.STAR], "")), Y = (K, Q) => (o("replaceGTE0", K, Q), K.trim().replace(s[Q.includePrerelease ? u.GTE0PRE : u.GTE0], "")), V = (K) => (Q, q, te, X, Z, se, H, ie, he, ye, _e, Ne, Oe) => (C(te) ? q = "" : C(X) ? q = `>=${te}.0.0${K ? "-0" : ""}` : C(Z) ? q = `>=${te}.${X}.0${K ? "-0" : ""}` : se ? q = `>=${q}` : q = `>=${q}${K ? "-0" : ""}`, C(he) ? ie = "" : C(ye) ? ie = `<${+he + 1}.0.0-0` : C(_e) ? ie = `<${he}.${+ye + 1}.0-0` : Ne ? ie = `<=${he}.${ye}.${_e}-${Ne}` : K ? ie = `<${he}.${ye}.${+_e + 1}-0` : ie = `<=${ie}`, `${q} ${ie}`.trim()), ee = (K, Q, q) => {
    for (let te = 0; te < K.length; te++)
      if (!K[te].test(Q))
        return !1;
    if (Q.prerelease.length && !q.includePrerelease) {
      for (let te = 0; te < K.length; te++)
        if (o(K[te].semver), K[te].semver !== i.ANY && K[te].semver.prerelease.length > 0) {
          const X = K[te].semver;
          if (X.major === Q.major && X.minor === Q.minor && X.patch === Q.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return qV;
}
const _8t = KIe(), E8t = (e, t, n) => {
  try {
    t = new _8t(t, n);
  } catch {
    return !1;
  }
  return t.test(e);
};
var S8t = E8t, ZIe = /* @__PURE__ */ M6t(S8t);
function M8t(e, t, n) {
  const r = e.open(t), i = 1e4, o = 250, {
    origin: a
  } = new URL(t);
  let s = ~~(i / o);
  function u(f) {
    f.source === r && (s = 0, e.removeEventListener("message", u, !1));
  }
  e.addEventListener("message", u, !1);
  function l() {
    s <= 0 || (r.postMessage(n, a), setTimeout(l, o), s -= 1);
  }
  setTimeout(l, o);
}
var T8t = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
function JIe(e, ...t) {
  for (const n of t)
    C8t(e, n);
  return e;
}
function C8t(e, t) {
  for (const n of Object.keys(t))
    TN(e, n, t[n], !0);
}
const by = c$t;
let h$ = gFt;
const V3 = typeof window < "u" ? window : void 0;
var Qve;
h$ === void 0 && ((Qve = V3 == null ? void 0 : V3.vl) != null && Qve.compile) && (h$ = V3.vl);
const N8t = {
  export: {
    svg: !0,
    png: !0
  },
  source: !0,
  compiled: !0,
  editor: !0
}, D8t = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
}, aR = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
}, Tz = {
  vega: by.version,
  "vega-lite": h$ ? h$.version : "not available"
}, A8t = {
  vega: (e) => e,
  "vega-lite": (e, t) => h$.compile(e, {
    config: t
  }).spec
}, O8t = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`, R8t = "chart-wrapper";
function k8t(e) {
  return typeof e == "function";
}
function Hve(e, t, n, r) {
  const i = `<html><head>${t}</head><body><pre><code class="json">`, o = `</code></pre>${n}</body></html>`, a = window.open("");
  a.document.write(i + e + o), a.document.title = `${aR[r]} JSON Source`;
}
function $8t(e, t) {
  if (e.$schema) {
    const n = HIe(e.$schema);
    t && t !== n.library && console.warn(`The given visualization spec is written in ${aR[n.library]}, but mode argument sets ${aR[t] ?? t}.`);
    const r = n.library;
    return ZIe(Tz[r], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${aR[r]} ${n.version}, but the current version of ${aR[r]} is v${Tz[r]}.`), r;
  }
  return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega";
}
function e3e(e) {
  return !!(e && "load" in e);
}
function Vve(e) {
  return e3e(e) ? e : by.loader(e);
}
function P8t(e) {
  var n;
  const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
  return kt(t.defaultStyle) && (t.defaultStyle = !1), t;
}
async function I8t(e, t, n = {}) {
  let r, i;
  kt(t) ? (i = Vve(n.loader), r = JSON.parse(await i.load(t))) : r = t;
  const o = P8t(r), a = o.loader;
  (!i || a) && (i = Vve(n.loader ?? a));
  const s = await Wve(o, i), u = await Wve(n, i), l = {
    ...JIe(u, s),
    config: MN(u.config ?? {}, s.config ?? {})
  };
  return await L8t(e, r, l, i);
}
async function Wve(e, t) {
  const n = kt(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {}, r = kt(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
  return {
    ...e,
    ...r ? {
      patch: r
    } : {},
    ...n ? {
      config: n
    } : {}
  };
}
function j8t(e) {
  const t = e.getRootNode ? e.getRootNode() : document;
  return t instanceof ShadowRoot ? {
    root: t,
    rootContainer: t
  } : {
    root: document,
    rootContainer: document.head ?? document.body
  };
}
async function L8t(e, t, n = {}, r) {
  const i = n.theme ? MN(m6t[n.theme], n.config ?? {}) : n.config, o = Pw(n.actions) ? n.actions : JIe({}, N8t, n.actions ?? {}), a = {
    ...D8t,
    ...n.i18n
  }, s = n.renderer ?? "canvas", u = n.logLevel ?? by.Warn, l = n.downloadFileName ?? "visualization", f = typeof e == "string" ? document.querySelector(e) : e;
  if (!f)
    throw new Error(`${e} does not exist`);
  if (n.defaultStyle !== !1) {
    const R = "vega-embed-style", {
      root: j,
      rootContainer: $
    } = j8t(f);
    if (!j.getElementById(R)) {
      const z = document.createElement("style");
      z.id = R, z.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? T8t.toString() : n.defaultStyle, $.appendChild(z);
    }
  }
  const h = $8t(t, n.mode);
  let p = A8t[h](t, i);
  if (h === "vega-lite" && p.$schema) {
    const R = HIe(p.$schema);
    ZIe(Tz.vega, `^${R.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${R.version}, but current version is v${Tz.vega}.`);
  }
  f.classList.add("vega-embed"), o && f.classList.add("has-actions"), f.innerHTML = "";
  let g = f;
  if (o) {
    const R = document.createElement("div");
    R.classList.add(R8t), f.appendChild(R), g = R;
  }
  const y = n.patch;
  if (y && (p = y instanceof Function ? y(p) : x6(p, y, !0, !1).newDocument), n.formatLocale && by.formatLocale(n.formatLocale), n.timeFormatLocale && by.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
    for (const R in n.expressionFunctions) {
      const j = n.expressionFunctions[R];
      "fn" in j ? by.expressionFunction(R, j.fn, j.visitor) : j instanceof Function && by.expressionFunction(R, j);
    }
  const {
    ast: b
  } = n, _ = by.parse(p, h === "vega-lite" ? {} : i, {
    ast: b
  }), S = new (n.viewClass || by.View)(_, {
    loader: r,
    logLevel: u,
    renderer: s,
    ...b ? {
      expr: by.expressionInterpreter ?? n.expr ?? x$t
    } : {}
  });
  if (S.addSignalListener("autosize", (R, j) => {
    const {
      type: $
    } = j;
    $ == "fit-x" ? (g.classList.add("fit-x"), g.classList.remove("fit-y")) : $ == "fit-y" ? (g.classList.remove("fit-x"), g.classList.add("fit-y")) : $ == "fit" ? g.classList.add("fit-x", "fit-y") : g.classList.remove("fit-x", "fit-y");
  }), n.tooltip !== !1) {
    const {
      loader: R,
      tooltip: j
    } = n, $ = R && !e3e(R) ? R == null ? void 0 : R.baseURL : void 0, z = k8t(j) ? j : (
      // user provided boolean true or tooltip options
      new S6t({
        baseURL: $,
        ...j === !0 ? {} : j
      }).call
    );
    S.tooltip(z);
  }
  let {
    hover: C
  } = n;
  if (C === void 0 && (C = h === "vega"), C) {
    const {
      hoverSet: R,
      updateSet: j
    } = typeof C == "boolean" ? {} : C;
    S.hover(R, j);
  }
  n && (n.width != null && S.width(n.width), n.height != null && S.height(n.height), n.padding != null && S.padding(n.padding)), await S.initialize(g, n.bind).runAsync();
  let A;
  if (o !== !1) {
    let R = f;
    if (n.defaultStyle !== !1 || n.forceActionsMenu) {
      const $ = document.createElement("details");
      $.title = a.CLICK_TO_VIEW_ACTIONS, f.append($), R = $;
      const z = document.createElement("summary");
      z.innerHTML = O8t, $.append(z), A = (W) => {
        $.contains(W.target) || $.removeAttribute("open");
      }, document.addEventListener("click", A);
    }
    const j = document.createElement("div");
    if (R.append(j), j.classList.add("vega-actions"), o === !0 || o.export !== !1) {
      for (const $ of ["svg", "png"])
        if (o === !0 || o.export === !0 || o.export[$]) {
          const z = a[`${$.toUpperCase()}_ACTION`], W = document.createElement("a"), Y = Pt(n.scaleFactor) ? n.scaleFactor[$] : n.scaleFactor;
          W.text = z, W.href = "#", W.target = "_blank", W.download = `${l}.${$}`, W.addEventListener("mousedown", async function(V) {
            V.preventDefault();
            const ee = await S.toImageURL($, Y);
            this.href = ee;
          }), j.append(W);
        }
    }
    if (o === !0 || o.source !== !1) {
      const $ = document.createElement("a");
      $.text = a.SOURCE_ACTION, $.href = "#", $.addEventListener("click", function(z) {
        Hve(VH(t), n.sourceHeader ?? "", n.sourceFooter ?? "", h), z.preventDefault();
      }), j.append($);
    }
    if (h === "vega-lite" && (o === !0 || o.compiled !== !1)) {
      const $ = document.createElement("a");
      $.text = a.COMPILED_ACTION, $.href = "#", $.addEventListener("click", function(z) {
        Hve(VH(p), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), z.preventDefault();
      }), j.append($);
    }
    if (o === !0 || o.editor !== !1) {
      const $ = n.editorUrl ?? "https://vega.github.io/editor/", z = document.createElement("a");
      z.text = a.EDITOR_ACTION, z.href = "#", z.addEventListener("click", function(W) {
        M8t(window, $, {
          config: i,
          mode: h,
          renderer: s,
          spec: VH(t)
        }), W.preventDefault();
      }), j.append(z);
    }
  }
  function O() {
    A && document.removeEventListener("click", A), S.finalize();
  }
  return {
    view: S,
    spec: t,
    vgSpec: p,
    finalize: O,
    embedOptions: n
  };
}
const z8t = "_vegaChart_zrjpi_1", F8t = {
  vegaChart: z8t
}, B8t = ({ id: e, style: t = {}, content: n }) => {
  const r = ae.useContext(tv), i = n.config, o = typeof i == "string" ? JSON.parse(i) : i;
  return ae.useLayoutEffect(() => {
    const a = z0t(o, r);
    I8t(`#vega-chart-${e}`, a, { actions: !1 });
  }, [r, e, o]), /* @__PURE__ */ pe.jsxs("div", { className: F8t.vegaChart, children: [
    /* @__PURE__ */ pe.jsx(JS, { contentTitle: n.title, style: t }),
    /* @__PURE__ */ pe.jsx("div", { id: `vega-chart-${e}` })
  ] });
}, U8t = ({ renderData: e, setQueryString: t }) => {
  ae.useContext(tv);
  const n = {
    ListKPIs: "listkpis",
    Markdown: "markdown",
    Table: "table",
    WordCloud: "wordcloud",
    Plot: "plot",
    VegaLite: "vegalite"
  }, r = /* @__PURE__ */ pe.jsx("div", { id: "pageDivider", children: /* @__PURE__ */ pe.jsx("hr", { className: HH.divider }) }), i = (o, a) => {
    const s = o.componentName.toLowerCase();
    let u;
    switch (s) {
      case n.ListKPIs:
        u = /* @__PURE__ */ pe.jsx(
          TGe,
          {
            style: o.style,
            content: o.content,
            version: o.version
          }
        );
        break;
      case n.Markdown:
        u = /* @__PURE__ */ pe.jsx(OGe, { style: o.style, content: o.content });
        break;
      case n.Table:
        u = /* @__PURE__ */ pe.jsx(
          htt,
          {
            content: o.content,
            setQueryString: t,
            style: o.style
          }
        );
        break;
      case n.WordCloud:
        u = /* @__PURE__ */ pe.jsx("div", { className: HH.wordCloudWrapper, children: /* @__PURE__ */ pe.jsx(
          krt,
          {
            id: a,
            style: o.style,
            content: o.content
          }
        ) });
        break;
      case n.Plot:
        u = /* @__PURE__ */ pe.jsx("div", { children: /* @__PURE__ */ pe.jsx(
          U0t,
          {
            id: a,
            style: o.style,
            content: o.content,
            chartConfig: o.content.config
          }
        ) });
        break;
      case n.VegaLite:
        u = /* @__PURE__ */ pe.jsx("div", { children: /* @__PURE__ */ pe.jsx(
          B8t,
          {
            id: a,
            style: o.style,
            content: o.content
          }
        ) });
        break;
    }
    return u;
  };
  return /* @__PURE__ */ pe.jsx("div", { className: HH.layoutListWrapper, children: e.map((o, a) => {
    var u, l;
    const s = e[a + 1];
    return o.error ? (console.log(`renderData at index: ${a}:`, o.error), null) : /* @__PURE__ */ pe.jsxs("div", { children: [
      i(o, a),
      s && !((u = o.style) != null && u.bgColor) && !((l = s.style) != null && l.bgColor) && r
    ] }, a);
  }) });
}, Y8t = "_maskBox_1145q_1", H8t = "_mask_1145q_1", qve = {
  maskBox: Y8t,
  mask: H8t
}, W3 = {
  base: {
    textTransform: "capitalize",
    fontFamily: "Nunito Sans, sans-serif",
    fontSize: "12px",
    fontWeight: "bold"
  },
  live: {
    color: "#ffffff"
  },
  drafting: (e) => ({
    color: e ? "#2A323C" : "#ffffff"
  })
}, V8t = {
  wrapper: {
    display: "flex"
  }
}, Gve = {
  live: {
    transform: "translateX(3px)",
    background: "#14c25a",
    width: "43%"
  },
  drafting: {
    transform: "translateX(64px)",
    background: "#ffffff",
    width: "47%"
  }
};
function W8t({
  handleChangeType: e,
  subType: t
}) {
  const n = (i) => {
    localStorage.setItem("subType", i), e(i);
  }, r = t === "live" ? Gve.live : Gve.drafting;
  return /* @__PURE__ */ pe.jsx(hR, { sx: V8t.wrapper, children: /* @__PURE__ */ pe.jsxs(hR, { className: qve.maskBox, children: [
    /* @__PURE__ */ pe.jsx(hR, { className: qve.mask, style: r }),
    /* @__PURE__ */ pe.jsx(
      mW,
      {
        disableRipple: !0,
        variant: "text",
        sx: { ...W3.base, ...W3.live },
        onClick: () => n("live"),
        children: "Live"
      }
    ),
    /* @__PURE__ */ pe.jsx(
      mW,
      {
        disableRipple: !0,
        variant: "text",
        sx: {
          ...W3.base,
          ...W3.drafting(t === "drafting")
        },
        onClick: () => n("drafting"),
        children: "Drafting"
      }
    )
  ] }) });
}
const q8t = "_footer_b777w_1", G8t = {
  footer: q8t
}, Q8t = ({ handleChangeType: e, subType: t }) => /* @__PURE__ */ pe.jsx("div", { className: G8t.footer, children: /* @__PURE__ */ pe.jsx(W8t, { handleChangeType: e, subType: t }) });
function X8t() {
  const [e, t] = ae.useState(
    window.location.search
  ), [n, r] = ae.useState(JV), [i, o] = ae.useState(Dze), [a, s] = ae.useState(Aze), [u, l] = ae.useState(Nze), [f, h] = ae.useState(null), [p, g] = ae.useState(!0), [y, b] = ae.useState(!1);
  ae.useState(!0), ae.useState(Oze), ae.useState(!1);
  const _ = localStorage.getItem("subType") || "live", [S, C] = ae.useState(_);
  window.onpopstate = () => {
    t(window.location.search);
  }, ae.useEffect(() => {
    r(JV), l([]), h(null), g(!0), console.log("+++++++++++++++++++++++++++++++="), console.log("window", window);
    async function V() {
      g(!0);
      const ee = S === "live" && window.config.ceRelative ? "/api/analytics/analytics" : "/api/analytics/analytics?mode=drafting", K = `${window.config.ceRoot}${ee}`, Q = S === "live" ? e : Cze(e), q = `${K}${Q}`, te = await Tze(q), X = ar.get(te, "data", {}), Z = ar.get(te, "status", null);
      console.log("solution", te), Object.entries(X).length && !X.error && (r(X.context), l(X.context.renders), o(X.public), s(X.chat)), Z && (h(Z), g(!1));
    }
    V();
  }, [e, S]);
  const A = () => {
    let V;
    switch (f) {
      case 401:
        V = /* @__PURE__ */ pe.jsx(nue, {});
        break;
      case 403:
        V = /* @__PURE__ */ pe.jsx(nue, {});
        break;
      case 404:
        V = /* @__PURE__ */ pe.jsx(bze, {});
        break;
      case 500:
        V = /* @__PURE__ */ pe.jsx(rue, {});
        break;
      case 503:
        V = /* @__PURE__ */ pe.jsx(rue, {});
        break;
      default:
        V = /* @__PURE__ */ pe.jsx(Mze, { componentsAvailable: u.length });
        break;
    }
    return V;
  }, O = (V) => {
    C(V);
  }, R = !p && f !== 200 || !p && u.length === 0, j = ar.get(
    i,
    "ui_settings.ai_chat_enabled",
    !1
  ), z = ar.get(n, "aiwareApps.ce_analytics_app.roleId", "") === Pze;
  ar.get(i, "ui_settings.app_logo_url", "/");
  const W = j && y ? "AppOpenChat" : "App", Y = z ? "dataContainerHasFooter" : "dataContainer";
  return /* @__PURE__ */ pe.jsxs("div", { className: W, id: "App", children: [
    /* @__PURE__ */ pe.jsx(tv.Provider, { value: n, children: /* @__PURE__ */ pe.jsx("div", { className: Y, children: !p && f === 200 && u.length > 0 && /* @__PURE__ */ pe.jsx(
      U8t,
      {
        renderData: u,
        setQueryString: t
      }
    ) }) }),
    z && /* @__PURE__ */ pe.jsx(Q8t, { handleChangeType: O, subType: S }),
    R && A()
  ] });
}
var K8t = { exports: {} };
(function(e) {
  (function(t) {
    var n = Object.prototype, r = n.hasOwnProperty, i, o = typeof Symbol == "function" ? Symbol : {}, a = o.iterator || "@@iterator", s = o.asyncIterator || "@@asyncIterator", u = o.toStringTag || "@@toStringTag", l = t.regeneratorRuntime;
    if (l) {
      e.exports = l;
      return;
    }
    l = t.regeneratorRuntime = e.exports;
    function f(X, Z, se, H) {
      var ie = Z && Z.prototype instanceof S ? Z : S, he = Object.create(ie.prototype), ye = new Q(H || []);
      return he._invoke = Y(X, se, ye), he;
    }
    l.wrap = f;
    function h(X, Z, se) {
      try {
        return { type: "normal", arg: X.call(Z, se) };
      } catch (H) {
        return { type: "throw", arg: H };
      }
    }
    var p = "suspendedStart", g = "suspendedYield", y = "executing", b = "completed", _ = {};
    function S() {
    }
    function C() {
    }
    function A() {
    }
    var O = {};
    O[a] = function() {
      return this;
    };
    var R = Object.getPrototypeOf, j = R && R(R(q([])));
    j && j !== n && r.call(j, a) && (O = j);
    var $ = A.prototype = S.prototype = Object.create(O);
    C.prototype = $.constructor = A, A.constructor = C, A[u] = C.displayName = "GeneratorFunction";
    function z(X) {
      ["next", "throw", "return"].forEach(function(Z) {
        X[Z] = function(se) {
          return this._invoke(Z, se);
        };
      });
    }
    l.isGeneratorFunction = function(X) {
      var Z = typeof X == "function" && X.constructor;
      return Z ? Z === C || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (Z.displayName || Z.name) === "GeneratorFunction" : !1;
    }, l.mark = function(X) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(X, A) : (X.__proto__ = A, u in X || (X[u] = "GeneratorFunction")), X.prototype = Object.create($), X;
    }, l.awrap = function(X) {
      return { __await: X };
    };
    function W(X) {
      function Z(ie, he, ye, _e) {
        var Ne = h(X[ie], X, he);
        if (Ne.type === "throw")
          _e(Ne.arg);
        else {
          var Oe = Ne.arg, ke = Oe.value;
          return ke && typeof ke == "object" && r.call(ke, "__await") ? Promise.resolve(ke.__await).then(function(Me) {
            Z("next", Me, ye, _e);
          }, function(Me) {
            Z("throw", Me, ye, _e);
          }) : Promise.resolve(ke).then(function(Me) {
            Oe.value = Me, ye(Oe);
          }, _e);
        }
      }
      var se;
      function H(ie, he) {
        function ye() {
          return new Promise(function(_e, Ne) {
            Z(ie, he, _e, Ne);
          });
        }
        return se = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        se ? se.then(
          ye,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          ye
        ) : ye();
      }
      this._invoke = H;
    }
    z(W.prototype), W.prototype[s] = function() {
      return this;
    }, l.AsyncIterator = W, l.async = function(X, Z, se, H) {
      var ie = new W(
        f(X, Z, se, H)
      );
      return l.isGeneratorFunction(Z) ? ie : ie.next().then(function(he) {
        return he.done ? he.value : ie.next();
      });
    };
    function Y(X, Z, se) {
      var H = p;
      return function(he, ye) {
        if (H === y)
          throw new Error("Generator is already running");
        if (H === b) {
          if (he === "throw")
            throw ye;
          return te();
        }
        for (se.method = he, se.arg = ye; ; ) {
          var _e = se.delegate;
          if (_e) {
            var Ne = V(_e, se);
            if (Ne) {
              if (Ne === _)
                continue;
              return Ne;
            }
          }
          if (se.method === "next")
            se.sent = se._sent = se.arg;
          else if (se.method === "throw") {
            if (H === p)
              throw H = b, se.arg;
            se.dispatchException(se.arg);
          } else
            se.method === "return" && se.abrupt("return", se.arg);
          H = y;
          var Oe = h(X, Z, se);
          if (Oe.type === "normal") {
            if (H = se.done ? b : g, Oe.arg === _)
              continue;
            return {
              value: Oe.arg,
              done: se.done
            };
          } else
            Oe.type === "throw" && (H = b, se.method = "throw", se.arg = Oe.arg);
        }
      };
    }
    function V(X, Z) {
      var se = X.iterator[Z.method];
      if (se === i) {
        if (Z.delegate = null, Z.method === "throw") {
          if (X.iterator.return && (Z.method = "return", Z.arg = i, V(X, Z), Z.method === "throw"))
            return _;
          Z.method = "throw", Z.arg = new TypeError(
            "The iterator does not provide a 'throw' method"
          );
        }
        return _;
      }
      var H = h(se, X.iterator, Z.arg);
      if (H.type === "throw")
        return Z.method = "throw", Z.arg = H.arg, Z.delegate = null, _;
      var ie = H.arg;
      if (!ie)
        return Z.method = "throw", Z.arg = new TypeError("iterator result is not an object"), Z.delegate = null, _;
      if (ie.done)
        Z[X.resultName] = ie.value, Z.next = X.nextLoc, Z.method !== "return" && (Z.method = "next", Z.arg = i);
      else
        return ie;
      return Z.delegate = null, _;
    }
    z($), $[u] = "Generator", $[a] = function() {
      return this;
    }, $.toString = function() {
      return "[object Generator]";
    };
    function ee(X) {
      var Z = { tryLoc: X[0] };
      1 in X && (Z.catchLoc = X[1]), 2 in X && (Z.finallyLoc = X[2], Z.afterLoc = X[3]), this.tryEntries.push(Z);
    }
    function K(X) {
      var Z = X.completion || {};
      Z.type = "normal", delete Z.arg, X.completion = Z;
    }
    function Q(X) {
      this.tryEntries = [{ tryLoc: "root" }], X.forEach(ee, this), this.reset(!0);
    }
    l.keys = function(X) {
      var Z = [];
      for (var se in X)
        Z.push(se);
      return Z.reverse(), function H() {
        for (; Z.length; ) {
          var ie = Z.pop();
          if (ie in X)
            return H.value = ie, H.done = !1, H;
        }
        return H.done = !0, H;
      };
    };
    function q(X) {
      if (X) {
        var Z = X[a];
        if (Z)
          return Z.call(X);
        if (typeof X.next == "function")
          return X;
        if (!isNaN(X.length)) {
          var se = -1, H = function ie() {
            for (; ++se < X.length; )
              if (r.call(X, se))
                return ie.value = X[se], ie.done = !1, ie;
            return ie.value = i, ie.done = !0, ie;
          };
          return H.next = H;
        }
      }
      return { next: te };
    }
    l.values = q;
    function te() {
      return { value: i, done: !0 };
    }
    Q.prototype = {
      constructor: Q,
      reset: function(X) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = i, this.done = !1, this.delegate = null, this.method = "next", this.arg = i, this.tryEntries.forEach(K), !X)
          for (var Z in this)
            Z.charAt(0) === "t" && r.call(this, Z) && !isNaN(+Z.slice(1)) && (this[Z] = i);
      },
      stop: function() {
        this.done = !0;
        var X = this.tryEntries[0], Z = X.completion;
        if (Z.type === "throw")
          throw Z.arg;
        return this.rval;
      },
      dispatchException: function(X) {
        if (this.done)
          throw X;
        var Z = this;
        function se(Ne, Oe) {
          return he.type = "throw", he.arg = X, Z.next = Ne, Oe && (Z.method = "next", Z.arg = i), !!Oe;
        }
        for (var H = this.tryEntries.length - 1; H >= 0; --H) {
          var ie = this.tryEntries[H], he = ie.completion;
          if (ie.tryLoc === "root")
            return se("end");
          if (ie.tryLoc <= this.prev) {
            var ye = r.call(ie, "catchLoc"), _e = r.call(ie, "finallyLoc");
            if (ye && _e) {
              if (this.prev < ie.catchLoc)
                return se(ie.catchLoc, !0);
              if (this.prev < ie.finallyLoc)
                return se(ie.finallyLoc);
            } else if (ye) {
              if (this.prev < ie.catchLoc)
                return se(ie.catchLoc, !0);
            } else if (_e) {
              if (this.prev < ie.finallyLoc)
                return se(ie.finallyLoc);
            } else
              throw new Error("try statement without catch or finally");
          }
        }
      },
      abrupt: function(X, Z) {
        for (var se = this.tryEntries.length - 1; se >= 0; --se) {
          var H = this.tryEntries[se];
          if (H.tryLoc <= this.prev && r.call(H, "finallyLoc") && this.prev < H.finallyLoc) {
            var ie = H;
            break;
          }
        }
        ie && (X === "break" || X === "continue") && ie.tryLoc <= Z && Z <= ie.finallyLoc && (ie = null);
        var he = ie ? ie.completion : {};
        return he.type = X, he.arg = Z, ie ? (this.method = "next", this.next = ie.finallyLoc, _) : this.complete(he);
      },
      complete: function(X, Z) {
        if (X.type === "throw")
          throw X.arg;
        return X.type === "break" || X.type === "continue" ? this.next = X.arg : X.type === "return" ? (this.rval = this.arg = X.arg, this.method = "return", this.next = "end") : X.type === "normal" && Z && (this.next = Z), _;
      },
      finish: function(X) {
        for (var Z = this.tryEntries.length - 1; Z >= 0; --Z) {
          var se = this.tryEntries[Z];
          if (se.finallyLoc === X)
            return this.complete(se.completion, se.afterLoc), K(se), _;
        }
      },
      catch: function(X) {
        for (var Z = this.tryEntries.length - 1; Z >= 0; --Z) {
          var se = this.tryEntries[Z];
          if (se.tryLoc === X) {
            var H = se.completion;
            if (H.type === "throw") {
              var ie = H.arg;
              K(se);
            }
            return ie;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(X, Z, se) {
        return this.delegate = {
          iterator: q(X),
          resultName: Z,
          nextLoc: se
        }, this.method === "next" && (this.arg = i), _;
      }
    };
  })(
    // In sloppy mode, unbound `this` refers to the global object, fallback to
    // Function constructor if we're in global strict mode. That is sadly a form
    // of indirect eval which violates Content Security Policy.
    function() {
      return this;
    }() || Function("return this")()
  );
})(K8t);
var fS = function() {
  return this;
}() || Function("return this")(), t3e = fS.regeneratorRuntime && Object.getOwnPropertyNames(fS).indexOf("regeneratorRuntime") >= 0, Z8t = t3e && fS.regeneratorRuntime;
fS.regeneratorRuntime = void 0;
if (t3e)
  fS.regeneratorRuntime = Z8t;
else
  try {
    delete fS.regeneratorRuntime;
  } catch {
    fS.regeneratorRuntime = void 0;
  }
var J8t = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.location.hash, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window.opener, r = void 0, i = void 0;
  try {
    r = t.match(/access_token=(.+)$/)[1].split("&")[0];
  } catch {
  }
  if (!r)
    try {
      i = t.match(/error=(.+)$/)[1].split("&")[0];
    } catch {
    }
  n.postMessage({
    OAuthToken: r,
    error: i
  }, window.origin);
};
const GV = [
  "apiRoot",
  "switchAppRoute",
  "loginRoute",
  "graphQLEndpoint",
  // @ts-ignore
  window && ar.get(window.config, "useOAuthGrant") && "OAuthClientID"
].filter(Boolean);
function e9t() {
  if (GV.some(
    // @ts-ignore
    (t) => !ar.get(window && window.config, t)
  )) {
    const t = ar.difference(
      GV,
      // @ts-ignore
      Object.keys(window && window.config)
    );
    throw new Error(
      `The app requires the keys ${JSON.stringify(
        GV
      )} to exist in config, but the following keys were not found: ${JSON.stringify(
        t
      )}`
    );
  }
}
function t9t(e, t, n) {
  if (e && window && window.name === "_auth")
    return J8t(window.location.hash, window.opener);
  _O.createRoot(document.getElementById(t)).render(/* @__PURE__ */ pe.jsx(X8t, {})), fetch(`${n}/config.json?v=${Math.random()}`).then((r) => r.json()).then((r) => {
    window && (window.config = r);
    const i = window.location.hash.substring(1) || "";
    if (i) {
      const o = i.split("&").reduce((a, s) => {
        const u = s.split("=");
        return a[u[0]] = u[1], a;
      }, {});
      sessionStorage.setItem("access_token", o.access_token), sessionStorage.setItem("token_type", o.token_type);
    }
    return window.config && e9t(), t9t(r.useImplicit);
  });
}
export {
  t9t as bootstrap
};
